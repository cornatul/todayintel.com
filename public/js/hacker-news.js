/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@kangc/v-md-editor/lib/base-editor.js":
/*!************************************************************!*\
  !*** ./node_modules/@kangc/v-md-editor/lib/base-editor.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\"));\n\telse {}\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_665__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_665__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_665__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_665__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_665__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_665__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_665__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_665__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_665__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_665__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_665__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_665__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_665__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_665__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_665__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_665__(__nested_webpack_require_665__.s = 108);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_4247__) {\n\n\"use strict\";\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"a\", function() { return bold; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"b\", function() { return clear; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"c\", function() { return code; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"d\", function() { return fullscreen; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"e\", function() { return h1; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"f\", function() { return h2; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"g\", function() { return h3; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"h\", function() { return h4; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"i\", function() { return h5; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"j\", function() { return h6; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"k\", function() { return hr; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"l\", function() { return image; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"m\", function() { return italic; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"n\", function() { return link; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"o\", function() { return ol; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"p\", function() { return quote; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"q\", function() { return redo; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"r\", function() { return strikethrough; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"s\", function() { return syncScroll; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"t\", function() { return table; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"u\", function() { return ul; });\n/* harmony export (binding) */ __nested_webpack_require_4247__.d(__webpack_exports__, \"v\", function() { return undo; });\nvar bold = 'bold';\nvar clear = 'clear';\nvar code = 'code';\nvar fullscreen = 'fullscreen';\nvar h1 = 'h1';\nvar h2 = 'h2';\nvar h3 = 'h3';\nvar h4 = 'h4';\nvar h5 = 'h5';\nvar h6 = 'h6';\nvar hr = 'hr';\nvar image = 'image';\nvar italic = 'italic';\nvar link = 'link';\nvar ol = 'ol';\nvar quote = 'quote';\nvar redo = 'redo';\nvar strikethrough = 'strikethrough';\nvar syncScroll = 'sync-scroll';\nvar table = 'table';\nvar ul = 'ul';\nvar undo = 'undo';\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_7193__) {\n\n\"use strict\";\n/* harmony export (binding) */ __nested_webpack_require_7193__.d(__webpack_exports__, \"f\", function() { return isObject; });\n/* harmony export (binding) */ __nested_webpack_require_7193__.d(__webpack_exports__, \"a\", function() { return arraytoObject; });\n/* harmony export (binding) */ __nested_webpack_require_7193__.d(__webpack_exports__, \"c\", function() { return importAll; });\n/* harmony export (binding) */ __nested_webpack_require_7193__.d(__webpack_exports__, \"d\", function() { return inBrowser; });\n/* harmony export (binding) */ __nested_webpack_require_7193__.d(__webpack_exports__, \"e\", function() { return isKorean; });\n/* harmony export (binding) */ __nested_webpack_require_7193__.d(__webpack_exports__, \"b\", function() { return generatorText; });\nvar toString = Object.prototype.toString;\nvar isObject = function isObject(target) {\n  return toString.call(target) === '[object Object]';\n};\n\nfunction extend(to, _from) {\n  Object.keys(_from).forEach(function (key) {\n    to[key] = _from[key];\n  });\n  return to;\n}\n\nfunction arraytoObject(arr) {\n  var res = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n\n  return res;\n}\nfunction importAll(map, r) {\n  r.keys().forEach(function (filePath) {\n    map[filePath] = r(filePath);\n  });\n}\nvar inBrowser = typeof window !== 'undefined';\nfunction isKorean(text) {\n  var reg = /([(\\uAC00-\\uD7AF)|(\\u3130-\\u318F)])+/gi;\n  return reg.test(text);\n}\nfunction generatorText(_ref) {\n  var selected = _ref.selected,\n      InsertGetter = _ref.InsertGetter,\n      _ref$selectedGetter = _ref.selectedGetter,\n      selectedGetter = _ref$selectedGetter === void 0 ? function (selected) {\n    return selected;\n  } : _ref$selectedGetter,\n      _ref$ignoreEmptyLine = _ref.ignoreEmptyLine,\n      ignoreEmptyLine = _ref$ignoreEmptyLine === void 0 ? true : _ref$ignoreEmptyLine;\n  var insertContent;\n  var newSelected;\n\n  if (selected) {\n    newSelected = selectedGetter(selected);\n    insertContent = InsertGetter(selected, 1); // 如果当前选中的文本包含换行 则插入后选中插入的所有文本\n\n    if (selected.indexOf('\\n') !== -1) {\n      insertContent = selected.split('\\n').map(function (rowText, index) {\n        var isEmptyLine = !rowText;\n        if (ignoreEmptyLine && isEmptyLine) return '';\n        return InsertGetter(rowText, index + 1).replace(selectedGetter(null), '');\n      }).join('\\n');\n      newSelected = insertContent;\n    }\n  } else {\n    insertContent = InsertGetter(null, 1);\n    newSelected = selectedGetter(selected);\n  }\n\n  return {\n    insertContent: insertContent,\n    newSelected: newSelected\n  };\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_9810__) {\n\n\"use strict\";\n/* harmony export (binding) */ __nested_webpack_require_9810__.d(__webpack_exports__, \"c\", function() { return LINE_MARKUP; });\n/* harmony export (binding) */ __nested_webpack_require_9810__.d(__webpack_exports__, \"b\", function() { return HEADING_MARKUP; });\n/* harmony export (binding) */ __nested_webpack_require_9810__.d(__webpack_exports__, \"a\", function() { return ANCHOR_MARKUP; });\nvar LINE_MARKUP = 'data-v-md-line';\nvar HEADING_MARKUP = 'data-v-md-heading';\nvar ANCHOR_MARKUP = 'data-v-md-anchor';\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  PREVIEW: 'preview',\n  EDITABLE: 'editable',\n  EDIT: 'edit'\n});\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_10609__) {\n\n\"use strict\";\n/* harmony export (binding) */ __nested_webpack_require_10609__.d(__webpack_exports__, \"a\", function() { return getScrollTop; });\n/* harmony export (binding) */ __nested_webpack_require_10609__.d(__webpack_exports__, \"b\", function() { return scrollTo; });\nfunction getScrollTop(target) {\n  var result = 0;\n\n  if (target === window) {\n    result = target.pageYOffset;\n  } else if (target) {\n    result = target.scrollTop;\n  }\n\n  return result;\n}\nfunction scrollTo(target, scrollTop) {\n  if (target === window) {\n    window.scrollTo(window.pageYOffset, scrollTop);\n  } else if (target) {\n    target.scrollTop = scrollTop;\n  }\n}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_11311__) {\n\n\"use strict\";\n/* harmony export (binding) */ __nested_webpack_require_11311__.d(__webpack_exports__, \"a\", function() { return _extends; });\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_11909__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nvar esm_extends = __nested_webpack_require_11909__(6);\n\n// EXTERNAL MODULE: ./node_modules/xss/lib/index.js\nvar lib = __nested_webpack_require_11909__(11);\nvar lib_default = /*#__PURE__*/__nested_webpack_require_11909__.n(lib);\n\n// CONCATENATED MODULE: ./src/utils/xss/svg.js\nvar svgTagWhiteList = {\n  svg: [],\n  altGlyph: [],\n  altGlyphDef: [],\n  altGlyphItem: [],\n  animate: [],\n  animateColor: [],\n  animateMotion: [],\n  animateTransform: [],\n  circle: [],\n  clipPath: [],\n  'color-profile': [],\n  cursor: [],\n  'definition-src': [],\n  defs: [],\n  desc: [],\n  ellipse: [],\n  feBlend: [],\n  feColorMatrix: [],\n  feComponentTransfer: [],\n  feComposite: [],\n  feConvolveMatrix: [],\n  feDiffuseLighting: [],\n  feDisplacementMap: [],\n  feDistantLight: [],\n  feFlood: [],\n  feFuncA: [],\n  feFuncB: [],\n  feFuncG: [],\n  feFuncR: [],\n  feGaussianBlur: [],\n  feImage: [],\n  feMerge: [],\n  feMergeNode: [],\n  feMorphology: [],\n  feOffset: [],\n  fePointLight: [],\n  feSpecularLighting: [],\n  feSpotLight: [],\n  feTile: [],\n  feTurbulence: [],\n  filter: [],\n  font: [],\n  foreignObject: [],\n  g: [],\n  glyph: [],\n  glyphRef: [],\n  hkern: [],\n  image: [],\n  line: [],\n  linearGradient: [],\n  marker: [],\n  mask: [],\n  metadata: [],\n  'missing-glyph': [],\n  mpath: [],\n  path: [],\n  pattern: [],\n  polygon: [],\n  polyline: [],\n  radialGradient: [],\n  rect: [],\n  set: [],\n  stop: [],\n  style: [],\n  switch: [],\n  symbol: [],\n  text: [],\n  textPath: [],\n  title: [],\n  tref: [],\n  tspan: [],\n  use: [],\n  view: [],\n  vkern: []\n};\nvar svgAttrWhiteList = ['width', 'height', 'x', 'y', 'rx', 'ry', 'cx', 'cy', 'r', 'viewbox', 'points', 'fill', 'stroke', 'stroke-width', 'opacity', 'transform', 'd', 'text-anchor', 'font-family', 'font-size', 'font-weight', 'filter', 'href', 'xlink:href'];\n// CONCATENATED MODULE: ./src/utils/xss/KaTex.js\nvar katexTagWhiteList = {\n  math: [],\n  annotation: [],\n  semantics: [],\n  mtext: [],\n  mn: [],\n  mo: [],\n  mi: [],\n  mspace: [],\n  mover: [],\n  munder: [],\n  munderover: [],\n  msup: [],\n  msub: [],\n  msubsup: [],\n  mfrac: [],\n  mroot: [],\n  msqrt: [],\n  mtable: [],\n  mtr: [],\n  mtd: [],\n  mlabeledtr: [],\n  mrow: [],\n  menclose: [],\n  mstyle: [],\n  mpadded: [],\n  mphantom: [],\n  mglyph: []\n};\nvar katexAttrWhiteList = ['mathcolor', 'mathbackground', 'mathsize', 'mathvariant', 'mathfamily', 'mathweight', 'mathstyle', 'mathdisplay'];\n// CONCATENATED MODULE: ./src/utils/xss/common.js\nvar attrWhiteList = ['style', 'align', 'class', 'id'];\nvar prefixAttrWhiteList = ['data-'];\nvar commonWhiteList = {\n  input: ['type'],\n  ol: ['reversed', 'start', 'type'],\n  button: ['type'],\n  summary: []\n};\n// CONCATENATED MODULE: ./src/utils/xss/index.js\n\n\n\n\n\nvar options = {\n  whiteList: Object(esm_extends[\"a\" /* default */])({}, lib_default.a.getDefaultWhiteList(), commonWhiteList, svgTagWhiteList, katexTagWhiteList),\n  onIgnoreTagAttr: function onIgnoreTagAttr(tag, name, value) {\n    if (svgTagWhiteList[tag] && svgAttrWhiteList.includes(name) || katexTagWhiteList[tag] && katexAttrWhiteList.includes(name) || attrWhiteList.some(function (attr) {\n      return attr === name;\n    }) || prefixAttrWhiteList.some(function (prefix) {\n      return name.startsWith(prefix);\n    })) {\n      return name + \"=\\\"\" + lib_default.a.escapeAttrValue(value) + \"\\\"\";\n    }\n  }\n};\nvar xssFilterInstance = new lib_default.a.FilterXSS(options);\n\nxssFilterInstance.extend = function (extendOptions) {\n  var instanceOptions = xssFilterInstance.options;\n  Object.keys(extendOptions).forEach(function (optionName) {\n    // extend whiteList\n    if (optionName === 'whiteList') {\n      Object.keys(extendOptions.whiteList).forEach(function (tagName) {\n        var tagAttrWhiteList = extendOptions.whiteList[tagName];\n        var instanceWhiteList = instanceOptions.whiteList;\n\n        if (instanceWhiteList[tagName]) {\n          instanceWhiteList[tagName] = [].concat(instanceWhiteList[tagName], tagAttrWhiteList);\n        } else {\n          instanceWhiteList[tagName] = tagAttrWhiteList;\n        }\n      });\n    } else if (optionName === 'onIgnoreTagAttr') {\n      var oldHandler = instanceOptions[optionName];\n\n      instanceOptions[optionName] = function () {\n        var _extendOptions$option;\n\n        for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {\n          arg[_key] = arguments[_key];\n        }\n\n        var oldReturnVal = oldHandler.call.apply(oldHandler, [this].concat(arg));\n\n        var newReturnVal = (_extendOptions$option = extendOptions[optionName]).call.apply(_extendOptions$option, [this].concat(arg));\n\n        return oldReturnVal || newReturnVal;\n      };\n    } else {\n      instanceOptions[optionName] = extendOptions[optionName];\n    }\n  });\n};\n\n/* harmony default export */ var xss = __webpack_exports__[\"a\"] = (xssFilterInstance);\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_16840__) {\n\n\"use strict\";\n/* harmony export (binding) */ __nested_webpack_require_16840__.d(__webpack_exports__, \"b\", function() { return smooth; });\n/* harmony export (binding) */ __nested_webpack_require_16840__.d(__webpack_exports__, \"a\", function() { return smoothScroll; });\n/* harmony import */ var _scroll_top__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_16840__(5);\n\nfunction smooth(_ref) {\n  var currentScrollTop = _ref.currentScrollTop,\n      scrollToTop = _ref.scrollToTop,\n      scrollFn = _ref.scrollFn,\n      _ref$percent = _ref.percent,\n      percent = _ref$percent === void 0 ? 10 : _ref$percent,\n      onScrollEnd = _ref.onScrollEnd;\n  var scrollWay = scrollToTop > currentScrollTop ? 'down' : 'up';\n  var step = (scrollToTop - currentScrollTop) * (percent / 100);\n  var id;\n\n  var scroll = function scroll() {\n    currentScrollTop += step;\n\n    if (scrollWay === 'down' && currentScrollTop >= scrollToTop || scrollWay === 'up' && currentScrollTop <= scrollToTop) {\n      scrollFn(scrollToTop);\n      window.cancelAnimationFrame(id);\n      if (onScrollEnd) window.requestAnimationFrame(onScrollEnd);\n    } else {\n      scrollFn(currentScrollTop);\n      window.requestAnimationFrame(scroll);\n    }\n  };\n\n  window.requestAnimationFrame(scroll);\n}\nfunction smoothScroll(_ref2) {\n  var scrollTarget = _ref2.scrollTarget,\n      scrollToTop = _ref2.scrollToTop,\n      _ref2$percent = _ref2.percent,\n      percent = _ref2$percent === void 0 ? 10 : _ref2$percent,\n      onScrollEnd = _ref2.onScrollEnd;\n  var currentScrollTop = Object(_scroll_top__WEBPACK_IMPORTED_MODULE_0__[/* getScrollTop */ \"a\"])(scrollTarget);\n  smooth({\n    currentScrollTop: currentScrollTop,\n    scrollToTop: scrollToTop,\n    scrollFn: function scrollFn(scrollTop) {\n      return Object(_scroll_top__WEBPACK_IMPORTED_MODULE_0__[/* scrollTo */ \"b\"])(scrollTarget, scrollTop);\n    },\n    percent: percent,\n    onScrollEnd: onScrollEnd\n  });\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_18813__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__nested_webpack_require_18813__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external {\"root\":\"Vue\",\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"amd\":\"vue\"}\nvar external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_ = __nested_webpack_require_18813__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/preview.vue?vue&type=template&id=52ff70be&bindings={}\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"div\", {\n    class: \"v-md-editor-preview\",\n    style: {\n      tabSize: _ctx.tabSize,\n      '-moz-tab-size': _ctx.tabSize,\n      '-o-tab-size': _ctx.tabSize\n    },\n    onClick: _cache[1] || (_cache[1] = function () {\n      return _ctx.handlePreviewClick.apply(_ctx, arguments);\n    })\n  }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n    class: [_ctx.previewClass],\n    innerHTML: _ctx.html\n  }, null, 10\n  /* CLASS, PROPS */\n  , [\"innerHTML\"])], 4\n  /* STYLE */\n  );\n}\n// CONCATENATED MODULE: ./src/preview.vue?vue&type=template&id=52ff70be&bindings={}\n\n// EXTERNAL MODULE: ./src/utils/xss/index.js + 3 modules\nvar xss = __nested_webpack_require_18813__(7);\n\n// EXTERNAL MODULE: ./src/utils/lang.js + 1 modules\nvar lang = __nested_webpack_require_18813__(13);\n\n// CONCATENATED MODULE: ./src/utils/v-md-parser.js\n\nvar v_md_parser_VMdParser = /*#__PURE__*/function () {\n  function VMdParser() {\n    this.lang = new lang[\"a\" /* default */]();\n  }\n\n  var _proto = VMdParser.prototype;\n\n  _proto.defaultMarkdownLoader = function defaultMarkdownLoader(text) {\n    return text;\n  };\n\n  _proto.use = function use(optionsOrInstall, opt) {\n    if (typeof optionsOrInstall === 'function') {\n      optionsOrInstall(this, opt);\n    } else {\n      optionsOrInstall.install(this, opt);\n    }\n\n    return this;\n  };\n\n  _proto.theme = function theme(themeConfig) {\n    this.themeConfig = themeConfig;\n  };\n\n  _proto.extendMarkdown = function extendMarkdown(extender) {\n    if (!this.themeConfig) {\n      return console.error('Please use theme before using plugins');\n    }\n\n    var markdownParser = this.themeConfig.markdownParser;\n    extender(markdownParser);\n  };\n\n  _proto.parse = function parse(text) {\n    var _markdownParser$rende;\n\n    var markdownParser = this.themeConfig.markdownParser;\n    var markdownLoader = (markdownParser == null ? void 0 : (_markdownParser$rende = markdownParser.render) == null ? void 0 : _markdownParser$rende.bind(markdownParser)) || this.defaultMarkdownLoader;\n\n    if (typeof markdownLoader !== 'function' || markdownLoader === this.defaultMarkdownLoader) {\n      console.error('Please configure your markdown parser');\n    }\n\n    return markdownLoader(text);\n  };\n\n  return VMdParser;\n}();\n// EXTERNAL MODULE: ./src/mixins/preview.js\nvar preview = __nested_webpack_require_18813__(16);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/preview.vue?vue&type=script&lang=js\n\n\n // mixins\n\n\nvar component = {\n  name: 'v-md-preview',\n  mixins: [preview[\"a\" /* default */]],\n  props: {\n    text: {\n      type: String,\n      default: ''\n    },\n    theme: Object,\n    beforeChange: Function\n  },\n  emits: ['change'],\n  data: function data() {\n    return {\n      html: ''\n    };\n  },\n  watch: {\n    text: function text() {\n      this.handleTextChange();\n    },\n    langConfig: function langConfig() {\n      this.handleTextChange();\n    }\n  },\n  computed: {\n    vMdParser: function vMdParser() {\n      return this.$options.vMdParser;\n    },\n    previewClass: function previewClass() {\n      return this.vMdParser.themeConfig.previewClass;\n    },\n    langConfig: function langConfig() {\n      return this.vMdParser.lang.config;\n    }\n  },\n  created: function created() {\n    this.handleTextChange();\n  },\n  methods: {\n    handleTextChange: function handleTextChange() {\n      var _this = this;\n\n      var next = function next(text) {\n        _this.html = xss[\"a\" /* default */].process(_this.$options.vMdParser.parse(text));\n\n        _this.$emit('change', text, _this.html);\n      };\n\n      if (this.beforeChange) {\n        this.beforeChange(this.text, next);\n      } else {\n        next(this.text);\n      }\n    }\n  }\n};\nvar vMdParser = new v_md_parser_VMdParser();\nvMdParser.lang.config = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"reactive\"])(vMdParser.lang.config);\ncomponent.vMdParser = new v_md_parser_VMdParser();\n/* harmony default export */ var previewvue_type_script_lang_js = (component);\n// CONCATENATED MODULE: ./src/preview.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/preview.vue\n\n\n\npreviewvue_type_script_lang_js.render = render\n\n/* harmony default export */ var src_preview = (previewvue_type_script_lang_js);\n// EXTERNAL MODULE: ./src/assets/css/font.css\nvar font = __nested_webpack_require_18813__(18);\n\n// CONCATENATED MODULE: ./src/preview.js\n// This file is auto generated by build/build-entry.js\n\n // font css\n\n\nvar version = '2.3.18';\n\nvar preview_install = function install(app) {\n  app.component(src_preview.name, src_preview);\n};\n\nsrc_preview.version = version;\nsrc_preview.install = preview_install;\nsrc_preview.xss = xss[\"a\" /* default */];\n\nsrc_preview.use = function (optionsOrInstall, opt) {\n  if (typeof optionsOrInstall === 'function') {\n    optionsOrInstall(src_preview, opt);\n  } else {\n    optionsOrInstall.install(src_preview, opt);\n  }\n\n  return src_preview;\n};\n\n/* harmony default export */ var src_preview_0 = __webpack_exports__[\"default\"] = (src_preview);\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __nested_webpack_require_24594__) {\n\nmodule.exports = __nested_webpack_require_24594__(37);\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __nested_webpack_require_24714__) {\n\n/**\n * xss\n *\n * @author Zongmin Lei<leizongmin@gmail.com>\n */\n\nvar DEFAULT = __nested_webpack_require_24714__(19);\nvar parser = __nested_webpack_require_24714__(22);\nvar FilterXSS = __nested_webpack_require_24714__(26);\n\n/**\n * filter xss function\n *\n * @param {String} html\n * @param {Object} options { whiteList, onTag, onTagAttr, onIgnoreTag, onIgnoreTagAttr, safeAttrValue, escapeHtml }\n * @return {String}\n */\nfunction filterXSS(html, options) {\n  var xss = new FilterXSS(options);\n  return xss.process(html);\n}\n\nexports = module.exports = filterXSS;\nexports.filterXSS = filterXSS;\nexports.FilterXSS = FilterXSS;\nfor (var i in DEFAULT) exports[i] = DEFAULT[i];\nfor (var i in parser) exports[i] = parser[i];\n\n// using `xss` on the browser, output `filterXSS` to the globals\nif (typeof window !== \"undefined\") {\n  window.filterXSS = module.exports;\n}\n\n// using `xss` on the WebWorker, output `filterXSS` to the globals\nfunction isWorkerEnv() {\n  return (\n    typeof self !== \"undefined\" &&\n    typeof DedicatedWorkerGlobalScope !== \"undefined\" &&\n    self instanceof DedicatedWorkerGlobalScope\n  );\n}\nif (isWorkerEnv()) {\n  self.filterXSS = module.exports;\n}\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_25928__) {\n\n\"use strict\";\n/* harmony export (binding) */ __nested_webpack_require_25928__.d(__webpack_exports__, \"a\", function() { return filesFilter; });\n/* harmony export (binding) */ __nested_webpack_require_25928__.d(__webpack_exports__, \"b\", function() { return getFilesFromClipboardData; });\n// Modified from https://github.com/ElemeFE/element/blob/dev/packages/upload/src/upload-dragger.vue\nfunction filesFilter(files, config) {\n  var accept = config.accept;\n  var filesKeys = Object.keys(files).filter(function (key) {\n    var file = files[key];\n    var type = file.type,\n        name = file.name;\n    var extension = name.indexOf('.') > -1 ? \".\" + name.split('.').pop() : '';\n    var baseType = type.replace(/\\/.*$/, '');\n    return accept.split(',').map(function (type) {\n      return type.trim();\n    }).filter(function (type) {\n      return type;\n    }).some(function (acceptedType) {\n      if (/\\..+$/.test(acceptedType)) {\n        return extension === acceptedType;\n      }\n\n      if (/\\/\\*$/.test(acceptedType)) {\n        return baseType === acceptedType.replace(/\\/\\*$/, '');\n      } // eslint-disable-next-line no-useless-escape\n\n\n      if (/^[^\\/]+\\/[^\\/]+$/.test(acceptedType)) {\n        return type === acceptedType;\n      }\n\n      return false;\n    });\n  });\n  return filesKeys.map(function (key) {\n    return files[key];\n  });\n}\nfunction getFilesFromClipboardData(clipboardData) {\n  var files = [];\n  Object.keys(clipboardData.items).forEach(function (key) {\n    var item = clipboardData.items[key];\n\n    if (item.kind === 'file') {\n      var file = item.getAsFile();\n      if (file) files.push(file);\n    }\n  });\n  return files;\n}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_27633__) {\n\n\"use strict\";\n\n// EXPORTS\n__nested_webpack_require_27633__.d(__webpack_exports__, \"a\", function() { return /* binding */ lang_Lang; });\n\n// EXTERNAL MODULE: ./src/utils/util.js\nvar util = __nested_webpack_require_27633__(2);\n\n// CONCATENATED MODULE: ./src/utils/deep-assign.js\n\nvar deep_assign_hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction assignKey(to, from, key) {\n  var val = from[key];\n\n  if (val === undefined || val === null) {\n    return;\n  }\n\n  if (!deep_assign_hasOwnProperty.call(to, key) || !Object(util[\"f\" /* isObject */])(val)) {\n    to[key] = val;\n  } else {\n    // eslint-disable-next-line\n    to[key] = deepAssign(Object(to[key]), from[key]);\n  }\n}\n\nfunction deepAssign(to, from) {\n  Object.keys(from).forEach(function (key) {\n    assignKey(to, from, key);\n  });\n  return to;\n}\n// CONCATENATED MODULE: ./src/utils/lang.js\n\n\nvar lang_Lang = /*#__PURE__*/function () {\n  function Lang(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.config = {\n      lang: 'zh-CN',\n      langConfig: {\n        'zh-CN': {}\n      }\n    };\n    this.options = options;\n  }\n\n  var _proto = Lang.prototype;\n\n  _proto.use = function use(lang, config) {\n    var _this$add;\n\n    this.config.lang = lang;\n    this.add((_this$add = {}, _this$add[lang] = config, _this$add));\n    if (this.options.afterUse) this.options.afterUse(lang, config);\n  };\n\n  _proto.add = function add(config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    deepAssign(this.config.langConfig, config);\n  };\n\n  return Lang;\n}();\n\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __nested_webpack_require_29232__) {\n\n/**\n * cssfilter\n *\n * @author 老雷<leizongmin@gmail.com>\n */\n\nvar DEFAULT = __nested_webpack_require_29232__(20);\nvar FilterCSS = __nested_webpack_require_29232__(24);\n\n\n/**\n * XSS过滤\n *\n * @param {String} css 要过滤的CSS代码\n * @param {Object} options 选项：whiteList, onAttr, onIgnoreAttr\n * @return {String}\n */\nfunction filterCSS (html, options) {\n  var xss = new FilterCSS(options);\n  return xss.process(html);\n}\n\n\n// 输出\nexports = module.exports = filterCSS;\nexports.FilterCSS = FilterCSS;\nfor (var i in DEFAULT) exports[i] = DEFAULT[i];\n\n// 在浏览器端使用\nif (typeof window !== 'undefined') {\n  window.filterCSS = module.exports;\n}\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  indexOf: function (arr, item) {\n    var i, j;\n    if (Array.prototype.indexOf) {\n      return arr.indexOf(item);\n    }\n    for (i = 0, j = arr.length; i < j; i++) {\n      if (arr[i] === item) {\n        return i;\n      }\n    }\n    return -1;\n  },\n  forEach: function (arr, fn, scope) {\n    var i, j;\n    if (Array.prototype.forEach) {\n      return arr.forEach(fn, scope);\n    }\n    for (i = 0, j = arr.length; i < j; i++) {\n      fn.call(scope, arr[i], i, arr);\n    }\n  },\n  trim: function (str) {\n    if (String.prototype.trim) {\n      return str.trim();\n    }\n    return str.replace(/(^\\s*)|(\\s*$)/g, \"\");\n  },\n  spaceIndex: function (str) {\n    var reg = /\\s|\\n|\\t/;\n    var match = reg.exec(str);\n    return match ? match.index : -1;\n  },\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_30739__) {\n\n\"use strict\";\n/* harmony import */ var _utils_scroll_top__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_30739__(5);\n/* harmony import */ var _utils_smooth_scroll__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_30739__(8);\n/* harmony import */ var _utils_constants_markup__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_30739__(3);\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  props: {\n    tabSize: {\n      type: Number,\n      default: 2\n    },\n    scrollContainer: {\n      type: Function,\n      default: function _default() {\n        return window;\n      }\n    },\n    top: {\n      type: Number,\n      default: 0\n    }\n  },\n  emits: ['image-click'],\n  methods: {\n    handlePreviewClick: function handlePreviewClick(e) {\n      var target = e.target; // image preview\n\n      if (target.tagName === 'IMG') {\n        var src = target.getAttribute('src');\n        if (!src) return;\n        var imageEls = Array.from(this.$el.querySelectorAll('img'));\n        var images = imageEls.map(function (el) {\n          return el.getAttribute('src');\n        }).filter(function (src) {\n          return src;\n        });\n        var imagePreviewInitIndex = imageEls.indexOf(target);\n        this.$emit('image-click', images, imagePreviewInitIndex);\n        return;\n      }\n\n      var scrollToTargetId = target.getAttribute(_utils_constants_markup__WEBPACK_IMPORTED_MODULE_2__[/* ANCHOR_MARKUP */ \"a\"]);\n      var scrollToTarget = this.$el.querySelector(\"[\" + _utils_constants_markup__WEBPACK_IMPORTED_MODULE_2__[/* HEADING_MARKUP */ \"b\"] + \"=\\\"\" + scrollToTargetId + \"\\\"]\");\n\n      if (scrollToTarget) {\n        this.scrollToTarget({\n          target: scrollToTarget\n        });\n      }\n    },\n    getOffsetTop: function getOffsetTop(target, container) {\n      var rect = target.getBoundingClientRect();\n\n      if (container === window || container === document.documentElement) {\n        return rect.top;\n      }\n\n      return rect.top - container.getBoundingClientRect().top;\n    },\n    scrollToTarget: function scrollToTarget(_ref) {\n      var target = _ref.target,\n          _ref$scrollContainer = _ref.scrollContainer,\n          scrollContainer = _ref$scrollContainer === void 0 ? this.scrollContainer() : _ref$scrollContainer,\n          _ref$top = _ref.top,\n          top = _ref$top === void 0 ? this.top : _ref$top,\n          onScrollEnd = _ref.onScrollEnd;\n      var offsetTop = this.getOffsetTop(target, scrollContainer);\n      var scrollTop = Object(_utils_scroll_top__WEBPACK_IMPORTED_MODULE_0__[/* getScrollTop */ \"a\"])(scrollContainer) + offsetTop - top;\n      Object(_utils_smooth_scroll__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])({\n        scrollTarget: scrollContainer,\n        scrollToTop: scrollTop,\n        onScrollEnd: onScrollEnd\n      });\n    },\n    scrollToLine: function scrollToLine(_ref2) {\n      var lineIndex = _ref2.lineIndex,\n          onScrollEnd = _ref2.onScrollEnd;\n\n      if (lineIndex) {\n        var target = this.$el.querySelector(\"[\" + _utils_constants_markup__WEBPACK_IMPORTED_MODULE_2__[/* LINE_MARKUP */ \"c\"] + \"=\\\"\" + lineIndex + \"\\\"]\");\n        if (target) this.scrollToTarget({\n          target: target,\n          onScrollEnd: onScrollEnd\n        });\n      }\n    }\n  }\n});\n\n/***/ }),\n/* 17 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_34039__) {\n\n\"use strict\";\n/* harmony export (binding) */ __nested_webpack_require_34039__.d(__webpack_exports__, \"a\", function() { return _asyncToGenerator; });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_35142__) {\n\n/**\n * default settings\n *\n * @author Zongmin Lei<leizongmin@gmail.com>\n */\n\nvar FilterCSS = __nested_webpack_require_35142__(14).FilterCSS;\nvar getDefaultCSSWhiteList = __nested_webpack_require_35142__(14).getDefaultWhiteList;\nvar _ = __nested_webpack_require_35142__(15);\n\nfunction getDefaultWhiteList() {\n  return {\n    a: [\"target\", \"href\", \"title\"],\n    abbr: [\"title\"],\n    address: [],\n    area: [\"shape\", \"coords\", \"href\", \"alt\"],\n    article: [],\n    aside: [],\n    audio: [\n      \"autoplay\",\n      \"controls\",\n      \"crossorigin\",\n      \"loop\",\n      \"muted\",\n      \"preload\",\n      \"src\",\n    ],\n    b: [],\n    bdi: [\"dir\"],\n    bdo: [\"dir\"],\n    big: [],\n    blockquote: [\"cite\"],\n    br: [],\n    caption: [],\n    center: [],\n    cite: [],\n    code: [],\n    col: [\"align\", \"valign\", \"span\", \"width\"],\n    colgroup: [\"align\", \"valign\", \"span\", \"width\"],\n    dd: [],\n    del: [\"datetime\"],\n    details: [\"open\"],\n    div: [],\n    dl: [],\n    dt: [],\n    em: [],\n    figcaption: [],\n    figure: [],\n    font: [\"color\", \"size\", \"face\"],\n    footer: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    header: [],\n    hr: [],\n    i: [],\n    img: [\"src\", \"alt\", \"title\", \"width\", \"height\"],\n    ins: [\"datetime\"],\n    li: [],\n    mark: [],\n    nav: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    section: [],\n    small: [],\n    span: [],\n    sub: [],\n    summary: [],\n    sup: [],\n    strong: [],\n    strike: [],\n    table: [\"width\", \"border\", \"align\", \"valign\"],\n    tbody: [\"align\", \"valign\"],\n    td: [\"width\", \"rowspan\", \"colspan\", \"align\", \"valign\"],\n    tfoot: [\"align\", \"valign\"],\n    th: [\"width\", \"rowspan\", \"colspan\", \"align\", \"valign\"],\n    thead: [\"align\", \"valign\"],\n    tr: [\"rowspan\", \"align\", \"valign\"],\n    tt: [],\n    u: [],\n    ul: [],\n    video: [\n      \"autoplay\",\n      \"controls\",\n      \"crossorigin\",\n      \"loop\",\n      \"muted\",\n      \"playsinline\",\n      \"poster\",\n      \"preload\",\n      \"src\",\n      \"height\",\n      \"width\",\n    ],\n  };\n}\n\nvar defaultCSSFilter = new FilterCSS();\n\n/**\n * default onTag function\n *\n * @param {String} tag\n * @param {String} html\n * @param {Object} options\n * @return {String}\n */\nfunction onTag(tag, html, options) {\n  // do nothing\n}\n\n/**\n * default onIgnoreTag function\n *\n * @param {String} tag\n * @param {String} html\n * @param {Object} options\n * @return {String}\n */\nfunction onIgnoreTag(tag, html, options) {\n  // do nothing\n}\n\n/**\n * default onTagAttr function\n *\n * @param {String} tag\n * @param {String} name\n * @param {String} value\n * @return {String}\n */\nfunction onTagAttr(tag, name, value) {\n  // do nothing\n}\n\n/**\n * default onIgnoreTagAttr function\n *\n * @param {String} tag\n * @param {String} name\n * @param {String} value\n * @return {String}\n */\nfunction onIgnoreTagAttr(tag, name, value) {\n  // do nothing\n}\n\n/**\n * default escapeHtml function\n *\n * @param {String} html\n */\nfunction escapeHtml(html) {\n  return html.replace(REGEXP_LT, \"&lt;\").replace(REGEXP_GT, \"&gt;\");\n}\n\n/**\n * default safeAttrValue function\n *\n * @param {String} tag\n * @param {String} name\n * @param {String} value\n * @param {Object} cssFilter\n * @return {String}\n */\nfunction safeAttrValue(tag, name, value, cssFilter) {\n  // unescape attribute value firstly\n  value = friendlyAttrValue(value);\n\n  if (name === \"href\" || name === \"src\") {\n    // filter `href` and `src` attribute\n    // only allow the value that starts with `http://` | `https://` | `mailto:` | `/` | `#`\n    value = _.trim(value);\n    if (value === \"#\") return \"#\";\n    if (\n      !(\n        value.substr(0, 7) === \"http://\" ||\n        value.substr(0, 8) === \"https://\" ||\n        value.substr(0, 7) === \"mailto:\" ||\n        value.substr(0, 4) === \"tel:\" ||\n        value.substr(0, 11) === \"data:image/\" ||\n        value.substr(0, 6) === \"ftp://\" ||\n        value.substr(0, 2) === \"./\" ||\n        value.substr(0, 3) === \"../\" ||\n        value[0] === \"#\" ||\n        value[0] === \"/\"\n      )\n    ) {\n      return \"\";\n    }\n  } else if (name === \"background\") {\n    // filter `background` attribute (maybe no use)\n    // `javascript:`\n    REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;\n    if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {\n      return \"\";\n    }\n  } else if (name === \"style\") {\n    // `expression()`\n    REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;\n    if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {\n      return \"\";\n    }\n    // `url()`\n    REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;\n    if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {\n      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;\n      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {\n        return \"\";\n      }\n    }\n    if (cssFilter !== false) {\n      cssFilter = cssFilter || defaultCSSFilter;\n      value = cssFilter.process(value);\n    }\n  }\n\n  // escape `<>\"` before returns\n  value = escapeAttrValue(value);\n  return value;\n}\n\n// RegExp list\nvar REGEXP_LT = /</g;\nvar REGEXP_GT = />/g;\nvar REGEXP_QUOTE = /\"/g;\nvar REGEXP_QUOTE_2 = /&quot;/g;\nvar REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;\nvar REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;\nvar REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;\nvar REGEXP_DEFAULT_ON_TAG_ATTR_3 = /\\/\\*|\\*\\//gm;\nvar REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\\s*a\\s*v\\s*a|v\\s*b|l\\s*i\\s*v\\s*e)\\s*s\\s*c\\s*r\\s*i\\s*p\\s*t\\s*|m\\s*o\\s*c\\s*h\\s*a)\\:/gi;\nvar REGEXP_DEFAULT_ON_TAG_ATTR_5 = /^[\\s\"'`]*(d\\s*a\\s*t\\s*a\\s*)\\:/gi;\nvar REGEXP_DEFAULT_ON_TAG_ATTR_6 = /^[\\s\"'`]*(d\\s*a\\s*t\\s*a\\s*)\\:\\s*image\\//gi;\nvar REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\\s*x\\s*p\\s*r\\s*e\\s*s\\s*s\\s*i\\s*o\\s*n\\s*\\(.*/gi;\nvar REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\\s*r\\s*l\\s*\\(.*/gi;\n\n/**\n * escape double quote\n *\n * @param {String} str\n * @return {String} str\n */\nfunction escapeQuote(str) {\n  return str.replace(REGEXP_QUOTE, \"&quot;\");\n}\n\n/**\n * unescape double quote\n *\n * @param {String} str\n * @return {String} str\n */\nfunction unescapeQuote(str) {\n  return str.replace(REGEXP_QUOTE_2, '\"');\n}\n\n/**\n * escape html entities\n *\n * @param {String} str\n * @return {String}\n */\nfunction escapeHtmlEntities(str) {\n  return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str, code) {\n    return code[0] === \"x\" || code[0] === \"X\"\n      ? String.fromCharCode(parseInt(code.substr(1), 16))\n      : String.fromCharCode(parseInt(code, 10));\n  });\n}\n\n/**\n * escape html5 new danger entities\n *\n * @param {String} str\n * @return {String}\n */\nfunction escapeDangerHtml5Entities(str) {\n  return str\n    .replace(REGEXP_ATTR_VALUE_COLON, \":\")\n    .replace(REGEXP_ATTR_VALUE_NEWLINE, \" \");\n}\n\n/**\n * clear nonprintable characters\n *\n * @param {String} str\n * @return {String}\n */\nfunction clearNonPrintableCharacter(str) {\n  var str2 = \"\";\n  for (var i = 0, len = str.length; i < len; i++) {\n    str2 += str.charCodeAt(i) < 32 ? \" \" : str.charAt(i);\n  }\n  return _.trim(str2);\n}\n\n/**\n * get friendly attribute value\n *\n * @param {String} str\n * @return {String}\n */\nfunction friendlyAttrValue(str) {\n  str = unescapeQuote(str);\n  str = escapeHtmlEntities(str);\n  str = escapeDangerHtml5Entities(str);\n  str = clearNonPrintableCharacter(str);\n  return str;\n}\n\n/**\n * unescape attribute value\n *\n * @param {String} str\n * @return {String}\n */\nfunction escapeAttrValue(str) {\n  str = escapeQuote(str);\n  str = escapeHtml(str);\n  return str;\n}\n\n/**\n * `onIgnoreTag` function for removing all the tags that are not in whitelist\n */\nfunction onIgnoreTagStripAll() {\n  return \"\";\n}\n\n/**\n * remove tag body\n * specify a `tags` list, if the tag is not in the `tags` list then process by the specify function (optional)\n *\n * @param {array} tags\n * @param {function} next\n */\nfunction StripTagBody(tags, next) {\n  if (typeof next !== \"function\") {\n    next = function () {};\n  }\n\n  var isRemoveAllTag = !Array.isArray(tags);\n  function isRemoveTag(tag) {\n    if (isRemoveAllTag) return true;\n    return _.indexOf(tags, tag) !== -1;\n  }\n\n  var removeList = [];\n  var posStart = false;\n\n  return {\n    onIgnoreTag: function (tag, html, options) {\n      if (isRemoveTag(tag)) {\n        if (options.isClosing) {\n          var ret = \"[/removed]\";\n          var end = options.position + ret.length;\n          removeList.push([\n            posStart !== false ? posStart : options.position,\n            end,\n          ]);\n          posStart = false;\n          return ret;\n        } else {\n          if (!posStart) {\n            posStart = options.position;\n          }\n          return \"[removed]\";\n        }\n      } else {\n        return next(tag, html, options);\n      }\n    },\n    remove: function (html) {\n      var rethtml = \"\";\n      var lastPos = 0;\n      _.forEach(removeList, function (pos) {\n        rethtml += html.slice(lastPos, pos[0]);\n        lastPos = pos[1];\n      });\n      rethtml += html.slice(lastPos);\n      return rethtml;\n    },\n  };\n}\n\n/**\n * remove html comments\n *\n * @param {String} html\n * @return {String}\n */\nfunction stripCommentTag(html) {\n  return html.replace(STRIP_COMMENT_TAG_REGEXP, \"\");\n}\nvar STRIP_COMMENT_TAG_REGEXP = /<!--[\\s\\S]*?-->/g;\n\n/**\n * remove invisible characters\n *\n * @param {String} html\n * @return {String}\n */\nfunction stripBlankChar(html) {\n  var chars = html.split(\"\");\n  chars = chars.filter(function (char) {\n    var c = char.charCodeAt(0);\n    if (c === 127) return false;\n    if (c <= 31) {\n      if (c === 10 || c === 13) return true;\n      return false;\n    }\n    return true;\n  });\n  return chars.join(\"\");\n}\n\nexports.whiteList = getDefaultWhiteList();\nexports.getDefaultWhiteList = getDefaultWhiteList;\nexports.onTag = onTag;\nexports.onIgnoreTag = onIgnoreTag;\nexports.onTagAttr = onTagAttr;\nexports.onIgnoreTagAttr = onIgnoreTagAttr;\nexports.safeAttrValue = safeAttrValue;\nexports.escapeHtml = escapeHtml;\nexports.escapeQuote = escapeQuote;\nexports.unescapeQuote = unescapeQuote;\nexports.escapeHtmlEntities = escapeHtmlEntities;\nexports.escapeDangerHtml5Entities = escapeDangerHtml5Entities;\nexports.clearNonPrintableCharacter = clearNonPrintableCharacter;\nexports.friendlyAttrValue = friendlyAttrValue;\nexports.escapeAttrValue = escapeAttrValue;\nexports.onIgnoreTagStripAll = onIgnoreTagStripAll;\nexports.StripTagBody = StripTagBody;\nexports.stripCommentTag = stripCommentTag;\nexports.stripBlankChar = stripBlankChar;\nexports.cssFilter = defaultCSSFilter;\nexports.getDefaultCSSWhiteList = getDefaultCSSWhiteList;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n/**\n * cssfilter\n *\n * @author 老雷<leizongmin@gmail.com>\n */\n\nfunction getDefaultWhiteList () {\n  // 白名单值说明：\n  // true: 允许该属性\n  // Function: function (val) { } 返回true表示允许该属性，其他值均表示不允许\n  // RegExp: regexp.test(val) 返回true表示允许该属性，其他值均表示不允许\n  // 除上面列出的值外均表示不允许\n  var whiteList = {};\n\n  whiteList['align-content'] = false; // default: auto\n  whiteList['align-items'] = false; // default: auto\n  whiteList['align-self'] = false; // default: auto\n  whiteList['alignment-adjust'] = false; // default: auto\n  whiteList['alignment-baseline'] = false; // default: baseline\n  whiteList['all'] = false; // default: depending on individual properties\n  whiteList['anchor-point'] = false; // default: none\n  whiteList['animation'] = false; // default: depending on individual properties\n  whiteList['animation-delay'] = false; // default: 0\n  whiteList['animation-direction'] = false; // default: normal\n  whiteList['animation-duration'] = false; // default: 0\n  whiteList['animation-fill-mode'] = false; // default: none\n  whiteList['animation-iteration-count'] = false; // default: 1\n  whiteList['animation-name'] = false; // default: none\n  whiteList['animation-play-state'] = false; // default: running\n  whiteList['animation-timing-function'] = false; // default: ease\n  whiteList['azimuth'] = false; // default: center\n  whiteList['backface-visibility'] = false; // default: visible\n  whiteList['background'] = true; // default: depending on individual properties\n  whiteList['background-attachment'] = true; // default: scroll\n  whiteList['background-clip'] = true; // default: border-box\n  whiteList['background-color'] = true; // default: transparent\n  whiteList['background-image'] = true; // default: none\n  whiteList['background-origin'] = true; // default: padding-box\n  whiteList['background-position'] = true; // default: 0% 0%\n  whiteList['background-repeat'] = true; // default: repeat\n  whiteList['background-size'] = true; // default: auto\n  whiteList['baseline-shift'] = false; // default: baseline\n  whiteList['binding'] = false; // default: none\n  whiteList['bleed'] = false; // default: 6pt\n  whiteList['bookmark-label'] = false; // default: content()\n  whiteList['bookmark-level'] = false; // default: none\n  whiteList['bookmark-state'] = false; // default: open\n  whiteList['border'] = true; // default: depending on individual properties\n  whiteList['border-bottom'] = true; // default: depending on individual properties\n  whiteList['border-bottom-color'] = true; // default: current color\n  whiteList['border-bottom-left-radius'] = true; // default: 0\n  whiteList['border-bottom-right-radius'] = true; // default: 0\n  whiteList['border-bottom-style'] = true; // default: none\n  whiteList['border-bottom-width'] = true; // default: medium\n  whiteList['border-collapse'] = true; // default: separate\n  whiteList['border-color'] = true; // default: depending on individual properties\n  whiteList['border-image'] = true; // default: none\n  whiteList['border-image-outset'] = true; // default: 0\n  whiteList['border-image-repeat'] = true; // default: stretch\n  whiteList['border-image-slice'] = true; // default: 100%\n  whiteList['border-image-source'] = true; // default: none\n  whiteList['border-image-width'] = true; // default: 1\n  whiteList['border-left'] = true; // default: depending on individual properties\n  whiteList['border-left-color'] = true; // default: current color\n  whiteList['border-left-style'] = true; // default: none\n  whiteList['border-left-width'] = true; // default: medium\n  whiteList['border-radius'] = true; // default: 0\n  whiteList['border-right'] = true; // default: depending on individual properties\n  whiteList['border-right-color'] = true; // default: current color\n  whiteList['border-right-style'] = true; // default: none\n  whiteList['border-right-width'] = true; // default: medium\n  whiteList['border-spacing'] = true; // default: 0\n  whiteList['border-style'] = true; // default: depending on individual properties\n  whiteList['border-top'] = true; // default: depending on individual properties\n  whiteList['border-top-color'] = true; // default: current color\n  whiteList['border-top-left-radius'] = true; // default: 0\n  whiteList['border-top-right-radius'] = true; // default: 0\n  whiteList['border-top-style'] = true; // default: none\n  whiteList['border-top-width'] = true; // default: medium\n  whiteList['border-width'] = true; // default: depending on individual properties\n  whiteList['bottom'] = false; // default: auto\n  whiteList['box-decoration-break'] = true; // default: slice\n  whiteList['box-shadow'] = true; // default: none\n  whiteList['box-sizing'] = true; // default: content-box\n  whiteList['box-snap'] = true; // default: none\n  whiteList['box-suppress'] = true; // default: show\n  whiteList['break-after'] = true; // default: auto\n  whiteList['break-before'] = true; // default: auto\n  whiteList['break-inside'] = true; // default: auto\n  whiteList['caption-side'] = false; // default: top\n  whiteList['chains'] = false; // default: none\n  whiteList['clear'] = true; // default: none\n  whiteList['clip'] = false; // default: auto\n  whiteList['clip-path'] = false; // default: none\n  whiteList['clip-rule'] = false; // default: nonzero\n  whiteList['color'] = true; // default: implementation dependent\n  whiteList['color-interpolation-filters'] = true; // default: auto\n  whiteList['column-count'] = false; // default: auto\n  whiteList['column-fill'] = false; // default: balance\n  whiteList['column-gap'] = false; // default: normal\n  whiteList['column-rule'] = false; // default: depending on individual properties\n  whiteList['column-rule-color'] = false; // default: current color\n  whiteList['column-rule-style'] = false; // default: medium\n  whiteList['column-rule-width'] = false; // default: medium\n  whiteList['column-span'] = false; // default: none\n  whiteList['column-width'] = false; // default: auto\n  whiteList['columns'] = false; // default: depending on individual properties\n  whiteList['contain'] = false; // default: none\n  whiteList['content'] = false; // default: normal\n  whiteList['counter-increment'] = false; // default: none\n  whiteList['counter-reset'] = false; // default: none\n  whiteList['counter-set'] = false; // default: none\n  whiteList['crop'] = false; // default: auto\n  whiteList['cue'] = false; // default: depending on individual properties\n  whiteList['cue-after'] = false; // default: none\n  whiteList['cue-before'] = false; // default: none\n  whiteList['cursor'] = false; // default: auto\n  whiteList['direction'] = false; // default: ltr\n  whiteList['display'] = true; // default: depending on individual properties\n  whiteList['display-inside'] = true; // default: auto\n  whiteList['display-list'] = true; // default: none\n  whiteList['display-outside'] = true; // default: inline-level\n  whiteList['dominant-baseline'] = false; // default: auto\n  whiteList['elevation'] = false; // default: level\n  whiteList['empty-cells'] = false; // default: show\n  whiteList['filter'] = false; // default: none\n  whiteList['flex'] = false; // default: depending on individual properties\n  whiteList['flex-basis'] = false; // default: auto\n  whiteList['flex-direction'] = false; // default: row\n  whiteList['flex-flow'] = false; // default: depending on individual properties\n  whiteList['flex-grow'] = false; // default: 0\n  whiteList['flex-shrink'] = false; // default: 1\n  whiteList['flex-wrap'] = false; // default: nowrap\n  whiteList['float'] = false; // default: none\n  whiteList['float-offset'] = false; // default: 0 0\n  whiteList['flood-color'] = false; // default: black\n  whiteList['flood-opacity'] = false; // default: 1\n  whiteList['flow-from'] = false; // default: none\n  whiteList['flow-into'] = false; // default: none\n  whiteList['font'] = true; // default: depending on individual properties\n  whiteList['font-family'] = true; // default: implementation dependent\n  whiteList['font-feature-settings'] = true; // default: normal\n  whiteList['font-kerning'] = true; // default: auto\n  whiteList['font-language-override'] = true; // default: normal\n  whiteList['font-size'] = true; // default: medium\n  whiteList['font-size-adjust'] = true; // default: none\n  whiteList['font-stretch'] = true; // default: normal\n  whiteList['font-style'] = true; // default: normal\n  whiteList['font-synthesis'] = true; // default: weight style\n  whiteList['font-variant'] = true; // default: normal\n  whiteList['font-variant-alternates'] = true; // default: normal\n  whiteList['font-variant-caps'] = true; // default: normal\n  whiteList['font-variant-east-asian'] = true; // default: normal\n  whiteList['font-variant-ligatures'] = true; // default: normal\n  whiteList['font-variant-numeric'] = true; // default: normal\n  whiteList['font-variant-position'] = true; // default: normal\n  whiteList['font-weight'] = true; // default: normal\n  whiteList['grid'] = false; // default: depending on individual properties\n  whiteList['grid-area'] = false; // default: depending on individual properties\n  whiteList['grid-auto-columns'] = false; // default: auto\n  whiteList['grid-auto-flow'] = false; // default: none\n  whiteList['grid-auto-rows'] = false; // default: auto\n  whiteList['grid-column'] = false; // default: depending on individual properties\n  whiteList['grid-column-end'] = false; // default: auto\n  whiteList['grid-column-start'] = false; // default: auto\n  whiteList['grid-row'] = false; // default: depending on individual properties\n  whiteList['grid-row-end'] = false; // default: auto\n  whiteList['grid-row-start'] = false; // default: auto\n  whiteList['grid-template'] = false; // default: depending on individual properties\n  whiteList['grid-template-areas'] = false; // default: none\n  whiteList['grid-template-columns'] = false; // default: none\n  whiteList['grid-template-rows'] = false; // default: none\n  whiteList['hanging-punctuation'] = false; // default: none\n  whiteList['height'] = true; // default: auto\n  whiteList['hyphens'] = false; // default: manual\n  whiteList['icon'] = false; // default: auto\n  whiteList['image-orientation'] = false; // default: auto\n  whiteList['image-resolution'] = false; // default: normal\n  whiteList['ime-mode'] = false; // default: auto\n  whiteList['initial-letters'] = false; // default: normal\n  whiteList['inline-box-align'] = false; // default: last\n  whiteList['justify-content'] = false; // default: auto\n  whiteList['justify-items'] = false; // default: auto\n  whiteList['justify-self'] = false; // default: auto\n  whiteList['left'] = false; // default: auto\n  whiteList['letter-spacing'] = true; // default: normal\n  whiteList['lighting-color'] = true; // default: white\n  whiteList['line-box-contain'] = false; // default: block inline replaced\n  whiteList['line-break'] = false; // default: auto\n  whiteList['line-grid'] = false; // default: match-parent\n  whiteList['line-height'] = false; // default: normal\n  whiteList['line-snap'] = false; // default: none\n  whiteList['line-stacking'] = false; // default: depending on individual properties\n  whiteList['line-stacking-ruby'] = false; // default: exclude-ruby\n  whiteList['line-stacking-shift'] = false; // default: consider-shifts\n  whiteList['line-stacking-strategy'] = false; // default: inline-line-height\n  whiteList['list-style'] = true; // default: depending on individual properties\n  whiteList['list-style-image'] = true; // default: none\n  whiteList['list-style-position'] = true; // default: outside\n  whiteList['list-style-type'] = true; // default: disc\n  whiteList['margin'] = true; // default: depending on individual properties\n  whiteList['margin-bottom'] = true; // default: 0\n  whiteList['margin-left'] = true; // default: 0\n  whiteList['margin-right'] = true; // default: 0\n  whiteList['margin-top'] = true; // default: 0\n  whiteList['marker-offset'] = false; // default: auto\n  whiteList['marker-side'] = false; // default: list-item\n  whiteList['marks'] = false; // default: none\n  whiteList['mask'] = false; // default: border-box\n  whiteList['mask-box'] = false; // default: see individual properties\n  whiteList['mask-box-outset'] = false; // default: 0\n  whiteList['mask-box-repeat'] = false; // default: stretch\n  whiteList['mask-box-slice'] = false; // default: 0 fill\n  whiteList['mask-box-source'] = false; // default: none\n  whiteList['mask-box-width'] = false; // default: auto\n  whiteList['mask-clip'] = false; // default: border-box\n  whiteList['mask-image'] = false; // default: none\n  whiteList['mask-origin'] = false; // default: border-box\n  whiteList['mask-position'] = false; // default: center\n  whiteList['mask-repeat'] = false; // default: no-repeat\n  whiteList['mask-size'] = false; // default: border-box\n  whiteList['mask-source-type'] = false; // default: auto\n  whiteList['mask-type'] = false; // default: luminance\n  whiteList['max-height'] = true; // default: none\n  whiteList['max-lines'] = false; // default: none\n  whiteList['max-width'] = true; // default: none\n  whiteList['min-height'] = true; // default: 0\n  whiteList['min-width'] = true; // default: 0\n  whiteList['move-to'] = false; // default: normal\n  whiteList['nav-down'] = false; // default: auto\n  whiteList['nav-index'] = false; // default: auto\n  whiteList['nav-left'] = false; // default: auto\n  whiteList['nav-right'] = false; // default: auto\n  whiteList['nav-up'] = false; // default: auto\n  whiteList['object-fit'] = false; // default: fill\n  whiteList['object-position'] = false; // default: 50% 50%\n  whiteList['opacity'] = false; // default: 1\n  whiteList['order'] = false; // default: 0\n  whiteList['orphans'] = false; // default: 2\n  whiteList['outline'] = false; // default: depending on individual properties\n  whiteList['outline-color'] = false; // default: invert\n  whiteList['outline-offset'] = false; // default: 0\n  whiteList['outline-style'] = false; // default: none\n  whiteList['outline-width'] = false; // default: medium\n  whiteList['overflow'] = false; // default: depending on individual properties\n  whiteList['overflow-wrap'] = false; // default: normal\n  whiteList['overflow-x'] = false; // default: visible\n  whiteList['overflow-y'] = false; // default: visible\n  whiteList['padding'] = true; // default: depending on individual properties\n  whiteList['padding-bottom'] = true; // default: 0\n  whiteList['padding-left'] = true; // default: 0\n  whiteList['padding-right'] = true; // default: 0\n  whiteList['padding-top'] = true; // default: 0\n  whiteList['page'] = false; // default: auto\n  whiteList['page-break-after'] = false; // default: auto\n  whiteList['page-break-before'] = false; // default: auto\n  whiteList['page-break-inside'] = false; // default: auto\n  whiteList['page-policy'] = false; // default: start\n  whiteList['pause'] = false; // default: implementation dependent\n  whiteList['pause-after'] = false; // default: implementation dependent\n  whiteList['pause-before'] = false; // default: implementation dependent\n  whiteList['perspective'] = false; // default: none\n  whiteList['perspective-origin'] = false; // default: 50% 50%\n  whiteList['pitch'] = false; // default: medium\n  whiteList['pitch-range'] = false; // default: 50\n  whiteList['play-during'] = false; // default: auto\n  whiteList['position'] = false; // default: static\n  whiteList['presentation-level'] = false; // default: 0\n  whiteList['quotes'] = false; // default: text\n  whiteList['region-fragment'] = false; // default: auto\n  whiteList['resize'] = false; // default: none\n  whiteList['rest'] = false; // default: depending on individual properties\n  whiteList['rest-after'] = false; // default: none\n  whiteList['rest-before'] = false; // default: none\n  whiteList['richness'] = false; // default: 50\n  whiteList['right'] = false; // default: auto\n  whiteList['rotation'] = false; // default: 0\n  whiteList['rotation-point'] = false; // default: 50% 50%\n  whiteList['ruby-align'] = false; // default: auto\n  whiteList['ruby-merge'] = false; // default: separate\n  whiteList['ruby-position'] = false; // default: before\n  whiteList['shape-image-threshold'] = false; // default: 0.0\n  whiteList['shape-outside'] = false; // default: none\n  whiteList['shape-margin'] = false; // default: 0\n  whiteList['size'] = false; // default: auto\n  whiteList['speak'] = false; // default: auto\n  whiteList['speak-as'] = false; // default: normal\n  whiteList['speak-header'] = false; // default: once\n  whiteList['speak-numeral'] = false; // default: continuous\n  whiteList['speak-punctuation'] = false; // default: none\n  whiteList['speech-rate'] = false; // default: medium\n  whiteList['stress'] = false; // default: 50\n  whiteList['string-set'] = false; // default: none\n  whiteList['tab-size'] = false; // default: 8\n  whiteList['table-layout'] = false; // default: auto\n  whiteList['text-align'] = true; // default: start\n  whiteList['text-align-last'] = true; // default: auto\n  whiteList['text-combine-upright'] = true; // default: none\n  whiteList['text-decoration'] = true; // default: none\n  whiteList['text-decoration-color'] = true; // default: currentColor\n  whiteList['text-decoration-line'] = true; // default: none\n  whiteList['text-decoration-skip'] = true; // default: objects\n  whiteList['text-decoration-style'] = true; // default: solid\n  whiteList['text-emphasis'] = true; // default: depending on individual properties\n  whiteList['text-emphasis-color'] = true; // default: currentColor\n  whiteList['text-emphasis-position'] = true; // default: over right\n  whiteList['text-emphasis-style'] = true; // default: none\n  whiteList['text-height'] = true; // default: auto\n  whiteList['text-indent'] = true; // default: 0\n  whiteList['text-justify'] = true; // default: auto\n  whiteList['text-orientation'] = true; // default: mixed\n  whiteList['text-overflow'] = true; // default: clip\n  whiteList['text-shadow'] = true; // default: none\n  whiteList['text-space-collapse'] = true; // default: collapse\n  whiteList['text-transform'] = true; // default: none\n  whiteList['text-underline-position'] = true; // default: auto\n  whiteList['text-wrap'] = true; // default: normal\n  whiteList['top'] = false; // default: auto\n  whiteList['transform'] = false; // default: none\n  whiteList['transform-origin'] = false; // default: 50% 50% 0\n  whiteList['transform-style'] = false; // default: flat\n  whiteList['transition'] = false; // default: depending on individual properties\n  whiteList['transition-delay'] = false; // default: 0s\n  whiteList['transition-duration'] = false; // default: 0s\n  whiteList['transition-property'] = false; // default: all\n  whiteList['transition-timing-function'] = false; // default: ease\n  whiteList['unicode-bidi'] = false; // default: normal\n  whiteList['vertical-align'] = false; // default: baseline\n  whiteList['visibility'] = false; // default: visible\n  whiteList['voice-balance'] = false; // default: center\n  whiteList['voice-duration'] = false; // default: auto\n  whiteList['voice-family'] = false; // default: implementation dependent\n  whiteList['voice-pitch'] = false; // default: medium\n  whiteList['voice-range'] = false; // default: medium\n  whiteList['voice-rate'] = false; // default: normal\n  whiteList['voice-stress'] = false; // default: normal\n  whiteList['voice-volume'] = false; // default: medium\n  whiteList['volume'] = false; // default: medium\n  whiteList['white-space'] = false; // default: normal\n  whiteList['widows'] = false; // default: 2\n  whiteList['width'] = true; // default: auto\n  whiteList['will-change'] = false; // default: auto\n  whiteList['word-break'] = true; // default: normal\n  whiteList['word-spacing'] = true; // default: normal\n  whiteList['word-wrap'] = true; // default: normal\n  whiteList['wrap-flow'] = false; // default: auto\n  whiteList['wrap-through'] = false; // default: wrap\n  whiteList['writing-mode'] = false; // default: horizontal-tb\n  whiteList['z-index'] = false; // default: auto\n\n  return whiteList;\n}\n\n\n/**\n * 匹配到白名单上的一个属性时\n *\n * @param {String} name\n * @param {String} value\n * @param {Object} options\n * @return {String}\n */\nfunction onAttr (name, value, options) {\n  // do nothing\n}\n\n/**\n * 匹配到不在白名单上的一个属性时\n *\n * @param {String} name\n * @param {String} value\n * @param {Object} options\n * @return {String}\n */\nfunction onIgnoreAttr (name, value, options) {\n  // do nothing\n}\n\nvar REGEXP_URL_JAVASCRIPT = /javascript\\s*\\:/img;\n\n/**\n * 过滤属性值\n *\n * @param {String} name\n * @param {String} value\n * @return {String}\n */\nfunction safeAttrValue(name, value) {\n  if (REGEXP_URL_JAVASCRIPT.test(value)) return '';\n  return value;\n}\n\n\nexports.whiteList = getDefaultWhiteList();\nexports.getDefaultWhiteList = getDefaultWhiteList;\nexports.onAttr = onAttr;\nexports.onIgnoreAttr = onIgnoreAttr;\nexports.safeAttrValue = safeAttrValue;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  indexOf: function (arr, item) {\n    var i, j;\n    if (Array.prototype.indexOf) {\n      return arr.indexOf(item);\n    }\n    for (i = 0, j = arr.length; i < j; i++) {\n      if (arr[i] === item) {\n        return i;\n      }\n    }\n    return -1;\n  },\n  forEach: function (arr, fn, scope) {\n    var i, j;\n    if (Array.prototype.forEach) {\n      return arr.forEach(fn, scope);\n    }\n    for (i = 0, j = arr.length; i < j; i++) {\n      fn.call(scope, arr[i], i, arr);\n    }\n  },\n  trim: function (str) {\n    if (String.prototype.trim) {\n      return str.trim();\n    }\n    return str.replace(/(^\\s*)|(\\s*$)/g, '');\n  },\n  trimRight: function (str) {\n    if (String.prototype.trimRight) {\n      return str.trimRight();\n    }\n    return str.replace(/(\\s*$)/g, '');\n  }\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_67041__) {\n\n/**\n * Simple HTML Parser\n *\n * @author Zongmin Lei<leizongmin@gmail.com>\n */\n\nvar _ = __nested_webpack_require_67041__(15);\n\n/**\n * get tag name\n *\n * @param {String} html e.g. '<a hef=\"#\">'\n * @return {String}\n */\nfunction getTagName(html) {\n  var i = _.spaceIndex(html);\n  if (i === -1) {\n    var tagName = html.slice(1, -1);\n  } else {\n    var tagName = html.slice(1, i + 1);\n  }\n  tagName = _.trim(tagName).toLowerCase();\n  if (tagName.slice(0, 1) === \"/\") tagName = tagName.slice(1);\n  if (tagName.slice(-1) === \"/\") tagName = tagName.slice(0, -1);\n  return tagName;\n}\n\n/**\n * is close tag?\n *\n * @param {String} html 如：'<a hef=\"#\">'\n * @return {Boolean}\n */\nfunction isClosing(html) {\n  return html.slice(0, 2) === \"</\";\n}\n\n/**\n * parse input html and returns processed html\n *\n * @param {String} html\n * @param {Function} onTag e.g. function (sourcePosition, position, tag, html, isClosing)\n * @param {Function} escapeHtml\n * @return {String}\n */\nfunction parseTag(html, onTag, escapeHtml) {\n  \"use strict\";\n\n  var rethtml = \"\";\n  var lastPos = 0;\n  var tagStart = false;\n  var quoteStart = false;\n  var currentPos = 0;\n  var len = html.length;\n  var currentTagName = \"\";\n  var currentHtml = \"\";\n\n  chariterator: for (currentPos = 0; currentPos < len; currentPos++) {\n    var c = html.charAt(currentPos);\n    if (tagStart === false) {\n      if (c === \"<\") {\n        tagStart = currentPos;\n        continue;\n      }\n    } else {\n      if (quoteStart === false) {\n        if (c === \"<\") {\n          rethtml += escapeHtml(html.slice(lastPos, currentPos));\n          tagStart = currentPos;\n          lastPos = currentPos;\n          continue;\n        }\n        if (c === \">\") {\n          rethtml += escapeHtml(html.slice(lastPos, tagStart));\n          currentHtml = html.slice(tagStart, currentPos + 1);\n          currentTagName = getTagName(currentHtml);\n          rethtml += onTag(\n            tagStart,\n            rethtml.length,\n            currentTagName,\n            currentHtml,\n            isClosing(currentHtml)\n          );\n          lastPos = currentPos + 1;\n          tagStart = false;\n          continue;\n        }\n        if (c === '\"' || c === \"'\") {\n          var i = 1;\n          var ic = html.charAt(currentPos - i);\n\n          while (ic.trim() === \"\" || ic === \"=\") {\n            if (ic === \"=\") {\n              quoteStart = c;\n              continue chariterator;\n            }\n            ic = html.charAt(currentPos - ++i);\n          }\n        }\n      } else {\n        if (c === quoteStart) {\n          quoteStart = false;\n          continue;\n        }\n      }\n    }\n  }\n  if (lastPos < html.length) {\n    rethtml += escapeHtml(html.substr(lastPos));\n  }\n\n  return rethtml;\n}\n\nvar REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9_:\\.\\-]/gim;\n\n/**\n * parse input attributes and returns processed attributes\n *\n * @param {String} html e.g. `href=\"#\" target=\"_blank\"`\n * @param {Function} onAttr e.g. `function (name, value)`\n * @return {String}\n */\nfunction parseAttr(html, onAttr) {\n  \"use strict\";\n\n  var lastPos = 0;\n  var retAttrs = [];\n  var tmpName = false;\n  var len = html.length;\n\n  function addAttr(name, value) {\n    name = _.trim(name);\n    name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, \"\").toLowerCase();\n    if (name.length < 1) return;\n    var ret = onAttr(name, value || \"\");\n    if (ret) retAttrs.push(ret);\n  }\n\n  // 逐个分析字符\n  for (var i = 0; i < len; i++) {\n    var c = html.charAt(i);\n    var v, j;\n    if (tmpName === false && c === \"=\") {\n      tmpName = html.slice(lastPos, i);\n      lastPos = i + 1;\n      continue;\n    }\n    if (tmpName !== false) {\n      if (\n        i === lastPos &&\n        (c === '\"' || c === \"'\") &&\n        html.charAt(i - 1) === \"=\"\n      ) {\n        j = html.indexOf(c, i + 1);\n        if (j === -1) {\n          break;\n        } else {\n          v = _.trim(html.slice(lastPos + 1, j));\n          addAttr(tmpName, v);\n          tmpName = false;\n          i = j;\n          lastPos = i + 1;\n          continue;\n        }\n      }\n    }\n    if (/\\s|\\n|\\t/.test(c)) {\n      html = html.replace(/\\s|\\n|\\t/g, \" \");\n      if (tmpName === false) {\n        j = findNextEqual(html, i);\n        if (j === -1) {\n          v = _.trim(html.slice(lastPos, i));\n          addAttr(v);\n          tmpName = false;\n          lastPos = i + 1;\n          continue;\n        } else {\n          i = j - 1;\n          continue;\n        }\n      } else {\n        j = findBeforeEqual(html, i - 1);\n        if (j === -1) {\n          v = _.trim(html.slice(lastPos, i));\n          v = stripQuoteWrap(v);\n          addAttr(tmpName, v);\n          tmpName = false;\n          lastPos = i + 1;\n          continue;\n        } else {\n          continue;\n        }\n      }\n    }\n  }\n\n  if (lastPos < html.length) {\n    if (tmpName === false) {\n      addAttr(html.slice(lastPos));\n    } else {\n      addAttr(tmpName, stripQuoteWrap(_.trim(html.slice(lastPos))));\n    }\n  }\n\n  return _.trim(retAttrs.join(\" \"));\n}\n\nfunction findNextEqual(str, i) {\n  for (; i < str.length; i++) {\n    var c = str[i];\n    if (c === \" \") continue;\n    if (c === \"=\") return i;\n    return -1;\n  }\n}\n\nfunction findBeforeEqual(str, i) {\n  for (; i > 0; i--) {\n    var c = str[i];\n    if (c === \" \") continue;\n    if (c === \"=\") return i;\n    return -1;\n  }\n}\n\nfunction isQuoteWrapString(text) {\n  if (\n    (text[0] === '\"' && text[text.length - 1] === '\"') ||\n    (text[0] === \"'\" && text[text.length - 1] === \"'\")\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction stripQuoteWrap(text) {\n  if (isQuoteWrapString(text)) {\n    return text.substr(1, text.length - 2);\n  } else {\n    return text;\n  }\n}\n\nexports.parseTag = parseTag;\nexports.parseAttr = parseAttr;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_72791__) {\n\n\"use strict\";\n__nested_webpack_require_72791__.r(__webpack_exports__);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_72791__(10);\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_72791__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_72791__(17);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_72791__(1);\n/* harmony import */ var _utils_file__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_72791__(12);\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_2__[/* image */ \"l\"],\n  icon: 'v-md-icon-img',\n  title: function title(editor) {\n    return editor.langConfig.image.toolbar;\n  },\n  menus: [{\n    name: 'image-link',\n    text: function text(editor) {\n      return editor.langConfig.imageLink.toolbar;\n    },\n    action: function action(editor, config) {\n      if (config != null && config.insertWithSize) {\n        editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_2__[/* image */ \"l\"], {\n          width: 'auto',\n          height: 'auto'\n        });\n      } else {\n        editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_2__[/* image */ \"l\"]);\n      }\n    }\n  }, {\n    name: 'upload-image',\n    text: function text(editor) {\n      return editor.langConfig.uploadImage.toolbar;\n    },\n    action: function action(editor) {\n      editor.uploadConfig = editor.uploadImgConfig;\n      editor.$nextTick( /*#__PURE__*/Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {\n        var event, files;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return editor.$refs.uploadFile.upload();\n\n            case 2:\n              event = _context.sent;\n              files = Object(_utils_file__WEBPACK_IMPORTED_MODULE_3__[/* filesFilter */ \"a\"])(event.target.files, editor.uploadImgConfig);\n              editor.emitUploadImage(event, files);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      })));\n    }\n  }]\n});\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __nested_webpack_require_75478__) {\n\n/**\n * cssfilter\n *\n * @author 老雷<leizongmin@gmail.com>\n */\n\nvar DEFAULT = __nested_webpack_require_75478__(20);\nvar parseStyle = __nested_webpack_require_75478__(25);\nvar _ = __nested_webpack_require_75478__(21);\n\n\n/**\n * 返回值是否为空\n *\n * @param {Object} obj\n * @return {Boolean}\n */\nfunction isNull (obj) {\n  return (obj === undefined || obj === null);\n}\n\n/**\n * 浅拷贝对象\n *\n * @param {Object} obj\n * @return {Object}\n */\nfunction shallowCopyObject (obj) {\n  var ret = {};\n  for (var i in obj) {\n    ret[i] = obj[i];\n  }\n  return ret;\n}\n\n/**\n * 创建CSS过滤器\n *\n * @param {Object} options\n *   - {Object} whiteList\n *   - {Function} onAttr\n *   - {Function} onIgnoreAttr\n *   - {Function} safeAttrValue\n */\nfunction FilterCSS (options) {\n  options = shallowCopyObject(options || {});\n  options.whiteList = options.whiteList || DEFAULT.whiteList;\n  options.onAttr = options.onAttr || DEFAULT.onAttr;\n  options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT.onIgnoreAttr;\n  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;\n  this.options = options;\n}\n\nFilterCSS.prototype.process = function (css) {\n  // 兼容各种奇葩输入\n  css = css || '';\n  css = css.toString();\n  if (!css) return '';\n\n  var me = this;\n  var options = me.options;\n  var whiteList = options.whiteList;\n  var onAttr = options.onAttr;\n  var onIgnoreAttr = options.onIgnoreAttr;\n  var safeAttrValue = options.safeAttrValue;\n\n  var retCSS = parseStyle(css, function (sourcePosition, position, name, value, source) {\n\n    var check = whiteList[name];\n    var isWhite = false;\n    if (check === true) isWhite = check;\n    else if (typeof check === 'function') isWhite = check(value);\n    else if (check instanceof RegExp) isWhite = check.test(value);\n    if (isWhite !== true) isWhite = false;\n\n    // 如果过滤后 value 为空则直接忽略\n    value = safeAttrValue(name, value);\n    if (!value) return;\n\n    var opts = {\n      position: position,\n      sourcePosition: sourcePosition,\n      source: source,\n      isWhite: isWhite\n    };\n\n    if (isWhite) {\n\n      var ret = onAttr(name, value, opts);\n      if (isNull(ret)) {\n        return name + ':' + value;\n      } else {\n        return ret;\n      }\n\n    } else {\n\n      var ret = onIgnoreAttr(name, value, opts);\n      if (!isNull(ret)) {\n        return ret;\n      }\n\n    }\n  });\n\n  return retCSS;\n};\n\n\nmodule.exports = FilterCSS;\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __nested_webpack_require_77852__) {\n\n/**\n * cssfilter\n *\n * @author 老雷<leizongmin@gmail.com>\n */\n\nvar _ = __nested_webpack_require_77852__(21);\n\n\n/**\n * 解析style\n *\n * @param {String} css\n * @param {Function} onAttr 处理属性的函数\n *   参数格式： function (sourcePosition, position, name, value, source)\n * @return {String}\n */\nfunction parseStyle (css, onAttr) {\n  css = _.trimRight(css);\n  if (css[css.length - 1] !== ';') css += ';';\n  var cssLength = css.length;\n  var isParenthesisOpen = false;\n  var lastPos = 0;\n  var i = 0;\n  var retCSS = '';\n\n  function addNewAttr () {\n    // 如果没有正常的闭合圆括号，则直接忽略当前属性\n    if (!isParenthesisOpen) {\n      var source = _.trim(css.slice(lastPos, i));\n      var j = source.indexOf(':');\n      if (j !== -1) {\n        var name = _.trim(source.slice(0, j));\n        var value = _.trim(source.slice(j + 1));\n        // 必须有属性名称\n        if (name) {\n          var ret = onAttr(lastPos, retCSS.length, name, value, source);\n          if (ret) retCSS += ret + '; ';\n        }\n      }\n    }\n    lastPos = i + 1;\n  }\n\n  for (; i < cssLength; i++) {\n    var c = css[i];\n    if (c === '/' && css[i + 1] === '*') {\n      // 备注开始\n      var j = css.indexOf('*/', i + 2);\n      // 如果没有正常的备注结束，则后面的部分全部跳过\n      if (j === -1) break;\n      // 直接将当前位置调到备注结尾，并且初始化状态\n      i = j + 1;\n      lastPos = i + 1;\n      isParenthesisOpen = false;\n    } else if (c === '(') {\n      isParenthesisOpen = true;\n    } else if (c === ')') {\n      isParenthesisOpen = false;\n    } else if (c === ';') {\n      if (isParenthesisOpen) {\n        // 在圆括号里面，忽略\n      } else {\n        addNewAttr();\n      }\n    } else if (c === '\\n') {\n      addNewAttr();\n    }\n  }\n\n  return _.trim(retCSS);\n}\n\nmodule.exports = parseStyle;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __nested_webpack_require_79586__) {\n\n/**\n * filter xss\n *\n * @author Zongmin Lei<leizongmin@gmail.com>\n */\n\nvar FilterCSS = __nested_webpack_require_79586__(14).FilterCSS;\nvar DEFAULT = __nested_webpack_require_79586__(19);\nvar parser = __nested_webpack_require_79586__(22);\nvar parseTag = parser.parseTag;\nvar parseAttr = parser.parseAttr;\nvar _ = __nested_webpack_require_79586__(15);\n\n/**\n * returns `true` if the input value is `undefined` or `null`\n *\n * @param {Object} obj\n * @return {Boolean}\n */\nfunction isNull(obj) {\n  return obj === undefined || obj === null;\n}\n\n/**\n * get attributes for a tag\n *\n * @param {String} html\n * @return {Object}\n *   - {String} html\n *   - {Boolean} closing\n */\nfunction getAttrs(html) {\n  var i = _.spaceIndex(html);\n  if (i === -1) {\n    return {\n      html: \"\",\n      closing: html[html.length - 2] === \"/\",\n    };\n  }\n  html = _.trim(html.slice(i + 1, -1));\n  var isClosing = html[html.length - 1] === \"/\";\n  if (isClosing) html = _.trim(html.slice(0, -1));\n  return {\n    html: html,\n    closing: isClosing,\n  };\n}\n\n/**\n * shallow copy\n *\n * @param {Object} obj\n * @return {Object}\n */\nfunction shallowCopyObject(obj) {\n  var ret = {};\n  for (var i in obj) {\n    ret[i] = obj[i];\n  }\n  return ret;\n}\n\n/**\n * FilterXSS class\n *\n * @param {Object} options\n *        whiteList, onTag, onTagAttr, onIgnoreTag,\n *        onIgnoreTagAttr, safeAttrValue, escapeHtml\n *        stripIgnoreTagBody, allowCommentTag, stripBlankChar\n *        css{whiteList, onAttr, onIgnoreAttr} `css=false` means don't use `cssfilter`\n */\nfunction FilterXSS(options) {\n  options = shallowCopyObject(options || {});\n\n  if (options.stripIgnoreTag) {\n    if (options.onIgnoreTag) {\n      console.error(\n        'Notes: cannot use these two options \"stripIgnoreTag\" and \"onIgnoreTag\" at the same time'\n      );\n    }\n    options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;\n  }\n\n  options.whiteList = options.whiteList || DEFAULT.whiteList;\n  options.onTag = options.onTag || DEFAULT.onTag;\n  options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;\n  options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;\n  options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;\n  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;\n  options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;\n  this.options = options;\n\n  if (options.css === false) {\n    this.cssFilter = false;\n  } else {\n    options.css = options.css || {};\n    this.cssFilter = new FilterCSS(options.css);\n  }\n}\n\n/**\n * start process and returns result\n *\n * @param {String} html\n * @return {String}\n */\nFilterXSS.prototype.process = function (html) {\n  // compatible with the input\n  html = html || \"\";\n  html = html.toString();\n  if (!html) return \"\";\n\n  var me = this;\n  var options = me.options;\n  var whiteList = options.whiteList;\n  var onTag = options.onTag;\n  var onIgnoreTag = options.onIgnoreTag;\n  var onTagAttr = options.onTagAttr;\n  var onIgnoreTagAttr = options.onIgnoreTagAttr;\n  var safeAttrValue = options.safeAttrValue;\n  var escapeHtml = options.escapeHtml;\n  var cssFilter = me.cssFilter;\n\n  // remove invisible characters\n  if (options.stripBlankChar) {\n    html = DEFAULT.stripBlankChar(html);\n  }\n\n  // remove html comments\n  if (!options.allowCommentTag) {\n    html = DEFAULT.stripCommentTag(html);\n  }\n\n  // if enable stripIgnoreTagBody\n  var stripIgnoreTagBody = false;\n  if (options.stripIgnoreTagBody) {\n    var stripIgnoreTagBody = DEFAULT.StripTagBody(\n      options.stripIgnoreTagBody,\n      onIgnoreTag\n    );\n    onIgnoreTag = stripIgnoreTagBody.onIgnoreTag;\n  }\n\n  var retHtml = parseTag(\n    html,\n    function (sourcePosition, position, tag, html, isClosing) {\n      var info = {\n        sourcePosition: sourcePosition,\n        position: position,\n        isClosing: isClosing,\n        isWhite: whiteList.hasOwnProperty(tag),\n      };\n\n      // call `onTag()`\n      var ret = onTag(tag, html, info);\n      if (!isNull(ret)) return ret;\n\n      if (info.isWhite) {\n        if (info.isClosing) {\n          return \"</\" + tag + \">\";\n        }\n\n        var attrs = getAttrs(html);\n        var whiteAttrList = whiteList[tag];\n        var attrsHtml = parseAttr(attrs.html, function (name, value) {\n          // call `onTagAttr()`\n          var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;\n          var ret = onTagAttr(tag, name, value, isWhiteAttr);\n          if (!isNull(ret)) return ret;\n\n          if (isWhiteAttr) {\n            // call `safeAttrValue()`\n            value = safeAttrValue(tag, name, value, cssFilter);\n            if (value) {\n              return name + '=\"' + value + '\"';\n            } else {\n              return name;\n            }\n          } else {\n            // call `onIgnoreTagAttr()`\n            var ret = onIgnoreTagAttr(tag, name, value, isWhiteAttr);\n            if (!isNull(ret)) return ret;\n            return;\n          }\n        });\n\n        // build new tag html\n        var html = \"<\" + tag;\n        if (attrsHtml) html += \" \" + attrsHtml;\n        if (attrs.closing) html += \" /\";\n        html += \">\";\n        return html;\n      } else {\n        // call `onIgnoreTag()`\n        var ret = onIgnoreTag(tag, html, info);\n        if (!isNull(ret)) return ret;\n        return escapeHtml(html);\n      }\n    },\n    escapeHtml\n  );\n\n  // if enable stripIgnoreTagBody\n  if (stripIgnoreTagBody) {\n    retHtml = stripIgnoreTagBody.remove(retHtml);\n  }\n\n  return retHtml;\n};\n\nmodule.exports = FilterXSS;\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 34 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_85907__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_85907__(86)))\n\n/***/ }),\n/* 35 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_119820__) {\n\n\"use strict\";\n\n// EXPORTS\n__nested_webpack_require_119820__.d(__webpack_exports__, \"a\", function() { return /* binding */ createEditor; });\n\n// EXTERNAL MODULE: ./src/utils/lang.js + 1 modules\nvar utils_lang = __nested_webpack_require_119820__(13);\n\n// CONCATENATED MODULE: ./src/lang/zh-CN.js\n/* harmony default export */ var zh_CN = ({\n  undo: {\n    toolbar: '撤销'\n  },\n  redo: {\n    toolbar: '重做'\n  },\n  clear: {\n    toolbar: '清空'\n  },\n  h: {\n    toolbar: '标题'\n  },\n  h1: {\n    toolbar: '一级标题',\n    placeholder: '一级标题'\n  },\n  h2: {\n    toolbar: '二级标题',\n    placeholder: '二级标题'\n  },\n  h3: {\n    toolbar: '三级标题',\n    placeholder: '三级标题'\n  },\n  h4: {\n    toolbar: '四级标题',\n    placeholder: '四级标题'\n  },\n  h5: {\n    toolbar: '五级标题',\n    placeholder: '五级标题'\n  },\n  h6: {\n    toolbar: '六级标题',\n    placeholder: '六级标题'\n  },\n  bold: {\n    toolbar: '粗体',\n    placeholder: '粗体'\n  },\n  italic: {\n    toolbar: '斜体',\n    placeholder: '斜体'\n  },\n  strikethrough: {\n    toolbar: '删除线',\n    placeholder: '删除线'\n  },\n  quote: {\n    toolbar: '插入引用',\n    placeholder: '引用'\n  },\n  ul: {\n    toolbar: '无序列表',\n    placeholder: '无序列表'\n  },\n  ol: {\n    toolbar: '有序列表',\n    placeholder: '有序列表'\n  },\n  table: {\n    toolbar: '表格'\n  },\n  hr: {\n    toolbar: '插入分割线'\n  },\n  link: {\n    toolbar: '插入链接',\n    descPlaceholder: '链接'\n  },\n  image: {\n    toolbar: '插入图片'\n  },\n  imageLink: {\n    toolbar: '添加图片链接'\n  },\n  uploadImage: {\n    toolbar: '上传本地图片'\n  },\n  code: {\n    toolbar: '插入代码块'\n  },\n  save: {\n    toolbar: '保存'\n  },\n  preview: {\n    enabled: '开启预览',\n    disabled: '关闭预览'\n  },\n  toc: {\n    title: '目录导航',\n    enabled: '开启目录导航',\n    disabled: '关闭目录导航'\n  },\n  syncScroll: {\n    enabled: '开启同步滚动',\n    disabled: '关闭同步滚动'\n  },\n  fullscreen: {\n    enabled: '全屏（按ESC还原）',\n    disabled: '退出全屏'\n  }\n});\n// EXTERNAL MODULE: external {\"root\":\"Vue\",\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"amd\":\"vue\"}\nvar external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_ = __nested_webpack_require_119820__(0);\n\n// EXTERNAL MODULE: ./src/utils/util.js\nvar util = __nested_webpack_require_119820__(2);\n\n// CONCATENATED MODULE: ./src/utils/command.js\n\nvar defaultCommands = {};\nObject(util[\"c\" /* importAll */])(defaultCommands, __nested_webpack_require_119820__(38));\nfunction command_registerCommand(target, commandName, callback) {\n  if (commandName) {\n    if (!target[commandName]) {\n      target[commandName] = callback;\n    } else {\n      console.error(\"The command name is already in use: \" + commandName);\n    }\n  } else {\n    console.error('Command name is required');\n  }\n}\nfunction commandWrapper(component) {\n  component.commands = {};\n\n  component.command = function (commandName, callback) {\n    command_registerCommand(component.commands, commandName, callback);\n  };\n\n  Object.keys(defaultCommands).forEach(function (key) {\n    var module = defaultCommands[key];\n    var name = module.name,\n        callback = module.default;\n    component.command(name, callback);\n  });\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nvar esm_extends = __nested_webpack_require_119820__(6);\n\n// CONCATENATED MODULE: ./src/utils/toolbar.js\n\n\nvar defaultToolbars = {};\nObject(util[\"c\" /* importAll */])(defaultToolbars, __nested_webpack_require_119820__(61));\nfunction toolbar_registerToolbar(target, name, config) {\n  if (name) {\n    target[name] = Object(esm_extends[\"a\" /* default */])({}, config);\n  } else {\n    console.error('Toolbar name is required');\n  }\n}\nfunction toolbarWrapper(component) {\n  component.toolbars = {};\n\n  component.toolbar = function (name, config) {\n    toolbar_registerToolbar(component.toolbars, name, config);\n  };\n\n  Object.keys(defaultToolbars).forEach(function (key) {\n    var module = defaultToolbars[key];\n    var config = module.default;\n    component.toolbar(config.name, config);\n  });\n}\n// EXTERNAL MODULE: ./src/styles/index.scss\nvar styles = __nested_webpack_require_119820__(81);\n\n// EXTERNAL MODULE: ./src/preview.js + 6 modules\nvar preview = __nested_webpack_require_119820__(9);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/components/container.vue?vue&type=template&id=6ac08d95&bindings={\"leftToolbar\":\"props\",\"rightToolbar\":\"props\",\"toolbars\":\"props\",\"fullscreen\":\"props\",\"height\":\"props\",\"noresize\":\"props\",\"disabledMenus\":\"props\",\"leftAreaVisible\":\"props\",\"leftAreaTitle\":\"props\",\"leftAreaReverse\":\"props\",\"leftAreaWidth\":\"props\",\"mode\":\"props\",\"toolbarHeight\":\"data\",\"heightGetter\":\"options\",\"leftToolbarGroup\":\"options\",\"rightToolbarGroup\":\"options\",\"isPreviewMode\":\"options\",\"isEditMode\":\"options\",\"handleResize\":\"options\",\"handleToolbarWrapperResize\":\"options\",\"getToolbarConfig\":\"options\",\"handleEditorWrapperClick\":\"options\",\"handleToolbarItemClick\":\"options\",\"handleToolbarMenuClick\":\"options\"}\n\nvar _hoisted_1 = {\n  class: \"v-md-editor__left-area-body\"\n};\nvar _hoisted_2 = {\n  class: \"v-md-editor__right-area\"\n};\nvar _hoisted_3 = {\n  class: \"v-md-editor__toolbar\",\n  ref: \"toolbarWrapper\"\n};\nvar _hoisted_4 = {\n  class: \"v-md-editor__toolbar-left-wrapper\"\n};\nvar _hoisted_5 = {\n  class: \"v-md-editor__toolbar-right-wrapper\"\n};\nvar _hoisted_6 = {\n  class: \"v-md-editor__main\"\n};\nvar _hoisted_7 = {\n  class: \"v-md-editor__preview-wrapper\",\n  ref: \"previewWrapper\"\n};\nfunction containervue_type_template_id_6ac08d95_bindings_leftToolbar_props_rightToolbar_props_toolbars_props_fullscreen_props_height_props_noresize_props_disabledMenus_props_leftAreaVisible_props_leftAreaTitle_props_leftAreaReverse_props_leftAreaWidth_props_mode_props_toolbarHeight_data_heightGetter_options_leftToolbarGroup_options_rightToolbarGroup_options_isPreviewMode_options_isEditMode_options_handleResize_options_handleToolbarWrapperResize_options_getToolbarConfig_options_handleEditorWrapperClick_options_handleToolbarItemClick_options_handleToolbarMenuClick_options_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_editor_toolbar = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"editor-toolbar\");\n\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"div\", {\n    class: [\"v-md-editor\", [\"v-md-editor--\" + $props.mode, {\n      'v-md-editor--fullscreen': $props.fullscreen,\n      'v-md-editor--left-area-reverse': $props.leftAreaReverse\n    }]],\n    style: {\n      height: $options.heightGetter\n    }\n  }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withDirectives\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n    class: \"v-md-editor__left-area\",\n    style: {\n      width: $props.leftAreaVisible ? $props.leftAreaWidth : 0,\n      borderWidth: $props.leftAreaVisible ? '1px' : 0\n    }\n  }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n    class: \"v-md-editor__left-area-title\",\n    style: {\n      height: $data.toolbarHeight + \"px\",\n      lineHeight: $data.toolbarHeight + \"px\"\n    }\n  }, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"toDisplayString\"])($props.leftAreaTitle), 5\n  /* TEXT, STYLE */\n  ), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", _hoisted_1, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderSlot\"])(_ctx.$slots, \"left-area\")])], 4\n  /* STYLE */\n  ), [[external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"vShow\"], !$options.isPreviewMode]]), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", _hoisted_2, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withDirectives\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", _hoisted_3, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", _hoisted_4, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderSlot\"])(_ctx.$slots, \"left-toolbar\", {}, function () {\n    return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_editor_toolbar, {\n      class: \"v-md-editor__toolbar-left\",\n      groups: $options.leftToolbarGroup,\n      toolbars: $props.toolbars,\n      \"disabled-menus\": $props.disabledMenus,\n      onItemClick: $options.handleToolbarItemClick,\n      onToolbarMenuClick: $options.handleToolbarMenuClick\n    }, null, 8\n    /* PROPS */\n    , [\"groups\", \"toolbars\", \"disabled-menus\", \"onItemClick\", \"onToolbarMenuClick\"])];\n  })]), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", _hoisted_5, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderSlot\"])(_ctx.$slots, \"right-toolbar\", {}, function () {\n    return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_editor_toolbar, {\n      class: \"v-md-editor__toolbar-right\",\n      groups: $options.rightToolbarGroup,\n      toolbars: $props.toolbars,\n      \"disabled-mens\": $props.disabledMenus,\n      onItemClick: $options.handleToolbarItemClick,\n      onToolbarMenuClick: $options.handleToolbarMenuClick\n    }, null, 8\n    /* PROPS */\n    , [\"groups\", \"toolbars\", \"disabled-mens\", \"onItemClick\", \"onToolbarMenuClick\"])];\n  })])], 512\n  /* NEED_PATCH */\n  ), [[external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"vShow\"], !$options.isPreviewMode]]), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", _hoisted_6, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withDirectives\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n    ref: \"editorWrapper\",\n    class: \"v-md-editor__editor-wrapper\",\n    onClick: _cache[1] || (_cache[1] = function () {\n      return $options.handleEditorWrapperClick.apply($options, arguments);\n    })\n  }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderSlot\"])(_ctx.$slots, \"editor\")], 512\n  /* NEED_PATCH */\n  ), [[external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"vShow\"], !$options.isPreviewMode]]), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withDirectives\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", _hoisted_7, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderSlot\"])(_ctx.$slots, \"preview\")], 512\n  /* NEED_PATCH */\n  ), [[external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"vShow\"], !$options.isEditMode]]), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderSlot\"])(_ctx.$slots, \"default\")])])], 6\n  /* CLASS, STYLE */\n  );\n}\n// CONCATENATED MODULE: ./src/components/container.vue?vue&type=template&id=6ac08d95&bindings={\"leftToolbar\":\"props\",\"rightToolbar\":\"props\",\"toolbars\":\"props\",\"fullscreen\":\"props\",\"height\":\"props\",\"noresize\":\"props\",\"disabledMenus\":\"props\",\"leftAreaVisible\":\"props\",\"leftAreaTitle\":\"props\",\"leftAreaReverse\":\"props\",\"leftAreaWidth\":\"props\",\"mode\":\"props\",\"toolbarHeight\":\"data\",\"heightGetter\":\"options\",\"leftToolbarGroup\":\"options\",\"rightToolbarGroup\":\"options\",\"isPreviewMode\":\"options\",\"isEditMode\":\"options\",\"handleResize\":\"options\",\"handleToolbarWrapperResize\":\"options\",\"getToolbarConfig\":\"options\",\"handleEditorWrapperClick\":\"options\",\"handleToolbarItemClick\":\"options\",\"handleToolbarMenuClick\":\"options\"}\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/components/toolbar.vue?vue&type=template&id=197f3a3b&bindings={\"markdownEditor\":\"options\",\"groups\":\"props\",\"toolbars\":\"props\",\"disabledMenus\":\"props\",\"getConfig\":\"options\"}\n\nvar toolbarvue_type_template_id_197f3a3b_bindings_markdownEditor_options_groups_props_toolbars_props_disabledMenus_props_getConfig_options_hoisted_1 = {\n  key: 0\n};\nvar toolbarvue_type_template_id_197f3a3b_bindings_markdownEditor_options_groups_props_toolbars_props_disabledMenus_props_getConfig_options_hoisted_2 = {\n  key: 0,\n  class: \"v-md-editor__toolbar-divider\"\n};\nfunction toolbarvue_type_template_id_197f3a3b_bindings_markdownEditor_options_groups_props_toolbars_props_disabledMenus_props_getConfig_options_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_toolbar_item = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"toolbar-item\");\n\n  return $props.groups.length ? (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"ul\", toolbarvue_type_template_id_197f3a3b_bindings_markdownEditor_options_groups_props_toolbars_props_disabledMenus_props_getConfig_options_hoisted_1, [(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(true), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], null, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderList\"])($props.groups, function (group, idx) {\n    return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], null, [(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(true), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], null, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderList\"])(group, function (toolbarName) {\n      return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(_component_toolbar_item, {\n        key: toolbarName,\n        name: toolbarName,\n        title: $options.getConfig(toolbarName, 'title'),\n        icon: $options.getConfig(toolbarName, 'icon'),\n        text: $options.getConfig(toolbarName, 'text'),\n        active: $options.getConfig(toolbarName, 'active'),\n        menus: $options.getConfig(toolbarName, 'menus'),\n        \"disabled-menus\": $props.disabledMenus,\n        onClick: function onClick($event) {\n          return _ctx.$emit('item-click', $props.toolbars[toolbarName]);\n        },\n        onMenuClick: _cache[1] || (_cache[1] = function ($event) {\n          return _ctx.$emit('toolbar-menu-click', $event);\n        })\n      }, null, 8\n      /* PROPS */\n      , [\"name\", \"title\", \"icon\", \"text\", \"active\", \"menus\", \"disabled-menus\", \"onClick\"]);\n    }), 128\n    /* KEYED_FRAGMENT */\n    )), idx !== $props.groups.length - 1 ? (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"li\", toolbarvue_type_template_id_197f3a3b_bindings_markdownEditor_options_groups_props_toolbars_props_disabledMenus_props_getConfig_options_hoisted_2)) : Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createCommentVNode\"])(\"v-if\", true)], 64\n    /* STABLE_FRAGMENT */\n    );\n  }), 256\n  /* UNKEYED_FRAGMENT */\n  ))])) : Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createCommentVNode\"])(\"v-if\", true);\n}\n// CONCATENATED MODULE: ./src/components/toolbar.vue?vue&type=template&id=197f3a3b&bindings={\"markdownEditor\":\"options\",\"groups\":\"props\",\"toolbars\":\"props\",\"disabledMenus\":\"props\",\"getConfig\":\"options\"}\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/components/toolbar-item/index.vue?vue&type=template&id=30f6176d&bindings={\"name\":\"props\",\"title\":\"props\",\"active\":\"props\",\"text\":\"props\",\"icon\":\"props\",\"menus\":\"props\",\"disabledMenus\":\"props\",\"menuActive\":\"data\",\"hasMenu\":\"options\",\"menuItems\":\"options\",\"menuMode\":\"options\",\"hideMenu\":\"options\",\"showMenu\":\"options\",\"handleClick\":\"options\",\"showTooltip\":\"options\",\"handleHideTooltip\":\"options\"}\n\nvar toolbar_itemvue_type_template_id_30f6176d_bindings_name_props_title_props_active_props_text_props_icon_props_menus_props_disabledMenus_props_menuActive_data_hasMenu_options_menuItems_options_menuMode_options_hideMenu_options_showMenu_options_handleClick_options_showTooltip_options_handleHideTooltip_options_hoisted_1 = {\n  key: 1,\n  class: \"v-md-icon-arrow-down v-md-editor__menu-ctrl\",\n  ref: \"menuCtrl\"\n};\nfunction toolbar_itemvue_type_template_id_30f6176d_bindings_name_props_title_props_active_props_text_props_icon_props_menus_props_disabledMenus_props_menuActive_data_hasMenu_options_menuItems_options_menuMode_options_hideMenu_options_showMenu_options_handleClick_options_showTooltip_options_handleHideTooltip_options_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_v_md_tooltip = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"v-md-tooltip\");\n\n  var _component_v_md_menu = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"v-md-menu\");\n\n  var _directive_clickoutside = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveDirective\"])(\"clickoutside\");\n\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withDirectives\"])((Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"li\", {\n    class: [\"v-md-editor__toolbar-item\", [$props.icon, \"v-md-editor__toolbar-item-\" + $props.name, {\n      'v-md-editor__toolbar-item--active': $props.active || $data.menuActive\n    }, {\n      'v-md-editor__toolbar-item--menu': $options.hasMenu\n    }]],\n    onMousedown: _cache[3] || (_cache[3] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {}, [\"prevent\"])),\n    onMouseleave: _cache[4] || (_cache[4] = function () {\n      return $options.handleHideTooltip.apply($options, arguments);\n    }),\n    onMousemove: _cache[5] || (_cache[5] = function () {\n      return $options.showTooltip.apply($options, arguments);\n    }),\n    onClick: _cache[6] || (_cache[6] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.handleClick.apply($options, arguments);\n    }, [\"stop\"]))\n  }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createTextVNode\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"toDisplayString\"])($props.text) + \" \", 1\n  /* TEXT */\n  ), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_v_md_tooltip, {\n    ref: \"tooltip\",\n    text: $props.title\n  }, null, 8\n  /* PROPS */\n  , [\"text\"]), $options.hasMenu ? (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(_component_v_md_menu, {\n    key: 0,\n    ref: \"menu\",\n    mode: $options.menuMode,\n    menus: $options.menuItems,\n    \"item-width\": $props.menus.itemWidth,\n    \"row-num\": $props.menus.rowNum,\n    visible: $data.menuActive,\n    \"onUpdate:visible\": _cache[1] || (_cache[1] = function ($event) {\n      return $data.menuActive = $event;\n    }),\n    onItemClick: _cache[2] || (_cache[2] = function ($event) {\n      return _ctx.$emit('menu-click', $event);\n    })\n  }, null, 8\n  /* PROPS */\n  , [\"mode\", \"menus\", \"item-width\", \"row-num\", \"visible\"])) : Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createCommentVNode\"])(\"v-if\", true), $options.hasMenu ? (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"i\", toolbar_itemvue_type_template_id_30f6176d_bindings_name_props_title_props_active_props_text_props_icon_props_menus_props_disabledMenus_props_menuActive_data_hasMenu_options_menuItems_options_menuMode_options_hideMenu_options_showMenu_options_handleClick_options_showTooltip_options_handleHideTooltip_options_hoisted_1, null, 512\n  /* NEED_PATCH */\n  )) : Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createCommentVNode\"])(\"v-if\", true)], 34\n  /* CLASS, HYDRATE_EVENTS */\n  )), [[_directive_clickoutside, $options.hideMenu, \"hideMenu\"]]);\n}\n// CONCATENATED MODULE: ./src/components/toolbar-item/index.vue?vue&type=template&id=30f6176d&bindings={\"name\":\"props\",\"title\":\"props\",\"active\":\"props\",\"text\":\"props\",\"icon\":\"props\",\"menus\":\"props\",\"disabledMenus\":\"props\",\"menuActive\":\"data\",\"hasMenu\":\"options\",\"menuItems\":\"options\",\"menuMode\":\"options\",\"hideMenu\":\"options\",\"showMenu\":\"options\",\"handleClick\":\"options\",\"showTooltip\":\"options\",\"handleHideTooltip\":\"options\"}\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/components/toolbar-item/tooltip.vue?vue&type=template&id=047bb94e&bindings={\"text\":\"props\",\"position\":\"data\",\"visible\":\"data\",\"show\":\"options\",\"hide\":\"options\",\"calculateLayout\":\"options\"}\n\nfunction tooltipvue_type_template_id_047bb94e_bindings_text_props_position_data_visible_data_show_options_hide_options_calculateLayout_options_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Transition\"], {\n    name: \"v-md-fade-in\"\n  }, {\n    default: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n      return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withDirectives\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n        style: {\n          left: $data.position.x + \"px\",\n          top: $data.position.y + \"px\"\n        },\n        class: \"v-md-editor__tooltip\"\n      }, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"toDisplayString\"])($props.text), 5\n      /* TEXT, STYLE */\n      ), [[external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"vShow\"], $data.visible]])];\n    }),\n    _: 1\n  });\n}\n// CONCATENATED MODULE: ./src/components/toolbar-item/tooltip.vue?vue&type=template&id=047bb94e&bindings={\"text\":\"props\",\"position\":\"data\",\"visible\":\"data\",\"show\":\"options\",\"hide\":\"options\",\"calculateLayout\":\"options\"}\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/toolbar-item/tooltip.vue?vue&type=script&lang=js\n/* harmony default export */ var tooltipvue_type_script_lang_js = ({\n  name: 'v-md-tooltip',\n  props: {\n    text: String\n  },\n  data: function data() {\n    return {\n      position: {\n        x: 0,\n        y: 0\n      },\n      visible: false\n    };\n  },\n  methods: {\n    show: function show(position) {\n      this.position = {\n        x: position.x,\n        y: position.y\n      };\n      this.visible = true;\n      this.$nextTick(this.calculateLayout);\n    },\n    hide: function hide() {\n      this.visible = false;\n    },\n    calculateLayout: function calculateLayout() {\n      // 容器右边框距离可视区域左侧的距离\n      var _this$$el$getBounding = this.$el.getBoundingClientRect(),\n          right = _this$$el$getBounding.right;\n\n      var windowWidth = document.documentElement.clientWidth;\n\n      if (windowWidth - right < 0) {\n        this.position.x -= right - windowWidth;\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/toolbar-item/tooltip.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./src/components/toolbar-item/tooltip.vue?vue&type=style&index=0&lang=scss\nvar tooltipvue_type_style_index_0_lang_scss = __nested_webpack_require_119820__(82);\n\n// CONCATENATED MODULE: ./src/components/toolbar-item/tooltip.vue\n\n\n\n\n\ntooltipvue_type_script_lang_js.render = tooltipvue_type_template_id_047bb94e_bindings_text_props_position_data_visible_data_show_options_hide_options_calculateLayout_options_render\n\n/* harmony default export */ var tooltip = (tooltipvue_type_script_lang_js);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/components/toolbar-item/menu.vue?vue&type=template&id=453a4c3c&bindings={\"markdownEditor\":\"options\",\"mode\":\"props\",\"menus\":\"props\",\"itemWidth\":\"props\",\"rowNum\":\"props\",\"visible\":\"props\",\"style\":\"data\",\"rowCount\":\"options\",\"isListMode\":\"options\",\"calculateLayout\":\"options\",\"getRowMenus\":\"options\",\"getText\":\"options\",\"hide\":\"options\",\"handleClick\":\"options\"}\n\nvar menuvue_type_template_id_453a4c3c_bindings_markdownEditor_options_mode_props_menus_props_itemWidth_props_rowNum_props_visible_props_style_data_rowCount_options_isListMode_options_calculateLayout_options_getRowMenus_options_getText_options_hide_options_handleClick_options_hoisted_1 = {\n  key: 1\n};\nvar menuvue_type_template_id_453a4c3c_bindings_markdownEditor_options_mode_props_menus_props_itemWidth_props_rowNum_props_visible_props_style_data_rowCount_options_isListMode_options_calculateLayout_options_getRowMenus_options_getText_options_hide_options_handleClick_options_hoisted_2 = {\n  class: \"v-md-editor__menu-row\"\n};\nfunction menuvue_type_template_id_453a4c3c_bindings_markdownEditor_options_mode_props_menus_props_itemWidth_props_rowNum_props_visible_props_style_data_rowCount_options_isListMode_options_calculateLayout_options_getRowMenus_options_getText_options_hide_options_handleClick_options_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_v_md_render = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"v-md-render\");\n\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Transition\"], {\n    name: \"v-md-zoom-in-top\"\n  }, {\n    default: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n      return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withDirectives\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"ul\", {\n        class: [\"v-md-editor__menu\", [\"v-md-editor__menu--\" + $props.mode]],\n        style: $data.style,\n        onMousemove: _cache[1] || (_cache[1] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {}, [\"stop\"])),\n        onClick: _cache[2] || (_cache[2] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {}, [\"stop\"]))\n      }, [$options.isListMode ? (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(true), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], {\n        key: 0\n      }, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderList\"])($props.menus, function (item) {\n        return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"li\", {\n          key: item.name,\n          class: [\"v-md-editor__menu-item\", [\"v-md-editor__menu-item-\" + item.name, item.class]],\n          onClick: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function ($event) {\n            return $options.handleClick(item);\n          }, [\"stop\"])\n        }, [item.render ? (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(_component_v_md_render, {\n          key: 0,\n          render: item.render\n        }, null, 8\n        /* PROPS */\n        , [\"render\"])) : (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], {\n          key: 1\n        }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createTextVNode\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"toDisplayString\"])($options.getText(item.text)), 1\n        /* TEXT */\n        )], 64\n        /* STABLE_FRAGMENT */\n        ))], 10\n        /* CLASS, PROPS */\n        , [\"onClick\"]);\n      }), 128\n      /* KEYED_FRAGMENT */\n      )) : (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"li\", menuvue_type_template_id_453a4c3c_bindings_markdownEditor_options_mode_props_menus_props_itemWidth_props_rowNum_props_visible_props_style_data_rowCount_options_isListMode_options_calculateLayout_options_getRowMenus_options_getText_options_hide_options_handleClick_options_hoisted_1, [(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(true), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], null, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderList\"])($options.rowCount, function (rowIndex) {\n        return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"div\", menuvue_type_template_id_453a4c3c_bindings_markdownEditor_options_mode_props_menus_props_itemWidth_props_rowNum_props_visible_props_style_data_rowCount_options_isListMode_options_calculateLayout_options_getRowMenus_options_getText_options_hide_options_handleClick_options_hoisted_2, [(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(true), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], null, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderList\"])($options.getRowMenus(rowIndex), function (item) {\n          return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"span\", {\n            key: item.name,\n            style: {\n              width: $props.itemWidth\n            },\n            class: [\"v-md-editor__menu-item\", [\"v-md-editor__menu-item-\" + item.name, item.class]],\n            onClick: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function ($event) {\n              return $options.handleClick(item);\n            }, [\"stop\"])\n          }, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"toDisplayString\"])(item.text), 15\n          /* TEXT, CLASS, STYLE, PROPS */\n          , [\"onClick\"]);\n        }), 128\n        /* KEYED_FRAGMENT */\n        ))]);\n      }), 256\n      /* UNKEYED_FRAGMENT */\n      ))]))], 38\n      /* CLASS, STYLE, HYDRATE_EVENTS */\n      ), [[external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"vShow\"], $props.visible]])];\n    }),\n    _: 1\n  });\n}\n// CONCATENATED MODULE: ./src/components/toolbar-item/menu.vue?vue&type=template&id=453a4c3c&bindings={\"markdownEditor\":\"options\",\"mode\":\"props\",\"menus\":\"props\",\"itemWidth\":\"props\",\"rowNum\":\"props\",\"visible\":\"props\",\"style\":\"data\",\"rowCount\":\"options\",\"isListMode\":\"options\",\"calculateLayout\":\"options\",\"getRowMenus\":\"options\",\"getText\":\"options\",\"hide\":\"options\",\"handleClick\":\"options\"}\n\n// CONCATENATED MODULE: ./src/components/render.js\nvar renderFn = function renderFn(props, _ref) {\n  var attrs = _ref.attrs;\n  return props.render.apply(props, attrs);\n};\n\nrenderFn.props = ['render'];\n/* harmony default export */ var components_render = (renderFn);\n// CONCATENATED MODULE: ./src/utils/constants/menu-mode.js\n/* harmony default export */ var menu_mode = ({\n  LIST: 'list',\n  PANEL: 'panel'\n});\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/toolbar-item/menu.vue?vue&type=script&lang=js\n\n\n/* harmony default export */ var menuvue_type_script_lang_js = ({\n  name: 'v-md-menu',\n  components: {\n    VMdRender: components_render\n  },\n  inject: ['markdownEditor'],\n  props: {\n    mode: {\n      type: String,\n      default: menu_mode.PANEL\n    },\n    menus: Array,\n    itemWidth: {\n      type: String,\n      default: '30px'\n    },\n    rowNum: {\n      type: Number,\n      default: 10\n    },\n    visible: Boolean\n  },\n  emits: ['update:visible', 'item-click'],\n  data: function data() {\n    return {\n      style: {\n        left: 0\n      }\n    };\n  },\n  computed: {\n    rowCount: function rowCount() {\n      return Math.ceil(this.menus.length / this.rowNum);\n    },\n    isListMode: function isListMode() {\n      return this.mode === menu_mode.LIST;\n    }\n  },\n  watch: {\n    visible: function visible() {\n      if (this.visible) this.$nextTick(this.calculateLayout);\n    }\n  },\n  methods: {\n    calculateLayout: function calculateLayout() {\n      // 容器右边框距离可视区域左侧的距离\n      var _this$$el$getBounding = this.$el.getBoundingClientRect(),\n          right = _this$$el$getBounding.right;\n\n      var windowWidth = document.documentElement.clientWidth;\n      if (windowWidth - right < 0) this.style = {\n        right: 0\n      };\n    },\n    getRowMenus: function getRowMenus(rowIndex) {\n      var end = rowIndex * this.rowNum;\n      var start = end - this.rowNum;\n      return this.menus.slice(start, end);\n    },\n    getText: function getText(text) {\n      if (typeof text === 'function') {\n        return text(this.markdownEditor);\n      }\n\n      return text;\n    },\n    hide: function hide() {\n      this.$emit('update:visible', false);\n    },\n    handleClick: function handleClick(item) {\n      this.$emit('item-click', item);\n      this.hide();\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/toolbar-item/menu.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./src/components/toolbar-item/menu.vue?vue&type=style&index=0&lang=scss\nvar menuvue_type_style_index_0_lang_scss = __nested_webpack_require_119820__(83);\n\n// CONCATENATED MODULE: ./src/components/toolbar-item/menu.vue\n\n\n\n\n\nmenuvue_type_script_lang_js.render = menuvue_type_template_id_453a4c3c_bindings_markdownEditor_options_mode_props_menus_props_itemWidth_props_rowNum_props_visible_props_style_data_rowCount_options_isListMode_options_calculateLayout_options_getRowMenus_options_getText_options_hide_options_handleClick_options_render\n\n/* harmony default export */ var menu = (menuvue_type_script_lang_js);\n// CONCATENATED MODULE: ./src/utils/clickoutside.js\n// Modified from https://github.com/ElemeFE/element/blob/dev/src/utils/clickoutside.js\n\nvar nodeList = [];\nvar ctx = '@@clickoutsideContext';\nvar startClick;\nvar seed = 0;\n\nif (util[\"d\" /* inBrowser */]) {\n  document.addEventListener('mousedown', function (e) {\n    startClick = e;\n  });\n  document.addEventListener('mouseup', function (e) {\n    nodeList.forEach(function (node) {\n      return node[ctx].documentHandler(e, startClick);\n    });\n  });\n}\n\nfunction createDocumentHandler(el, binding, vnode) {\n  return function (mouseup, mousedown) {\n    if (mouseup === void 0) {\n      mouseup = {};\n    }\n\n    if (mousedown === void 0) {\n      mousedown = {};\n    }\n\n    if (!vnode || !binding || !binding.instance || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target) {\n      return;\n    }\n\n    if (binding.arg && el[ctx].methodName && binding.instance[el[ctx].methodName]) {\n      binding.instance[el[ctx].methodName]();\n    } else {\n      el[ctx].bindingFn && el[ctx].bindingFn();\n    }\n  };\n}\n\n/* harmony default export */ var clickoutside = ({\n  beforeMount: function beforeMount(el, binding, vnode) {\n    nodeList.push(el);\n    var id = seed++;\n    el[ctx] = {\n      id: id,\n      documentHandler: createDocumentHandler(el, binding, vnode),\n      methodName: binding.arg,\n      bindingFn: binding.value\n    };\n  },\n  updated: function updated(el, binding, vnode) {\n    el[ctx].documentHandler = createDocumentHandler(el, binding, vnode);\n    el[ctx].methodName = binding.arg;\n    el[ctx].bindingFn = binding.value;\n  },\n  unmounted: function unmounted(el) {\n    var len = nodeList.length;\n\n    for (var i = 0; i < len; i++) {\n      if (nodeList[i][ctx].id === el[ctx].id) {\n        nodeList.splice(i, 1);\n        break;\n      }\n    }\n\n    delete el[ctx];\n  }\n});\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/toolbar-item/index.vue?vue&type=script&lang=js\nvar _components;\n\n\n\n\n\n\n/* harmony default export */ var toolbar_itemvue_type_script_lang_js = ({\n  name: 'toolbar-item',\n  directives: {\n    Clickoutside: clickoutside\n  },\n  components: (_components = {}, _components[tooltip.name] = tooltip, _components[menu.name] = menu, _components),\n  props: {\n    name: String,\n    title: String,\n    active: Boolean,\n    text: String,\n    icon: String,\n    menus: [Array, Object],\n    disabledMenus: Array\n  },\n  emits: ['click', 'menu-click'],\n  data: function data() {\n    return {\n      menuActive: false\n    };\n  },\n  computed: {\n    hasMenu: function hasMenu() {\n      var _this$menuItems;\n\n      return (_this$menuItems = this.menuItems) == null ? void 0 : _this$menuItems.length;\n    },\n    menuItems: function menuItems() {\n      var _this = this;\n\n      var menus = Object(util[\"f\" /* isObject */])(this.menus) ? this.menus.items : this.menus;\n      return menus == null ? void 0 : menus.filter(function (_ref) {\n        var _this$disabledMenus;\n\n        var menuName = _ref.name;\n        return !((_this$disabledMenus = _this.disabledMenus) != null && _this$disabledMenus.includes(_this.name + \"/\" + menuName));\n      });\n    },\n    menuMode: function menuMode() {\n      return Object(util[\"f\" /* isObject */])(this.menus) ? this.menus.mode : menu_mode.LIST;\n    }\n  },\n  methods: {\n    hideMenu: function hideMenu() {\n      if (this.hasMenu) {\n        this.menuActive = false;\n      }\n    },\n    showMenu: function showMenu() {\n      if (this.hasMenu) {\n        this.menuActive = true;\n      }\n    },\n    handleClick: function handleClick(e) {\n      this.$emit('click');\n      this.menuActive ? this.hideMenu() : this.showMenu();\n\n      if (this.hasMenu) {\n        this.handleHideTooltip();\n      } else {\n        this.showTooltip(e);\n      }\n    },\n    showTooltip: function showTooltip(e) {\n      var _this2 = this;\n\n      var selfEl = this.$el;\n      var target = e.target;\n      var menuCtrl = this.$refs.menuCtrl;\n\n      if (target !== selfEl && target !== menuCtrl || this.menuActive) {\n        this.handleHideTooltip();\n        return;\n      }\n\n      if (this.timmer) clearTimeout(this.timmer);\n      var selfElRect = selfEl.getBoundingClientRect();\n      var x = e.clientX - selfElRect.left;\n      var y = e.clientY - selfElRect.top;\n      this.timmer = setTimeout(function () {\n        var _this2$$refs$tooltip;\n\n        (_this2$$refs$tooltip = _this2.$refs.tooltip) == null ? void 0 : _this2$$refs$tooltip.show({\n          x: x - 2,\n          y: y + 20\n        });\n      }, 100);\n    },\n    handleHideTooltip: function handleHideTooltip() {\n      if (this.timmer) clearTimeout(this.timmer);\n      this.$refs.tooltip.hide();\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/toolbar-item/index.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./src/components/toolbar-item/index.vue?vue&type=style&index=0&lang=scss\nvar toolbar_itemvue_type_style_index_0_lang_scss = __nested_webpack_require_119820__(84);\n\n// CONCATENATED MODULE: ./src/components/toolbar-item/index.vue\n\n\n\n\n\ntoolbar_itemvue_type_script_lang_js.render = toolbar_itemvue_type_template_id_30f6176d_bindings_name_props_title_props_active_props_text_props_icon_props_menus_props_disabledMenus_props_menuActive_data_hasMenu_options_menuItems_options_menuMode_options_hideMenu_options_showMenu_options_handleClick_options_showTooltip_options_handleHideTooltip_options_render\n\n/* harmony default export */ var toolbar_item = (toolbar_itemvue_type_script_lang_js);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/toolbar.vue?vue&type=script&lang=js\nvar toolbarvue_type_script_lang_js_components;\n\n\n/* harmony default export */ var toolbarvue_type_script_lang_js = ({\n  name: 'editor-toolbar',\n  components: (toolbarvue_type_script_lang_js_components = {}, toolbarvue_type_script_lang_js_components[toolbar_item.name] = toolbar_item, toolbarvue_type_script_lang_js_components),\n  inject: ['markdownEditor'],\n  props: {\n    groups: Array,\n    toolbars: Object,\n    disabledMenus: Array\n  },\n  emits: ['item-click', 'toolbar-menu-click'],\n  methods: {\n    getConfig: function getConfig(toolbarName, configName) {\n      var toolbarConfig = this.toolbars[toolbarName];\n      var value = toolbarConfig[configName];\n      return typeof value === 'function' ? value(this.markdownEditor) : value;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/toolbar.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./src/components/toolbar.vue?vue&type=style&index=0&lang=scss\nvar toolbarvue_type_style_index_0_lang_scss = __nested_webpack_require_119820__(85);\n\n// CONCATENATED MODULE: ./src/components/toolbar.vue\n\n\n\n\n\ntoolbarvue_type_script_lang_js.render = toolbarvue_type_template_id_197f3a3b_bindings_markdownEditor_options_groups_props_toolbars_props_disabledMenus_props_getConfig_options_render\n\n/* harmony default export */ var toolbar = (toolbarvue_type_script_lang_js);\n// EXTERNAL MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\nvar ResizeObserver_es = __nested_webpack_require_119820__(34);\n\n// CONCATENATED MODULE: ./src/utils/resize-event.js\n// Modified from https://github.com/ElemeFE/element/blob/dev/src/utils/resize-event.js\n\n/* eslint-disable no-underscore-dangle */\n\nvar isServer = typeof window === 'undefined';\n/* istanbul ignore next */\n\nvar resizeHandler = function resizeHandler(entries) {\n  entries.forEach(function (entry) {\n    var listeners = entry.target.__resizeListeners__ || [];\n\n    if (listeners.length) {\n      listeners.forEach(function (fn) {\n        fn();\n      });\n    }\n  });\n};\n/* istanbul ignore next */\n\n\nvar resize_event_addResizeListener = function addResizeListener(element, fn) {\n  if (isServer) return;\n\n  if (!element.__resizeListeners__) {\n    element.__resizeListeners__ = [];\n    element.__ro__ = new ResizeObserver_es[\"a\" /* default */](resizeHandler);\n\n    element.__ro__.observe(element);\n  }\n\n  element.__resizeListeners__.push(fn);\n};\n/* istanbul ignore next */\n\nvar removeResizeListener = function removeResizeListener(element, fn) {\n  if (!element || !element.__resizeListeners__) return;\n\n  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);\n\n  if (!element.__resizeListeners__.length) {\n    element.__ro__.disconnect();\n  }\n};\n// EXTERNAL MODULE: ./src/utils/constants/editor-mode.js\nvar editor_mode = __nested_webpack_require_119820__(4);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/container.vue?vue&type=script&lang=js\nvar containervue_type_script_lang_js_components;\n\n\n\n\n/* harmony default export */ var containervue_type_script_lang_js = ({\n  name: 'v-md-container',\n  components: (containervue_type_script_lang_js_components = {}, containervue_type_script_lang_js_components[toolbar.name] = toolbar, containervue_type_script_lang_js_components),\n  props: {\n    leftToolbar: String,\n    rightToolbar: String,\n    toolbars: Object,\n    fullscreen: Boolean,\n    height: String,\n    noresize: Boolean,\n    disabledMenus: Array,\n    leftAreaVisible: Boolean,\n    leftAreaTitle: String,\n    leftAreaReverse: Boolean,\n    leftAreaWidth: {\n      type: String,\n      default: '200px'\n    },\n    mode: {\n      type: String,\n      default: editor_mode[\"a\" /* default */].EDITABLE\n    }\n  },\n  emits: ['resize', 'editor-wrapper-click', 'toolbar-item-click', 'toolbar-menu-click'],\n  data: function data() {\n    return {\n      toolbarHeight: 0\n    };\n  },\n  computed: {\n    heightGetter: function heightGetter() {\n      return this.fullscreen ? 'auto' : this.height;\n    },\n    leftToolbarGroup: function leftToolbarGroup() {\n      return this.getToolbarConfig(this.leftToolbar);\n    },\n    rightToolbarGroup: function rightToolbarGroup() {\n      return this.getToolbarConfig(this.rightToolbar);\n    },\n    isPreviewMode: function isPreviewMode() {\n      return this.mode === editor_mode[\"a\" /* default */].PREVIEW;\n    },\n    isEditMode: function isEditMode() {\n      return this.mode === editor_mode[\"a\" /* default */].EDIT;\n    }\n  },\n  mounted: function mounted() {\n    if (!this.noresize) {\n      resize_event_addResizeListener(this.$refs.editorWrapper, this.handleResize);\n      resize_event_addResizeListener(this.$refs.toolbarWrapper, this.handleToolbarWrapperResize);\n    }\n  },\n  beforeUnmount: function beforeUnmount() {\n    if (!this.noresize) {\n      removeResizeListener(this.$refs.editorWrapper, this.handleResize);\n      removeResizeListener(this.$refs.toolbarWrapper, this.handleToolbarWrapperResize);\n    }\n  },\n  methods: {\n    handleResize: function handleResize() {\n      this.$emit('resize');\n    },\n    handleToolbarWrapperResize: function handleToolbarWrapperResize() {\n      var toolbarWrapper = this.$refs.toolbarWrapper;\n      if (toolbarWrapper) this.toolbarHeight = toolbarWrapper.offsetHeight;\n    },\n    getToolbarConfig: function getToolbarConfig(toolbarStr) {\n      var _this = this;\n\n      return toolbarStr.split('|').map(function (group) {\n        return group.split(' ').filter(function (toolbarName) {\n          return toolbarName && _this.toolbars[toolbarName];\n        });\n      });\n    },\n    handleEditorWrapperClick: function handleEditorWrapperClick(e) {\n      this.$emit('editor-wrapper-click', e);\n    },\n    handleToolbarItemClick: function handleToolbarItemClick(toolbar) {\n      this.$emit('toolbar-item-click', toolbar);\n    },\n    handleToolbarMenuClick: function handleToolbarMenuClick(menu) {\n      this.$emit('toolbar-menu-click', menu);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/container.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./src/components/container.vue?vue&type=style&index=0&lang=scss\nvar containervue_type_style_index_0_lang_scss = __nested_webpack_require_119820__(87);\n\n// CONCATENATED MODULE: ./src/components/container.vue\n\n\n\n\n\ncontainervue_type_script_lang_js.render = containervue_type_template_id_6ac08d95_bindings_leftToolbar_props_rightToolbar_props_toolbars_props_fullscreen_props_height_props_noresize_props_disabledMenus_props_leftAreaVisible_props_leftAreaTitle_props_leftAreaReverse_props_leftAreaWidth_props_mode_props_toolbarHeight_data_heightGetter_options_leftToolbarGroup_options_rightToolbarGroup_options_isPreviewMode_options_isEditMode_options_handleResize_options_handleToolbarWrapperResize_options_getToolbarConfig_options_handleEditorWrapperClick_options_handleToolbarItemClick_options_handleToolbarMenuClick_options_render\n\n/* harmony default export */ var container = (containervue_type_script_lang_js);\n// CONCATENATED MODULE: ./src/utils/scrollbar-width.js\n// Modified from https://github.com/ElemeFE/element/blob/dev/src/utils/scrollbar-width.js\nvar scrollBarWidth;\nvar scrollbar_width_isServer = typeof window === 'undefined';\n/* harmony default export */ var scrollbar_width = (function () {\n  if (scrollbar_width_isServer) return 0;\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\n  var outer = document.createElement('div');\n  outer.className = 'scrollbar__wrap';\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.position = 'absolute';\n  outer.style.top = '-9999px';\n  document.body.appendChild(outer);\n  var widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = 'scroll';\n  var inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n  var widthWithScroll = inner.offsetWidth;\n  outer.parentNode.removeChild(outer);\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n  return scrollBarWidth;\n});\n// CONCATENATED MODULE: ./src/components/scrollbar/util.js\n// Modified from https://github.com/ElemeFE/element/tree/dev/packages/scrollbar\nvar BAR_MAP = {\n  vertical: {\n    offset: 'offsetHeight',\n    scroll: 'scrollTop',\n    scrollSize: 'scrollHeight',\n    size: 'height',\n    key: 'vertical',\n    axis: 'Y',\n    client: 'clientY',\n    direction: 'top'\n  },\n  horizontal: {\n    offset: 'offsetWidth',\n    scroll: 'scrollLeft',\n    scrollSize: 'scrollWidth',\n    size: 'width',\n    key: 'horizontal',\n    axis: 'X',\n    client: 'clientX',\n    direction: 'left'\n  }\n};\nfunction renderThumbStyle(_ref) {\n  var move = _ref.move,\n      size = _ref.size,\n      bar = _ref.bar;\n  var style = {};\n  var translate = \"translate\" + bar.axis + \"(\" + move + \"%)\";\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n  return style;\n}\n// CONCATENATED MODULE: ./src/components/scrollbar/bar.js\n\n// Modified from https://github.com/ElemeFE/element/tree/dev/packages/scrollbar\n\n/* istanbul ignore next */\n\n/* harmony default export */ var scrollbar_bar = ({\n  name: 'Bar',\n  props: {\n    vertical: Boolean,\n    size: String,\n    move: Number\n  },\n  computed: {\n    bar: function bar() {\n      return BAR_MAP[this.vertical ? 'vertical' : 'horizontal'];\n    },\n    wrap: function wrap() {\n      return this.$parent.wrap;\n    }\n  },\n  render: function render() {\n    var size = this.size,\n        move = this.move,\n        bar = this.bar;\n    return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n      \"class\": ['scrollbar__bar', 'is-' + bar.key],\n      \"onMousedown\": this.clickTrackHandler,\n      \"onClick\": function onClick(e) {\n        return e.stopPropagation();\n      }\n    }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n      \"ref\": \"thumb\",\n      \"class\": \"scrollbar__thumb\",\n      \"onMousedown\": this.clickThumbHandler,\n      \"style\": renderThumbStyle({\n        size: size,\n        move: move,\n        bar: bar\n      })\n    }, null)]);\n  },\n  methods: {\n    clickThumbHandler: function clickThumbHandler(e) {\n      // prevent click event of right button\n      if (e.ctrlKey || e.button === 2) {\n        return;\n      }\n\n      this.startDrag(e);\n      this[this.bar.axis] = e.currentTarget[this.bar.offset] - (e[this.bar.client] - e.currentTarget.getBoundingClientRect()[this.bar.direction]);\n    },\n    clickTrackHandler: function clickTrackHandler(e) {\n      var offset = Math.abs(e.target.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]);\n      var thumbHalf = this.$refs.thumb[this.bar.offset] / 2;\n      var thumbPositionPercentage = (offset - thumbHalf) * 100 / this.$el[this.bar.offset];\n      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;\n    },\n    startDrag: function startDrag(e) {\n      e.stopImmediatePropagation();\n      this.cursorDown = true;\n      document.addEventListener('mousemove', this.mouseMoveDocumentHandler, false);\n      document.addEventListener('mouseup', this.mouseUpDocumentHandler, false);\n\n      document.onselectstart = function () {\n        return false;\n      };\n    },\n    mouseMoveDocumentHandler: function mouseMoveDocumentHandler(e) {\n      if (this.cursorDown === false) return;\n      var prevPage = this[this.bar.axis];\n      if (!prevPage) return;\n      var offset = (this.$el.getBoundingClientRect()[this.bar.direction] - e[this.bar.client]) * -1;\n      var thumbClickPosition = this.$refs.thumb[this.bar.offset] - prevPage;\n      var thumbPositionPercentage = (offset - thumbClickPosition) * 100 / this.$el[this.bar.offset];\n      this.wrap[this.bar.scroll] = thumbPositionPercentage * this.wrap[this.bar.scrollSize] / 100;\n    },\n    mouseUpDocumentHandler: function mouseUpDocumentHandler() {\n      this.cursorDown = false;\n      this[this.bar.axis] = 0;\n      document.removeEventListener('mousemove', this.mouseMoveDocumentHandler, false);\n      document.onselectstart = null;\n    }\n  },\n  unmounted: function unmounted() {\n    document.removeEventListener('mouseup', this.mouseUpDocumentHandler, false);\n  }\n});\n// EXTERNAL MODULE: ./src/utils/smooth-scroll.js\nvar smooth_scroll = __nested_webpack_require_119820__(8);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/scrollbar/index.vue?vue&type=script&lang=js\n\n// Modified from https://github.com/ElemeFE/element/tree/dev/packages/scrollbar\n\n\n\n\n\n/* harmony default export */ var scrollbarvue_type_script_lang_js = ({\n  name: 'scrollbar',\n  components: {\n    Bar: scrollbar_bar\n  },\n  props: {\n    native: Boolean,\n    disabled: Boolean,\n    wrapStyle: null,\n    wrapClass: null,\n    viewClass: null,\n    viewStyle: null,\n    noresize: Boolean,\n    // 如果 container 尺寸不会发生变化，最好设置它可以优化性能\n    tag: {\n      type: String,\n      default: 'div'\n    }\n  },\n  emits: ['scroll'],\n  data: function data() {\n    return {\n      sizeWidth: '0',\n      sizeHeight: '0',\n      moveX: 0,\n      moveY: 0\n    };\n  },\n  computed: {\n    wrap: function wrap() {\n      return this.$refs.wrap;\n    }\n  },\n  mounted: function mounted() {\n    if (this.native || this.disabled) return;\n    this.$nextTick(this.update);\n    !this.noresize && resize_event_addResizeListener(this.$refs.resize, this.update);\n  },\n  beforeUnmount: function beforeUnmount() {\n    if (this.native || this.disabled) return;\n    !this.noresize && removeResizeListener(this.$refs.resize, this.update);\n  },\n  methods: {\n    getScrollInfo: function getScrollInfo() {\n      var wrap = this.wrap;\n      return {\n        left: wrap.scrollLeft,\n        top: wrap.scrollTop,\n        width: wrap.scrollWidth,\n        height: wrap.scrollHeight,\n        clientWidth: wrap.clientWidth,\n        clientHeight: wrap.clientHeight\n      };\n    },\n    scrollTo: function scrollTo(scrollTop) {\n      Object(smooth_scroll[\"a\" /* default */])({\n        scrollTarget: this.wrap,\n        scrollToTop: scrollTop\n      });\n    },\n    handleScroll: function handleScroll() {\n      var wrap = this.wrap;\n      this.moveY = wrap.scrollTop * 100 / wrap.clientHeight;\n      this.moveX = wrap.scrollLeft * 100 / wrap.clientWidth;\n      this.$emit('scroll');\n    },\n    update: function update() {\n      var wrap = this.wrap;\n      if (!wrap) return;\n      var heightPercentage = wrap.clientHeight * 100 / wrap.scrollHeight;\n      var widthPercentage = wrap.clientWidth * 100 / wrap.scrollWidth;\n      this.sizeHeight = heightPercentage < 100 ? heightPercentage + '%' : '';\n      this.sizeWidth = widthPercentage < 100 ? widthPercentage + '%' : '';\n    }\n  },\n  render: function render() {\n    if (this.disabled) return this.$slots.default();\n    var gutter = scrollbar_width();\n    var style = this.wrapStyle;\n\n    if (gutter) {\n      var scrollView = this.$refs.resize;\n      var wrapper = this.$refs.wrap;\n      var scrollViewHeight = scrollView == null ? void 0 : scrollView.scrollHeight;\n      var scrollViewWidth = scrollView == null ? void 0 : scrollView.scrollWidth;\n      var wrapperHeight = wrapper == null ? void 0 : wrapper.clientHeight;\n      var wrapperWidth = wrapper == null ? void 0 : wrapper.clientWidth;\n      var gutterWith = \"-\" + gutter + \"px\";\n      var marginBottom = scrollViewWidth > wrapperWidth ? gutterWith : 0;\n      var marginRight = scrollViewHeight > wrapperHeight ? gutterWith : 0;\n      var gutterStyle = \"margin-bottom: \" + marginBottom + \"; margin-right: \" + marginRight + \";\";\n\n      if (Array.isArray(this.wrapStyle)) {\n        style = Object(util[\"a\" /* arraytoObject */])(this.wrapStyle);\n        style.marginRight = gutterWith;\n        style.marginBottom = gutterWith;\n      } else if (typeof this.wrapStyle === 'string') {\n        style += gutterStyle;\n      } else {\n        style = gutterStyle;\n      }\n    }\n\n    var view = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"h\"])(this.tag, {\n      class: ['scrollbar__view', this.viewClass],\n      style: this.viewStyle,\n      ref: 'resize'\n    }, this.$slots.default());\n    var wrap = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n      \"ref\": \"wrap\",\n      \"style\": style,\n      \"onScroll\": this.handleScroll,\n      \"class\": [this.wrapClass, 'scrollbar__wrap', gutter ? '' : 'scrollbar__wrap--hidden-default']\n    }, [[view]]);\n    var nodes;\n\n    if (!this.native) {\n      nodes = [wrap, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(scrollbar_bar, {\n        \"move\": this.moveX,\n        \"size\": this.sizeWidth\n      }, null), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(scrollbar_bar, {\n        \"vertical\": true,\n        \"move\": this.moveY,\n        \"size\": this.sizeHeight\n      }, null)];\n    } else {\n      nodes = [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"div\", {\n        \"ref\": \"wrap\",\n        \"class\": [this.wrapClass, 'scrollbar__wrap'],\n        \"style\": style\n      }, [[view]])];\n    }\n\n    return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"h\"])('div', {\n      class: 'scrollbar'\n    }, nodes);\n  }\n});\n// CONCATENATED MODULE: ./src/components/scrollbar/index.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./src/components/scrollbar/index.vue?vue&type=style&index=0&lang=scss\nvar scrollbarvue_type_style_index_0_lang_scss = __nested_webpack_require_119820__(88);\n\n// CONCATENATED MODULE: ./src/components/scrollbar/index.vue\n\n\n\n\n\n/* harmony default export */ var scrollbar = (scrollbarvue_type_script_lang_js);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/components/toc-nav.vue?vue&type=template&id=035b0d52&bindings={\"titles\":\"props\",\"indent\":\"props\"}\n\nvar toc_navvue_type_template_id_035b0d52_bindings_titles_props_indent_props_hoisted_1 = {\n  class: \"v-md-editor__toc-nav\"\n};\nvar toc_navvue_type_template_id_035b0d52_bindings_titles_props_indent_props_hoisted_2 = {\n  class: \"v-md-editor__toc-nav-title\"\n};\nfunction toc_navvue_type_template_id_035b0d52_bindings_titles_props_indent_props_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"ul\", toc_navvue_type_template_id_035b0d52_bindings_titles_props_indent_props_hoisted_1, [(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(true), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], null, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderList\"])($props.titles, function (item) {\n    return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"li\", {\n      style: {\n        paddingLeft: $props.indent * item.indent + \"px\"\n      },\n      onClick: function onClick($event) {\n        return _ctx.$emit('nav-click', item);\n      },\n      class: \"v-md-editor__toc-nav-item\"\n    }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"span\", toc_navvue_type_template_id_035b0d52_bindings_titles_props_indent_props_hoisted_2, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"toDisplayString\"])(item.title), 1\n    /* TEXT */\n    )], 12\n    /* STYLE, PROPS */\n    , [\"onClick\"]);\n  }), 256\n  /* UNKEYED_FRAGMENT */\n  ))]);\n}\n// CONCATENATED MODULE: ./src/components/toc-nav.vue?vue&type=template&id=035b0d52&bindings={\"titles\":\"props\",\"indent\":\"props\"}\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/toc-nav.vue?vue&type=script&lang=js\n/* harmony default export */ var toc_navvue_type_script_lang_js = ({\n  name: 'toc-nav',\n  props: {\n    titles: Array,\n    indent: {\n      type: Number,\n      default: 16\n    }\n  },\n  emits: ['nav-click']\n});\n// CONCATENATED MODULE: ./src/components/toc-nav.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./src/components/toc-nav.vue?vue&type=style&index=0&lang=scss\nvar toc_navvue_type_style_index_0_lang_scss = __nested_webpack_require_119820__(89);\n\n// CONCATENATED MODULE: ./src/components/toc-nav.vue\n\n\n\n\n\ntoc_navvue_type_script_lang_js.render = toc_navvue_type_template_id_035b0d52_bindings_titles_props_indent_props_render\n\n/* harmony default export */ var toc_nav = (toc_navvue_type_script_lang_js);\n// CONCATENATED MODULE: ./src/mixins/common.js\nvar common_components;\n\n// base css\n\n\n\n\n\n\n/* harmony default export */ var common = ({\n  inheritAttrs: false,\n  components: (common_components = {}, common_components[preview[\"default\"].name] = preview[\"default\"], common_components[container.name] = container, common_components[scrollbar.name] = scrollbar, common_components[toc_nav.name] = toc_nav, common_components),\n  provide: function provide() {\n    return {\n      markdownEditor: this\n    };\n  },\n  props: {\n    height: String,\n    theme: Object,\n    mode: {\n      type: String,\n      default: editor_mode[\"a\" /* default */].EDITABLE\n    },\n    autofocus: Boolean,\n    placeholder: String,\n    tocNavPositionRight: Boolean,\n    tabSize: {\n      type: Number,\n      default: 2\n    },\n    beforePreviewChange: {\n      type: Function,\n      default: function _default(text, next) {\n        next(text);\n      }\n    }\n  },\n  emits: ['blur', 'change', 'save', 'image-click'],\n  data: function data() {\n    return {\n      currentMode: this.mode,\n      uploadConfig: {}\n    };\n  },\n  watch: {\n    mode: function mode() {\n      this.currentMode = this.mode;\n    },\n    currentMode: function currentMode() {\n      if (this.currentMode === editor_mode[\"a\" /* default */].EDITABLE && this.enableSyncScroll) {\n        this.$nextTick(this.previewSyncScroll);\n      }\n    }\n  },\n  created: function created() {\n    if (this.theme) this.$options.use(this.theme);\n  },\n  computed: {\n    isPreviewMode: function isPreviewMode() {\n      return this.currentMode === editor_mode[\"a\" /* default */].PREVIEW;\n    },\n    isEditMode: function isEditMode() {\n      return this.currentMode === editor_mode[\"a\" /* default */].EDIT;\n    },\n    proxySlots: function proxySlots() {\n      var _this = this;\n\n      return ['left-toolbar', 'right-toolbar'].filter(function (slotName) {\n        return _this.$slots[slotName];\n      });\n    }\n  },\n  mounted: function mounted() {\n    if (this.autofocus) {\n      this.$nextTick(this.setFocusEnd);\n    }\n  },\n  methods: {\n    setFocusEnd: function setFocusEnd() {\n      this.editorFocusEnd();\n      this.editorScrollToTop(9999);\n      this.previewScrollTo(9999);\n    },\n    // change event\n    handleChange: function handleChange(text, html) {\n      this.$emit('change', text, html);\n    },\n    handleBlur: function handleBlur(e) {\n      this.$emit('blur', e);\n    },\n    handlePreviewImageClick: function handlePreviewImageClick(images, currentIndex) {\n      this.$emit('image-click', images, currentIndex);\n    },\n    save: function save() {\n      this.$emit('save', this.text, this.$refs.preview.html);\n    },\n    insert: function insert(getInsertContent) {\n      var _this2 = this;\n\n      this.focus();\n      var currentSelectedStr = this.getCurrentSelectedStr();\n\n      var _getInsertContent = getInsertContent(currentSelectedStr),\n          selected = _getInsertContent.selected,\n          text = _getInsertContent.text;\n\n      this.replaceSelectionText(text);\n      this.$nextTick(function () {\n        _this2.changeSelctionTo(text, selected);\n      });\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/mixins/v-model.js\n/* harmony default export */ var v_model = ({\n  props: {\n    modelValue: {\n      type: String,\n      default: ''\n    }\n  },\n  emits: ['update:modelValue'],\n  data: function data() {\n    return {\n      text: this.modelValue\n    };\n  },\n  methods: {\n    handleInput: function handleInput(val) {\n      this.text = val;\n      this.$emit('update:modelValue', val);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/mixins/fullscreen.js\n/* harmony default export */ var fullscreen = ({\n  props: {\n    defaultFullscreen: Boolean\n  },\n  emits: ['fullscreen-change'],\n  data: function data() {\n    return {\n      fullscreen: false\n    };\n  },\n  watch: {\n    fullscreen: function fullscreen() {\n      this.$emit('fullscreen-change', this.fullscreen);\n    }\n  },\n  mounted: function mounted() {\n    window.addEventListener('keyup', this.handleWindowKeyup, false);\n\n    if (this.defaultFullscreen) {\n      this.toggleFullScreen();\n    }\n  },\n  beforeUnmount: function beforeUnmount() {\n    window.removeEventListener('keyup', this.handleWindowKeyup, false);\n  },\n  methods: {\n    handleWindowKeyup: function handleWindowKeyup(e) {\n      // esc\n      if (e.keyCode === 27 && this.fullscreen) {\n        this.toggleFullScreen(false);\n      }\n    },\n    toggleFullScreen: function toggleFullScreen(fullscreen) {\n      if (fullscreen === void 0) {\n        fullscreen = !this.fullscreen;\n      }\n\n      this.fullscreen = fullscreen;\n\n      var _document$querySelect = document.querySelectorAll('html, body'),\n          html = _document$querySelect[0],\n          body = _document$querySelect[1];\n\n      var overflow = this.fullscreen ? 'hidden' : null;\n      body.style.overflow = overflow;\n      html.style.overflow = overflow;\n    }\n  }\n});\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/components/upload-file.vue?vue&type=template&id=e27464d6&bindings={\"uploadConfig\":\"props\",\"handleUpload\":\"data\",\"key\":\"data\",\"upload\":\"options\",\"chooseFile\":\"options\"}\n\nfunction upload_filevue_type_template_id_e27464d6_bindings_uploadConfig_props_handleUpload_data_key_data_upload_options_chooseFile_options_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"input\", {\n    type: \"file\",\n    style: {\n      \"display\": \"none\"\n    },\n    key: $data.key,\n    accept: $props.uploadConfig.accept,\n    multiple: $props.uploadConfig.multiple,\n    onInput: _cache[1] || (_cache[1] = function () {\n      return $data.handleUpload.apply($data, arguments);\n    }),\n    ref: \"fileInput\"\n  }, null, 40\n  /* PROPS, HYDRATE_EVENTS */\n  , [\"accept\", \"multiple\"]);\n}\n// CONCATENATED MODULE: ./src/components/upload-file.vue?vue&type=template&id=e27464d6&bindings={\"uploadConfig\":\"props\",\"handleUpload\":\"data\",\"key\":\"data\",\"upload\":\"options\",\"chooseFile\":\"options\"}\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __nested_webpack_require_119820__(10);\nvar regenerator_default = /*#__PURE__*/__nested_webpack_require_119820__.n(regenerator);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nvar asyncToGenerator = __nested_webpack_require_119820__(17);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/upload-file.vue?vue&type=script&lang=js\n\n\n/* harmony default export */ var upload_filevue_type_script_lang_js = ({\n  name: 'v-md-upload-file',\n  props: {\n    uploadConfig: Object\n  },\n  data: function data() {\n    return {\n      handleUpload: function handleUpload() {},\n      key: 0\n    };\n  },\n  methods: {\n    upload: function upload() {\n      var _this = this;\n\n      return Object(asyncToGenerator[\"a\" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n        var event;\n        return regenerator_default.a.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _this.chooseFile();\n\n            case 2:\n              event = _context.sent;\n              return _context.abrupt(\"return\", event);\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    },\n    chooseFile: function chooseFile() {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        _this2.handleUpload = function (e) {\n          resolve(e); // 解决上传同一文件不触发change事件的问题\n\n          _this2.key++;\n        };\n\n        _this2.$refs.fileInput.click();\n      });\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/upload-file.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/components/upload-file.vue\n\n\n\nupload_filevue_type_script_lang_js.render = upload_filevue_type_template_id_e27464d6_bindings_uploadConfig_props_handleUpload_data_key_data_upload_options_chooseFile_options_render\n\n/* harmony default export */ var upload_file = (upload_filevue_type_script_lang_js);\n// EXTERNAL MODULE: ./src/toolbar/image.js\nvar toolbar_image = __nested_webpack_require_119820__(23);\n\n// EXTERNAL MODULE: ./src/utils/file.js\nvar file = __nested_webpack_require_119820__(12);\n\n// EXTERNAL MODULE: ./src/utils/constants/command.js\nvar command = __nested_webpack_require_119820__(1);\n\n// CONCATENATED MODULE: ./src/mixins/upload-image.js\n\n\nvar upload_image_components;\n\n\n\n\n\nvar defaultConfig = {\n  accept: 'image/*',\n  multiple: false\n};\n/* harmony default export */ var upload_image = ({\n  components: (upload_image_components = {}, upload_image_components[upload_file.name] = upload_file, upload_image_components),\n  props: {\n    uploadImageConfig: Object\n  },\n  emits: ['upload-image'],\n  computed: {\n    uploadImgConfig: function uploadImgConfig() {\n      return Object(esm_extends[\"a\" /* default */])({}, defaultConfig, this.uploadImageConfig);\n    },\n    hasUploadImage: function hasUploadImage() {\n      return !this.disabledMenus.includes(toolbar_image[\"default\"].name + \"/upload-image\");\n    }\n  },\n  methods: {\n    handleDrop: function handleDrop(e) {\n      var files = Object(file[\"a\" /* filesFilter */])(e.dataTransfer.files, this.uploadImgConfig);\n      this.emitUploadImage(e, files);\n    },\n    handlePaste: function handlePaste(e) {\n      var clipboardData = e.clipboardData;\n      if (!clipboardData) return;\n      var files = Object(file[\"a\" /* filesFilter */])(Object(file[\"b\" /* getFilesFromClipboardData */])(clipboardData), this.uploadImgConfig);\n      this.emitUploadImage(e, files);\n    },\n    emitUploadImage: function emitUploadImage(e, files) {\n      var _this = this;\n\n      if (this.hasUploadImage && files.length) {\n        e.preventDefault();\n        this.$emit('upload-image', e, function (imageConfig) {\n          _this.execCommand(command[\"l\" /* image */], imageConfig);\n        }, files);\n      }\n    }\n  }\n});\n// EXTERNAL MODULE: ./src/utils/constants/markup.js\nvar markup = __nested_webpack_require_119820__(3);\n\n// CONCATENATED MODULE: ./src/mixins/sync-scroll.js\n\n/* harmony default export */ var sync_scroll = ({\n  data: function data() {\n    return {\n      enableSyncScroll: true\n    };\n  },\n  methods: {\n    toggleSyncScroll: function toggleSyncScroll(isEnable) {\n      if (isEnable === void 0) {\n        isEnable = !this.enableSyncScroll;\n      }\n\n      this.enableSyncScroll = isEnable;\n      if (isEnable) this.previewSyncScroll();\n    },\n    previewSyncScroll: function previewSyncScroll() {\n      if (this.isEditMode) return;\n      var previewEl = this.$refs.preview.$el;\n      var previewScrollerEl = this.$refs.previewScroller.$el;\n      var previewLines = previewEl.querySelectorAll(\"[\" + markup[\"c\" /* LINE_MARKUP */] + \"]\");\n\n      var _this$getScrollInfo = this.getScrollInfo(),\n          editorClientHeight = _this$getScrollInfo.clientHeight,\n          editorScrollTop = _this$getScrollInfo.top,\n          editorScrollHeight = _this$getScrollInfo.height;\n\n      var previewScrollWrapper = previewScrollerEl.querySelector('.scrollbar__wrap');\n\n      if (editorClientHeight + editorScrollTop === editorScrollHeight) {\n        var clientHeight = previewScrollWrapper.clientHeight;\n        var scrollHeight = previewScrollWrapper.scrollHeight;\n        this.previewScrollTo(scrollHeight - clientHeight);\n      } else {\n        var currentLine;\n        var nextLine;\n\n        for (var i = 0; i < previewLines.length; i++) {\n          var lineNumber = previewLines[i].getAttribute(markup[\"c\" /* LINE_MARKUP */]);\n          var height = this.heightAtLine(lineNumber - 1, 'local');\n\n          if (height < editorScrollTop) {\n            currentLine = lineNumber;\n          } else {\n            nextLine = lineNumber;\n            break;\n          }\n        }\n\n        var percent = 0;\n\n        if (currentLine && nextLine && currentLine !== nextLine) {\n          var currentLineTop = this.heightAtLine(currentLine - 1, 'local');\n          var nextLineTop = this.heightAtLine(nextLine - 1, 'local');\n          percent = (editorScrollTop - currentLineTop) / (nextLineTop - currentLineTop);\n        }\n\n        var newLineTop = 0;\n        var newNextLineTop = previewScrollWrapper.scrollHeight - previewScrollWrapper.clientHeight;\n\n        if (currentLine) {\n          newLineTop = previewEl.querySelector(\"[\" + markup[\"c\" /* LINE_MARKUP */] + \"=\\\"\" + currentLine + \"\\\"]\").offsetTop;\n        }\n\n        if (nextLine) {\n          newNextLineTop = previewEl.querySelector(\"[\" + markup[\"c\" /* LINE_MARKUP */] + \"=\\\"\" + nextLine + \"\\\"]\").offsetTop;\n        }\n\n        var newScrollTop = newLineTop + (newNextLineTop - newLineTop) * percent;\n        this.previewScrollTo(newScrollTop);\n      }\n    },\n    handleEditorScroll: function handleEditorScroll() {\n      if (!this.enableSyncScroll || this.ignoreSyncScroll) return;\n      clearTimeout(this.scrollTimmer);\n      this.scrollTimmer = setTimeout(this.previewSyncScroll, 60);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/mixins/toolbar.js\n\n/* harmony default export */ var mixins_toolbar = (function (Component) {\n  return {\n    props: {\n      leftToolbar: {\n        type: String,\n        default: 'undo redo clear | h bold italic strikethrough quote | ul ol table hr | link image code | save'\n      },\n      rightToolbar: {\n        type: String,\n        default: 'preview toc sync-scroll fullscreen'\n      },\n      toolbar: {\n        type: Object,\n        default: function _default() {\n          return {};\n        }\n      },\n      disabledMenus: {\n        type: Array,\n        default: function _default() {\n          return ['image/upload-image'];\n        }\n      },\n      toolbarConfig: {\n        type: Object,\n        default: function _default() {\n          return {};\n        }\n      }\n    },\n    created: function created() {\n      var _this = this;\n\n      var toolbars = Component.toolbars;\n      this.toolbars = {};\n      Object.keys(toolbars).forEach(function (name) {\n        _this.registerToolbar(name, toolbars[name]);\n      });\n      Object.keys(this.toolbar).forEach(function (name) {\n        _this.registerToolbar(name, _this.toolbar[name]);\n      });\n    },\n    methods: {\n      registerToolbar: function registerToolbar(name, config) {\n        toolbar_registerToolbar(this.toolbars, name, config);\n      },\n      handleToolbarItemClick: function handleToolbarItemClick(toolbar) {\n        var _toolbar$menus;\n\n        if (toolbar.action && !((_toolbar$menus = toolbar.menus) != null && _toolbar$menus.length) && typeof toolbar.action === 'function') {\n          toolbar.action.call(toolbar, this, this.toolbarConfig[toolbar.name]);\n        }\n      },\n      handleToolbarMenuClick: function handleToolbarMenuClick(menu) {\n        if (menu.action && typeof menu.action === 'function') {\n          menu.action.call(menu, this, this.toolbarConfig[menu.name]);\n        }\n      }\n    }\n  };\n});\n// CONCATENATED MODULE: ./src/mixins/command.js\n\n/* harmony default export */ var mixins_command = (function (Component) {\n  return {\n    created: function created() {\n      var _this = this;\n\n      var commands = Component.commands;\n      this.commands = {};\n      Object.keys(commands).forEach(function (name) {\n        _this.registerCommand(name, commands[name]);\n      });\n    },\n    methods: {\n      registerCommand: function registerCommand(name, callback) {\n        command_registerCommand(this.commands, name, callback);\n      },\n      execCommand: function execCommand(name) {\n        var commandCallBack = this.commands[name];\n\n        if (commandCallBack) {\n          for (var _len = arguments.length, arg = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            arg[_key - 1] = arguments[_key];\n          }\n\n          commandCallBack.apply(void 0, [this].concat(arg));\n        } else {\n          console.error(\"Command not found: \" + name);\n        }\n      }\n    }\n  };\n});\n// CONCATENATED MODULE: ./src/mixins/toc.js\n\n/* harmony default export */ var toc = ({\n  data: function data() {\n    return {\n      tocVisible: this.defaultShowToc,\n      titles: []\n    };\n  },\n  props: {\n    includeLevel: {\n      type: Array,\n      default: function _default() {\n        return [2, 3];\n      }\n    },\n    defaultShowToc: Boolean\n  },\n  watch: {\n    text: {\n      immediate: true,\n      handler: function handler(newval, oldVal) {\n        // render in the first time\n        if (typeof oldVal === 'undefined') {\n          this.$nextTick(this.updateTocNav);\n          return;\n        }\n\n        if (this.updateTocNavTimmer) clearTimeout(this.updateTocNavTimmer);\n        this.updateTocNavTimmer = setTimeout(this.updateTocNav, 800);\n      }\n    }\n  },\n  computed: {\n    anchorsSelector: function anchorsSelector() {\n      return this.includeLevel.map(function (level) {\n        return \"h\" + level;\n      }).join(',');\n    }\n  },\n  methods: {\n    toggleToc: function toggleToc(visible) {\n      if (visible === void 0) {\n        visible = !this.tocVisible;\n      }\n\n      this.tocVisible = visible;\n    },\n    updateTocNav: function updateTocNav() {\n      var _this$$refs$preview;\n\n      var previewEl = (_this$$refs$preview = this.$refs.preview) == null ? void 0 : _this$$refs$preview.$el;\n      if (!previewEl) return;\n      var anchors = previewEl.querySelectorAll(this.anchorsSelector);\n      var titles = Array.from(anchors).filter(function (title) {\n        return !!title.innerText.trim();\n      });\n\n      if (!titles.length) {\n        this.titles = [];\n        return;\n      }\n\n      var hTags = Array.from(new Set(titles.map(function (title) {\n        return title.tagName;\n      }))).sort();\n      this.titles = titles.map(function (el) {\n        return {\n          title: el.innerText,\n          lineIndex: el.getAttribute(markup[\"c\" /* LINE_MARKUP */]),\n          indent: hTags.indexOf(el.tagName)\n        };\n      });\n    },\n    handleNavClick: function handleNavClick(_ref) {\n      var lineIndex = _ref.lineIndex;\n      this.scrollToLine(lineIndex);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/mixins/scroll.js\n/* harmony default export */ var mixins_scroll = ({\n  props: {\n    previewScrollContainer: Function\n  },\n  computed: {\n    getPreviewScrollContainer: function getPreviewScrollContainer() {\n      var _this = this;\n\n      return function () {\n        var previewScrollContainer = _this.$refs.previewScroller.$el.querySelector('.scrollbar__wrap');\n\n        var defaultContainer = _this.isPreviewMode ? window : previewScrollContainer;\n        return _this.previewScrollContainer ? _this.previewScrollContainer() : defaultContainer;\n      };\n    }\n  },\n  methods: {\n    previewScrollTo: function previewScrollTo(scrollTop) {\n      this.$refs.previewScroller.scrollTo(scrollTop);\n    },\n    scrollToLine: function scrollToLine(lineIndex) {\n      var _this2 = this;\n\n      if (!this.isPreviewMode) {\n        this.editorScrollToLine(lineIndex);\n      }\n\n      if (!this.isEditMode) {\n        this.ignoreSyncScroll = true;\n        this.previewScrollToLine({\n          lineIndex: lineIndex,\n          onScrollEnd: function onScrollEnd() {\n            _this2.ignoreSyncScroll = false;\n          }\n        });\n      }\n    },\n    editorScrollToLine: function editorScrollToLine(lineIndex) {\n      var offsetTop = this.heightAtLine(lineIndex - 1, 'local');\n      this.editorScrollToTop(offsetTop);\n    },\n    previewScrollToTarget: function previewScrollToTarget() {\n      var _this$$refs$preview;\n\n      (_this$$refs$preview = this.$refs.preview).scrollToTarget.apply(_this$$refs$preview, arguments);\n    },\n    previewScrollToLine: function previewScrollToLine(_ref) {\n      var lineIndex = _ref.lineIndex,\n          onScrollEnd = _ref.onScrollEnd;\n      this.$refs.preview.scrollToLine({\n        lineIndex: lineIndex,\n        onScrollEnd: onScrollEnd\n      });\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/mixins/hotkeys.js\n\nvar defaultHotkeys = {};\nObject(util[\"c\" /* importAll */])(defaultHotkeys, __nested_webpack_require_119820__(90));\n/* harmony default export */ var hotkeys = (function (Component) {\n  return {\n    mounted: function mounted() {\n      var _this = this;\n\n      if (this.isPreviewMode) return;\n      var hotkeys = Component.hotkeys;\n      Object.keys(defaultHotkeys).forEach(function (key) {\n        _this.registerHotkeys(defaultHotkeys[key].default);\n      });\n      hotkeys.forEach(function (config) {\n        _this.registerHotkeys(config);\n      });\n    },\n    methods: {\n      registerHotkeys: function registerHotkeys(_ref) {\n        var _this2 = this;\n\n        var modifier = _ref.modifier,\n            key = _ref.key,\n            _action = _ref.action,\n            _ref$preventDefault = _ref.preventDefault,\n            preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault;\n        this.editorRegisterHotkeys({\n          modifier: modifier,\n          key: key,\n          preventDefault: preventDefault,\n          action: function action() {\n            for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {\n              arg[_key] = arguments[_key];\n            }\n\n            return _action.apply(void 0, [_this2].concat(arg));\n          }\n        });\n      }\n    }\n  };\n});\n// CONCATENATED MODULE: ./src/mixins/list.js\nvar ol = /^\\s*([\\d]+\\.)( \\[[ xX]])? /;\nvar ul = /^\\s*([-*])( \\[[ xX]])? /;\nvar ulSyntax = /([*-] |[\\d]+\\. )/;\nvar olSyntax = /([\\d])+\\.( \\[[ xX]])? /;\n/* harmony default export */ var list = ({\n  mounted: function mounted() {\n    var _this = this;\n\n    if (this.isPreviewMode) return;\n    this.registerHotkeys({\n      key: 'enter',\n      preventDefault: false,\n      action: function action(editor, e) {\n        if (e.isComposing) return;\n\n        var cursorLineLeftText = _this.getCursorLineLeftText();\n\n        var suffix;\n        var syntax;\n\n        if (ol.test(cursorLineLeftText)) {\n          suffix = 'x. ';\n          syntax = olSyntax;\n          e.preventDefault();\n        } else if (ul.test(cursorLineLeftText)) {\n          suffix = '- ';\n          syntax = ulSyntax;\n          e.preventDefault();\n        } else {\n          return;\n        }\n\n        var indent = cursorLineLeftText.search(syntax);\n        var suffixIndex = indent + suffix.length;\n        var beforeText = cursorLineLeftText.slice(0, suffixIndex);\n        var content = cursorLineLeftText.slice(suffixIndex, cursorLineLeftText.length);\n\n        if (content) {\n          if (suffix === 'x. ') {\n            beforeText = beforeText.replace(/(\\d+)/, window.parseInt(beforeText) + 1);\n          }\n\n          _this.replaceSelectionText(\"\\n\" + beforeText, 'end');\n        } else {\n          // break\n          _this.delLineLeft();\n\n          _this.replaceSelectionText('\\n', 'end');\n        }\n      }\n    });\n  }\n});\n// CONCATENATED MODULE: ./src/mixins/lang.js\n/* harmony default export */ var mixins_lang = ({\n  computed: {\n    langConfig: function langConfig() {\n      var lang = this.$options.lang.config;\n      return lang.langConfig[lang.lang];\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/create-editor.js\n\n\n\n\n // mixins\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar create_editor_lang = new utils_lang[\"a\" /* default */]({\n  afterUse: function afterUse(lang) {\n    preview[\"default\"].vMdParser.lang.config.lang = lang;\n  }\n});\ncreate_editor_lang.config = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"reactive\"])(create_editor_lang.config);\ncreate_editor_lang.add({\n  'zh-CN': zh_CN\n});\nfunction createEditor(component) {\n  commandWrapper(component);\n  toolbarWrapper(component);\n  component.name = 'v-md-editor';\n  component.lang = create_editor_lang;\n  component.vMdParser = preview[\"default\"].vMdParser;\n  component.Preview = preview[\"default\"];\n  component.hotkeys = [];\n\n  component.hotkey = function (config) {\n    component.hotkeys.push(config);\n  };\n\n  component.mixins = [common, v_model, mixins_toolbar(component), mixins_command(component), hotkeys(component), fullscreen, upload_image, sync_scroll, toc, mixins_scroll, list, mixins_lang];\n}\n\n/***/ }),\n/* 36 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// CONCATENATED MODULE: ./src/utils/key-codes.js\nvar keyCodesToName = {\n  // Numbers and letters\n  48: 0,\n  49: 1,\n  50: 2,\n  51: 3,\n  52: 4,\n  53: 5,\n  54: 6,\n  55: 7,\n  56: 8,\n  57: 9,\n  65: 'a',\n  66: 'b',\n  67: 'c',\n  68: 'd',\n  69: 'e',\n  70: 'f',\n  71: 'g',\n  72: 'h',\n  73: 'i',\n  74: 'j',\n  75: 'k',\n  76: 'l',\n  77: 'm',\n  78: 'n',\n  79: 'o',\n  80: 'p',\n  81: 'q',\n  82: 'r',\n  83: 's',\n  84: 't',\n  85: 'u',\n  86: 'v',\n  87: 'w',\n  88: 'x',\n  89: 'y',\n  90: 'z',\n  // Function keys\n  112: 'F1',\n  113: 'F2',\n  114: 'F3',\n  115: 'F4',\n  116: 'F5',\n  117: 'F6',\n  118: 'F7',\n  119: 'F8',\n  120: 'F9',\n  121: 'F10',\n  122: 'F11',\n  123: 'F12'\n};\nvar keyNames = {\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  space: [' ', 'Spacebar'],\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  delete: ['Backspace', 'Delete', 'Del']\n};\n// CONCATENATED MODULE: ./src/utils/hotkeys.js\n\n\nvar hotkeys_Hotkeys = /*#__PURE__*/function () {\n  function Hotkeys() {\n    this.hotkeys = {\n      ctrl: {},\n      shift: {},\n      ctrlAlt: {},\n      ctrlShift: {},\n      keys: {}\n    };\n  }\n\n  var _proto = Hotkeys.prototype;\n\n  _proto.dispatch = function dispatch(e) {\n    var keyName = this.getKeyName(e).toLowerCase();\n    var opt;\n    if (!keyName) return;\n\n    if (this.isKeyEnterExact(e)) {\n      opt = this.hotkeys.keys[keyName];\n    } else if (this.isCtrlEnterExact(e)) {\n      opt = this.hotkeys.ctrl[keyName];\n    } else if (this.isShiftEnterExact(e)) {\n      opt = this.hotkeys.shift[keyName];\n    } else if (this.isCtrlAltEnterExact(e)) {\n      opt = this.hotkeys.ctrlAlt[keyName];\n    } else if (this.isCtrlShiftEnterExact(e)) {\n      opt = this.hotkeys.ctrlShift[keyName];\n    }\n\n    if (opt) {\n      var _opt2 = opt,\n          action = _opt2.action,\n          preventDefault = _opt2.preventDefault;\n      if (preventDefault) e.preventDefault();\n      action(e);\n    }\n  };\n\n  _proto.isKeyEnterExact = function isKeyEnterExact(e) {\n    return !this.isCtrlEnter(e) && !this.isShiftEnter(e) && !this.isAltEnter(e);\n  };\n\n  _proto.isCtrlShiftEnterExact = function isCtrlShiftEnterExact(e) {\n    return this.isCtrlEnter(e) && this.isShiftEnter(e) && !this.isAltEnter(e);\n  };\n\n  _proto.isCtrlAltEnterExact = function isCtrlAltEnterExact(e) {\n    return this.isCtrlEnter(e) && this.isAltEnter(e) && !this.isShiftEnter(e);\n  };\n\n  _proto.isCtrlEnterExact = function isCtrlEnterExact(e) {\n    return this.isCtrlEnter(e) && !this.isShiftEnter(e) && !this.isAltEnter(e);\n  };\n\n  _proto.isShiftEnterExact = function isShiftEnterExact(e) {\n    return this.isShiftEnter(e) && !this.isCtrlEnter(e) && !this.isAltEnter(e);\n  };\n\n  _proto.isCtrlEnter = function isCtrlEnter(e) {\n    return e.ctrlKey || e.metaKey;\n  };\n\n  _proto.isShiftEnter = function isShiftEnter(e) {\n    return e.shiftKey;\n  };\n\n  _proto.isAltEnter = function isAltEnter(e) {\n    return e.altKey;\n  };\n\n  _proto.registerHotkeys = function registerHotkeys(_ref) {\n    var modifier = _ref.modifier,\n        key = _ref.key,\n        _ref$preventDefault = _ref.preventDefault,\n        preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault,\n        action = _ref.action;\n\n    if (modifier) {\n      this.hotkeys[modifier][key] = {\n        preventDefault: preventDefault,\n        action: action\n      };\n    } else {\n      this.hotkeys.keys[key] = {\n        preventDefault: preventDefault,\n        action: action\n      };\n    }\n  };\n\n  _proto.getKeyName = function getKeyName(e) {\n    var key = e.key,\n        keyCode = e.keyCode;\n\n    if (key !== undefined) {\n      var keyName = Object.keys(keyNames).find(function (keyName) {\n        var validNames = keyNames[keyName];\n        return typeof validNames === 'string' ? validNames === key : validNames.indexOf(key) !== -1;\n      });\n      return keyName || key;\n    }\n\n    return keyCodesToName[keyCode];\n  };\n\n  return Hotkeys;\n}();\n\n/* harmony default export */ var hotkeys = __webpack_exports__[\"a\"] = (hotkeys_Hotkeys);\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n    true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __nested_webpack_require_233445__) {\n\nvar map = {\n\t\"./bold.js\": 39,\n\t\"./clear.js\": 40,\n\t\"./code.js\": 41,\n\t\"./fullscreen.js\": 42,\n\t\"./h1.js\": 43,\n\t\"./h2.js\": 44,\n\t\"./h3.js\": 45,\n\t\"./h4.js\": 46,\n\t\"./h5.js\": 47,\n\t\"./h6.js\": 48,\n\t\"./hr.js\": 49,\n\t\"./image.js\": 50,\n\t\"./italic.js\": 51,\n\t\"./link.js\": 52,\n\t\"./ol.js\": 53,\n\t\"./quote.js\": 54,\n\t\"./redo.js\": 55,\n\t\"./strikethrough.js\": 56,\n\t\"./sync-scroll.js\": 57,\n\t\"./table.js\": 58,\n\t\"./ul.js\": 59,\n\t\"./undo.js\": 60\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __nested_webpack_require_233445__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__nested_webpack_require_233445__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 38;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_234448__) {\n\n\"use strict\";\n__nested_webpack_require_234448__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_234448__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_234448__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_234448__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"a\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '**';\n    var suffix = '**';\n    var placeholder = editor.langConfig.bold.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return \"\" + prefix + selectedGetter(selected) + suffix;\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 40 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_235788__) {\n\n\"use strict\";\n__nested_webpack_require_235788__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_235788__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_235788__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"b\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.clear();\n});\n\n/***/ }),\n/* 41 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_236318__) {\n\n\"use strict\";\n__nested_webpack_require_236318__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_236318__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_236318__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"c\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '``` language';\n    var suffix = '```';\n    var text = prefix + \"\\n\" + suffix;\n\n    if (selected) {\n      text = prefix + \"\\n  \" + selected + \"\\n\" + suffix;\n    }\n\n    return {\n      text: text,\n      selected: 'language'\n    };\n  });\n});\n\n/***/ }),\n/* 42 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_237120__) {\n\n\"use strict\";\n__nested_webpack_require_237120__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_237120__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_237120__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"d\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor, fullScreen) {\n  editor.toggleFullScreen(fullScreen);\n});\n\n/***/ }),\n/* 43 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_237683__) {\n\n\"use strict\";\n__nested_webpack_require_237683__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_237683__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_237683__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_237683__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"e\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '#';\n    var placeholder = editor.langConfig.h1.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return prefix + \" \" + selectedGetter(selected);\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 44 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_238989__) {\n\n\"use strict\";\n__nested_webpack_require_238989__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_238989__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_238989__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_238989__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"f\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '##';\n    var placeholder = editor.langConfig.h2.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return prefix + \" \" + selectedGetter(selected);\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 45 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_240296__) {\n\n\"use strict\";\n__nested_webpack_require_240296__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_240296__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_240296__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_240296__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"g\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '###';\n    var placeholder = editor.langConfig.h3.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return prefix + \" \" + selectedGetter(selected);\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 46 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_241604__) {\n\n\"use strict\";\n__nested_webpack_require_241604__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_241604__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_241604__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_241604__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"h\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '####';\n    var placeholder = editor.langConfig.h4.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return prefix + \" \" + selectedGetter(selected);\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 47 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_242913__) {\n\n\"use strict\";\n__nested_webpack_require_242913__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_242913__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_242913__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_242913__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"i\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '#####';\n    var placeholder = editor.langConfig.h5.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return prefix + \" \" + selectedGetter(selected);\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 48 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_244223__) {\n\n\"use strict\";\n__nested_webpack_require_244223__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_244223__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_244223__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_244223__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"j\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '######';\n    var placeholder = editor.langConfig.h6.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return prefix + \" \" + selectedGetter(selected);\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 49 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_245534__) {\n\n\"use strict\";\n__nested_webpack_require_245534__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_245534__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_245534__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"k\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function () {\n    return {\n      text: '------------------------------------'\n    };\n  });\n});\n\n/***/ }),\n/* 50 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_246153__) {\n\n\"use strict\";\n__nested_webpack_require_246153__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_246153__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_246153__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"l\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      url = _ref.url,\n      desc = _ref.desc,\n      width = _ref.width,\n      height = _ref.height;\n\n  editor.insert(function () {\n    var urlPlaceholder = 'http://';\n    var descPlaceholder = 'Description';\n    var selected = urlPlaceholder;\n    var text = \"![\" + (desc || descPlaceholder) + \"](\" + (url || urlPlaceholder) + \")\";\n    var style = [];\n\n    if (width) {\n      style.push(\"width=\\\"\" + width + \"\\\"\");\n    }\n\n    if (height) {\n      style.push(\"height=\\\"\" + height + \"\\\"\");\n    }\n\n    if (style.length) {\n      text += \"{{{\" + style.join(' ') + \"}}}\";\n    }\n\n    if (url && desc) {\n      selected = null;\n    } else if (url) {\n      selected = descPlaceholder;\n    } else if (desc) {\n      selected = urlPlaceholder;\n    }\n\n    return {\n      text: text,\n      selected: selected\n    };\n  });\n});\n\n/***/ }),\n/* 51 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_247521__) {\n\n\"use strict\";\n__nested_webpack_require_247521__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_247521__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_247521__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_247521__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"m\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '*';\n    var suffix = '*';\n    var placeholder = editor.langConfig.italic.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return \"\" + prefix + selectedGetter(selected) + suffix;\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 52 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_248861__) {\n\n\"use strict\";\n__nested_webpack_require_248861__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_248861__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_248861__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_248861__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"n\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var descPlaceholder = editor.langConfig.link.descPlaceholder;\n    var linkPlaceholder = 'http://';\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return \"[\" + (selected || descPlaceholder) + \"](\" + linkPlaceholder + \")\";\n      },\n      selectedGetter: function selectedGetter(selected) {\n        return selected ? linkPlaceholder : descPlaceholder;\n      }\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 53 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_250202__) {\n\n\"use strict\";\n__nested_webpack_require_250202__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_250202__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_250202__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_250202__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"o\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var placeholder = editor.langConfig.ol.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected, rowIndex) {\n        return rowIndex + \". \" + selectedGetter(selected);\n      },\n      selectedGetter: selectedGetter,\n      ignoreEmptyLine: false\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 54 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_251529__) {\n\n\"use strict\";\n__nested_webpack_require_251529__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_251529__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_251529__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"p\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '>';\n    var content = selected || editor.langConfig.quote.placeholder;\n    return {\n      text: prefix + \" \" + content,\n      selected: content\n    };\n  });\n});\n\n/***/ }),\n/* 55 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_252254__) {\n\n\"use strict\";\n__nested_webpack_require_252254__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_252254__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_252254__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"q\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.redo();\n});\n\n/***/ }),\n/* 56 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_252783__) {\n\n\"use strict\";\n__nested_webpack_require_252783__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_252783__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_252783__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_252783__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"r\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var prefix = '~~';\n    var suffix = '~~';\n    var placeholder = editor.langConfig.strikethrough.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return \"\" + prefix + selectedGetter(selected) + suffix;\n      },\n      selectedGetter: selectedGetter\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 57 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_254132__) {\n\n\"use strict\";\n__nested_webpack_require_254132__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_254132__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_254132__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"s\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor, isEnable) {\n  editor.toggleSyncScroll(isEnable);\n});\n\n/***/ }),\n/* 58 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_254691__) {\n\n\"use strict\";\n__nested_webpack_require_254691__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_254691__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_254691__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"t\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function () {\n    var content = '|column1|column2|column3|\\n|-|-|-|\\n|content1|content2|content3|';\n    return {\n      text: content,\n      selected: 'column1'\n    };\n  });\n});\n\n/***/ }),\n/* 59 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_255392__) {\n\n\"use strict\";\n__nested_webpack_require_255392__.r(__webpack_exports__);\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_255392__(2);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_255392__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_255392__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_1__[\"u\"]; });\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.insert(function (selected) {\n    var placeholder = editor.langConfig.ul.placeholder;\n\n    var selectedGetter = function selectedGetter(selected) {\n      return selected || placeholder;\n    };\n\n    var _generatorText = Object(_utils_util__WEBPACK_IMPORTED_MODULE_0__[/* generatorText */ \"b\"])({\n      selected: selected,\n      InsertGetter: function InsertGetter(selected) {\n        return \"- \" + selectedGetter(selected);\n      },\n      selectedGetter: selectedGetter,\n      ignoreEmptyLine: false\n    }),\n        insertContent = _generatorText.insertContent,\n        newSelected = _generatorText.newSelected;\n\n    return {\n      text: insertContent,\n      selected: newSelected\n    };\n  });\n});\n\n/***/ }),\n/* 60 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_256698__) {\n\n\"use strict\";\n__nested_webpack_require_256698__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_256698__(1);\n/* harmony reexport (safe) */ __nested_webpack_require_256698__.d(__webpack_exports__, \"name\", function() { return _utils_constants_command_js__WEBPACK_IMPORTED_MODULE_0__[\"v\"]; });\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (editor) {\n  editor.undo();\n});\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __nested_webpack_require_257215__) {\n\nvar map = {\n\t\"./bold.js\": 62,\n\t\"./clear.js\": 63,\n\t\"./code.js\": 64,\n\t\"./fullscreen.js\": 65,\n\t\"./h.js\": 66,\n\t\"./hr.js\": 67,\n\t\"./image.js\": 23,\n\t\"./italic.js\": 68,\n\t\"./link.js\": 69,\n\t\"./ol.js\": 70,\n\t\"./preview.js\": 71,\n\t\"./quote.js\": 72,\n\t\"./redo.js\": 73,\n\t\"./save.js\": 74,\n\t\"./strikethrough.js\": 75,\n\t\"./sync-scroll.js\": 76,\n\t\"./table.js\": 77,\n\t\"./toc.js\": 78,\n\t\"./ul.js\": 79,\n\t\"./undo.js\": 80\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __nested_webpack_require_257215__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__nested_webpack_require_257215__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 61;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_258193__) {\n\n\"use strict\";\n__nested_webpack_require_258193__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_258193__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* bold */ \"a\"],\n  icon: 'v-md-icon-bold',\n  title: function title(editor) {\n    return editor.langConfig.bold.toolbar + \"\\uFF08Ctrl+B\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* bold */ \"a\"]);\n  }\n});\n\n/***/ }),\n/* 63 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_258860__) {\n\n\"use strict\";\n__nested_webpack_require_258860__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_258860__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* clear */ \"b\"],\n  icon: 'v-md-icon-clear',\n  title: function title(editor) {\n    return editor.langConfig.clear.toolbar;\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* clear */ \"b\"]);\n  }\n});\n\n/***/ }),\n/* 64 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_259508__) {\n\n\"use strict\";\n__nested_webpack_require_259508__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_259508__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* code */ \"c\"],\n  icon: 'v-md-icon-code',\n  title: function title(editor) {\n    return editor.langConfig.code.toolbar;\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* code */ \"c\"]);\n  }\n});\n\n/***/ }),\n/* 65 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_260152__) {\n\n\"use strict\";\n__nested_webpack_require_260152__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_260152__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* fullscreen */ \"d\"],\n  icon: 'v-md-icon-fullscreen',\n  title: function title(editor) {\n    var fullscreenLang = editor.langConfig.fullscreen;\n    return editor.fullscreen ? fullscreenLang.disabled : fullscreenLang.enabled;\n  },\n  active: function active(editor) {\n    return editor.fullscreen;\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* fullscreen */ \"d\"], !editor.fullscreen);\n  }\n});\n\n/***/ }),\n/* 66 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_260998__) {\n\n\"use strict\";\n__nested_webpack_require_260998__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_260998__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'h',\n  text: 'H',\n  title: function title(editor) {\n    return editor.langConfig.h.toolbar + \"\\uFF08Ctrl+1~6\\uFF09\";\n  },\n  menus: [{\n    name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h1 */ \"e\"],\n    text: function text(editor) {\n      return editor.langConfig.h1.toolbar;\n    },\n    action: function action(editor) {\n      editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h1 */ \"e\"]);\n    }\n  }, {\n    name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h2 */ \"f\"],\n    text: function text(editor) {\n      return editor.langConfig.h2.toolbar;\n    },\n    action: function action(editor) {\n      editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h2 */ \"f\"]);\n    }\n  }, {\n    name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h3 */ \"g\"],\n    text: function text(editor) {\n      return editor.langConfig.h3.toolbar;\n    },\n    action: function action(editor) {\n      editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h3 */ \"g\"]);\n    }\n  }, {\n    name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h4 */ \"h\"],\n    text: function text(editor) {\n      return editor.langConfig.h4.toolbar;\n    },\n    action: function action(editor) {\n      editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h4 */ \"h\"]);\n    }\n  }, {\n    name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h5 */ \"i\"],\n    text: function text(editor) {\n      return editor.langConfig.h5.toolbar;\n    },\n    action: function action(editor) {\n      editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h5 */ \"i\"]);\n    }\n  }, {\n    name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h6 */ \"j\"],\n    text: function text(editor) {\n      return editor.langConfig.h6.toolbar;\n    },\n    action: function action(editor) {\n      editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h6 */ \"j\"]);\n    }\n  }]\n});\n\n/***/ }),\n/* 67 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_263314__) {\n\n\"use strict\";\n__nested_webpack_require_263314__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_263314__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* hr */ \"k\"],\n  icon: 'v-md-icon-horizontal',\n  title: function title(editor) {\n    return editor.langConfig.hr.toolbar;\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* hr */ \"k\"]);\n  }\n});\n\n/***/ }),\n/* 68 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_263958__) {\n\n\"use strict\";\n__nested_webpack_require_263958__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_263958__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* italic */ \"m\"],\n  icon: 'v-md-icon-italic',\n  title: function title(editor) {\n    return editor.langConfig.italic.toolbar + \"\\uFF08Ctrl+I\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* italic */ \"m\"]);\n  }\n});\n\n/***/ }),\n/* 69 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_264633__) {\n\n\"use strict\";\n__nested_webpack_require_264633__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_264633__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* link */ \"n\"],\n  icon: 'v-md-icon-link',\n  title: function title(editor) {\n    return editor.langConfig.link.toolbar + \"\\uFF08Ctrl+L\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* link */ \"n\"]);\n  }\n});\n\n/***/ }),\n/* 70 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_265300__) {\n\n\"use strict\";\n__nested_webpack_require_265300__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_265300__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* ol */ \"o\"],\n  icon: 'v-md-icon-ol',\n  title: function title(editor) {\n    return editor.langConfig.ol.toolbar + \"\\uFF08Ctrl+O\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* ol */ \"o\"]);\n  }\n});\n\n/***/ }),\n/* 71 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_265959__) {\n\n\"use strict\";\n__nested_webpack_require_265959__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_editor_mode__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_265959__(4);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'preview',\n  icon: 'v-md-icon-preview',\n  title: function title(editor) {\n    var previewLang = editor.langConfig.preview;\n    return editor.currentMode === _utils_constants_editor_mode__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].EDITABLE ? previewLang.disabled : previewLang.enabled;\n  },\n  active: function active(editor) {\n    return editor.currentMode === _utils_constants_editor_mode__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].EDITABLE;\n  },\n  action: function action(editor) {\n    editor.currentMode = editor.currentMode === _utils_constants_editor_mode__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].EDITABLE ? _utils_constants_editor_mode__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].EDIT : _utils_constants_editor_mode__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].EDITABLE;\n  }\n});\n\n/***/ }),\n/* 72 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_267096__) {\n\n\"use strict\";\n__nested_webpack_require_267096__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_267096__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* quote */ \"p\"],\n  icon: 'v-md-icon-quote',\n  title: function title(editor) {\n    return editor.langConfig.quote.toolbar + \"\\uFF08Ctrl+Q\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* quote */ \"p\"]);\n  }\n});\n\n/***/ }),\n/* 73 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_267767__) {\n\n\"use strict\";\n__nested_webpack_require_267767__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_267767__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* redo */ \"q\"],\n  icon: 'v-md-icon-redo',\n  title: function title(editor) {\n    return editor.langConfig.redo.toolbar + \"\\uFF08Ctrl+Y\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* redo */ \"q\"]);\n  }\n});\n\n/***/ }),\n/* 74 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_268434__) {\n\n\"use strict\";\n__nested_webpack_require_268434__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'save',\n  icon: 'v-md-icon-save',\n  title: function title(editor) {\n    return editor.langConfig.save.toolbar + \"\\uFF08Ctrl+S\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.save();\n  }\n});\n\n/***/ }),\n/* 75 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_268856__) {\n\n\"use strict\";\n__nested_webpack_require_268856__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_268856__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* strikethrough */ \"r\"],\n  icon: 'v-md-icon-strikethrough',\n  title: function title(editor) {\n    return editor.langConfig.strikethrough.toolbar;\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* strikethrough */ \"r\"]);\n  }\n});\n\n/***/ }),\n/* 76 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_269536__) {\n\n\"use strict\";\n__nested_webpack_require_269536__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_269536__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* syncScroll */ \"s\"],\n  icon: 'v-md-icon-sync',\n  title: function title(editor) {\n    var syncScrollLang = editor.langConfig.syncScroll;\n    return editor.enableSyncScroll ? syncScrollLang.disabled : syncScrollLang.enabled;\n  },\n  active: function active(editor) {\n    return editor.enableSyncScroll;\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* syncScroll */ \"s\"], !editor.enableSyncScroll);\n  }\n});\n\n/***/ }),\n/* 77 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_270394__) {\n\n\"use strict\";\n__nested_webpack_require_270394__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_270394__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* table */ \"t\"],\n  icon: 'v-md-icon-table',\n  title: function title(editor) {\n    return editor.langConfig.table.toolbar;\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* table */ \"t\"]);\n  }\n});\n\n/***/ }),\n/* 78 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_271042__) {\n\n\"use strict\";\n__nested_webpack_require_271042__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'toc',\n  icon: 'v-md-icon-toc',\n  title: function title(editor) {\n    var tocLang = editor.langConfig.toc;\n    return editor.tocVisible ? tocLang.disabled : tocLang.enabled;\n  },\n  active: function active(editor) {\n    return editor.tocVisible;\n  },\n  action: function action(editor) {\n    editor.toggleToc();\n  }\n});\n\n/***/ }),\n/* 79 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_271580__) {\n\n\"use strict\";\n__nested_webpack_require_271580__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_271580__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* ul */ \"u\"],\n  icon: 'v-md-icon-ul',\n  title: function title(editor) {\n    return editor.langConfig.ul.toolbar + \"\\uFF08Ctrl+U\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* ul */ \"u\"]);\n  }\n});\n\n/***/ }),\n/* 80 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_272239__) {\n\n\"use strict\";\n__nested_webpack_require_272239__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_272239__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* undo */ \"v\"],\n  icon: 'v-md-icon-undo',\n  title: function title(editor) {\n    return editor.langConfig.undo.toolbar + \"\\uFF08Ctrl+Z\\uFF09\";\n  },\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* undo */ \"v\"]);\n  }\n});\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 82 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_273023__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_tooltip_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_273023__(27);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_tooltip_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_273023__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_tooltip_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n/***/ }),\n/* 83 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_274288__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_menu_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_274288__(28);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_menu_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_274288__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_menu_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_275544__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_index_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_275544__(29);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_index_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_275544__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_index_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_276803__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_toolbar_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_276803__(30);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_toolbar_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_276803__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_toolbar_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_278597__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_container_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_278597__(31);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_container_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_278597__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_container_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_279868__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_index_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_279868__(32);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_index_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_279868__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_index_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_281127__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_toc_nav_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_281127__(33);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_toc_nav_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_281127__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_toc_nav_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __nested_webpack_require_282380__) {\n\nvar map = {\n\t\"./bold.js\": 91,\n\t\"./h1.js\": 92,\n\t\"./h2.js\": 93,\n\t\"./h3.js\": 94,\n\t\"./h4.js\": 95,\n\t\"./h5.js\": 96,\n\t\"./h6.js\": 97,\n\t\"./italic.js\": 98,\n\t\"./link.js\": 99,\n\t\"./ol.js\": 100,\n\t\"./quote.js\": 101,\n\t\"./save.js\": 102,\n\t\"./ul.js\": 103\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __nested_webpack_require_282380__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__nested_webpack_require_282380__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 90;\n\n/***/ }),\n/* 91 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_283202__) {\n\n\"use strict\";\n__nested_webpack_require_283202__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_283202__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: 'b',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* bold */ \"a\"]);\n  }\n});\n\n/***/ }),\n/* 92 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_283691__) {\n\n\"use strict\";\n__nested_webpack_require_283691__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_283691__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: '1',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h1 */ \"e\"]);\n  }\n});\n\n/***/ }),\n/* 93 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_284178__) {\n\n\"use strict\";\n__nested_webpack_require_284178__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_284178__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: '2',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h2 */ \"f\"]);\n  }\n});\n\n/***/ }),\n/* 94 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_284665__) {\n\n\"use strict\";\n__nested_webpack_require_284665__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_284665__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: '3',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h3 */ \"g\"]);\n  }\n});\n\n/***/ }),\n/* 95 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_285152__) {\n\n\"use strict\";\n__nested_webpack_require_285152__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_285152__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: '4',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h4 */ \"h\"]);\n  }\n});\n\n/***/ }),\n/* 96 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_285639__) {\n\n\"use strict\";\n__nested_webpack_require_285639__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_285639__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: '5',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h5 */ \"i\"]);\n  }\n});\n\n/***/ }),\n/* 97 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_286126__) {\n\n\"use strict\";\n__nested_webpack_require_286126__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_286126__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: '6',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* h6 */ \"j\"]);\n  }\n});\n\n/***/ }),\n/* 98 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_286613__) {\n\n\"use strict\";\n__nested_webpack_require_286613__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_286613__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: 'i',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* italic */ \"m\"]);\n  }\n});\n\n/***/ }),\n/* 99 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_287104__) {\n\n\"use strict\";\n__nested_webpack_require_287104__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_287104__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: 'l',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* link */ \"n\"]);\n  }\n});\n\n/***/ }),\n/* 100 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_287594__) {\n\n\"use strict\";\n__nested_webpack_require_287594__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_287594__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: 'o',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* ol */ \"o\"]);\n  }\n});\n\n/***/ }),\n/* 101 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_288082__) {\n\n\"use strict\";\n__nested_webpack_require_288082__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_288082__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: 'q',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* quote */ \"p\"]);\n  }\n});\n\n/***/ }),\n/* 102 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_288573__) {\n\n\"use strict\";\n__nested_webpack_require_288573__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: 's',\n  action: function action(editor) {\n    editor.save();\n  }\n});\n\n/***/ }),\n/* 103 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_288881__) {\n\n\"use strict\";\n__nested_webpack_require_288881__.r(__webpack_exports__);\n/* harmony import */ var _utils_constants_command__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_288881__(1);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  modifier: 'ctrl',\n  key: 'u',\n  action: function action(editor) {\n    editor.execCommand(_utils_constants_command__WEBPACK_IMPORTED_MODULE_0__[/* ul */ \"u\"]);\n  }\n});\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n/* 105 */,\n/* 106 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_289498__) {\n\n\"use strict\";\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_textarea_editor_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_289498__(104);\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_textarea_editor_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_289498__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_dist_cjs_js_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_src_index_js_node_modules_sass_loader_dist_cjs_js_node_modules_vue_loader_dist_index_js_ref_2_0_textarea_editor_vue_vue_type_style_index_0_lang_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n\n\n/***/ }),\n/* 107 */,\n/* 108 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_290800__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__nested_webpack_require_290800__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external {\"root\":\"Vue\",\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"amd\":\"vue\"}\nvar external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_ = __nested_webpack_require_290800__(0);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/base-editor.vue?vue&type=template&id=a6ac1c84&bindings={}\n\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_toc_nav = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"toc-nav\");\n\n  var _component_scrollbar = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"scrollbar\");\n\n  var _component_v_md_textarea_editor = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"v-md-textarea-editor\");\n\n  var _component_v_md_preview = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"v-md-preview\");\n\n  var _component_v_md_upload_file = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"v-md-upload-file\");\n\n  var _component_v_md_container = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"resolveComponent\"])(\"v-md-container\");\n\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(_component_v_md_container, {\n    \"left-toolbar\": _ctx.leftToolbar,\n    \"right-toolbar\": _ctx.rightToolbar,\n    toolbars: _ctx.toolbars,\n    \"disabled-menus\": _ctx.disabledMenus,\n    height: _ctx.height,\n    fullscreen: _ctx.fullscreen,\n    \"left-area-visible\": _ctx.tocVisible,\n    \"left-area-title\": _ctx.langConfig.toc.title,\n    \"left-area-reverse\": _ctx.tocNavPositionRight,\n    mode: _ctx.currentMode,\n    onEditorWrapperClick: _ctx.handleEditorWrapperClick,\n    onToolbarItemClick: _ctx.handleToolbarItemClick,\n    onToolbarMenuClick: _ctx.handleToolbarMenuClick,\n    ref: \"contaner\"\n  }, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createSlots\"])({\n    \"left-area\": Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n      return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_scrollbar, null, {\n        default: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n          return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_toc_nav, {\n            titles: _ctx.titles,\n            onNavClick: _ctx.handleNavClick\n          }, null, 8\n          /* PROPS */\n          , [\"titles\", \"onNavClick\"])];\n        }),\n        _: 1\n      })];\n    }),\n    editor: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n      return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_scrollbar, {\n        onScroll: _ctx.handleEditorScroll,\n        ref: \"editorScroller\"\n      }, {\n        default: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n          return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_v_md_textarea_editor, {\n            \"model-value\": _ctx.text,\n            \"min-height\": _ctx.textEditorMinHeight,\n            placeholder: _ctx.placeholder,\n            \"onUpdate:modelValue\": _ctx.handleInput,\n            onClick: _cache[1] || (_cache[1] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {}, [\"stop\"])),\n            onDrop: _ctx.handleDrop,\n            onPaste: _ctx.handlePaste,\n            onBlur: _ctx.handleBlur,\n            ref: \"editorEgine\"\n          }, null, 8\n          /* PROPS */\n          , [\"model-value\", \"min-height\", \"placeholder\", \"onUpdate:modelValue\", \"onDrop\", \"onPaste\", \"onBlur\"])];\n        }),\n        _: 1\n      }, 8\n      /* PROPS */\n      , [\"onScroll\"])];\n    }),\n    preview: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n      return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_scrollbar, {\n        ref: \"previewScroller\"\n      }, {\n        default: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n          return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(_component_v_md_preview, {\n            text: _ctx.text,\n            \"tab-size\": _ctx.tabSize,\n            \"scroll-container\": _ctx.getPreviewScrollContainer,\n            \"before-change\": _ctx.beforePreviewChange,\n            onChange: _ctx.handleChange,\n            onImageClick: _ctx.handlePreviewImageClick,\n            ref: \"preview\"\n          }, null, 8\n          /* PROPS */\n          , [\"text\", \"tab-size\", \"scroll-container\", \"before-change\", \"onChange\", \"onImageClick\"])];\n        }),\n        _: 1\n      }, 512\n      /* NEED_PATCH */\n      )];\n    }),\n    default: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function () {\n      return [_ctx.hasUploadImage ? (Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(_component_v_md_upload_file, {\n        key: 0,\n        \"upload-config\": _ctx.uploadConfig,\n        ref: \"uploadFile\"\n      }, null, 8\n      /* PROPS */\n      , [\"upload-config\"])) : Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createCommentVNode\"])(\"v-if\", true)];\n    }),\n    _: 2\n  }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderList\"])(_ctx.proxySlots, function (slotName) {\n    return {\n      name: slotName,\n      fn: Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withCtx\"])(function (scope) {\n        return [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderSlot\"])(_ctx.$slots, slotName, scope)];\n      })\n    };\n  })]), 1032\n  /* PROPS, DYNAMIC_SLOTS */\n  , [\"left-toolbar\", \"right-toolbar\", \"toolbars\", \"disabled-menus\", \"height\", \"fullscreen\", \"left-area-visible\", \"left-area-title\", \"left-area-reverse\", \"mode\", \"onEditorWrapperClick\", \"onToolbarItemClick\", \"onToolbarMenuClick\"]);\n}\n// CONCATENATED MODULE: ./src/base-editor.vue?vue&type=template&id=a6ac1c84&bindings={}\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __nested_webpack_require_290800__(10);\nvar regenerator_default = /*#__PURE__*/__nested_webpack_require_290800__.n(regenerator);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nvar asyncToGenerator = __nested_webpack_require_290800__(17);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist/templateLoader.js??ref--6!./node_modules/vue-loader/dist??ref--2-0!./src/components/textarea-editor.vue?vue&type=template&id=31fed1ea&bindings={\"modelValue\":\"props\",\"minHeight\":\"props\",\"placeholder\":\"props\",\"historyDebounce\":\"props\",\"historyMax\":\"props\",\"isComposing\":\"data\",\"textareaEl\":\"options\",\"handleCompositionStart\":\"options\",\"handleCompositionUpdate\":\"options\",\"handleCompositionEnd\":\"options\",\"handlePaste\":\"options\",\"handleBlur\":\"options\",\"registerHotkeys\":\"options\",\"handleKeydown\":\"options\",\"heightAtLine\":\"options\",\"clearTimeout\":\"options\",\"updateCurrentHistoryRange\":\"options\",\"handleInput\":\"options\",\"saveHistory\":\"options\",\"updateHistory\":\"options\",\"goHistory\":\"options\",\"getRange\":\"options\",\"setRange\":\"options\",\"focus\":\"options\",\"insertText\":\"options\",\"undo\":\"options\",\"redo\":\"options\"}\n\nvar _hoisted_1 = {\n  class: \"v-md-textarea-editor\"\n};\n\nvar _hoisted_2 = /*#__PURE__*/Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"br\", null, null, -1\n/* HOISTED */\n);\n\nfunction textarea_editorvue_type_template_id_31fed1ea_bindings_modelValue_props_minHeight_props_placeholder_props_historyDebounce_props_historyMax_props_isComposing_data_textareaEl_options_handleCompositionStart_options_handleCompositionUpdate_options_handleCompositionEnd_options_handlePaste_options_handleBlur_options_registerHotkeys_options_handleKeydown_options_heightAtLine_options_clearTimeout_options_updateCurrentHistoryRange_options_handleInput_options_saveHistory_options_updateHistory_options_goHistory_options_getRange_options_setRange_options_focus_options_insertText_options_undo_options_redo_options_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"div\", _hoisted_1, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"pre\", {\n    style: {\n      minHeight: $props.minHeight\n    }\n  }, [(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(true), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"Fragment\"], null, Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"renderList\"])($props.modelValue.split('\\n'), function (row, idx) {\n    return Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"openBlock\"])(), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createBlock\"])(\"section\", {\n      \"data-line\": idx + 1\n    }, [Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createTextVNode\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"toDisplayString\"])(row || ' '), 1\n    /* TEXT */\n    ), _hoisted_2], 8\n    /* PROPS */\n    , [\"data-line\"]);\n  }), 256\n  /* UNKEYED_FRAGMENT */\n  ))], 4\n  /* STYLE */\n  ), Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"createVNode\"])(\"textarea\", {\n    ref: \"textarea\",\n    value: $props.modelValue,\n    placeholder: $props.placeholder,\n    spellcheck: \"false\",\n    onCompositionstart: _cache[1] || (_cache[1] = function () {\n      return $options.handleCompositionStart.apply($options, arguments);\n    }),\n    onCompositionupdate: _cache[2] || (_cache[2] = function () {\n      return $options.handleCompositionUpdate.apply($options, arguments);\n    }),\n    onCompositionend: _cache[3] || (_cache[3] = function () {\n      return $options.handleCompositionEnd.apply($options, arguments);\n    }),\n    onInput: _cache[4] || (_cache[4] = function () {\n      return $options.handleInput.apply($options, arguments);\n    }),\n    onClick: _cache[5] || (_cache[5] = function () {\n      return $options.updateCurrentHistoryRange.apply($options, arguments);\n    }),\n    onPaste: _cache[6] || (_cache[6] = function () {\n      return $options.handlePaste.apply($options, arguments);\n    }),\n    onBlur: _cache[7] || (_cache[7] = function () {\n      return $options.handleBlur.apply($options, arguments);\n    }),\n    onKeydown: [_cache[8] || (_cache[8] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {}, [\"prevent\"]), [\"tab\"])), _cache[9] || (_cache[9] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.undo.apply($options, arguments);\n    }, [\"ctrl\", \"prevent\", \"exact\"]), [\"z\"])), _cache[10] || (_cache[10] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.undo.apply($options, arguments);\n    }, [\"meta\", \"prevent\", \"exact\"]), [\"z\"])), _cache[11] || (_cache[11] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.redo.apply($options, arguments);\n    }, [\"ctrl\", \"prevent\", \"exact\"]), [\"y\"])), _cache[12] || (_cache[12] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.redo.apply($options, arguments);\n    }, [\"meta\", \"prevent\", \"exact\"]), [\"y\"]))],\n    onKeyup: [_cache[13] || (_cache[13] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.updateCurrentHistoryRange.apply($options, arguments);\n    }, [\"shift\", \"exact\"]), [\"up\"])), _cache[14] || (_cache[14] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.updateCurrentHistoryRange.apply($options, arguments);\n    }, [\"shift\", \"exact\"]), [\"down\"])), _cache[15] || (_cache[15] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.updateCurrentHistoryRange.apply($options, arguments);\n    }, [\"shift\", \"exact\"]), [\"left\"])), _cache[16] || (_cache[16] = Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withKeys\"])(Object(external_root_Vue_commonjs_vue_commonjs2_vue_amd_vue_[\"withModifiers\"])(function () {\n      return $options.updateCurrentHistoryRange.apply($options, arguments);\n    }, [\"shift\", \"exact\"]), [\"right\"]))]\n  }, null, 40\n  /* PROPS, HYDRATE_EVENTS */\n  , [\"value\", \"placeholder\"])]);\n}\n// CONCATENATED MODULE: ./src/components/textarea-editor.vue?vue&type=template&id=31fed1ea&bindings={\"modelValue\":\"props\",\"minHeight\":\"props\",\"placeholder\":\"props\",\"historyDebounce\":\"props\",\"historyMax\":\"props\",\"isComposing\":\"data\",\"textareaEl\":\"options\",\"handleCompositionStart\":\"options\",\"handleCompositionUpdate\":\"options\",\"handleCompositionEnd\":\"options\",\"handlePaste\":\"options\",\"handleBlur\":\"options\",\"registerHotkeys\":\"options\",\"handleKeydown\":\"options\",\"heightAtLine\":\"options\",\"clearTimeout\":\"options\",\"updateCurrentHistoryRange\":\"options\",\"handleInput\":\"options\",\"saveHistory\":\"options\",\"updateHistory\":\"options\",\"goHistory\":\"options\",\"getRange\":\"options\",\"setRange\":\"options\",\"focus\":\"options\",\"insertText\":\"options\",\"undo\":\"options\",\"redo\":\"options\"}\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nvar esm_extends = __nested_webpack_require_290800__(6);\n\n// CONCATENATED MODULE: ./node_modules/insert-text-at-cursor/dist/index.esm.js\nvar browserSupportsTextareaTextNodes;\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\n\nfunction canManipulateViaTextNodes(input) {\n  if (input.nodeName !== \"TEXTAREA\") {\n    return false;\n  }\n\n  if (typeof browserSupportsTextareaTextNodes === \"undefined\") {\n    var textarea = document.createElement(\"textarea\");\n    textarea.value = 1;\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n\n  return browserSupportsTextareaTextNodes;\n}\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\n\n\nfunction index_esm_index (input, text) {\n  // Most of the used APIs only work with the field selected\n  input.focus(); // IE 8-10\n\n  if (document.selection) {\n    var ieRange = document.selection.createRange();\n    ieRange.text = text; // Move cursor after the inserted text\n\n    ieRange.collapse(false\n    /* to the end */\n    );\n    ieRange.select();\n    return;\n  } // Webkit + Edge\n\n\n  var isSuccess = document.execCommand(\"insertText\", false, text);\n\n  if (!isSuccess) {\n    var start = input.selectionStart;\n    var end = input.selectionEnd; // Firefox (non-standard method)\n\n    if (typeof input.setRangeText === \"function\") {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      var range = document.createRange();\n      var textNode = document.createTextNode(text);\n\n      if (canManipulateViaTextNodes(input)) {\n        var node = input.firstChild; // If textarea is empty, just insert the text\n\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          var offset = 0;\n          var startNode = null;\n          var endNode = null;\n\n          while (node && (startNode === null || endNode === null)) {\n            var nodeLength = node.nodeValue.length; // if start of the selection falls into current node\n\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart(startNode = node, start - offset);\n            } // if end of the selection falls into current node\n\n\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd(endNode = node, end - offset);\n            }\n\n            offset += nodeLength;\n            node = node.nextSibling;\n          } // If there is some text selected, remove it as we should replace it\n\n\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      } // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n\n\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === \"#text\") {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        var value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    } // Correct the cursor position to be at the end of the insertion\n\n\n    input.setSelectionRange(start + text.length, start + text.length); // Notify any possible listeners of the change\n\n    var e = document.createEvent(\"UIEvent\");\n    e.initEvent(\"input\", true, false);\n    input.dispatchEvent(e);\n  }\n}\n\n/* harmony default export */ var index_esm = (index_esm_index);\n//# sourceMappingURL=index.esm.js.map\n\n// EXTERNAL MODULE: ./src/utils/hotkeys.js + 1 modules\nvar hotkeys = __nested_webpack_require_290800__(36);\n\n// EXTERNAL MODULE: ./src/utils/util.js\nvar util = __nested_webpack_require_290800__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/components/textarea-editor.vue?vue&type=script&lang=js\n\n\n\n\n/* harmony default export */ var textarea_editorvue_type_script_lang_js = ({\n  name: 'v-md-textarea-editor',\n  props: {\n    modelValue: String,\n    minHeight: String,\n    placeholder: String,\n    historyDebounce: {\n      type: Number,\n      default: 400\n    },\n    historyMax: {\n      type: Number,\n      default: 30\n    }\n  },\n  emits: ['blur', 'paste', 'update:modelValue'],\n  data: function data() {\n    return {\n      isComposing: false\n    };\n  },\n  computed: {\n    textareaEl: function textareaEl() {\n      return this.$refs.textarea;\n    }\n  },\n  watch: {\n    modelValue: function modelValue() {\n      var _this = this;\n\n      this.clearTimeout();\n\n      if (!this.triggerInputBySetHistory) {\n        this.timmer = setTimeout(function () {\n          _this.saveHistory();\n\n          _this.clearTimeout();\n        }, this.historyDebounce);\n      }\n    }\n  },\n  created: function created() {\n    this.historyStack = [];\n    this.historyIndex = 0;\n    this.hotkeysManager = new hotkeys[\"a\" /* default */]();\n  },\n  mounted: function mounted() {\n    this.saveHistory();\n    this.textareaEl.addEventListener('keydown', this.handleKeydown, false);\n  },\n  beforeUnmount: function beforeUnmount() {\n    this.textareaEl.removeEventListener('keydown', this.handleKeydown, false);\n  },\n  methods: {\n    handleCompositionStart: function handleCompositionStart() {\n      this.isComposing = true;\n    },\n    handleCompositionUpdate: function handleCompositionUpdate(event) {\n      var text = event.target.value;\n      var lastCharacter = text[text.length - 1] || '';\n      this.isComposing = !Object(util[\"e\" /* isKorean */])(lastCharacter);\n    },\n    handleCompositionEnd: function handleCompositionEnd(event) {\n      if (this.isComposing) {\n        this.isComposing = false;\n        this.handleInput(event);\n      }\n    },\n    handlePaste: function handlePaste(e) {\n      this.$emit('paste', e);\n    },\n    handleBlur: function handleBlur(e) {\n      this.$emit('blur', e);\n    },\n    registerHotkeys: function registerHotkeys() {\n      var _this$hotkeysManager;\n\n      (_this$hotkeysManager = this.hotkeysManager).registerHotkeys.apply(_this$hotkeysManager, arguments);\n    },\n    handleKeydown: function handleKeydown(e) {\n      this.hotkeysManager.dispatch(e);\n    },\n    heightAtLine: function heightAtLine(lineIndex) {\n      var el = this.$el.querySelector(\"section[data-line=\\\"\" + lineIndex + \"\\\"]\");\n      return el ? el.offsetTop + el.offsetHeight : 0;\n    },\n    clearTimeout: function (_clearTimeout) {\n      function clearTimeout() {\n        return _clearTimeout.apply(this, arguments);\n      }\n\n      clearTimeout.toString = function () {\n        return _clearTimeout.toString();\n      };\n\n      return clearTimeout;\n    }(function () {\n      if (this.timmer) clearTimeout(this.timmer);\n      this.timmer = null;\n    }),\n    updateCurrentHistoryRange: function updateCurrentHistoryRange() {\n      if (!this.timmer) {\n        this.updateHistory(this.historyIndex, {\n          range: this.getRange()\n        });\n      }\n    },\n    handleInput: function handleInput(e) {\n      if (this.isComposing) return;\n      this.$emit('update:modelValue', e.target.value);\n    },\n    saveHistory: function saveHistory() {\n      var range = this.getRange();\n      var history = {\n        value: this.modelValue,\n        range: range\n      };\n      this.historyStack = this.historyStack.slice(0, this.historyIndex + 1);\n      this.historyStack.push(history);\n      if (this.historyStack.length > this.historyMax) this.historyStack.shift();\n      this.historyIndex = this.historyStack.length - 1;\n    },\n    updateHistory: function updateHistory(index, data) {\n      var history = this.historyStack[index];\n      if ('value' in data) history.value = data.value;\n\n      Object(esm_extends[\"a\" /* default */])(history.range, data.range);\n    },\n    goHistory: function goHistory(index) {\n      var _this2 = this;\n\n      var _this$historyStack$in = this.historyStack[index],\n          value = _this$historyStack$in.value,\n          range = _this$historyStack$in.range;\n      this.$emit('update:modelValue', value);\n      this.triggerInputBySetHistory = true;\n      this.$nextTick(function () {\n        _this2.triggerInputBySetHistory = false;\n\n        _this2.setRange(range);\n      });\n    },\n    getRange: function getRange() {\n      return {\n        start: this.textareaEl.selectionStart,\n        end: this.textareaEl.selectionEnd\n      };\n    },\n    setRange: function setRange(_ref) {\n      var start = _ref.start,\n          end = _ref.end;\n      this.textareaEl.setSelectionRange(start, end);\n      this.updateCurrentHistoryRange();\n    },\n    focus: function focus() {\n      this.textareaEl.focus();\n    },\n    insertText: function insertText(text) {\n      index_esm(this.textareaEl, text);\n    },\n    undo: function undo() {\n      if (this.historyIndex > 0) {\n        this.historyIndex--;\n        this.goHistory(this.historyIndex);\n      }\n    },\n    redo: function redo() {\n      if (this.historyIndex < this.historyStack.length - 1) {\n        this.historyIndex++;\n        this.goHistory(this.historyIndex);\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/textarea-editor.vue?vue&type=script&lang=js\n \n// EXTERNAL MODULE: ./src/components/textarea-editor.vue?vue&type=style&index=0&lang=scss\nvar textarea_editorvue_type_style_index_0_lang_scss = __nested_webpack_require_290800__(106);\n\n// CONCATENATED MODULE: ./src/components/textarea-editor.vue\n\n\n\n\n\ntextarea_editorvue_type_script_lang_js.render = textarea_editorvue_type_template_id_31fed1ea_bindings_modelValue_props_minHeight_props_placeholder_props_historyDebounce_props_historyMax_props_isComposing_data_textareaEl_options_handleCompositionStart_options_handleCompositionUpdate_options_handleCompositionEnd_options_handlePaste_options_handleBlur_options_registerHotkeys_options_handleKeydown_options_heightAtLine_options_clearTimeout_options_updateCurrentHistoryRange_options_handleInput_options_saveHistory_options_updateHistory_options_goHistory_options_getRange_options_setRange_options_focus_options_insertText_options_undo_options_redo_options_render\n\n/* harmony default export */ var textarea_editor = (textarea_editorvue_type_script_lang_js);\n// EXTERNAL MODULE: ./src/create-editor.js + 60 modules\nvar create_editor = __nested_webpack_require_290800__(35);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3!./node_modules/vue-loader/dist??ref--2-0!./src/base-editor.vue?vue&type=script&lang=js\n\n\n\nvar _components;\n\n\n\n\nvar component = {\n  components: (_components = {}, _components[textarea_editor.name] = textarea_editor, _components),\n  watch: {\n    modelValue: function modelValue() {\n      this.text = this.modelValue;\n    },\n    height: {\n      handler: function handler() {\n        var _this = this;\n\n        return Object(asyncToGenerator[\"a\" /* default */])( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n          var editorWrapper;\n          return regenerator_default.a.wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                if (util[\"d\" /* inBrowser */]) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.next = 4;\n                return _this.$nextTick();\n\n              case 4:\n                if (_this.height) {\n                  editorWrapper = _this.$el.querySelector('.v-md-editor__editor-wrapper');\n                  _this.textEditorMinHeight = window.getComputedStyle(editorWrapper).height;\n                } else {\n                  _this.textEditorMinHeight = '';\n                }\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee);\n        }))();\n      },\n      immediate: true\n    }\n  },\n  data: function data() {\n    return {\n      textEditorMinHeight: ''\n    };\n  },\n  methods: {\n    handleEditorWrapperClick: function handleEditorWrapperClick() {\n      this.setFocusEnd();\n    },\n    // Must implement\n    editorFocusEnd: function editorFocusEnd() {\n      this.focus();\n      this.$refs.editorEgine.setRange({\n        start: this.text.length,\n        end: this.text.length\n      });\n    },\n    // Must implement\n    delLineLeft: function delLineLeft() {\n      var editorEgine = this.$refs.editorEgine;\n\n      var _editorEgine$getRange = editorEgine.getRange(),\n          start = _editorEgine$getRange.start;\n\n      var leftText = this.getCursorLineLeftText();\n      editorEgine.setRange({\n        start: start - leftText.length - 1,\n        end: start\n      });\n      this.replaceSelectionText('\\n');\n    },\n    // Must implement\n    getCursorLineLeftText: function getCursorLineLeftText() {\n      var _this$$refs$editorEgi = this.$refs.editorEgine.getRange(),\n          start = _this$$refs$editorEgi.start,\n          end = _this$$refs$editorEgi.end;\n\n      return start === end ? this.text.slice(0, start).split('\\n').pop() : null;\n    },\n    // Must implement\n    editorRegisterHotkeys: function editorRegisterHotkeys() {\n      var _this$$refs$editorEgi2;\n\n      (_this$$refs$editorEgi2 = this.$refs.editorEgine).registerHotkeys.apply(_this$$refs$editorEgi2, arguments);\n    },\n    // Must implement\n    editorScrollToTop: function editorScrollToTop(scrollTop) {\n      this.$refs.editorScroller.scrollTo(scrollTop);\n    },\n    // Must implement\n    getScrollInfo: function getScrollInfo() {\n      return this.$refs.editorScroller.getScrollInfo();\n    },\n    // Must implement\n    heightAtLine: function heightAtLine() {\n      var _this$$refs$editorEgi3;\n\n      return (_this$$refs$editorEgi3 = this.$refs.editorEgine).heightAtLine.apply(_this$$refs$editorEgi3, arguments);\n    },\n    // Must implement\n    focus: function focus() {\n      this.$refs.editorEgine.focus();\n    },\n    // Must implement\n    undo: function undo() {\n      this.$refs.editorEgine.undo();\n    },\n    // Must implement\n    redo: function redo() {\n      this.$refs.editorEgine.redo();\n    },\n    // Must implement\n    clear: function clear() {\n      this.focus();\n      this.handleInput('');\n    },\n    // Must implement\n    replaceSelectionText: function replaceSelectionText(text) {\n      this.$refs.editorEgine.insertText(text);\n    },\n    // Must implement\n    getCurrentSelectedStr: function getCurrentSelectedStr() {\n      var _this$$refs$editorEgi4 = this.$refs.editorEgine.getRange(),\n          start = _this$$refs$editorEgi4.start,\n          end = _this$$refs$editorEgi4.end;\n\n      return end > start ? this.text.slice(start, end) : null;\n    },\n    // Must implement\n    changeSelctionTo: function changeSelctionTo(insertText, selectedText) {\n      var editorEgine = this.$refs.editorEgine;\n      var selectedIndexOfStr = insertText.indexOf(selectedText);\n      var cursorEndIndex = editorEgine.getRange().end;\n      if (selectedIndexOfStr === -1) return;\n      var text = this.text.slice(0, cursorEndIndex);\n      var insertTextIndex = text.length - insertText.length;\n      var rangeStartIndex = insertTextIndex + selectedIndexOfStr;\n      var rangeEndIndex = rangeStartIndex + selectedText.length;\n      this.$refs.editorEgine.setRange({\n        start: rangeStartIndex,\n        end: rangeEndIndex\n      });\n    }\n  }\n};\nObject(create_editor[\"a\" /* default */])(component);\n/* harmony default export */ var base_editorvue_type_script_lang_js = (component);\n// CONCATENATED MODULE: ./src/base-editor.vue?vue&type=script&lang=js\n \n// CONCATENATED MODULE: ./src/base-editor.vue\n\n\n\nbase_editorvue_type_script_lang_js.render = render\n\n/* harmony default export */ var base_editor = (base_editorvue_type_script_lang_js);\n// EXTERNAL MODULE: ./src/utils/xss/index.js + 3 modules\nvar xss = __nested_webpack_require_290800__(7);\n\n// EXTERNAL MODULE: ./src/assets/css/font.css\nvar font = __nested_webpack_require_290800__(18);\n\n// CONCATENATED MODULE: ./src/base-editor.js\n// This file is auto generated by build/build-entry.js\n\n // font css\n\n\nvar version = '2.3.18';\n\nvar base_editor_install = function install(app) {\n  app.component(base_editor.name, base_editor);\n};\n\nbase_editor.version = version;\nbase_editor.install = base_editor_install;\nbase_editor.xss = xss[\"a\" /* default */];\n\nbase_editor.use = function (optionsOrInstall, opt) {\n  if (typeof optionsOrInstall === 'function') {\n    optionsOrInstall(base_editor, opt);\n  } else {\n    optionsOrInstall.install(base_editor, opt);\n  }\n\n  return base_editor;\n};\n\n/* harmony default export */ var src_base_editor = __webpack_exports__[\"default\"] = (base_editor);\n\n/***/ })\n/******/ ])[\"default\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGthbmdjL3YtbWQtZWRpdG9yL2xpYi9iYXNlLWVkaXRvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsdURBQUs7QUFDeEMsTUFBTSxFQUtxQztBQUMzQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGdDQUFnQyw4QkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBbUI7QUFDOUIsa0RBQWtELGdDQUFnQztBQUNsRiwwRUFBMEUsOEJBQW1CLDRCQUE0QixvQkFBb0I7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFD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QUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGdDQUFtQjs7QUFFN0I7QUFDQSxXQUFXLGdDQUFtQjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxjQUFjLGdDQUFtQjs7QUFFakM7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0NBQW1COztBQUU5QjtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0NBQW9DO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0IsaUNBQW1COztBQUV2Qzs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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QUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsZ0dBQWdHLGFBQWE7QUFDN0c7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQSxrREFBa0QsaUNBQW1CO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7OztBQUtBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxpQ0FBbUI7O0FBRTdCO0FBQ0EsV0FBVyxpQ0FBbUI7O0FBRTlCO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BrYW5nYy92LW1kLWVkaXRvci9saWIvYmFzZS1lZGl0b3IuanM/YmE0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJ2dWVcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJWTWRFZGl0b3JcIiwgW1widnVlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlZNZEVkaXRvclwiXSA9IGZhY3RvcnkocmVxdWlyZShcInZ1ZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiVk1kRWRpdG9yXCJdID0gZmFjdG9yeShyb290W1wiVnVlXCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18wX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwOCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMF9fO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGJvbGQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbGVhcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvZGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmdWxsc2NyZWVuOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaDE7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBoMjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGgzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaDQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBoNTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwialwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGg2OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaHI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbWFnZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGl0YWxpYzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbms7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBvbDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHF1b3RlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJxXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVkbzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHN0cmlrZXRocm91Z2g7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBzeW5jU2Nyb2xsOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGFibGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1bDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHVuZG87IH0pO1xudmFyIGJvbGQgPSAnYm9sZCc7XG52YXIgY2xlYXIgPSAnY2xlYXInO1xudmFyIGNvZGUgPSAnY29kZSc7XG52YXIgZnVsbHNjcmVlbiA9ICdmdWxsc2NyZWVuJztcbnZhciBoMSA9ICdoMSc7XG52YXIgaDIgPSAnaDInO1xudmFyIGgzID0gJ2gzJztcbnZhciBoNCA9ICdoNCc7XG52YXIgaDUgPSAnaDUnO1xudmFyIGg2ID0gJ2g2JztcbnZhciBociA9ICdocic7XG52YXIgaW1hZ2UgPSAnaW1hZ2UnO1xudmFyIGl0YWxpYyA9ICdpdGFsaWMnO1xudmFyIGxpbmsgPSAnbGluayc7XG52YXIgb2wgPSAnb2wnO1xudmFyIHF1b3RlID0gJ3F1b3RlJztcbnZhciByZWRvID0gJ3JlZG8nO1xudmFyIHN0cmlrZXRocm91Z2ggPSAnc3RyaWtldGhyb3VnaCc7XG52YXIgc3luY1Njcm9sbCA9ICdzeW5jLXNjcm9sbCc7XG52YXIgdGFibGUgPSAndGFibGUnO1xudmFyIHVsID0gJ3VsJztcbnZhciB1bmRvID0gJ3VuZG8nO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT2JqZWN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJyYXl0b09iamVjdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGltcG9ydEFsbDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGluQnJvd3NlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzS29yZWFuOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2VuZXJhdG9yVGV4dDsgfSk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodGFyZ2V0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHRhcmdldCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufTtcblxuZnVuY3Rpb24gZXh0ZW5kKHRvLCBfZnJvbSkge1xuICBPYmplY3Qua2V5cyhfZnJvbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH0pO1xuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIGFycmF5dG9PYmplY3QoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGltcG9ydEFsbChtYXAsIHIpIHtcbiAgci5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICBtYXBbZmlsZVBhdGhdID0gcihmaWxlUGF0aCk7XG4gIH0pO1xufVxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gaXNLb3JlYW4odGV4dCkge1xuICB2YXIgcmVnID0gLyhbKFxcdUFDMDAtXFx1RDdBRil8KFxcdTMxMzAtXFx1MzE4RildKSsvZ2k7XG4gIHJldHVybiByZWcudGVzdCh0ZXh0KTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRvclRleHQoX3JlZikge1xuICB2YXIgc2VsZWN0ZWQgPSBfcmVmLnNlbGVjdGVkLFxuICAgICAgSW5zZXJ0R2V0dGVyID0gX3JlZi5JbnNlcnRHZXR0ZXIsXG4gICAgICBfcmVmJHNlbGVjdGVkR2V0dGVyID0gX3JlZi5zZWxlY3RlZEdldHRlcixcbiAgICAgIHNlbGVjdGVkR2V0dGVyID0gX3JlZiRzZWxlY3RlZEdldHRlciA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgcmV0dXJuIHNlbGVjdGVkO1xuICB9IDogX3JlZiRzZWxlY3RlZEdldHRlcixcbiAgICAgIF9yZWYkaWdub3JlRW1wdHlMaW5lID0gX3JlZi5pZ25vcmVFbXB0eUxpbmUsXG4gICAgICBpZ25vcmVFbXB0eUxpbmUgPSBfcmVmJGlnbm9yZUVtcHR5TGluZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkaWdub3JlRW1wdHlMaW5lO1xuICB2YXIgaW5zZXJ0Q29udGVudDtcbiAgdmFyIG5ld1NlbGVjdGVkO1xuXG4gIGlmIChzZWxlY3RlZCkge1xuICAgIG5ld1NlbGVjdGVkID0gc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpO1xuICAgIGluc2VydENvbnRlbnQgPSBJbnNlcnRHZXR0ZXIoc2VsZWN0ZWQsIDEpOyAvLyDlpoLmnpzlvZPliY3pgInkuK3nmoTmlofmnKzljIXlkKvmjaLooYwg5YiZ5o+S5YWl5ZCO6YCJ5Lit5o+S5YWl55qE5omA5pyJ5paH5pysXG5cbiAgICBpZiAoc2VsZWN0ZWQuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICBpbnNlcnRDb250ZW50ID0gc2VsZWN0ZWQuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbiAocm93VGV4dCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlzRW1wdHlMaW5lID0gIXJvd1RleHQ7XG4gICAgICAgIGlmIChpZ25vcmVFbXB0eUxpbmUgJiYgaXNFbXB0eUxpbmUpIHJldHVybiAnJztcbiAgICAgICAgcmV0dXJuIEluc2VydEdldHRlcihyb3dUZXh0LCBpbmRleCArIDEpLnJlcGxhY2Uoc2VsZWN0ZWRHZXR0ZXIobnVsbCksICcnKTtcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgbmV3U2VsZWN0ZWQgPSBpbnNlcnRDb250ZW50O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRDb250ZW50ID0gSW5zZXJ0R2V0dGVyKG51bGwsIDEpO1xuICAgIG5ld1NlbGVjdGVkID0gc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpbnNlcnRDb250ZW50OiBpbnNlcnRDb250ZW50LFxuICAgIG5ld1NlbGVjdGVkOiBuZXdTZWxlY3RlZFxuICB9O1xufVxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIExJTkVfTUFSS1VQOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSEVBRElOR19NQVJLVVA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBBTkNIT1JfTUFSS1VQOyB9KTtcbnZhciBMSU5FX01BUktVUCA9ICdkYXRhLXYtbWQtbGluZSc7XG52YXIgSEVBRElOR19NQVJLVVAgPSAnZGF0YS12LW1kLWhlYWRpbmcnO1xudmFyIEFOQ0hPUl9NQVJLVVAgPSAnZGF0YS12LW1kLWFuY2hvcic7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoe1xuICBQUkVWSUVXOiAncHJldmlldycsXG4gIEVESVRBQkxFOiAnZWRpdGFibGUnLFxuICBFRElUOiAnZWRpdCdcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFNjcm9sbFRvcDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNjcm9sbFRvOyB9KTtcbmZ1bmN0aW9uIGdldFNjcm9sbFRvcCh0YXJnZXQpIHtcbiAgdmFyIHJlc3VsdCA9IDA7XG5cbiAgaWYgKHRhcmdldCA9PT0gd2luZG93KSB7XG4gICAgcmVzdWx0ID0gdGFyZ2V0LnBhZ2VZT2Zmc2V0O1xuICB9IGVsc2UgaWYgKHRhcmdldCkge1xuICAgIHJlc3VsdCA9IHRhcmdldC5zY3JvbGxUb3A7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2Nyb2xsVG8odGFyZ2V0LCBzY3JvbGxUb3ApIHtcbiAgaWYgKHRhcmdldCA9PT0gd2luZG93KSB7XG4gICAgd2luZG93LnNjcm9sbFRvKHdpbmRvdy5wYWdlWU9mZnNldCwgc2Nyb2xsVG9wKTtcbiAgfSBlbHNlIGlmICh0YXJnZXQpIHtcbiAgICB0YXJnZXQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2V4dGVuZHM7IH0pO1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanNcbnZhciBlc21fZXh0ZW5kcyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMveHNzL2xpYi9pbmRleC5qc1xudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIGxpYl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsaWIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy94c3Mvc3ZnLmpzXG52YXIgc3ZnVGFnV2hpdGVMaXN0ID0ge1xuICBzdmc6IFtdLFxuICBhbHRHbHlwaDogW10sXG4gIGFsdEdseXBoRGVmOiBbXSxcbiAgYWx0R2x5cGhJdGVtOiBbXSxcbiAgYW5pbWF0ZTogW10sXG4gIGFuaW1hdGVDb2xvcjogW10sXG4gIGFuaW1hdGVNb3Rpb246IFtdLFxuICBhbmltYXRlVHJhbnNmb3JtOiBbXSxcbiAgY2lyY2xlOiBbXSxcbiAgY2xpcFBhdGg6IFtdLFxuICAnY29sb3ItcHJvZmlsZSc6IFtdLFxuICBjdXJzb3I6IFtdLFxuICAnZGVmaW5pdGlvbi1zcmMnOiBbXSxcbiAgZGVmczogW10sXG4gIGRlc2M6IFtdLFxuICBlbGxpcHNlOiBbXSxcbiAgZmVCbGVuZDogW10sXG4gIGZlQ29sb3JNYXRyaXg6IFtdLFxuICBmZUNvbXBvbmVudFRyYW5zZmVyOiBbXSxcbiAgZmVDb21wb3NpdGU6IFtdLFxuICBmZUNvbnZvbHZlTWF0cml4OiBbXSxcbiAgZmVEaWZmdXNlTGlnaHRpbmc6IFtdLFxuICBmZURpc3BsYWNlbWVudE1hcDogW10sXG4gIGZlRGlzdGFudExpZ2h0OiBbXSxcbiAgZmVGbG9vZDogW10sXG4gIGZlRnVuY0E6IFtdLFxuICBmZUZ1bmNCOiBbXSxcbiAgZmVGdW5jRzogW10sXG4gIGZlRnVuY1I6IFtdLFxuICBmZUdhdXNzaWFuQmx1cjogW10sXG4gIGZlSW1hZ2U6IFtdLFxuICBmZU1lcmdlOiBbXSxcbiAgZmVNZXJnZU5vZGU6IFtdLFxuICBmZU1vcnBob2xvZ3k6IFtdLFxuICBmZU9mZnNldDogW10sXG4gIGZlUG9pbnRMaWdodDogW10sXG4gIGZlU3BlY3VsYXJMaWdodGluZzogW10sXG4gIGZlU3BvdExpZ2h0OiBbXSxcbiAgZmVUaWxlOiBbXSxcbiAgZmVUdXJidWxlbmNlOiBbXSxcbiAgZmlsdGVyOiBbXSxcbiAgZm9udDogW10sXG4gIGZvcmVpZ25PYmplY3Q6IFtdLFxuICBnOiBbXSxcbiAgZ2x5cGg6IFtdLFxuICBnbHlwaFJlZjogW10sXG4gIGhrZXJuOiBbXSxcbiAgaW1hZ2U6IFtdLFxuICBsaW5lOiBbXSxcbiAgbGluZWFyR3JhZGllbnQ6IFtdLFxuICBtYXJrZXI6IFtdLFxuICBtYXNrOiBbXSxcbiAgbWV0YWRhdGE6IFtdLFxuICAnbWlzc2luZy1nbHlwaCc6IFtdLFxuICBtcGF0aDogW10sXG4gIHBhdGg6IFtdLFxuICBwYXR0ZXJuOiBbXSxcbiAgcG9seWdvbjogW10sXG4gIHBvbHlsaW5lOiBbXSxcbiAgcmFkaWFsR3JhZGllbnQ6IFtdLFxuICByZWN0OiBbXSxcbiAgc2V0OiBbXSxcbiAgc3RvcDogW10sXG4gIHN0eWxlOiBbXSxcbiAgc3dpdGNoOiBbXSxcbiAgc3ltYm9sOiBbXSxcbiAgdGV4dDogW10sXG4gIHRleHRQYXRoOiBbXSxcbiAgdGl0bGU6IFtdLFxuICB0cmVmOiBbXSxcbiAgdHNwYW46IFtdLFxuICB1c2U6IFtdLFxuICB2aWV3OiBbXSxcbiAgdmtlcm46IFtdXG59O1xudmFyIHN2Z0F0dHJXaGl0ZUxpc3QgPSBbJ3dpZHRoJywgJ2hlaWdodCcsICd4JywgJ3knLCAncngnLCAncnknLCAnY3gnLCAnY3knLCAncicsICd2aWV3Ym94JywgJ3BvaW50cycsICdmaWxsJywgJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnb3BhY2l0eScsICd0cmFuc2Zvcm0nLCAnZCcsICd0ZXh0LWFuY2hvcicsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC13ZWlnaHQnLCAnZmlsdGVyJywgJ2hyZWYnLCAneGxpbms6aHJlZiddO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMveHNzL0thVGV4LmpzXG52YXIga2F0ZXhUYWdXaGl0ZUxpc3QgPSB7XG4gIG1hdGg6IFtdLFxuICBhbm5vdGF0aW9uOiBbXSxcbiAgc2VtYW50aWNzOiBbXSxcbiAgbXRleHQ6IFtdLFxuICBtbjogW10sXG4gIG1vOiBbXSxcbiAgbWk6IFtdLFxuICBtc3BhY2U6IFtdLFxuICBtb3ZlcjogW10sXG4gIG11bmRlcjogW10sXG4gIG11bmRlcm92ZXI6IFtdLFxuICBtc3VwOiBbXSxcbiAgbXN1YjogW10sXG4gIG1zdWJzdXA6IFtdLFxuICBtZnJhYzogW10sXG4gIG1yb290OiBbXSxcbiAgbXNxcnQ6IFtdLFxuICBtdGFibGU6IFtdLFxuICBtdHI6IFtdLFxuICBtdGQ6IFtdLFxuICBtbGFiZWxlZHRyOiBbXSxcbiAgbXJvdzogW10sXG4gIG1lbmNsb3NlOiBbXSxcbiAgbXN0eWxlOiBbXSxcbiAgbXBhZGRlZDogW10sXG4gIG1waGFudG9tOiBbXSxcbiAgbWdseXBoOiBbXVxufTtcbnZhciBrYXRleEF0dHJXaGl0ZUxpc3QgPSBbJ21hdGhjb2xvcicsICdtYXRoYmFja2dyb3VuZCcsICdtYXRoc2l6ZScsICdtYXRodmFyaWFudCcsICdtYXRoZmFtaWx5JywgJ21hdGh3ZWlnaHQnLCAnbWF0aHN0eWxlJywgJ21hdGhkaXNwbGF5J107XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy94c3MvY29tbW9uLmpzXG52YXIgYXR0cldoaXRlTGlzdCA9IFsnc3R5bGUnLCAnYWxpZ24nLCAnY2xhc3MnLCAnaWQnXTtcbnZhciBwcmVmaXhBdHRyV2hpdGVMaXN0ID0gWydkYXRhLSddO1xudmFyIGNvbW1vbldoaXRlTGlzdCA9IHtcbiAgaW5wdXQ6IFsndHlwZSddLFxuICBvbDogWydyZXZlcnNlZCcsICdzdGFydCcsICd0eXBlJ10sXG4gIGJ1dHRvbjogWyd0eXBlJ10sXG4gIHN1bW1hcnk6IFtdXG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMveHNzL2luZGV4LmpzXG5cblxuXG5cblxudmFyIG9wdGlvbnMgPSB7XG4gIHdoaXRlTGlzdDogT2JqZWN0KGVzbV9leHRlbmRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh7fSwgbGliX2RlZmF1bHQuYS5nZXREZWZhdWx0V2hpdGVMaXN0KCksIGNvbW1vbldoaXRlTGlzdCwgc3ZnVGFnV2hpdGVMaXN0LCBrYXRleFRhZ1doaXRlTGlzdCksXG4gIG9uSWdub3JlVGFnQXR0cjogZnVuY3Rpb24gb25JZ25vcmVUYWdBdHRyKHRhZywgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoc3ZnVGFnV2hpdGVMaXN0W3RhZ10gJiYgc3ZnQXR0cldoaXRlTGlzdC5pbmNsdWRlcyhuYW1lKSB8fCBrYXRleFRhZ1doaXRlTGlzdFt0YWddICYmIGthdGV4QXR0cldoaXRlTGlzdC5pbmNsdWRlcyhuYW1lKSB8fCBhdHRyV2hpdGVMaXN0LnNvbWUoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHJldHVybiBhdHRyID09PSBuYW1lO1xuICAgIH0pIHx8IHByZWZpeEF0dHJXaGl0ZUxpc3Quc29tZShmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICByZXR1cm4gbmFtZS5zdGFydHNXaXRoKHByZWZpeCk7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBuYW1lICsgXCI9XFxcIlwiICsgbGliX2RlZmF1bHQuYS5lc2NhcGVBdHRyVmFsdWUodmFsdWUpICsgXCJcXFwiXCI7XG4gICAgfVxuICB9XG59O1xudmFyIHhzc0ZpbHRlckluc3RhbmNlID0gbmV3IGxpYl9kZWZhdWx0LmEuRmlsdGVyWFNTKG9wdGlvbnMpO1xuXG54c3NGaWx0ZXJJbnN0YW5jZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICB2YXIgaW5zdGFuY2VPcHRpb25zID0geHNzRmlsdGVySW5zdGFuY2Uub3B0aW9ucztcbiAgT2JqZWN0LmtleXMoZXh0ZW5kT3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uTmFtZSkge1xuICAgIC8vIGV4dGVuZCB3aGl0ZUxpc3RcbiAgICBpZiAob3B0aW9uTmFtZSA9PT0gJ3doaXRlTGlzdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKGV4dGVuZE9wdGlvbnMud2hpdGVMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgIHZhciB0YWdBdHRyV2hpdGVMaXN0ID0gZXh0ZW5kT3B0aW9ucy53aGl0ZUxpc3RbdGFnTmFtZV07XG4gICAgICAgIHZhciBpbnN0YW5jZVdoaXRlTGlzdCA9IGluc3RhbmNlT3B0aW9ucy53aGl0ZUxpc3Q7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlV2hpdGVMaXN0W3RhZ05hbWVdKSB7XG4gICAgICAgICAgaW5zdGFuY2VXaGl0ZUxpc3RbdGFnTmFtZV0gPSBbXS5jb25jYXQoaW5zdGFuY2VXaGl0ZUxpc3RbdGFnTmFtZV0sIHRhZ0F0dHJXaGl0ZUxpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlV2hpdGVMaXN0W3RhZ05hbWVdID0gdGFnQXR0cldoaXRlTGlzdDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25OYW1lID09PSAnb25JZ25vcmVUYWdBdHRyJykge1xuICAgICAgdmFyIG9sZEhhbmRsZXIgPSBpbnN0YW5jZU9wdGlvbnNbb3B0aW9uTmFtZV07XG5cbiAgICAgIGluc3RhbmNlT3B0aW9uc1tvcHRpb25OYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9leHRlbmRPcHRpb25zJG9wdGlvbjtcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJnID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvbGRSZXR1cm5WYWwgPSBvbGRIYW5kbGVyLmNhbGwuYXBwbHkob2xkSGFuZGxlciwgW3RoaXNdLmNvbmNhdChhcmcpKTtcblxuICAgICAgICB2YXIgbmV3UmV0dXJuVmFsID0gKF9leHRlbmRPcHRpb25zJG9wdGlvbiA9IGV4dGVuZE9wdGlvbnNbb3B0aW9uTmFtZV0pLmNhbGwuYXBwbHkoX2V4dGVuZE9wdGlvbnMkb3B0aW9uLCBbdGhpc10uY29uY2F0KGFyZykpO1xuXG4gICAgICAgIHJldHVybiBvbGRSZXR1cm5WYWwgfHwgbmV3UmV0dXJuVmFsO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2VPcHRpb25zW29wdGlvbk5hbWVdID0gZXh0ZW5kT3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeHNzID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoeHNzRmlsdGVySW5zdGFuY2UpO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNtb290aDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNtb290aFNjcm9sbDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Njcm9sbF90b3BfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbmZ1bmN0aW9uIHNtb290aChfcmVmKSB7XG4gIHZhciBjdXJyZW50U2Nyb2xsVG9wID0gX3JlZi5jdXJyZW50U2Nyb2xsVG9wLFxuICAgICAgc2Nyb2xsVG9Ub3AgPSBfcmVmLnNjcm9sbFRvVG9wLFxuICAgICAgc2Nyb2xsRm4gPSBfcmVmLnNjcm9sbEZuLFxuICAgICAgX3JlZiRwZXJjZW50ID0gX3JlZi5wZXJjZW50LFxuICAgICAgcGVyY2VudCA9IF9yZWYkcGVyY2VudCA9PT0gdm9pZCAwID8gMTAgOiBfcmVmJHBlcmNlbnQsXG4gICAgICBvblNjcm9sbEVuZCA9IF9yZWYub25TY3JvbGxFbmQ7XG4gIHZhciBzY3JvbGxXYXkgPSBzY3JvbGxUb1RvcCA+IGN1cnJlbnRTY3JvbGxUb3AgPyAnZG93bicgOiAndXAnO1xuICB2YXIgc3RlcCA9IChzY3JvbGxUb1RvcCAtIGN1cnJlbnRTY3JvbGxUb3ApICogKHBlcmNlbnQgLyAxMDApO1xuICB2YXIgaWQ7XG5cbiAgdmFyIHNjcm9sbCA9IGZ1bmN0aW9uIHNjcm9sbCgpIHtcbiAgICBjdXJyZW50U2Nyb2xsVG9wICs9IHN0ZXA7XG5cbiAgICBpZiAoc2Nyb2xsV2F5ID09PSAnZG93bicgJiYgY3VycmVudFNjcm9sbFRvcCA+PSBzY3JvbGxUb1RvcCB8fCBzY3JvbGxXYXkgPT09ICd1cCcgJiYgY3VycmVudFNjcm9sbFRvcCA8PSBzY3JvbGxUb1RvcCkge1xuICAgICAgc2Nyb2xsRm4oc2Nyb2xsVG9Ub3ApO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgIGlmIChvblNjcm9sbEVuZCkgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvblNjcm9sbEVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcm9sbEZuKGN1cnJlbnRTY3JvbGxUb3ApO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzY3JvbGwpO1xuICAgIH1cbiAgfTtcblxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNjcm9sbCk7XG59XG5mdW5jdGlvbiBzbW9vdGhTY3JvbGwoX3JlZjIpIHtcbiAgdmFyIHNjcm9sbFRhcmdldCA9IF9yZWYyLnNjcm9sbFRhcmdldCxcbiAgICAgIHNjcm9sbFRvVG9wID0gX3JlZjIuc2Nyb2xsVG9Ub3AsXG4gICAgICBfcmVmMiRwZXJjZW50ID0gX3JlZjIucGVyY2VudCxcbiAgICAgIHBlcmNlbnQgPSBfcmVmMiRwZXJjZW50ID09PSB2b2lkIDAgPyAxMCA6IF9yZWYyJHBlcmNlbnQsXG4gICAgICBvblNjcm9sbEVuZCA9IF9yZWYyLm9uU2Nyb2xsRW5kO1xuICB2YXIgY3VycmVudFNjcm9sbFRvcCA9IE9iamVjdChfc2Nyb2xsX3RvcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdldFNjcm9sbFRvcCAqLyBcImFcIl0pKHNjcm9sbFRhcmdldCk7XG4gIHNtb290aCh7XG4gICAgY3VycmVudFNjcm9sbFRvcDogY3VycmVudFNjcm9sbFRvcCxcbiAgICBzY3JvbGxUb1RvcDogc2Nyb2xsVG9Ub3AsXG4gICAgc2Nyb2xsRm46IGZ1bmN0aW9uIHNjcm9sbEZuKHNjcm9sbFRvcCkge1xuICAgICAgcmV0dXJuIE9iamVjdChfc2Nyb2xsX3RvcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIHNjcm9sbFRvICovIFwiYlwiXSkoc2Nyb2xsVGFyZ2V0LCBzY3JvbGxUb3ApO1xuICAgIH0sXG4gICAgcGVyY2VudDogcGVyY2VudCxcbiAgICBvblNjcm9sbEVuZDogb25TY3JvbGxFbmRcbiAgfSk7XG59XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcInJvb3RcIjpcIlZ1ZVwiLFwiY29tbW9uanNcIjpcInZ1ZVwiLFwiY29tbW9uanMyXCI6XCJ2dWVcIixcImFtZFwiOlwidnVlXCJ9XG52YXIgZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9yZWYtLTYhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9wcmV2aWV3LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01MmZmNzBiZSZiaW5kaW5ncz17fVxuXG5mdW5jdGlvbiByZW5kZXIoX2N0eCwgX2NhY2hlLCAkcHJvcHMsICRzZXR1cCwgJGRhdGEsICRvcHRpb25zKSB7XG4gIHJldHVybiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKCksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUJsb2NrXCJdKShcImRpdlwiLCB7XG4gICAgY2xhc3M6IFwidi1tZC1lZGl0b3ItcHJldmlld1wiLFxuICAgIHN0eWxlOiB7XG4gICAgICB0YWJTaXplOiBfY3R4LnRhYlNpemUsXG4gICAgICAnLW1vei10YWItc2l6ZSc6IF9jdHgudGFiU2l6ZSxcbiAgICAgICctby10YWItc2l6ZSc6IF9jdHgudGFiU2l6ZVxuICAgIH0sXG4gICAgb25DbGljazogX2NhY2hlWzFdIHx8IChfY2FjaGVbMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2N0eC5oYW5kbGVQcmV2aWV3Q2xpY2suYXBwbHkoX2N0eCwgYXJndW1lbnRzKTtcbiAgICB9KVxuICB9LCBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKFwiZGl2XCIsIHtcbiAgICBjbGFzczogW19jdHgucHJldmlld0NsYXNzXSxcbiAgICBpbm5lckhUTUw6IF9jdHguaHRtbFxuICB9LCBudWxsLCAxMFxuICAvKiBDTEFTUywgUFJPUFMgKi9cbiAgLCBbXCJpbm5lckhUTUxcIl0pXSwgNFxuICAvKiBTVFlMRSAqL1xuICApO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcHJldmlldy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTJmZjcwYmUmYmluZGluZ3M9e31cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy91dGlscy94c3MvaW5kZXguanMgKyAzIG1vZHVsZXNcbnZhciB4c3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWxzL2xhbmcuanMgKyAxIG1vZHVsZXNcbnZhciBsYW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL3YtbWQtcGFyc2VyLmpzXG5cbnZhciB2X21kX3BhcnNlcl9WTWRQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWTWRQYXJzZXIoKSB7XG4gICAgdGhpcy5sYW5nID0gbmV3IGxhbmdbXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBWTWRQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZWZhdWx0TWFya2Rvd25Mb2FkZXIgPSBmdW5jdGlvbiBkZWZhdWx0TWFya2Rvd25Mb2FkZXIodGV4dCkge1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2Uob3B0aW9uc09ySW5zdGFsbCwgb3B0KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JJbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zT3JJbnN0YWxsKHRoaXMsIG9wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnNPckluc3RhbGwuaW5zdGFsbCh0aGlzLCBvcHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by50aGVtZSA9IGZ1bmN0aW9uIHRoZW1lKHRoZW1lQ29uZmlnKSB7XG4gICAgdGhpcy50aGVtZUNvbmZpZyA9IHRoZW1lQ29uZmlnO1xuICB9O1xuXG4gIF9wcm90by5leHRlbmRNYXJrZG93biA9IGZ1bmN0aW9uIGV4dGVuZE1hcmtkb3duKGV4dGVuZGVyKSB7XG4gICAgaWYgKCF0aGlzLnRoZW1lQ29uZmlnKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignUGxlYXNlIHVzZSB0aGVtZSBiZWZvcmUgdXNpbmcgcGx1Z2lucycpO1xuICAgIH1cblxuICAgIHZhciBtYXJrZG93blBhcnNlciA9IHRoaXMudGhlbWVDb25maWcubWFya2Rvd25QYXJzZXI7XG4gICAgZXh0ZW5kZXIobWFya2Rvd25QYXJzZXIpO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICB2YXIgX21hcmtkb3duUGFyc2VyJHJlbmRlO1xuXG4gICAgdmFyIG1hcmtkb3duUGFyc2VyID0gdGhpcy50aGVtZUNvbmZpZy5tYXJrZG93blBhcnNlcjtcbiAgICB2YXIgbWFya2Rvd25Mb2FkZXIgPSAobWFya2Rvd25QYXJzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IChfbWFya2Rvd25QYXJzZXIkcmVuZGUgPSBtYXJrZG93blBhcnNlci5yZW5kZXIpID09IG51bGwgPyB2b2lkIDAgOiBfbWFya2Rvd25QYXJzZXIkcmVuZGUuYmluZChtYXJrZG93blBhcnNlcikpIHx8IHRoaXMuZGVmYXVsdE1hcmtkb3duTG9hZGVyO1xuXG4gICAgaWYgKHR5cGVvZiBtYXJrZG93bkxvYWRlciAhPT0gJ2Z1bmN0aW9uJyB8fCBtYXJrZG93bkxvYWRlciA9PT0gdGhpcy5kZWZhdWx0TWFya2Rvd25Mb2FkZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsZWFzZSBjb25maWd1cmUgeW91ciBtYXJrZG93biBwYXJzZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya2Rvd25Mb2FkZXIodGV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIFZNZFBhcnNlcjtcbn0oKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvbWl4aW5zL3ByZXZpZXcuanNcbnZhciBwcmV2aWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Q/P3JlZi0tMi0wIS4vc3JjL3ByZXZpZXcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG5cblxuIC8vIG1peGluc1xuXG5cbnZhciBjb21wb25lbnQgPSB7XG4gIG5hbWU6ICd2LW1kLXByZXZpZXcnLFxuICBtaXhpbnM6IFtwcmV2aWV3W1wiYVwiIC8qIGRlZmF1bHQgKi9dXSxcbiAgcHJvcHM6IHtcbiAgICB0ZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnJ1xuICAgIH0sXG4gICAgdGhlbWU6IE9iamVjdCxcbiAgICBiZWZvcmVDaGFuZ2U6IEZ1bmN0aW9uXG4gIH0sXG4gIGVtaXRzOiBbJ2NoYW5nZSddLFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBodG1sOiAnJ1xuICAgIH07XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdGV4dDogZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgIHRoaXMuaGFuZGxlVGV4dENoYW5nZSgpO1xuICAgIH0sXG4gICAgbGFuZ0NvbmZpZzogZnVuY3Rpb24gbGFuZ0NvbmZpZygpIHtcbiAgICAgIHRoaXMuaGFuZGxlVGV4dENoYW5nZSgpO1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICB2TWRQYXJzZXI6IGZ1bmN0aW9uIHZNZFBhcnNlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRvcHRpb25zLnZNZFBhcnNlcjtcbiAgICB9LFxuICAgIHByZXZpZXdDbGFzczogZnVuY3Rpb24gcHJldmlld0NsYXNzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudk1kUGFyc2VyLnRoZW1lQ29uZmlnLnByZXZpZXdDbGFzcztcbiAgICB9LFxuICAgIGxhbmdDb25maWc6IGZ1bmN0aW9uIGxhbmdDb25maWcoKSB7XG4gICAgICByZXR1cm4gdGhpcy52TWRQYXJzZXIubGFuZy5jb25maWc7XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuaGFuZGxlVGV4dENoYW5nZSgpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaGFuZGxlVGV4dENoYW5nZTogZnVuY3Rpb24gaGFuZGxlVGV4dENoYW5nZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gbmV4dCh0ZXh0KSB7XG4gICAgICAgIF90aGlzLmh0bWwgPSB4c3NbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvY2VzcyhfdGhpcy4kb3B0aW9ucy52TWRQYXJzZXIucGFyc2UodGV4dCkpO1xuXG4gICAgICAgIF90aGlzLiRlbWl0KCdjaGFuZ2UnLCB0ZXh0LCBfdGhpcy5odG1sKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmJlZm9yZUNoYW5nZSkge1xuICAgICAgICB0aGlzLmJlZm9yZUNoYW5nZSh0aGlzLnRleHQsIG5leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCh0aGlzLnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciB2TWRQYXJzZXIgPSBuZXcgdl9tZF9wYXJzZXJfVk1kUGFyc2VyKCk7XG52TWRQYXJzZXIubGFuZy5jb25maWcgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZWFjdGl2ZVwiXSkodk1kUGFyc2VyLmxhbmcuY29uZmlnKTtcbmNvbXBvbmVudC52TWRQYXJzZXIgPSBuZXcgdl9tZF9wYXJzZXJfVk1kUGFyc2VyKCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwcmV2aWV3dnVlX3R5cGVfc2NyaXB0X2xhbmdfanMgPSAoY29tcG9uZW50KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3ByZXZpZXcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG4gXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wcmV2aWV3LnZ1ZVxuXG5cblxucHJldmlld3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzLnJlbmRlciA9IHJlbmRlclxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfcHJldmlldyA9IChwcmV2aWV3dnVlX3R5cGVfc2NyaXB0X2xhbmdfanMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9hc3NldHMvY3NzL2ZvbnQuY3NzXG52YXIgZm9udCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9wcmV2aWV3LmpzXG4vLyBUaGlzIGZpbGUgaXMgYXV0byBnZW5lcmF0ZWQgYnkgYnVpbGQvYnVpbGQtZW50cnkuanNcblxuIC8vIGZvbnQgY3NzXG5cblxudmFyIHZlcnNpb24gPSAnMi4zLjE4JztcblxudmFyIHByZXZpZXdfaW5zdGFsbCA9IGZ1bmN0aW9uIGluc3RhbGwoYXBwKSB7XG4gIGFwcC5jb21wb25lbnQoc3JjX3ByZXZpZXcubmFtZSwgc3JjX3ByZXZpZXcpO1xufTtcblxuc3JjX3ByZXZpZXcudmVyc2lvbiA9IHZlcnNpb247XG5zcmNfcHJldmlldy5pbnN0YWxsID0gcHJldmlld19pbnN0YWxsO1xuc3JjX3ByZXZpZXcueHNzID0geHNzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuXG5zcmNfcHJldmlldy51c2UgPSBmdW5jdGlvbiAob3B0aW9uc09ySW5zdGFsbCwgb3B0KSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9uc09ySW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnNPckluc3RhbGwoc3JjX3ByZXZpZXcsIG9wdCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9uc09ySW5zdGFsbC5pbnN0YWxsKHNyY19wcmV2aWV3LCBvcHQpO1xuICB9XG5cbiAgcmV0dXJuIHNyY19wcmV2aWV3O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3ByZXZpZXdfMCA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHNyY19wcmV2aWV3KTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiB4c3NcbiAqXG4gKiBAYXV0aG9yIFpvbmdtaW4gTGVpPGxlaXpvbmdtaW5AZ21haWwuY29tPlxuICovXG5cbnZhciBERUZBVUxUID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgRmlsdGVyWFNTID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbi8qKlxuICogZmlsdGVyIHhzcyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB7IHdoaXRlTGlzdCwgb25UYWcsIG9uVGFnQXR0ciwgb25JZ25vcmVUYWcsIG9uSWdub3JlVGFnQXR0ciwgc2FmZUF0dHJWYWx1ZSwgZXNjYXBlSHRtbCB9XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZpbHRlclhTUyhodG1sLCBvcHRpb25zKSB7XG4gIHZhciB4c3MgPSBuZXcgRmlsdGVyWFNTKG9wdGlvbnMpO1xuICByZXR1cm4geHNzLnByb2Nlc3MoaHRtbCk7XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZpbHRlclhTUztcbmV4cG9ydHMuZmlsdGVyWFNTID0gZmlsdGVyWFNTO1xuZXhwb3J0cy5GaWx0ZXJYU1MgPSBGaWx0ZXJYU1M7XG5mb3IgKHZhciBpIGluIERFRkFVTFQpIGV4cG9ydHNbaV0gPSBERUZBVUxUW2ldO1xuZm9yICh2YXIgaSBpbiBwYXJzZXIpIGV4cG9ydHNbaV0gPSBwYXJzZXJbaV07XG5cbi8vIHVzaW5nIGB4c3NgIG9uIHRoZSBicm93c2VyLCBvdXRwdXQgYGZpbHRlclhTU2AgdG8gdGhlIGdsb2JhbHNcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5maWx0ZXJYU1MgPSBtb2R1bGUuZXhwb3J0cztcbn1cblxuLy8gdXNpbmcgYHhzc2Agb24gdGhlIFdlYldvcmtlciwgb3V0cHV0IGBmaWx0ZXJYU1NgIHRvIHRoZSBnbG9iYWxzXG5mdW5jdGlvbiBpc1dvcmtlckVudigpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHNlbGYgaW5zdGFuY2VvZiBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZVxuICApO1xufVxuaWYgKGlzV29ya2VyRW52KCkpIHtcbiAgc2VsZi5maWx0ZXJYU1MgPSBtb2R1bGUuZXhwb3J0cztcbn1cblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmaWxlc0ZpbHRlcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEZpbGVzRnJvbUNsaXBib2FyZERhdGE7IH0pO1xuLy8gTW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vRWxlbWVGRS9lbGVtZW50L2Jsb2IvZGV2L3BhY2thZ2VzL3VwbG9hZC9zcmMvdXBsb2FkLWRyYWdnZXIudnVlXG5mdW5jdGlvbiBmaWxlc0ZpbHRlcihmaWxlcywgY29uZmlnKSB7XG4gIHZhciBhY2NlcHQgPSBjb25maWcuYWNjZXB0O1xuICB2YXIgZmlsZXNLZXlzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGZpbGUgPSBmaWxlc1trZXldO1xuICAgIHZhciB0eXBlID0gZmlsZS50eXBlLFxuICAgICAgICBuYW1lID0gZmlsZS5uYW1lO1xuICAgIHZhciBleHRlbnNpb24gPSBuYW1lLmluZGV4T2YoJy4nKSA+IC0xID8gXCIuXCIgKyBuYW1lLnNwbGl0KCcuJykucG9wKCkgOiAnJztcbiAgICB2YXIgYmFzZVR5cGUgPSB0eXBlLnJlcGxhY2UoL1xcLy4qJC8sICcnKTtcbiAgICByZXR1cm4gYWNjZXB0LnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZS50cmltKCk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9KS5zb21lKGZ1bmN0aW9uIChhY2NlcHRlZFR5cGUpIHtcbiAgICAgIGlmICgvXFwuLiskLy50ZXN0KGFjY2VwdGVkVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbiA9PT0gYWNjZXB0ZWRUeXBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoL1xcL1xcKiQvLnRlc3QoYWNjZXB0ZWRUeXBlKSkge1xuICAgICAgICByZXR1cm4gYmFzZVR5cGUgPT09IGFjY2VwdGVkVHlwZS5yZXBsYWNlKC9cXC9cXCokLywgJycpO1xuICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuXG4gICAgICBpZiAoL15bXlxcL10rXFwvW15cXC9dKyQvLnRlc3QoYWNjZXB0ZWRUeXBlKSkge1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gYWNjZXB0ZWRUeXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsZXNLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGZpbGVzW2tleV07XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RmlsZXNGcm9tQ2xpcGJvYXJkRGF0YShjbGlwYm9hcmREYXRhKSB7XG4gIHZhciBmaWxlcyA9IFtdO1xuICBPYmplY3Qua2V5cyhjbGlwYm9hcmREYXRhLml0ZW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaXRlbSA9IGNsaXBib2FyZERhdGEuaXRlbXNba2V5XTtcblxuICAgIGlmIChpdGVtLmtpbmQgPT09ICdmaWxlJykge1xuICAgICAgdmFyIGZpbGUgPSBpdGVtLmdldEFzRmlsZSgpO1xuICAgICAgaWYgKGZpbGUpIGZpbGVzLnB1c2goZmlsZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZpbGVzO1xufVxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBsYW5nX0xhbmc7IH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWxzL3V0aWwuanNcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvZGVlcC1hc3NpZ24uanNcblxudmFyIGRlZXBfYXNzaWduX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gYXNzaWduS2V5KHRvLCBmcm9tLCBrZXkpIHtcbiAgdmFyIHZhbCA9IGZyb21ba2V5XTtcblxuICBpZiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFkZWVwX2Fzc2lnbl9oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvLCBrZXkpIHx8ICFPYmplY3QodXRpbFtcImZcIiAvKiBpc09iamVjdCAqL10pKHZhbCkpIHtcbiAgICB0b1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIHRvW2tleV0gPSBkZWVwQXNzaWduKE9iamVjdCh0b1trZXldKSwgZnJvbVtrZXldKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWVwQXNzaWduKHRvLCBmcm9tKSB7XG4gIE9iamVjdC5rZXlzKGZyb20pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGFzc2lnbktleSh0bywgZnJvbSwga2V5KTtcbiAgfSk7XG4gIHJldHVybiB0bztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL2xhbmcuanNcblxuXG52YXIgbGFuZ19MYW5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFuZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgbGFuZzogJ3poLUNOJyxcbiAgICAgIGxhbmdDb25maWc6IHtcbiAgICAgICAgJ3poLUNOJzoge31cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGFuZy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZShsYW5nLCBjb25maWcpIHtcbiAgICB2YXIgX3RoaXMkYWRkO1xuXG4gICAgdGhpcy5jb25maWcubGFuZyA9IGxhbmc7XG4gICAgdGhpcy5hZGQoKF90aGlzJGFkZCA9IHt9LCBfdGhpcyRhZGRbbGFuZ10gPSBjb25maWcsIF90aGlzJGFkZCkpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYWZ0ZXJVc2UpIHRoaXMub3B0aW9ucy5hZnRlclVzZShsYW5nLCBjb25maWcpO1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICB9XG5cbiAgICBkZWVwQXNzaWduKHRoaXMuY29uZmlnLmxhbmdDb25maWcsIGNvbmZpZyk7XG4gIH07XG5cbiAgcmV0dXJuIExhbmc7XG59KCk7XG5cblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogY3NzZmlsdGVyXG4gKlxuICogQGF1dGhvciDogIHpm7c8bGVpem9uZ21pbkBnbWFpbC5jb20+XG4gKi9cblxudmFyIERFRkFVTFQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbnZhciBGaWx0ZXJDU1MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuXG4vKipcbiAqIFhTU+i/h+a7pFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjc3Mg6KaB6L+H5ruk55qEQ1NT5Luj56CBXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyDpgInpobnvvJp3aGl0ZUxpc3QsIG9uQXR0ciwgb25JZ25vcmVBdHRyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZpbHRlckNTUyAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgeHNzID0gbmV3IEZpbHRlckNTUyhvcHRpb25zKTtcbiAgcmV0dXJuIHhzcy5wcm9jZXNzKGh0bWwpO1xufVxuXG5cbi8vIOi+k+WHulxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZmlsdGVyQ1NTO1xuZXhwb3J0cy5GaWx0ZXJDU1MgPSBGaWx0ZXJDU1M7XG5mb3IgKHZhciBpIGluIERFRkFVTFQpIGV4cG9ydHNbaV0gPSBERUZBVUxUW2ldO1xuXG4vLyDlnKjmtY/op4jlmajnq6/kvb/nlKhcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuZmlsdGVyQ1NTID0gbW9kdWxlLmV4cG9ydHM7XG59XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5kZXhPZjogZnVuY3Rpb24gKGFyciwgaXRlbSkge1xuICAgIHZhciBpLCBqO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBqID0gYXJyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9LFxuICBmb3JFYWNoOiBmdW5jdGlvbiAoYXJyLCBmbiwgc2NvcGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICAgIHJldHVybiBhcnIuZm9yRWFjaChmbiwgc2NvcGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBqID0gYXJyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgZm4uY2FsbChzY29wZSwgYXJyW2ldLCBpLCBhcnIpO1xuICAgIH1cbiAgfSxcbiAgdHJpbTogZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyheXFxzKil8KFxccyokKS9nLCBcIlwiKTtcbiAgfSxcbiAgc3BhY2VJbmRleDogZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciByZWcgPSAvXFxzfFxcbnxcXHQvO1xuICAgIHZhciBtYXRjaCA9IHJlZy5leGVjKHN0cik7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2guaW5kZXggOiAtMTtcbiAgfSxcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfc2Nyb2xsX3RvcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfc21vb3RoX3Njcm9sbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX21hcmt1cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoe1xuICBwcm9wczoge1xuICAgIHRhYlNpemU6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDJcbiAgICB9LFxuICAgIHNjcm9sbENvbnRhaW5lcjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvcDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH1cbiAgfSxcbiAgZW1pdHM6IFsnaW1hZ2UtY2xpY2snXSxcbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZVByZXZpZXdDbGljazogZnVuY3Rpb24gaGFuZGxlUHJldmlld0NsaWNrKGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDsgLy8gaW1hZ2UgcHJldmlld1xuXG4gICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09ICdJTUcnKSB7XG4gICAgICAgIHZhciBzcmMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgaWYgKCFzcmMpIHJldHVybjtcbiAgICAgICAgdmFyIGltYWdlRWxzID0gQXJyYXkuZnJvbSh0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKSk7XG4gICAgICAgIHZhciBpbWFnZXMgPSBpbWFnZUVscy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbWFnZVByZXZpZXdJbml0SW5kZXggPSBpbWFnZUVscy5pbmRleE9mKHRhcmdldCk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2ltYWdlLWNsaWNrJywgaW1hZ2VzLCBpbWFnZVByZXZpZXdJbml0SW5kZXgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JvbGxUb1RhcmdldElkID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShfdXRpbHNfY29uc3RhbnRzX21hcmt1cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIEFOQ0hPUl9NQVJLVVAgKi8gXCJhXCJdKTtcbiAgICAgIHZhciBzY3JvbGxUb1RhcmdldCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXCJbXCIgKyBfdXRpbHNfY29uc3RhbnRzX21hcmt1cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIEhFQURJTkdfTUFSS1VQICovIFwiYlwiXSArIFwiPVxcXCJcIiArIHNjcm9sbFRvVGFyZ2V0SWQgKyBcIlxcXCJdXCIpO1xuXG4gICAgICBpZiAoc2Nyb2xsVG9UYXJnZXQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb1RhcmdldCh7XG4gICAgICAgICAgdGFyZ2V0OiBzY3JvbGxUb1RhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldE9mZnNldFRvcDogZnVuY3Rpb24gZ2V0T2Zmc2V0VG9wKHRhcmdldCwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKGNvbnRhaW5lciA9PT0gd2luZG93IHx8IGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiByZWN0LnRvcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlY3QudG9wIC0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9LFxuICAgIHNjcm9sbFRvVGFyZ2V0OiBmdW5jdGlvbiBzY3JvbGxUb1RhcmdldChfcmVmKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICAgICAgX3JlZiRzY3JvbGxDb250YWluZXIgPSBfcmVmLnNjcm9sbENvbnRhaW5lcixcbiAgICAgICAgICBzY3JvbGxDb250YWluZXIgPSBfcmVmJHNjcm9sbENvbnRhaW5lciA9PT0gdm9pZCAwID8gdGhpcy5zY3JvbGxDb250YWluZXIoKSA6IF9yZWYkc2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICAgIF9yZWYkdG9wID0gX3JlZi50b3AsXG4gICAgICAgICAgdG9wID0gX3JlZiR0b3AgPT09IHZvaWQgMCA/IHRoaXMudG9wIDogX3JlZiR0b3AsXG4gICAgICAgICAgb25TY3JvbGxFbmQgPSBfcmVmLm9uU2Nyb2xsRW5kO1xuICAgICAgdmFyIG9mZnNldFRvcCA9IHRoaXMuZ2V0T2Zmc2V0VG9wKHRhcmdldCwgc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBPYmplY3QoX3V0aWxzX3Njcm9sbF90b3BfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBnZXRTY3JvbGxUb3AgKi8gXCJhXCJdKShzY3JvbGxDb250YWluZXIpICsgb2Zmc2V0VG9wIC0gdG9wO1xuICAgICAgT2JqZWN0KF91dGlsc19zbW9vdGhfc2Nyb2xsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKHtcbiAgICAgICAgc2Nyb2xsVGFyZ2V0OiBzY3JvbGxDb250YWluZXIsXG4gICAgICAgIHNjcm9sbFRvVG9wOiBzY3JvbGxUb3AsXG4gICAgICAgIG9uU2Nyb2xsRW5kOiBvblNjcm9sbEVuZFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzY3JvbGxUb0xpbmU6IGZ1bmN0aW9uIHNjcm9sbFRvTGluZShfcmVmMikge1xuICAgICAgdmFyIGxpbmVJbmRleCA9IF9yZWYyLmxpbmVJbmRleCxcbiAgICAgICAgICBvblNjcm9sbEVuZCA9IF9yZWYyLm9uU2Nyb2xsRW5kO1xuXG4gICAgICBpZiAobGluZUluZGV4KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKFwiW1wiICsgX3V0aWxzX2NvbnN0YW50c19tYXJrdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBMSU5FX01BUktVUCAqLyBcImNcIl0gKyBcIj1cXFwiXCIgKyBsaW5lSW5kZXggKyBcIlxcXCJdXCIpO1xuICAgICAgICBpZiAodGFyZ2V0KSB0aGlzLnNjcm9sbFRvVGFyZ2V0KHtcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICBvblNjcm9sbEVuZDogb25TY3JvbGxFbmRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3I7IH0pO1xuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzXG4gKlxuICogQGF1dGhvciBab25nbWluIExlaTxsZWl6b25nbWluQGdtYWlsLmNvbT5cbiAqL1xuXG52YXIgRmlsdGVyQ1NTID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuRmlsdGVyQ1NTO1xudmFyIGdldERlZmF1bHRDU1NXaGl0ZUxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5nZXREZWZhdWx0V2hpdGVMaXN0O1xudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFdoaXRlTGlzdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBhOiBbXCJ0YXJnZXRcIiwgXCJocmVmXCIsIFwidGl0bGVcIl0sXG4gICAgYWJicjogW1widGl0bGVcIl0sXG4gICAgYWRkcmVzczogW10sXG4gICAgYXJlYTogW1wic2hhcGVcIiwgXCJjb29yZHNcIiwgXCJocmVmXCIsIFwiYWx0XCJdLFxuICAgIGFydGljbGU6IFtdLFxuICAgIGFzaWRlOiBbXSxcbiAgICBhdWRpbzogW1xuICAgICAgXCJhdXRvcGxheVwiLFxuICAgICAgXCJjb250cm9sc1wiLFxuICAgICAgXCJjcm9zc29yaWdpblwiLFxuICAgICAgXCJsb29wXCIsXG4gICAgICBcIm11dGVkXCIsXG4gICAgICBcInByZWxvYWRcIixcbiAgICAgIFwic3JjXCIsXG4gICAgXSxcbiAgICBiOiBbXSxcbiAgICBiZGk6IFtcImRpclwiXSxcbiAgICBiZG86IFtcImRpclwiXSxcbiAgICBiaWc6IFtdLFxuICAgIGJsb2NrcXVvdGU6IFtcImNpdGVcIl0sXG4gICAgYnI6IFtdLFxuICAgIGNhcHRpb246IFtdLFxuICAgIGNlbnRlcjogW10sXG4gICAgY2l0ZTogW10sXG4gICAgY29kZTogW10sXG4gICAgY29sOiBbXCJhbGlnblwiLCBcInZhbGlnblwiLCBcInNwYW5cIiwgXCJ3aWR0aFwiXSxcbiAgICBjb2xncm91cDogW1wiYWxpZ25cIiwgXCJ2YWxpZ25cIiwgXCJzcGFuXCIsIFwid2lkdGhcIl0sXG4gICAgZGQ6IFtdLFxuICAgIGRlbDogW1wiZGF0ZXRpbWVcIl0sXG4gICAgZGV0YWlsczogW1wib3BlblwiXSxcbiAgICBkaXY6IFtdLFxuICAgIGRsOiBbXSxcbiAgICBkdDogW10sXG4gICAgZW06IFtdLFxuICAgIGZpZ2NhcHRpb246IFtdLFxuICAgIGZpZ3VyZTogW10sXG4gICAgZm9udDogW1wiY29sb3JcIiwgXCJzaXplXCIsIFwiZmFjZVwiXSxcbiAgICBmb290ZXI6IFtdLFxuICAgIGgxOiBbXSxcbiAgICBoMjogW10sXG4gICAgaDM6IFtdLFxuICAgIGg0OiBbXSxcbiAgICBoNTogW10sXG4gICAgaDY6IFtdLFxuICAgIGhlYWRlcjogW10sXG4gICAgaHI6IFtdLFxuICAgIGk6IFtdLFxuICAgIGltZzogW1wic3JjXCIsIFwiYWx0XCIsIFwidGl0bGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcbiAgICBpbnM6IFtcImRhdGV0aW1lXCJdLFxuICAgIGxpOiBbXSxcbiAgICBtYXJrOiBbXSxcbiAgICBuYXY6IFtdLFxuICAgIG9sOiBbXSxcbiAgICBwOiBbXSxcbiAgICBwcmU6IFtdLFxuICAgIHM6IFtdLFxuICAgIHNlY3Rpb246IFtdLFxuICAgIHNtYWxsOiBbXSxcbiAgICBzcGFuOiBbXSxcbiAgICBzdWI6IFtdLFxuICAgIHN1bW1hcnk6IFtdLFxuICAgIHN1cDogW10sXG4gICAgc3Ryb25nOiBbXSxcbiAgICBzdHJpa2U6IFtdLFxuICAgIHRhYmxlOiBbXCJ3aWR0aFwiLCBcImJvcmRlclwiLCBcImFsaWduXCIsIFwidmFsaWduXCJdLFxuICAgIHRib2R5OiBbXCJhbGlnblwiLCBcInZhbGlnblwiXSxcbiAgICB0ZDogW1wid2lkdGhcIiwgXCJyb3dzcGFuXCIsIFwiY29sc3BhblwiLCBcImFsaWduXCIsIFwidmFsaWduXCJdLFxuICAgIHRmb290OiBbXCJhbGlnblwiLCBcInZhbGlnblwiXSxcbiAgICB0aDogW1wid2lkdGhcIiwgXCJyb3dzcGFuXCIsIFwiY29sc3BhblwiLCBcImFsaWduXCIsIFwidmFsaWduXCJdLFxuICAgIHRoZWFkOiBbXCJhbGlnblwiLCBcInZhbGlnblwiXSxcbiAgICB0cjogW1wicm93c3BhblwiLCBcImFsaWduXCIsIFwidmFsaWduXCJdLFxuICAgIHR0OiBbXSxcbiAgICB1OiBbXSxcbiAgICB1bDogW10sXG4gICAgdmlkZW86IFtcbiAgICAgIFwiYXV0b3BsYXlcIixcbiAgICAgIFwiY29udHJvbHNcIixcbiAgICAgIFwiY3Jvc3NvcmlnaW5cIixcbiAgICAgIFwibG9vcFwiLFxuICAgICAgXCJtdXRlZFwiLFxuICAgICAgXCJwbGF5c2lubGluZVwiLFxuICAgICAgXCJwb3N0ZXJcIixcbiAgICAgIFwicHJlbG9hZFwiLFxuICAgICAgXCJzcmNcIixcbiAgICAgIFwiaGVpZ2h0XCIsXG4gICAgICBcIndpZHRoXCIsXG4gICAgXSxcbiAgfTtcbn1cblxudmFyIGRlZmF1bHRDU1NGaWx0ZXIgPSBuZXcgRmlsdGVyQ1NTKCk7XG5cbi8qKlxuICogZGVmYXVsdCBvblRhZyBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YWdcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBvblRhZyh0YWcsIGh0bWwsIG9wdGlvbnMpIHtcbiAgLy8gZG8gbm90aGluZ1xufVxuXG4vKipcbiAqIGRlZmF1bHQgb25JZ25vcmVUYWcgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gb25JZ25vcmVUYWcodGFnLCBodG1sLCBvcHRpb25zKSB7XG4gIC8vIGRvIG5vdGhpbmdcbn1cblxuLyoqXG4gKiBkZWZhdWx0IG9uVGFnQXR0ciBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YWdcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gb25UYWdBdHRyKHRhZywgbmFtZSwgdmFsdWUpIHtcbiAgLy8gZG8gbm90aGluZ1xufVxuXG4vKipcbiAqIGRlZmF1bHQgb25JZ25vcmVUYWdBdHRyIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRhZ1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBvbklnbm9yZVRhZ0F0dHIodGFnLCBuYW1lLCB2YWx1ZSkge1xuICAvLyBkbyBub3RoaW5nXG59XG5cbi8qKlxuICogZGVmYXVsdCBlc2NhcGVIdG1sIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqL1xuZnVuY3Rpb24gZXNjYXBlSHRtbChodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoUkVHRVhQX0xULCBcIiZsdDtcIikucmVwbGFjZShSRUdFWFBfR1QsIFwiJmd0O1wiKTtcbn1cblxuLyoqXG4gKiBkZWZhdWx0IHNhZmVBdHRyVmFsdWUgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gY3NzRmlsdGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNhZmVBdHRyVmFsdWUodGFnLCBuYW1lLCB2YWx1ZSwgY3NzRmlsdGVyKSB7XG4gIC8vIHVuZXNjYXBlIGF0dHJpYnV0ZSB2YWx1ZSBmaXJzdGx5XG4gIHZhbHVlID0gZnJpZW5kbHlBdHRyVmFsdWUodmFsdWUpO1xuXG4gIGlmIChuYW1lID09PSBcImhyZWZcIiB8fCBuYW1lID09PSBcInNyY1wiKSB7XG4gICAgLy8gZmlsdGVyIGBocmVmYCBhbmQgYHNyY2AgYXR0cmlidXRlXG4gICAgLy8gb25seSBhbGxvdyB0aGUgdmFsdWUgdGhhdCBzdGFydHMgd2l0aCBgaHR0cDovL2AgfCBgaHR0cHM6Ly9gIHwgYG1haWx0bzpgIHwgYC9gIHwgYCNgXG4gICAgdmFsdWUgPSBfLnRyaW0odmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gXCIjXCIpIHJldHVybiBcIiNcIjtcbiAgICBpZiAoXG4gICAgICAhKFxuICAgICAgICB2YWx1ZS5zdWJzdHIoMCwgNykgPT09IFwiaHR0cDovL1wiIHx8XG4gICAgICAgIHZhbHVlLnN1YnN0cigwLCA4KSA9PT0gXCJodHRwczovL1wiIHx8XG4gICAgICAgIHZhbHVlLnN1YnN0cigwLCA3KSA9PT0gXCJtYWlsdG86XCIgfHxcbiAgICAgICAgdmFsdWUuc3Vic3RyKDAsIDQpID09PSBcInRlbDpcIiB8fFxuICAgICAgICB2YWx1ZS5zdWJzdHIoMCwgMTEpID09PSBcImRhdGE6aW1hZ2UvXCIgfHxcbiAgICAgICAgdmFsdWUuc3Vic3RyKDAsIDYpID09PSBcImZ0cDovL1wiIHx8XG4gICAgICAgIHZhbHVlLnN1YnN0cigwLCAyKSA9PT0gXCIuL1wiIHx8XG4gICAgICAgIHZhbHVlLnN1YnN0cigwLCAzKSA9PT0gXCIuLi9cIiB8fFxuICAgICAgICB2YWx1ZVswXSA9PT0gXCIjXCIgfHxcbiAgICAgICAgdmFsdWVbMF0gPT09IFwiL1wiXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJiYWNrZ3JvdW5kXCIpIHtcbiAgICAvLyBmaWx0ZXIgYGJhY2tncm91bmRgIGF0dHJpYnV0ZSAobWF5YmUgbm8gdXNlKVxuICAgIC8vIGBqYXZhc2NyaXB0OmBcbiAgICBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl80Lmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzQudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAvLyBgZXhwcmVzc2lvbigpYFxuICAgIFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzcubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoUkVHRVhQX0RFRkFVTFRfT05fVEFHX0FUVFJfNy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIC8vIGB1cmwoKWBcbiAgICBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl84Lmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzgudGVzdCh2YWx1ZSkpIHtcbiAgICAgIFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzQubGFzdEluZGV4ID0gMDtcbiAgICAgIGlmIChSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl80LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3NzRmlsdGVyICE9PSBmYWxzZSkge1xuICAgICAgY3NzRmlsdGVyID0gY3NzRmlsdGVyIHx8IGRlZmF1bHRDU1NGaWx0ZXI7XG4gICAgICB2YWx1ZSA9IGNzc0ZpbHRlci5wcm9jZXNzKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2NhcGUgYDw+XCJgIGJlZm9yZSByZXR1cm5zXG4gIHZhbHVlID0gZXNjYXBlQXR0clZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBSZWdFeHAgbGlzdFxudmFyIFJFR0VYUF9MVCA9IC88L2c7XG52YXIgUkVHRVhQX0dUID0gLz4vZztcbnZhciBSRUdFWFBfUVVPVEUgPSAvXCIvZztcbnZhciBSRUdFWFBfUVVPVEVfMiA9IC8mcXVvdDsvZztcbnZhciBSRUdFWFBfQVRUUl9WQUxVRV8xID0gLyYjKFthLXpBLVowLTldKik7Py9naW07XG52YXIgUkVHRVhQX0FUVFJfVkFMVUVfQ09MT04gPSAvJmNvbG9uOz8vZ2ltO1xudmFyIFJFR0VYUF9BVFRSX1ZBTFVFX05FV0xJTkUgPSAvJm5ld2xpbmU7Py9naW07XG52YXIgUkVHRVhQX0RFRkFVTFRfT05fVEFHX0FUVFJfMyA9IC9cXC9cXCp8XFwqXFwvL2dtO1xudmFyIFJFR0VYUF9ERUZBVUxUX09OX1RBR19BVFRSXzQgPSAvKChqXFxzKmFcXHMqdlxccyphfHZcXHMqYnxsXFxzKmlcXHMqdlxccyplKVxccypzXFxzKmNcXHMqclxccyppXFxzKnBcXHMqdFxccyp8bVxccypvXFxzKmNcXHMqaFxccyphKVxcOi9naTtcbnZhciBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl81ID0gL15bXFxzXCInYF0qKGRcXHMqYVxccyp0XFxzKmFcXHMqKVxcOi9naTtcbnZhciBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl82ID0gL15bXFxzXCInYF0qKGRcXHMqYVxccyp0XFxzKmFcXHMqKVxcOlxccyppbWFnZVxcLy9naTtcbnZhciBSRUdFWFBfREVGQVVMVF9PTl9UQUdfQVRUUl83ID0gL2VcXHMqeFxccypwXFxzKnJcXHMqZVxccypzXFxzKnNcXHMqaVxccypvXFxzKm5cXHMqXFwoLiovZ2k7XG52YXIgUkVHRVhQX0RFRkFVTFRfT05fVEFHX0FUVFJfOCA9IC91XFxzKnJcXHMqbFxccypcXCguKi9naTtcblxuLyoqXG4gKiBlc2NhcGUgZG91YmxlIHF1b3RlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfSBzdHJcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUXVvdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfUVVPVEUsIFwiJnF1b3Q7XCIpO1xufVxuXG4vKipcbiAqIHVuZXNjYXBlIGRvdWJsZSBxdW90ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlUXVvdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfUVVPVEVfMiwgJ1wiJyk7XG59XG5cbi8qKlxuICogZXNjYXBlIGh0bWwgZW50aXRpZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUh0bWxFbnRpdGllcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYUF9BVFRSX1ZBTFVFXzEsIGZ1bmN0aW9uIHJlcGxhY2VVbmljb2RlKHN0ciwgY29kZSkge1xuICAgIHJldHVybiBjb2RlWzBdID09PSBcInhcIiB8fCBjb2RlWzBdID09PSBcIlhcIlxuICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGNvZGUuc3Vic3RyKDEpLCAxNikpXG4gICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoY29kZSwgMTApKTtcbiAgfSk7XG59XG5cbi8qKlxuICogZXNjYXBlIGh0bWw1IG5ldyBkYW5nZXIgZW50aXRpZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZURhbmdlckh0bWw1RW50aXRpZXMoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShSRUdFWFBfQVRUUl9WQUxVRV9DT0xPTiwgXCI6XCIpXG4gICAgLnJlcGxhY2UoUkVHRVhQX0FUVFJfVkFMVUVfTkVXTElORSwgXCIgXCIpO1xufVxuXG4vKipcbiAqIGNsZWFyIG5vbnByaW50YWJsZSBjaGFyYWN0ZXJzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBjbGVhck5vblByaW50YWJsZUNoYXJhY3RlcihzdHIpIHtcbiAgdmFyIHN0cjIgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc3RyMiArPSBzdHIuY2hhckNvZGVBdChpKSA8IDMyID8gXCIgXCIgOiBzdHIuY2hhckF0KGkpO1xuICB9XG4gIHJldHVybiBfLnRyaW0oc3RyMik7XG59XG5cbi8qKlxuICogZ2V0IGZyaWVuZGx5IGF0dHJpYnV0ZSB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZnJpZW5kbHlBdHRyVmFsdWUoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlUXVvdGUoc3RyKTtcbiAgc3RyID0gZXNjYXBlSHRtbEVudGl0aWVzKHN0cik7XG4gIHN0ciA9IGVzY2FwZURhbmdlckh0bWw1RW50aXRpZXMoc3RyKTtcbiAgc3RyID0gY2xlYXJOb25QcmludGFibGVDaGFyYWN0ZXIoc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiB1bmVzY2FwZSBhdHRyaWJ1dGUgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUF0dHJWYWx1ZShzdHIpIHtcbiAgc3RyID0gZXNjYXBlUXVvdGUoc3RyKTtcbiAgc3RyID0gZXNjYXBlSHRtbChzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIGBvbklnbm9yZVRhZ2AgZnVuY3Rpb24gZm9yIHJlbW92aW5nIGFsbCB0aGUgdGFncyB0aGF0IGFyZSBub3QgaW4gd2hpdGVsaXN0XG4gKi9cbmZ1bmN0aW9uIG9uSWdub3JlVGFnU3RyaXBBbGwoKSB7XG4gIHJldHVybiBcIlwiO1xufVxuXG4vKipcbiAqIHJlbW92ZSB0YWcgYm9keVxuICogc3BlY2lmeSBhIGB0YWdzYCBsaXN0LCBpZiB0aGUgdGFnIGlzIG5vdCBpbiB0aGUgYHRhZ3NgIGxpc3QgdGhlbiBwcm9jZXNzIGJ5IHRoZSBzcGVjaWZ5IGZ1bmN0aW9uIChvcHRpb25hbClcbiAqXG4gKiBAcGFyYW0ge2FycmF5fSB0YWdzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBuZXh0XG4gKi9cbmZ1bmN0aW9uIFN0cmlwVGFnQm9keSh0YWdzLCBuZXh0KSB7XG4gIGlmICh0eXBlb2YgbmV4dCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgbmV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgdmFyIGlzUmVtb3ZlQWxsVGFnID0gIUFycmF5LmlzQXJyYXkodGFncyk7XG4gIGZ1bmN0aW9uIGlzUmVtb3ZlVGFnKHRhZykge1xuICAgIGlmIChpc1JlbW92ZUFsbFRhZykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIF8uaW5kZXhPZih0YWdzLCB0YWcpICE9PSAtMTtcbiAgfVxuXG4gIHZhciByZW1vdmVMaXN0ID0gW107XG4gIHZhciBwb3NTdGFydCA9IGZhbHNlO1xuXG4gIHJldHVybiB7XG4gICAgb25JZ25vcmVUYWc6IGZ1bmN0aW9uICh0YWcsIGh0bWwsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChpc1JlbW92ZVRhZyh0YWcpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlzQ2xvc2luZykge1xuICAgICAgICAgIHZhciByZXQgPSBcIlsvcmVtb3ZlZF1cIjtcbiAgICAgICAgICB2YXIgZW5kID0gb3B0aW9ucy5wb3NpdGlvbiArIHJldC5sZW5ndGg7XG4gICAgICAgICAgcmVtb3ZlTGlzdC5wdXNoKFtcbiAgICAgICAgICAgIHBvc1N0YXJ0ICE9PSBmYWxzZSA/IHBvc1N0YXJ0IDogb3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBwb3NTdGFydCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFwb3NTdGFydCkge1xuICAgICAgICAgICAgcG9zU3RhcnQgPSBvcHRpb25zLnBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJbcmVtb3ZlZF1cIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5leHQodGFnLCBodG1sLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgIHZhciByZXRodG1sID0gXCJcIjtcbiAgICAgIHZhciBsYXN0UG9zID0gMDtcbiAgICAgIF8uZm9yRWFjaChyZW1vdmVMaXN0LCBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldGh0bWwgKz0gaHRtbC5zbGljZShsYXN0UG9zLCBwb3NbMF0pO1xuICAgICAgICBsYXN0UG9zID0gcG9zWzFdO1xuICAgICAgfSk7XG4gICAgICByZXRodG1sICs9IGh0bWwuc2xpY2UobGFzdFBvcyk7XG4gICAgICByZXR1cm4gcmV0aHRtbDtcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIHJlbW92ZSBodG1sIGNvbW1lbnRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaXBDb21tZW50VGFnKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZShTVFJJUF9DT01NRU5UX1RBR19SRUdFWFAsIFwiXCIpO1xufVxudmFyIFNUUklQX0NPTU1FTlRfVEFHX1JFR0VYUCA9IC88IS0tW1xcc1xcU10qPy0tPi9nO1xuXG4vKipcbiAqIHJlbW92ZSBpbnZpc2libGUgY2hhcmFjdGVyc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmlwQmxhbmtDaGFyKGh0bWwpIHtcbiAgdmFyIGNoYXJzID0gaHRtbC5zcGxpdChcIlwiKTtcbiAgY2hhcnMgPSBjaGFycy5maWx0ZXIoZnVuY3Rpb24gKGNoYXIpIHtcbiAgICB2YXIgYyA9IGNoYXIuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoYyA9PT0gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGMgPD0gMzEpIHtcbiAgICAgIGlmIChjID09PSAxMCB8fCBjID09PSAxMykgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG59XG5cbmV4cG9ydHMud2hpdGVMaXN0ID0gZ2V0RGVmYXVsdFdoaXRlTGlzdCgpO1xuZXhwb3J0cy5nZXREZWZhdWx0V2hpdGVMaXN0ID0gZ2V0RGVmYXVsdFdoaXRlTGlzdDtcbmV4cG9ydHMub25UYWcgPSBvblRhZztcbmV4cG9ydHMub25JZ25vcmVUYWcgPSBvbklnbm9yZVRhZztcbmV4cG9ydHMub25UYWdBdHRyID0gb25UYWdBdHRyO1xuZXhwb3J0cy5vbklnbm9yZVRhZ0F0dHIgPSBvbklnbm9yZVRhZ0F0dHI7XG5leHBvcnRzLnNhZmVBdHRyVmFsdWUgPSBzYWZlQXR0clZhbHVlO1xuZXhwb3J0cy5lc2NhcGVIdG1sID0gZXNjYXBlSHRtbDtcbmV4cG9ydHMuZXNjYXBlUXVvdGUgPSBlc2NhcGVRdW90ZTtcbmV4cG9ydHMudW5lc2NhcGVRdW90ZSA9IHVuZXNjYXBlUXVvdGU7XG5leHBvcnRzLmVzY2FwZUh0bWxFbnRpdGllcyA9IGVzY2FwZUh0bWxFbnRpdGllcztcbmV4cG9ydHMuZXNjYXBlRGFuZ2VySHRtbDVFbnRpdGllcyA9IGVzY2FwZURhbmdlckh0bWw1RW50aXRpZXM7XG5leHBvcnRzLmNsZWFyTm9uUHJpbnRhYmxlQ2hhcmFjdGVyID0gY2xlYXJOb25QcmludGFibGVDaGFyYWN0ZXI7XG5leHBvcnRzLmZyaWVuZGx5QXR0clZhbHVlID0gZnJpZW5kbHlBdHRyVmFsdWU7XG5leHBvcnRzLmVzY2FwZUF0dHJWYWx1ZSA9IGVzY2FwZUF0dHJWYWx1ZTtcbmV4cG9ydHMub25JZ25vcmVUYWdTdHJpcEFsbCA9IG9uSWdub3JlVGFnU3RyaXBBbGw7XG5leHBvcnRzLlN0cmlwVGFnQm9keSA9IFN0cmlwVGFnQm9keTtcbmV4cG9ydHMuc3RyaXBDb21tZW50VGFnID0gc3RyaXBDb21tZW50VGFnO1xuZXhwb3J0cy5zdHJpcEJsYW5rQ2hhciA9IHN0cmlwQmxhbmtDaGFyO1xuZXhwb3J0cy5jc3NGaWx0ZXIgPSBkZWZhdWx0Q1NTRmlsdGVyO1xuZXhwb3J0cy5nZXREZWZhdWx0Q1NTV2hpdGVMaXN0ID0gZ2V0RGVmYXVsdENTU1doaXRlTGlzdDtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogY3NzZmlsdGVyXG4gKlxuICogQGF1dGhvciDogIHpm7c8bGVpem9uZ21pbkBnbWFpbC5jb20+XG4gKi9cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFdoaXRlTGlzdCAoKSB7XG4gIC8vIOeZveWQjeWNleWAvOivtOaYju+8mlxuICAvLyB0cnVlOiDlhYHorrjor6XlsZ7mgKdcbiAgLy8gRnVuY3Rpb246IGZ1bmN0aW9uICh2YWwpIHsgfSDov5Tlm550cnVl6KGo56S65YWB6K646K+l5bGe5oCn77yM5YW25LuW5YC85Z2H6KGo56S65LiN5YWB6K64XG4gIC8vIFJlZ0V4cDogcmVnZXhwLnRlc3QodmFsKSDov5Tlm550cnVl6KGo56S65YWB6K646K+l5bGe5oCn77yM5YW25LuW5YC85Z2H6KGo56S65LiN5YWB6K64XG4gIC8vIOmZpOS4iumdouWIl+WHuueahOWAvOWkluWdh+ihqOekuuS4jeWFgeiuuFxuICB2YXIgd2hpdGVMaXN0ID0ge307XG5cbiAgd2hpdGVMaXN0WydhbGlnbi1jb250ZW50J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2FsaWduLWl0ZW1zJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2FsaWduLXNlbGYnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnYWxpZ25tZW50LWFkanVzdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydhbGlnbm1lbnQtYmFzZWxpbmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBiYXNlbGluZVxuICB3aGl0ZUxpc3RbJ2FsbCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydhbmNob3ItcG9pbnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYW5pbWF0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2FuaW1hdGlvbi1kZWxheSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydhbmltYXRpb24tZGlyZWN0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnYW5pbWF0aW9uLWR1cmF0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ2FuaW1hdGlvbi1maWxsLW1vZGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDFcbiAgd2hpdGVMaXN0WydhbmltYXRpb24tbmFtZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydhbmltYXRpb24tcGxheS1zdGF0ZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IHJ1bm5pbmdcbiAgd2hpdGVMaXN0WydhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZWFzZVxuICB3aGl0ZUxpc3RbJ2F6aW11dGgnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBjZW50ZXJcbiAgd2hpdGVMaXN0WydiYWNrZmFjZS12aXNpYmlsaXR5J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogdmlzaWJsZVxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydiYWNrZ3JvdW5kLWF0dGFjaG1lbnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHNjcm9sbFxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtY2xpcCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYm9yZGVyLWJveFxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtY29sb3InXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHRyYW5zcGFyZW50XG4gIHdoaXRlTGlzdFsnYmFja2dyb3VuZC1pbWFnZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtb3JpZ2luJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBwYWRkaW5nLWJveFxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtcG9zaXRpb24nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDAlIDAlXG4gIHdoaXRlTGlzdFsnYmFja2dyb3VuZC1yZXBlYXQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHJlcGVhdFxuICB3aGl0ZUxpc3RbJ2JhY2tncm91bmQtc2l6ZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2Jhc2VsaW5lLXNoaWZ0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYmFzZWxpbmVcbiAgd2hpdGVMaXN0WydiaW5kaW5nJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2JsZWVkJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogNnB0XG4gIHdoaXRlTGlzdFsnYm9va21hcmstbGFiZWwnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBjb250ZW50KClcbiAgd2hpdGVMaXN0Wydib29rbWFyay1sZXZlbCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydib29rbWFyay1zdGF0ZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG9wZW5cbiAgd2hpdGVMaXN0Wydib3JkZXInXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wydib3JkZXItYm90dG9tJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWJvdHRvbS1jb2xvciddID0gdHJ1ZTsgLy8gZGVmYXVsdDogY3VycmVudCBjb2xvclxuICB3aGl0ZUxpc3RbJ2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wydib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ2JvcmRlci1ib3R0b20tc3R5bGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydib3JkZXItYm90dG9tLXdpZHRoJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBtZWRpdW1cbiAgd2hpdGVMaXN0Wydib3JkZXItY29sbGFwc2UnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHNlcGFyYXRlXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWNvbG9yJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWltYWdlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWltYWdlLW91dHNldCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ2JvcmRlci1pbWFnZS1yZXBlYXQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IHN0cmV0Y2hcbiAgd2hpdGVMaXN0Wydib3JkZXItaW1hZ2Utc2xpY2UnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDEwMCVcbiAgd2hpdGVMaXN0Wydib3JkZXItaW1hZ2Utc291cmNlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWltYWdlLXdpZHRoJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAxXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWxlZnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wydib3JkZXItbGVmdC1jb2xvciddID0gdHJ1ZTsgLy8gZGVmYXVsdDogY3VycmVudCBjb2xvclxuICB3aGl0ZUxpc3RbJ2JvcmRlci1sZWZ0LXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm9yZGVyLWxlZnQtd2lkdGgnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ2JvcmRlci1yYWRpdXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wydib3JkZXItcmlnaHQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wydib3JkZXItcmlnaHQtY29sb3InXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGN1cnJlbnQgY29sb3JcbiAgd2hpdGVMaXN0Wydib3JkZXItcmlnaHQtc3R5bGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydib3JkZXItcmlnaHQtd2lkdGgnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ2JvcmRlci1zcGFjaW5nJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXRvcCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2JvcmRlci10b3AtY29sb3InXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGN1cnJlbnQgY29sb3JcbiAgd2hpdGVMaXN0Wydib3JkZXItdG9wLWxlZnQtcmFkaXVzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wydib3JkZXItdG9wLXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXRvcC13aWR0aCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbWVkaXVtXG4gIHdoaXRlTGlzdFsnYm9yZGVyLXdpZHRoJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnYm90dG9tJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2JveC1kZWNvcmF0aW9uLWJyZWFrJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBzbGljZVxuICB3aGl0ZUxpc3RbJ2JveC1zaGFkb3cnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydib3gtc2l6aW5nJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBjb250ZW50LWJveFxuICB3aGl0ZUxpc3RbJ2JveC1zbmFwJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnYm94LXN1cHByZXNzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBzaG93XG4gIHdoaXRlTGlzdFsnYnJlYWstYWZ0ZXInXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydicmVhay1iZWZvcmUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydicmVhay1pbnNpZGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydjYXB0aW9uLXNpZGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiB0b3BcbiAgd2hpdGVMaXN0WydjaGFpbnMnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY2xlYXInXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydjbGlwJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2NsaXAtcGF0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydjbGlwLXJ1bGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub256ZXJvXG4gIHdoaXRlTGlzdFsnY29sb3InXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGltcGxlbWVudGF0aW9uIGRlcGVuZGVudFxuICB3aGl0ZUxpc3RbJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2NvbHVtbi1jb3VudCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wydjb2x1bW4tZmlsbCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGJhbGFuY2VcbiAgd2hpdGVMaXN0Wydjb2x1bW4tZ2FwJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnY29sdW1uLXJ1bGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnY29sdW1uLXJ1bGUtY29sb3InXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBjdXJyZW50IGNvbG9yXG4gIHdoaXRlTGlzdFsnY29sdW1uLXJ1bGUtc3R5bGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBtZWRpdW1cbiAgd2hpdGVMaXN0Wydjb2x1bW4tcnVsZS13aWR0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ2NvbHVtbi1zcGFuJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2NvbHVtbi13aWR0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wydjb2x1bW5zJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2NvbnRhaW4nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY29udGVudCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2NvdW50ZXItaW5jcmVtZW50J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2NvdW50ZXItcmVzZXQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY291bnRlci1zZXQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY3JvcCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydjdWUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnY3VlLWFmdGVyJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2N1ZS1iZWZvcmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnY3Vyc29yJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2RpcmVjdGlvbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGx0clxuICB3aGl0ZUxpc3RbJ2Rpc3BsYXknXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydkaXNwbGF5LWluc2lkZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2Rpc3BsYXktbGlzdCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2Rpc3BsYXktb3V0c2lkZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogaW5saW5lLWxldmVsXG4gIHdoaXRlTGlzdFsnZG9taW5hbnQtYmFzZWxpbmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnZWxldmF0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbGV2ZWxcbiAgd2hpdGVMaXN0WydlbXB0eS1jZWxscyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IHNob3dcbiAgd2hpdGVMaXN0WydmaWx0ZXInXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnZmxleCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydmbGV4LWJhc2lzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2ZsZXgtZGlyZWN0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogcm93XG4gIHdoaXRlTGlzdFsnZmxleC1mbG93J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2ZsZXgtZ3JvdyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydmbGV4LXNocmluayddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDFcbiAgd2hpdGVMaXN0WydmbGV4LXdyYXAnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub3dyYXBcbiAgd2hpdGVMaXN0WydmbG9hdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydmbG9hdC1vZmZzZXQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiAwIDBcbiAgd2hpdGVMaXN0WydmbG9vZC1jb2xvciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGJsYWNrXG4gIHdoaXRlTGlzdFsnZmxvb2Qtb3BhY2l0eSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDFcbiAgd2hpdGVMaXN0WydmbG93LWZyb20nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnZmxvdy1pbnRvJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2ZvbnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wydmb250LWZhbWlseSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogaW1wbGVtZW50YXRpb24gZGVwZW5kZW50XG4gIHdoaXRlTGlzdFsnZm9udC1mZWF0dXJlLXNldHRpbmdzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wydmb250LWtlcm5pbmcnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wydmb250LWxhbmd1YWdlLW92ZXJyaWRlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wydmb250LXNpemUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ2ZvbnQtc2l6ZS1hZGp1c3QnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wydmb250LXN0cmV0Y2gnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtc3R5bGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtc3ludGhlc2lzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiB3ZWlnaHQgc3R5bGVcbiAgd2hpdGVMaXN0Wydmb250LXZhcmlhbnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtdmFyaWFudC1hbHRlcm5hdGVzJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wydmb250LXZhcmlhbnQtY2FwcyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnZm9udC12YXJpYW50LWVhc3QtYXNpYW4nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtdmFyaWFudC1saWdhdHVyZXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtdmFyaWFudC1udW1lcmljJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wydmb250LXZhcmlhbnQtcG9zaXRpb24nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ZvbnQtd2VpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0WydncmlkJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ2dyaWQtYXJlYSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydncmlkLWF1dG8tY29sdW1ucyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydncmlkLWF1dG8tZmxvdyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydncmlkLWF1dG8tcm93cyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydncmlkLWNvbHVtbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydncmlkLWNvbHVtbi1lbmQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnZ3JpZC1jb2x1bW4tc3RhcnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnZ3JpZC1yb3cnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnZ3JpZC1yb3ctZW5kJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2dyaWQtcm93LXN0YXJ0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2dyaWQtdGVtcGxhdGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnZ3JpZC10ZW1wbGF0ZS1hcmVhcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydncmlkLXRlbXBsYXRlLWNvbHVtbnMnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnZ3JpZC10ZW1wbGF0ZS1yb3dzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2hhbmdpbmctcHVuY3R1YXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnaGVpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnaHlwaGVucyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1hbnVhbFxuICB3aGl0ZUxpc3RbJ2ljb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnaW1hZ2Utb3JpZW50YXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnaW1hZ2UtcmVzb2x1dGlvbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2ltZS1tb2RlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2luaXRpYWwtbGV0dGVycyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2lubGluZS1ib3gtYWxpZ24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBsYXN0XG4gIHdoaXRlTGlzdFsnanVzdGlmeS1jb250ZW50J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2p1c3RpZnktaXRlbXMnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnanVzdGlmeS1zZWxmJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2xlZnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnbGV0dGVyLXNwYWNpbmcnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ2xpZ2h0aW5nLWNvbG9yJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiB3aGl0ZVxuICB3aGl0ZUxpc3RbJ2xpbmUtYm94LWNvbnRhaW4nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBibG9jayBpbmxpbmUgcmVwbGFjZWRcbiAgd2hpdGVMaXN0WydsaW5lLWJyZWFrJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ2xpbmUtZ3JpZCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1hdGNoLXBhcmVudFxuICB3aGl0ZUxpc3RbJ2xpbmUtaGVpZ2h0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnbGluZS1zbmFwJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2xpbmUtc3RhY2tpbmcnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnbGluZS1zdGFja2luZy1ydWJ5J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZXhjbHVkZS1ydWJ5XG4gIHdoaXRlTGlzdFsnbGluZS1zdGFja2luZy1zaGlmdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGNvbnNpZGVyLXNoaWZ0c1xuICB3aGl0ZUxpc3RbJ2xpbmUtc3RhY2tpbmctc3RyYXRlZ3knXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBpbmxpbmUtbGluZS1oZWlnaHRcbiAgd2hpdGVMaXN0WydsaXN0LXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnbGlzdC1zdHlsZS1pbWFnZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ2xpc3Qtc3R5bGUtcG9zaXRpb24nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG91dHNpZGVcbiAgd2hpdGVMaXN0WydsaXN0LXN0eWxlLXR5cGUnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRpc2NcbiAgd2hpdGVMaXN0WydtYXJnaW4nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0WydtYXJnaW4tYm90dG9tJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnbWFyZ2luLWxlZnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydtYXJnaW4tcmlnaHQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydtYXJnaW4tdG9wJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnbWFya2VyLW9mZnNldCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydtYXJrZXItc2lkZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGxpc3QtaXRlbVxuICB3aGl0ZUxpc3RbJ21hcmtzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ21hc2snXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBib3JkZXItYm94XG4gIHdoaXRlTGlzdFsnbWFzay1ib3gnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBzZWUgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnbWFzay1ib3gtb3V0c2V0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ21hc2stYm94LXJlcGVhdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IHN0cmV0Y2hcbiAgd2hpdGVMaXN0WydtYXNrLWJveC1zbGljZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDAgZmlsbFxuICB3aGl0ZUxpc3RbJ21hc2stYm94LXNvdXJjZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydtYXNrLWJveC13aWR0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydtYXNrLWNsaXAnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBib3JkZXItYm94XG4gIHdoaXRlTGlzdFsnbWFzay1pbWFnZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydtYXNrLW9yaWdpbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGJvcmRlci1ib3hcbiAgd2hpdGVMaXN0WydtYXNrLXBvc2l0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogY2VudGVyXG4gIHdoaXRlTGlzdFsnbWFzay1yZXBlYXQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBuby1yZXBlYXRcbiAgd2hpdGVMaXN0WydtYXNrLXNpemUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBib3JkZXItYm94XG4gIHdoaXRlTGlzdFsnbWFzay1zb3VyY2UtdHlwZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydtYXNrLXR5cGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBsdW1pbmFuY2VcbiAgd2hpdGVMaXN0WydtYXgtaGVpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnbWF4LWxpbmVzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ21heC13aWR0aCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ21pbi1oZWlnaHQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydtaW4td2lkdGgnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wydtb3ZlLXRvJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnbmF2LWRvd24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnbmF2LWluZGV4J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ25hdi1sZWZ0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ25hdi1yaWdodCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WyduYXYtdXAnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnb2JqZWN0LWZpdCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGZpbGxcbiAgd2hpdGVMaXN0WydvYmplY3QtcG9zaXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiA1MCUgNTAlXG4gIHdoaXRlTGlzdFsnb3BhY2l0eSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDFcbiAgd2hpdGVMaXN0WydvcmRlciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0WydvcnBoYW5zJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMlxuICB3aGl0ZUxpc3RbJ291dGxpbmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsnb3V0bGluZS1jb2xvciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGludmVydFxuICB3aGl0ZUxpc3RbJ291dGxpbmUtb2Zmc2V0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ291dGxpbmUtc3R5bGUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsnb3V0bGluZS13aWR0aCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ292ZXJmbG93J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ292ZXJmbG93LXdyYXAnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0WydvdmVyZmxvdy14J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogdmlzaWJsZVxuICB3aGl0ZUxpc3RbJ292ZXJmbG93LXknXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiB2aXNpYmxlXG4gIHdoaXRlTGlzdFsncGFkZGluZyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogZGVwZW5kaW5nIG9uIGluZGl2aWR1YWwgcHJvcGVydGllc1xuICB3aGl0ZUxpc3RbJ3BhZGRpbmctYm90dG9tJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsncGFkZGluZy1sZWZ0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsncGFkZGluZy1yaWdodCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ3BhZGRpbmctdG9wJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsncGFnZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydwYWdlLWJyZWFrLWFmdGVyJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3BhZ2UtYnJlYWstYmVmb3JlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3BhZ2UtYnJlYWstaW5zaWRlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3BhZ2UtcG9saWN5J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogc3RhcnRcbiAgd2hpdGVMaXN0WydwYXVzZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGltcGxlbWVudGF0aW9uIGRlcGVuZGVudFxuICB3aGl0ZUxpc3RbJ3BhdXNlLWFmdGVyJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogaW1wbGVtZW50YXRpb24gZGVwZW5kZW50XG4gIHdoaXRlTGlzdFsncGF1c2UtYmVmb3JlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogaW1wbGVtZW50YXRpb24gZGVwZW5kZW50XG4gIHdoaXRlTGlzdFsncGVyc3BlY3RpdmUnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsncGVyc3BlY3RpdmUtb3JpZ2luJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogNTAlIDUwJVxuICB3aGl0ZUxpc3RbJ3BpdGNoJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbWVkaXVtXG4gIHdoaXRlTGlzdFsncGl0Y2gtcmFuZ2UnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiA1MFxuICB3aGl0ZUxpc3RbJ3BsYXktZHVyaW5nJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3Bvc2l0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogc3RhdGljXG4gIHdoaXRlTGlzdFsncHJlc2VudGF0aW9uLWxldmVsJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMFxuICB3aGl0ZUxpc3RbJ3F1b3RlcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IHRleHRcbiAgd2hpdGVMaXN0WydyZWdpb24tZnJhZ21lbnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsncmVzaXplJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3Jlc3QnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsncmVzdC1hZnRlciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydyZXN0LWJlZm9yZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydyaWNobmVzcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDUwXG4gIHdoaXRlTGlzdFsncmlnaHQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsncm90YXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsncm90YXRpb24tcG9pbnQnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiA1MCUgNTAlXG4gIHdoaXRlTGlzdFsncnVieS1hbGlnbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydydWJ5LW1lcmdlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogc2VwYXJhdGVcbiAgd2hpdGVMaXN0WydydWJ5LXBvc2l0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYmVmb3JlXG4gIHdoaXRlTGlzdFsnc2hhcGUtaW1hZ2UtdGhyZXNob2xkJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMC4wXG4gIHdoaXRlTGlzdFsnc2hhcGUtb3V0c2lkZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0WydzaGFwZS1tYXJnaW4nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiAwXG4gIHdoaXRlTGlzdFsnc2l6ZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydzcGVhayddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0WydzcGVhay1hcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3NwZWFrLWhlYWRlciddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG9uY2VcbiAgd2hpdGVMaXN0WydzcGVhay1udW1lcmFsJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogY29udGludW91c1xuICB3aGl0ZUxpc3RbJ3NwZWFrLXB1bmN0dWF0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3NwZWVjaC1yYXRlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbWVkaXVtXG4gIHdoaXRlTGlzdFsnc3RyZXNzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogNTBcbiAgd2hpdGVMaXN0WydzdHJpbmctc2V0J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3RhYi1zaXplJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogOFxuICB3aGl0ZUxpc3RbJ3RhYmxlLWxheW91dCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wyd0ZXh0LWFsaWduJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBzdGFydFxuICB3aGl0ZUxpc3RbJ3RleHQtYWxpZ24tbGFzdCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3RleHQtY29tYmluZS11cHJpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsndGV4dC1kZWNvcmF0aW9uJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub25lXG4gIHdoaXRlTGlzdFsndGV4dC1kZWNvcmF0aW9uLWNvbG9yJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBjdXJyZW50Q29sb3JcbiAgd2hpdGVMaXN0Wyd0ZXh0LWRlY29yYXRpb24tbGluZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3RleHQtZGVjb3JhdGlvbi1za2lwJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBvYmplY3RzXG4gIHdoaXRlTGlzdFsndGV4dC1kZWNvcmF0aW9uLXN0eWxlJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBzb2xpZFxuICB3aGl0ZUxpc3RbJ3RleHQtZW1waGFzaXMnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGRlcGVuZGluZyBvbiBpbmRpdmlkdWFsIHByb3BlcnRpZXNcbiAgd2hpdGVMaXN0Wyd0ZXh0LWVtcGhhc2lzLWNvbG9yJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBjdXJyZW50Q29sb3JcbiAgd2hpdGVMaXN0Wyd0ZXh0LWVtcGhhc2lzLXBvc2l0aW9uJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBvdmVyIHJpZ2h0XG4gIHdoaXRlTGlzdFsndGV4dC1lbXBoYXNpcy1zdHlsZSddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3RleHQtaGVpZ2h0J10gPSB0cnVlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsndGV4dC1pbmRlbnQnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IDBcbiAgd2hpdGVMaXN0Wyd0ZXh0LWp1c3RpZnknXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wyd0ZXh0LW9yaWVudGF0aW9uJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBtaXhlZFxuICB3aGl0ZUxpc3RbJ3RleHQtb3ZlcmZsb3cnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGNsaXBcbiAgd2hpdGVMaXN0Wyd0ZXh0LXNoYWRvdyddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9uZVxuICB3aGl0ZUxpc3RbJ3RleHQtc3BhY2UtY29sbGFwc2UnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IGNvbGxhcHNlXG4gIHdoaXRlTGlzdFsndGV4dC10cmFuc2Zvcm0nXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wyd0ZXh0LXVuZGVybGluZS1wb3NpdGlvbiddID0gdHJ1ZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3RleHQtd3JhcCddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsndG9wJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYXV0b1xuICB3aGl0ZUxpc3RbJ3RyYW5zZm9ybSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vbmVcbiAgd2hpdGVMaXN0Wyd0cmFuc2Zvcm0tb3JpZ2luJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogNTAlIDUwJSAwXG4gIHdoaXRlTGlzdFsndHJhbnNmb3JtLXN0eWxlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZmxhdFxuICB3aGl0ZUxpc3RbJ3RyYW5zaXRpb24nXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBkZXBlbmRpbmcgb24gaW5kaXZpZHVhbCBwcm9wZXJ0aWVzXG4gIHdoaXRlTGlzdFsndHJhbnNpdGlvbi1kZWxheSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBzXG4gIHdoaXRlTGlzdFsndHJhbnNpdGlvbi1kdXJhdGlvbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IDBzXG4gIHdoaXRlTGlzdFsndHJhbnNpdGlvbi1wcm9wZXJ0eSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGFsbFxuICB3aGl0ZUxpc3RbJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogZWFzZVxuICB3aGl0ZUxpc3RbJ3VuaWNvZGUtYmlkaSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3ZlcnRpY2FsLWFsaWduJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogYmFzZWxpbmVcbiAgd2hpdGVMaXN0Wyd2aXNpYmlsaXR5J10gPSBmYWxzZTsgLy8gZGVmYXVsdDogdmlzaWJsZVxuICB3aGl0ZUxpc3RbJ3ZvaWNlLWJhbGFuY2UnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBjZW50ZXJcbiAgd2hpdGVMaXN0Wyd2b2ljZS1kdXJhdGlvbiddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wyd2b2ljZS1mYW1pbHknXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBpbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnRcbiAgd2hpdGVMaXN0Wyd2b2ljZS1waXRjaCddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ3ZvaWNlLXJhbmdlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbWVkaXVtXG4gIHdoaXRlTGlzdFsndm9pY2UtcmF0ZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3ZvaWNlLXN0cmVzcyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3ZvaWNlLXZvbHVtZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ3ZvbHVtZSddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IG1lZGl1bVxuICB3aGl0ZUxpc3RbJ3doaXRlLXNwYWNlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnd2lkb3dzJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogMlxuICB3aGl0ZUxpc3RbJ3dpZHRoJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnd2lsbC1jaGFuZ2UnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG4gIHdoaXRlTGlzdFsnd29yZC1icmVhayddID0gdHJ1ZTsgLy8gZGVmYXVsdDogbm9ybWFsXG4gIHdoaXRlTGlzdFsnd29yZC1zcGFjaW5nJ10gPSB0cnVlOyAvLyBkZWZhdWx0OiBub3JtYWxcbiAgd2hpdGVMaXN0Wyd3b3JkLXdyYXAnXSA9IHRydWU7IC8vIGRlZmF1bHQ6IG5vcm1hbFxuICB3aGl0ZUxpc3RbJ3dyYXAtZmxvdyddID0gZmFsc2U7IC8vIGRlZmF1bHQ6IGF1dG9cbiAgd2hpdGVMaXN0Wyd3cmFwLXRocm91Z2gnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiB3cmFwXG4gIHdoaXRlTGlzdFsnd3JpdGluZy1tb2RlJ10gPSBmYWxzZTsgLy8gZGVmYXVsdDogaG9yaXpvbnRhbC10YlxuICB3aGl0ZUxpc3RbJ3otaW5kZXgnXSA9IGZhbHNlOyAvLyBkZWZhdWx0OiBhdXRvXG5cbiAgcmV0dXJuIHdoaXRlTGlzdDtcbn1cblxuXG4vKipcbiAqIOWMuemFjeWIsOeZveWQjeWNleS4iueahOS4gOS4quWxnuaAp+aXtlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uQXR0ciAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgLy8gZG8gbm90aGluZ1xufVxuXG4vKipcbiAqIOWMuemFjeWIsOS4jeWcqOeZveWQjeWNleS4iueahOS4gOS4quWxnuaAp+aXtlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIG9uSWdub3JlQXR0ciAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgLy8gZG8gbm90aGluZ1xufVxuXG52YXIgUkVHRVhQX1VSTF9KQVZBU0NSSVBUID0gL2phdmFzY3JpcHRcXHMqXFw6L2ltZztcblxuLyoqXG4gKiDov4fmu6TlsZ7mgKflgLxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNhZmVBdHRyVmFsdWUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKFJFR0VYUF9VUkxfSkFWQVNDUklQVC50ZXN0KHZhbHVlKSkgcmV0dXJuICcnO1xuICByZXR1cm4gdmFsdWU7XG59XG5cblxuZXhwb3J0cy53aGl0ZUxpc3QgPSBnZXREZWZhdWx0V2hpdGVMaXN0KCk7XG5leHBvcnRzLmdldERlZmF1bHRXaGl0ZUxpc3QgPSBnZXREZWZhdWx0V2hpdGVMaXN0O1xuZXhwb3J0cy5vbkF0dHIgPSBvbkF0dHI7XG5leHBvcnRzLm9uSWdub3JlQXR0ciA9IG9uSWdub3JlQXR0cjtcbmV4cG9ydHMuc2FmZUF0dHJWYWx1ZSA9IHNhZmVBdHRyVmFsdWU7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5kZXhPZjogZnVuY3Rpb24gKGFyciwgaXRlbSkge1xuICAgIHZhciBpLCBqO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgcmV0dXJuIGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBqID0gYXJyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9LFxuICBmb3JFYWNoOiBmdW5jdGlvbiAoYXJyLCBmbiwgc2NvcGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICAgIHJldHVybiBhcnIuZm9yRWFjaChmbiwgc2NvcGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBqID0gYXJyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgZm4uY2FsbChzY29wZSwgYXJyW2ldLCBpLCBhcnIpO1xuICAgIH1cbiAgfSxcbiAgdHJpbTogZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChTdHJpbmcucHJvdG90eXBlLnRyaW0pIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyheXFxzKil8KFxccyokKS9nLCAnJyk7XG4gIH0sXG4gIHRyaW1SaWdodDogZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChTdHJpbmcucHJvdG90eXBlLnRyaW1SaWdodCkge1xuICAgICAgcmV0dXJuIHN0ci50cmltUmlnaHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oXFxzKiQpL2csICcnKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2ltcGxlIEhUTUwgUGFyc2VyXG4gKlxuICogQGF1dGhvciBab25nbWluIExlaTxsZWl6b25nbWluQGdtYWlsLmNvbT5cbiAqL1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG4vKipcbiAqIGdldCB0YWcgbmFtZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIGUuZy4gJzxhIGhlZj1cIiNcIj4nXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFRhZ05hbWUoaHRtbCkge1xuICB2YXIgaSA9IF8uc3BhY2VJbmRleChodG1sKTtcbiAgaWYgKGkgPT09IC0xKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBodG1sLnNsaWNlKDEsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnTmFtZSA9IGh0bWwuc2xpY2UoMSwgaSArIDEpO1xuICB9XG4gIHRhZ05hbWUgPSBfLnRyaW0odGFnTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHRhZ05hbWUuc2xpY2UoMCwgMSkgPT09IFwiL1wiKSB0YWdOYW1lID0gdGFnTmFtZS5zbGljZSgxKTtcbiAgaWYgKHRhZ05hbWUuc2xpY2UoLTEpID09PSBcIi9cIikgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gdGFnTmFtZTtcbn1cblxuLyoqXG4gKiBpcyBjbG9zZSB0YWc/XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWwg5aaC77yaJzxhIGhlZj1cIiNcIj4nXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Nsb3NpbmcoaHRtbCkge1xuICByZXR1cm4gaHRtbC5zbGljZSgwLCAyKSA9PT0gXCI8L1wiO1xufVxuXG4vKipcbiAqIHBhcnNlIGlucHV0IGh0bWwgYW5kIHJldHVybnMgcHJvY2Vzc2VkIGh0bWxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25UYWcgZS5nLiBmdW5jdGlvbiAoc291cmNlUG9zaXRpb24sIHBvc2l0aW9uLCB0YWcsIGh0bWwsIGlzQ2xvc2luZylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVzY2FwZUh0bWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcGFyc2VUYWcoaHRtbCwgb25UYWcsIGVzY2FwZUh0bWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIHJldGh0bWwgPSBcIlwiO1xuICB2YXIgbGFzdFBvcyA9IDA7XG4gIHZhciB0YWdTdGFydCA9IGZhbHNlO1xuICB2YXIgcXVvdGVTdGFydCA9IGZhbHNlO1xuICB2YXIgY3VycmVudFBvcyA9IDA7XG4gIHZhciBsZW4gPSBodG1sLmxlbmd0aDtcbiAgdmFyIGN1cnJlbnRUYWdOYW1lID0gXCJcIjtcbiAgdmFyIGN1cnJlbnRIdG1sID0gXCJcIjtcblxuICBjaGFyaXRlcmF0b3I6IGZvciAoY3VycmVudFBvcyA9IDA7IGN1cnJlbnRQb3MgPCBsZW47IGN1cnJlbnRQb3MrKykge1xuICAgIHZhciBjID0gaHRtbC5jaGFyQXQoY3VycmVudFBvcyk7XG4gICAgaWYgKHRhZ1N0YXJ0ID09PSBmYWxzZSkge1xuICAgICAgaWYgKGMgPT09IFwiPFwiKSB7XG4gICAgICAgIHRhZ1N0YXJ0ID0gY3VycmVudFBvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdW90ZVN0YXJ0ID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoYyA9PT0gXCI8XCIpIHtcbiAgICAgICAgICByZXRodG1sICs9IGVzY2FwZUh0bWwoaHRtbC5zbGljZShsYXN0UG9zLCBjdXJyZW50UG9zKSk7XG4gICAgICAgICAgdGFnU3RhcnQgPSBjdXJyZW50UG9zO1xuICAgICAgICAgIGxhc3RQb3MgPSBjdXJyZW50UG9zO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgIHJldGh0bWwgKz0gZXNjYXBlSHRtbChodG1sLnNsaWNlKGxhc3RQb3MsIHRhZ1N0YXJ0KSk7XG4gICAgICAgICAgY3VycmVudEh0bWwgPSBodG1sLnNsaWNlKHRhZ1N0YXJ0LCBjdXJyZW50UG9zICsgMSk7XG4gICAgICAgICAgY3VycmVudFRhZ05hbWUgPSBnZXRUYWdOYW1lKGN1cnJlbnRIdG1sKTtcbiAgICAgICAgICByZXRodG1sICs9IG9uVGFnKFxuICAgICAgICAgICAgdGFnU3RhcnQsXG4gICAgICAgICAgICByZXRodG1sLmxlbmd0aCxcbiAgICAgICAgICAgIGN1cnJlbnRUYWdOYW1lLFxuICAgICAgICAgICAgY3VycmVudEh0bWwsXG4gICAgICAgICAgICBpc0Nsb3NpbmcoY3VycmVudEh0bWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsYXN0UG9zID0gY3VycmVudFBvcyArIDE7XG4gICAgICAgICAgdGFnU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1wiJyB8fCBjID09PSBcIidcIikge1xuICAgICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgICB2YXIgaWMgPSBodG1sLmNoYXJBdChjdXJyZW50UG9zIC0gaSk7XG5cbiAgICAgICAgICB3aGlsZSAoaWMudHJpbSgpID09PSBcIlwiIHx8IGljID09PSBcIj1cIikge1xuICAgICAgICAgICAgaWYgKGljID09PSBcIj1cIikge1xuICAgICAgICAgICAgICBxdW90ZVN0YXJ0ID0gYztcbiAgICAgICAgICAgICAgY29udGludWUgY2hhcml0ZXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWMgPSBodG1sLmNoYXJBdChjdXJyZW50UG9zIC0gKytpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjID09PSBxdW90ZVN0YXJ0KSB7XG4gICAgICAgICAgcXVvdGVTdGFydCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXN0UG9zIDwgaHRtbC5sZW5ndGgpIHtcbiAgICByZXRodG1sICs9IGVzY2FwZUh0bWwoaHRtbC5zdWJzdHIobGFzdFBvcykpO1xuICB9XG5cbiAgcmV0dXJuIHJldGh0bWw7XG59XG5cbnZhciBSRUdFWFBfSUxMRUdBTF9BVFRSX05BTUUgPSAvW15hLXpBLVowLTlfOlxcLlxcLV0vZ2ltO1xuXG4vKipcbiAqIHBhcnNlIGlucHV0IGF0dHJpYnV0ZXMgYW5kIHJldHVybnMgcHJvY2Vzc2VkIGF0dHJpYnV0ZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBlLmcuIGBocmVmPVwiI1wiIHRhcmdldD1cIl9ibGFua1wiYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25BdHRyIGUuZy4gYGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSlgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXR0cihodG1sLCBvbkF0dHIpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgcmV0QXR0cnMgPSBbXTtcbiAgdmFyIHRtcE5hbWUgPSBmYWxzZTtcbiAgdmFyIGxlbiA9IGh0bWwubGVuZ3RoO1xuXG4gIGZ1bmN0aW9uIGFkZEF0dHIobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gXy50cmltKG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoUkVHRVhQX0lMTEVHQUxfQVRUUl9OQU1FLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChuYW1lLmxlbmd0aCA8IDEpIHJldHVybjtcbiAgICB2YXIgcmV0ID0gb25BdHRyKG5hbWUsIHZhbHVlIHx8IFwiXCIpO1xuICAgIGlmIChyZXQpIHJldEF0dHJzLnB1c2gocmV0KTtcbiAgfVxuXG4gIC8vIOmAkOS4quWIhuaekOWtl+esplxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBodG1sLmNoYXJBdChpKTtcbiAgICB2YXIgdiwgajtcbiAgICBpZiAodG1wTmFtZSA9PT0gZmFsc2UgJiYgYyA9PT0gXCI9XCIpIHtcbiAgICAgIHRtcE5hbWUgPSBodG1sLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0bXBOYW1lICE9PSBmYWxzZSkge1xuICAgICAgaWYgKFxuICAgICAgICBpID09PSBsYXN0UG9zICYmXG4gICAgICAgIChjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiKSAmJlxuICAgICAgICBodG1sLmNoYXJBdChpIC0gMSkgPT09IFwiPVwiXG4gICAgICApIHtcbiAgICAgICAgaiA9IGh0bWwuaW5kZXhPZihjLCBpICsgMSk7XG4gICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYgPSBfLnRyaW0oaHRtbC5zbGljZShsYXN0UG9zICsgMSwgaikpO1xuICAgICAgICAgIGFkZEF0dHIodG1wTmFtZSwgdik7XG4gICAgICAgICAgdG1wTmFtZSA9IGZhbHNlO1xuICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoL1xcc3xcXG58XFx0Ly50ZXN0KGMpKSB7XG4gICAgICBodG1sID0gaHRtbC5yZXBsYWNlKC9cXHN8XFxufFxcdC9nLCBcIiBcIik7XG4gICAgICBpZiAodG1wTmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaiA9IGZpbmROZXh0RXF1YWwoaHRtbCwgaSk7XG4gICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgIHYgPSBfLnRyaW0oaHRtbC5zbGljZShsYXN0UG9zLCBpKSk7XG4gICAgICAgICAgYWRkQXR0cih2KTtcbiAgICAgICAgICB0bXBOYW1lID0gZmFsc2U7XG4gICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSBqIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaiA9IGZpbmRCZWZvcmVFcXVhbChodG1sLCBpIC0gMSk7XG4gICAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICAgIHYgPSBfLnRyaW0oaHRtbC5zbGljZShsYXN0UG9zLCBpKSk7XG4gICAgICAgICAgdiA9IHN0cmlwUXVvdGVXcmFwKHYpO1xuICAgICAgICAgIGFkZEF0dHIodG1wTmFtZSwgdik7XG4gICAgICAgICAgdG1wTmFtZSA9IGZhbHNlO1xuICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsYXN0UG9zIDwgaHRtbC5sZW5ndGgpIHtcbiAgICBpZiAodG1wTmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgIGFkZEF0dHIoaHRtbC5zbGljZShsYXN0UG9zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZEF0dHIodG1wTmFtZSwgc3RyaXBRdW90ZVdyYXAoXy50cmltKGh0bWwuc2xpY2UobGFzdFBvcykpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF8udHJpbShyZXRBdHRycy5qb2luKFwiIFwiKSk7XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0RXF1YWwoc3RyLCBpKSB7XG4gIGZvciAoOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBzdHJbaV07XG4gICAgaWYgKGMgPT09IFwiIFwiKSBjb250aW51ZTtcbiAgICBpZiAoYyA9PT0gXCI9XCIpIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQmVmb3JlRXF1YWwoc3RyLCBpKSB7XG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBzdHJbaV07XG4gICAgaWYgKGMgPT09IFwiIFwiKSBjb250aW51ZTtcbiAgICBpZiAoYyA9PT0gXCI9XCIpIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1F1b3RlV3JhcFN0cmluZyh0ZXh0KSB7XG4gIGlmIChcbiAgICAodGV4dFswXSA9PT0gJ1wiJyAmJiB0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT09ICdcIicpIHx8XG4gICAgKHRleHRbMF0gPT09IFwiJ1wiICYmIHRleHRbdGV4dC5sZW5ndGggLSAxXSA9PT0gXCInXCIpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcFF1b3RlV3JhcCh0ZXh0KSB7XG4gIGlmIChpc1F1b3RlV3JhcFN0cmluZyh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0LnN1YnN0cigxLCB0ZXh0Lmxlbmd0aCAtIDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG59XG5cbmV4cG9ydHMucGFyc2VUYWcgPSBwYXJzZVRhZztcbmV4cG9ydHMucGFyc2VBdHRyID0gcGFyc2VBdHRyO1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX3JlZ2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19lc21fYXN5bmNUb0dlbmVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19maWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6IF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGltYWdlICovIFwibFwiXSxcbiAgaWNvbjogJ3YtbWQtaWNvbi1pbWcnLFxuICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sYW5nQ29uZmlnLmltYWdlLnRvb2xiYXI7XG4gIH0sXG4gIG1lbnVzOiBbe1xuICAgIG5hbWU6ICdpbWFnZS1saW5rJyxcbiAgICB0ZXh0OiBmdW5jdGlvbiB0ZXh0KGVkaXRvcikge1xuICAgICAgcmV0dXJuIGVkaXRvci5sYW5nQ29uZmlnLmltYWdlTGluay50b29sYmFyO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yLCBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcgIT0gbnVsbCAmJiBjb25maWcuaW5zZXJ0V2l0aFNpemUpIHtcbiAgICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGltYWdlICovIFwibFwiXSwge1xuICAgICAgICAgIHdpZHRoOiAnYXV0bycsXG4gICAgICAgICAgaGVpZ2h0OiAnYXV0bydcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogaW1hZ2UgKi8gXCJsXCJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAndXBsb2FkLWltYWdlJyxcbiAgICB0ZXh0OiBmdW5jdGlvbiB0ZXh0KGVkaXRvcikge1xuICAgICAgcmV0dXJuIGVkaXRvci5sYW5nQ29uZmlnLnVwbG9hZEltYWdlLnRvb2xiYXI7XG4gICAgfSxcbiAgICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICAgIGVkaXRvci51cGxvYWRDb25maWcgPSBlZGl0b3IudXBsb2FkSW1nQ29uZmlnO1xuICAgICAgZWRpdG9yLiRuZXh0VGljayggLyojX19QVVJFX18qL09iamVjdChfYmFiZWxfcnVudGltZV9oZWxwZXJzX2VzbV9hc3luY1RvR2VuZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pKCAvKiNfX1BVUkVfXyovX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgZXZlbnQsIGZpbGVzO1xuICAgICAgICByZXR1cm4gX2JhYmVsX3J1bnRpbWVfcmVnZW5lcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yLiRyZWZzLnVwbG9hZEZpbGUudXBsb2FkKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgZXZlbnQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBmaWxlcyA9IE9iamVjdChfdXRpbHNfZmlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGZpbGVzRmlsdGVyICovIFwiYVwiXSkoZXZlbnQudGFyZ2V0LmZpbGVzLCBlZGl0b3IudXBsb2FkSW1nQ29uZmlnKTtcbiAgICAgICAgICAgICAgZWRpdG9yLmVtaXRVcGxvYWRJbWFnZShldmVudCwgZmlsZXMpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKSk7XG4gICAgfVxuICB9XVxufSk7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBjc3NmaWx0ZXJcbiAqXG4gKiBAYXV0aG9yIOiAgembtzxsZWl6b25nbWluQGdtYWlsLmNvbT5cbiAqL1xuXG52YXIgREVGQVVMVCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xudmFyIHBhcnNlU3R5bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cblxuLyoqXG4gKiDov5Tlm57lgLzmmK/lkKbkuLrnqbpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bGwgKG9iaikge1xuICByZXR1cm4gKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICog5rWF5ou36LSd5a+56LGhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBzaGFsbG93Q29weU9iamVjdCAob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICByZXRbaV0gPSBvYmpbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiDliJvlu7pDU1Pov4fmu6TlmahcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICAtIHtPYmplY3R9IHdoaXRlTGlzdFxuICogICAtIHtGdW5jdGlvbn0gb25BdHRyXG4gKiAgIC0ge0Z1bmN0aW9ufSBvbklnbm9yZUF0dHJcbiAqICAgLSB7RnVuY3Rpb259IHNhZmVBdHRyVmFsdWVcbiAqL1xuZnVuY3Rpb24gRmlsdGVyQ1NTIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBzaGFsbG93Q29weU9iamVjdChvcHRpb25zIHx8IHt9KTtcbiAgb3B0aW9ucy53aGl0ZUxpc3QgPSBvcHRpb25zLndoaXRlTGlzdCB8fCBERUZBVUxULndoaXRlTGlzdDtcbiAgb3B0aW9ucy5vbkF0dHIgPSBvcHRpb25zLm9uQXR0ciB8fCBERUZBVUxULm9uQXR0cjtcbiAgb3B0aW9ucy5vbklnbm9yZUF0dHIgPSBvcHRpb25zLm9uSWdub3JlQXR0ciB8fCBERUZBVUxULm9uSWdub3JlQXR0cjtcbiAgb3B0aW9ucy5zYWZlQXR0clZhbHVlID0gb3B0aW9ucy5zYWZlQXR0clZhbHVlIHx8IERFRkFVTFQuc2FmZUF0dHJWYWx1ZTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbn1cblxuRmlsdGVyQ1NTLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyDlhbzlrrnlkITnp43lpYfokanovpPlhaVcbiAgY3NzID0gY3NzIHx8ICcnO1xuICBjc3MgPSBjc3MudG9TdHJpbmcoKTtcbiAgaWYgKCFjc3MpIHJldHVybiAnJztcblxuICB2YXIgbWUgPSB0aGlzO1xuICB2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gIHZhciB3aGl0ZUxpc3QgPSBvcHRpb25zLndoaXRlTGlzdDtcbiAgdmFyIG9uQXR0ciA9IG9wdGlvbnMub25BdHRyO1xuICB2YXIgb25JZ25vcmVBdHRyID0gb3B0aW9ucy5vbklnbm9yZUF0dHI7XG4gIHZhciBzYWZlQXR0clZhbHVlID0gb3B0aW9ucy5zYWZlQXR0clZhbHVlO1xuXG4gIHZhciByZXRDU1MgPSBwYXJzZVN0eWxlKGNzcywgZnVuY3Rpb24gKHNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbiwgbmFtZSwgdmFsdWUsIHNvdXJjZSkge1xuXG4gICAgdmFyIGNoZWNrID0gd2hpdGVMaXN0W25hbWVdO1xuICAgIHZhciBpc1doaXRlID0gZmFsc2U7XG4gICAgaWYgKGNoZWNrID09PSB0cnVlKSBpc1doaXRlID0gY2hlY2s7XG4gICAgZWxzZSBpZiAodHlwZW9mIGNoZWNrID09PSAnZnVuY3Rpb24nKSBpc1doaXRlID0gY2hlY2sodmFsdWUpO1xuICAgIGVsc2UgaWYgKGNoZWNrIGluc3RhbmNlb2YgUmVnRXhwKSBpc1doaXRlID0gY2hlY2sudGVzdCh2YWx1ZSk7XG4gICAgaWYgKGlzV2hpdGUgIT09IHRydWUpIGlzV2hpdGUgPSBmYWxzZTtcblxuICAgIC8vIOWmguaenOi/h+a7pOWQjiB2YWx1ZSDkuLrnqbrliJnnm7TmjqXlv73nlaVcbiAgICB2YWx1ZSA9IHNhZmVBdHRyVmFsdWUobmFtZSwgdmFsdWUpO1xuICAgIGlmICghdmFsdWUpIHJldHVybjtcblxuICAgIHZhciBvcHRzID0ge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBpc1doaXRlOiBpc1doaXRlXG4gICAgfTtcblxuICAgIGlmIChpc1doaXRlKSB7XG5cbiAgICAgIHZhciByZXQgPSBvbkF0dHIobmFtZSwgdmFsdWUsIG9wdHMpO1xuICAgICAgaWYgKGlzTnVsbChyZXQpKSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgJzonICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIHJldCA9IG9uSWdub3JlQXR0cihuYW1lLCB2YWx1ZSwgb3B0cyk7XG4gICAgICBpZiAoIWlzTnVsbChyZXQpKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXRDU1M7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyQ1NTO1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBjc3NmaWx0ZXJcbiAqXG4gKiBAYXV0aG9yIOiAgembtzxsZWl6b25nbWluQGdtYWlsLmNvbT5cbiAqL1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5cbi8qKlxuICog6Kej5p6Qc3R5bGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY3NzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkF0dHIg5aSE55CG5bGe5oCn55qE5Ye95pWwXG4gKiAgIOWPguaVsOagvOW8j++8miBmdW5jdGlvbiAoc291cmNlUG9zaXRpb24sIHBvc2l0aW9uLCBuYW1lLCB2YWx1ZSwgc291cmNlKVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBwYXJzZVN0eWxlIChjc3MsIG9uQXR0cikge1xuICBjc3MgPSBfLnRyaW1SaWdodChjc3MpO1xuICBpZiAoY3NzW2Nzcy5sZW5ndGggLSAxXSAhPT0gJzsnKSBjc3MgKz0gJzsnO1xuICB2YXIgY3NzTGVuZ3RoID0gY3NzLmxlbmd0aDtcbiAgdmFyIGlzUGFyZW50aGVzaXNPcGVuID0gZmFsc2U7XG4gIHZhciBsYXN0UG9zID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmV0Q1NTID0gJyc7XG5cbiAgZnVuY3Rpb24gYWRkTmV3QXR0ciAoKSB7XG4gICAgLy8g5aaC5p6c5rKh5pyJ5q2j5bi455qE6Zet5ZCI5ZyG5ous5Y+377yM5YiZ55u05o6l5b+955Wl5b2T5YmN5bGe5oCnXG4gICAgaWYgKCFpc1BhcmVudGhlc2lzT3Blbikge1xuICAgICAgdmFyIHNvdXJjZSA9IF8udHJpbShjc3Muc2xpY2UobGFzdFBvcywgaSkpO1xuICAgICAgdmFyIGogPSBzb3VyY2UuaW5kZXhPZignOicpO1xuICAgICAgaWYgKGogIT09IC0xKSB7XG4gICAgICAgIHZhciBuYW1lID0gXy50cmltKHNvdXJjZS5zbGljZSgwLCBqKSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IF8udHJpbShzb3VyY2Uuc2xpY2UoaiArIDEpKTtcbiAgICAgICAgLy8g5b+F6aG75pyJ5bGe5oCn5ZCN56ewXG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgdmFyIHJldCA9IG9uQXR0cihsYXN0UG9zLCByZXRDU1MubGVuZ3RoLCBuYW1lLCB2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICBpZiAocmV0KSByZXRDU1MgKz0gcmV0ICsgJzsgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsYXN0UG9zID0gaSArIDE7XG4gIH1cblxuICBmb3IgKDsgaSA8IGNzc0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBjc3NbaV07XG4gICAgaWYgKGMgPT09ICcvJyAmJiBjc3NbaSArIDFdID09PSAnKicpIHtcbiAgICAgIC8vIOWkh+azqOW8gOWni1xuICAgICAgdmFyIGogPSBjc3MuaW5kZXhPZignKi8nLCBpICsgMik7XG4gICAgICAvLyDlpoLmnpzmsqHmnInmraPluLjnmoTlpIfms6jnu5PmnZ/vvIzliJnlkI7pnaLnmoTpg6jliIblhajpg6jot7Pov4dcbiAgICAgIGlmIChqID09PSAtMSkgYnJlYWs7XG4gICAgICAvLyDnm7TmjqXlsIblvZPliY3kvY3nva7osIPliLDlpIfms6jnu5PlsL7vvIzlubbkuJTliJ3lp4vljJbnirbmgIFcbiAgICAgIGkgPSBqICsgMTtcbiAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgIGlzUGFyZW50aGVzaXNPcGVuID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjID09PSAnKCcpIHtcbiAgICAgIGlzUGFyZW50aGVzaXNPcGVuID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09ICcpJykge1xuICAgICAgaXNQYXJlbnRoZXNpc09wZW4gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGMgPT09ICc7Jykge1xuICAgICAgaWYgKGlzUGFyZW50aGVzaXNPcGVuKSB7XG4gICAgICAgIC8vIOWcqOWchuaLrOWPt+mHjOmdou+8jOW/veeVpVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkTmV3QXR0cigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgIGFkZE5ld0F0dHIoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXy50cmltKHJldENTUyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VTdHlsZTtcblxuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogZmlsdGVyIHhzc1xuICpcbiAqIEBhdXRob3IgWm9uZ21pbiBMZWk8bGVpem9uZ21pbkBnbWFpbC5jb20+XG4gKi9cblxudmFyIEZpbHRlckNTUyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLkZpbHRlckNTUztcbnZhciBERUZBVUxUID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG52YXIgcGFyc2VUYWcgPSBwYXJzZXIucGFyc2VUYWc7XG52YXIgcGFyc2VBdHRyID0gcGFyc2VyLnBhcnNlQXR0cjtcbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbi8qKlxuICogcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGB1bmRlZmluZWRgIG9yIGBudWxsYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVsbChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbn1cblxuLyoqXG4gKiBnZXQgYXR0cmlidXRlcyBmb3IgYSB0YWdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7T2JqZWN0fVxuICogICAtIHtTdHJpbmd9IGh0bWxcbiAqICAgLSB7Qm9vbGVhbn0gY2xvc2luZ1xuICovXG5mdW5jdGlvbiBnZXRBdHRycyhodG1sKSB7XG4gIHZhciBpID0gXy5zcGFjZUluZGV4KGh0bWwpO1xuICBpZiAoaSA9PT0gLTEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHRtbDogXCJcIixcbiAgICAgIGNsb3Npbmc6IGh0bWxbaHRtbC5sZW5ndGggLSAyXSA9PT0gXCIvXCIsXG4gICAgfTtcbiAgfVxuICBodG1sID0gXy50cmltKGh0bWwuc2xpY2UoaSArIDEsIC0xKSk7XG4gIHZhciBpc0Nsb3NpbmcgPSBodG1sW2h0bWwubGVuZ3RoIC0gMV0gPT09IFwiL1wiO1xuICBpZiAoaXNDbG9zaW5nKSBodG1sID0gXy50cmltKGh0bWwuc2xpY2UoMCwgLTEpKTtcbiAgcmV0dXJuIHtcbiAgICBodG1sOiBodG1sLFxuICAgIGNsb3Npbmc6IGlzQ2xvc2luZyxcbiAgfTtcbn1cblxuLyoqXG4gKiBzaGFsbG93IGNvcHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5T2JqZWN0KG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgcmV0W2ldID0gb2JqW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRmlsdGVyWFNTIGNsYXNzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICB3aGl0ZUxpc3QsIG9uVGFnLCBvblRhZ0F0dHIsIG9uSWdub3JlVGFnLFxuICogICAgICAgIG9uSWdub3JlVGFnQXR0ciwgc2FmZUF0dHJWYWx1ZSwgZXNjYXBlSHRtbFxuICogICAgICAgIHN0cmlwSWdub3JlVGFnQm9keSwgYWxsb3dDb21tZW50VGFnLCBzdHJpcEJsYW5rQ2hhclxuICogICAgICAgIGNzc3t3aGl0ZUxpc3QsIG9uQXR0ciwgb25JZ25vcmVBdHRyfSBgY3NzPWZhbHNlYCBtZWFucyBkb24ndCB1c2UgYGNzc2ZpbHRlcmBcbiAqL1xuZnVuY3Rpb24gRmlsdGVyWFNTKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHNoYWxsb3dDb3B5T2JqZWN0KG9wdGlvbnMgfHwge30pO1xuXG4gIGlmIChvcHRpb25zLnN0cmlwSWdub3JlVGFnKSB7XG4gICAgaWYgKG9wdGlvbnMub25JZ25vcmVUYWcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdOb3RlczogY2Fubm90IHVzZSB0aGVzZSB0d28gb3B0aW9ucyBcInN0cmlwSWdub3JlVGFnXCIgYW5kIFwib25JZ25vcmVUYWdcIiBhdCB0aGUgc2FtZSB0aW1lJ1xuICAgICAgKTtcbiAgICB9XG4gICAgb3B0aW9ucy5vbklnbm9yZVRhZyA9IERFRkFVTFQub25JZ25vcmVUYWdTdHJpcEFsbDtcbiAgfVxuXG4gIG9wdGlvbnMud2hpdGVMaXN0ID0gb3B0aW9ucy53aGl0ZUxpc3QgfHwgREVGQVVMVC53aGl0ZUxpc3Q7XG4gIG9wdGlvbnMub25UYWcgPSBvcHRpb25zLm9uVGFnIHx8IERFRkFVTFQub25UYWc7XG4gIG9wdGlvbnMub25UYWdBdHRyID0gb3B0aW9ucy5vblRhZ0F0dHIgfHwgREVGQVVMVC5vblRhZ0F0dHI7XG4gIG9wdGlvbnMub25JZ25vcmVUYWcgPSBvcHRpb25zLm9uSWdub3JlVGFnIHx8IERFRkFVTFQub25JZ25vcmVUYWc7XG4gIG9wdGlvbnMub25JZ25vcmVUYWdBdHRyID0gb3B0aW9ucy5vbklnbm9yZVRhZ0F0dHIgfHwgREVGQVVMVC5vbklnbm9yZVRhZ0F0dHI7XG4gIG9wdGlvbnMuc2FmZUF0dHJWYWx1ZSA9IG9wdGlvbnMuc2FmZUF0dHJWYWx1ZSB8fCBERUZBVUxULnNhZmVBdHRyVmFsdWU7XG4gIG9wdGlvbnMuZXNjYXBlSHRtbCA9IG9wdGlvbnMuZXNjYXBlSHRtbCB8fCBERUZBVUxULmVzY2FwZUh0bWw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgaWYgKG9wdGlvbnMuY3NzID09PSBmYWxzZSkge1xuICAgIHRoaXMuY3NzRmlsdGVyID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy5jc3MgPSBvcHRpb25zLmNzcyB8fCB7fTtcbiAgICB0aGlzLmNzc0ZpbHRlciA9IG5ldyBGaWx0ZXJDU1Mob3B0aW9ucy5jc3MpO1xuICB9XG59XG5cbi8qKlxuICogc3RhcnQgcHJvY2VzcyBhbmQgcmV0dXJucyByZXN1bHRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5GaWx0ZXJYU1MucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAvLyBjb21wYXRpYmxlIHdpdGggdGhlIGlucHV0XG4gIGh0bWwgPSBodG1sIHx8IFwiXCI7XG4gIGh0bWwgPSBodG1sLnRvU3RyaW5nKCk7XG4gIGlmICghaHRtbCkgcmV0dXJuIFwiXCI7XG5cbiAgdmFyIG1lID0gdGhpcztcbiAgdmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuICB2YXIgd2hpdGVMaXN0ID0gb3B0aW9ucy53aGl0ZUxpc3Q7XG4gIHZhciBvblRhZyA9IG9wdGlvbnMub25UYWc7XG4gIHZhciBvbklnbm9yZVRhZyA9IG9wdGlvbnMub25JZ25vcmVUYWc7XG4gIHZhciBvblRhZ0F0dHIgPSBvcHRpb25zLm9uVGFnQXR0cjtcbiAgdmFyIG9uSWdub3JlVGFnQXR0ciA9IG9wdGlvbnMub25JZ25vcmVUYWdBdHRyO1xuICB2YXIgc2FmZUF0dHJWYWx1ZSA9IG9wdGlvbnMuc2FmZUF0dHJWYWx1ZTtcbiAgdmFyIGVzY2FwZUh0bWwgPSBvcHRpb25zLmVzY2FwZUh0bWw7XG4gIHZhciBjc3NGaWx0ZXIgPSBtZS5jc3NGaWx0ZXI7XG5cbiAgLy8gcmVtb3ZlIGludmlzaWJsZSBjaGFyYWN0ZXJzXG4gIGlmIChvcHRpb25zLnN0cmlwQmxhbmtDaGFyKSB7XG4gICAgaHRtbCA9IERFRkFVTFQuc3RyaXBCbGFua0NoYXIoaHRtbCk7XG4gIH1cblxuICAvLyByZW1vdmUgaHRtbCBjb21tZW50c1xuICBpZiAoIW9wdGlvbnMuYWxsb3dDb21tZW50VGFnKSB7XG4gICAgaHRtbCA9IERFRkFVTFQuc3RyaXBDb21tZW50VGFnKGh0bWwpO1xuICB9XG5cbiAgLy8gaWYgZW5hYmxlIHN0cmlwSWdub3JlVGFnQm9keVxuICB2YXIgc3RyaXBJZ25vcmVUYWdCb2R5ID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLnN0cmlwSWdub3JlVGFnQm9keSkge1xuICAgIHZhciBzdHJpcElnbm9yZVRhZ0JvZHkgPSBERUZBVUxULlN0cmlwVGFnQm9keShcbiAgICAgIG9wdGlvbnMuc3RyaXBJZ25vcmVUYWdCb2R5LFxuICAgICAgb25JZ25vcmVUYWdcbiAgICApO1xuICAgIG9uSWdub3JlVGFnID0gc3RyaXBJZ25vcmVUYWdCb2R5Lm9uSWdub3JlVGFnO1xuICB9XG5cbiAgdmFyIHJldEh0bWwgPSBwYXJzZVRhZyhcbiAgICBodG1sLFxuICAgIGZ1bmN0aW9uIChzb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24sIHRhZywgaHRtbCwgaXNDbG9zaW5nKSB7XG4gICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgc291cmNlUG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIGlzQ2xvc2luZzogaXNDbG9zaW5nLFxuICAgICAgICBpc1doaXRlOiB3aGl0ZUxpc3QuaGFzT3duUHJvcGVydHkodGFnKSxcbiAgICAgIH07XG5cbiAgICAgIC8vIGNhbGwgYG9uVGFnKClgXG4gICAgICB2YXIgcmV0ID0gb25UYWcodGFnLCBodG1sLCBpbmZvKTtcbiAgICAgIGlmICghaXNOdWxsKHJldCkpIHJldHVybiByZXQ7XG5cbiAgICAgIGlmIChpbmZvLmlzV2hpdGUpIHtcbiAgICAgICAgaWYgKGluZm8uaXNDbG9zaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIFwiPC9cIiArIHRhZyArIFwiPlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0dHJzID0gZ2V0QXR0cnMoaHRtbCk7XG4gICAgICAgIHZhciB3aGl0ZUF0dHJMaXN0ID0gd2hpdGVMaXN0W3RhZ107XG4gICAgICAgIHZhciBhdHRyc0h0bWwgPSBwYXJzZUF0dHIoYXR0cnMuaHRtbCwgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gY2FsbCBgb25UYWdBdHRyKClgXG4gICAgICAgICAgdmFyIGlzV2hpdGVBdHRyID0gXy5pbmRleE9mKHdoaXRlQXR0ckxpc3QsIG5hbWUpICE9PSAtMTtcbiAgICAgICAgICB2YXIgcmV0ID0gb25UYWdBdHRyKHRhZywgbmFtZSwgdmFsdWUsIGlzV2hpdGVBdHRyKTtcbiAgICAgICAgICBpZiAoIWlzTnVsbChyZXQpKSByZXR1cm4gcmV0O1xuXG4gICAgICAgICAgaWYgKGlzV2hpdGVBdHRyKSB7XG4gICAgICAgICAgICAvLyBjYWxsIGBzYWZlQXR0clZhbHVlKClgXG4gICAgICAgICAgICB2YWx1ZSA9IHNhZmVBdHRyVmFsdWUodGFnLCBuYW1lLCB2YWx1ZSwgY3NzRmlsdGVyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmFtZSArICc9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGwgYG9uSWdub3JlVGFnQXR0cigpYFxuICAgICAgICAgICAgdmFyIHJldCA9IG9uSWdub3JlVGFnQXR0cih0YWcsIG5hbWUsIHZhbHVlLCBpc1doaXRlQXR0cik7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbChyZXQpKSByZXR1cm4gcmV0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYnVpbGQgbmV3IHRhZyBodG1sXG4gICAgICAgIHZhciBodG1sID0gXCI8XCIgKyB0YWc7XG4gICAgICAgIGlmIChhdHRyc0h0bWwpIGh0bWwgKz0gXCIgXCIgKyBhdHRyc0h0bWw7XG4gICAgICAgIGlmIChhdHRycy5jbG9zaW5nKSBodG1sICs9IFwiIC9cIjtcbiAgICAgICAgaHRtbCArPSBcIj5cIjtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYWxsIGBvbklnbm9yZVRhZygpYFxuICAgICAgICB2YXIgcmV0ID0gb25JZ25vcmVUYWcodGFnLCBodG1sLCBpbmZvKTtcbiAgICAgICAgaWYgKCFpc051bGwocmV0KSkgcmV0dXJuIHJldDtcbiAgICAgICAgcmV0dXJuIGVzY2FwZUh0bWwoaHRtbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlc2NhcGVIdG1sXG4gICk7XG5cbiAgLy8gaWYgZW5hYmxlIHN0cmlwSWdub3JlVGFnQm9keVxuICBpZiAoc3RyaXBJZ25vcmVUYWdCb2R5KSB7XG4gICAgcmV0SHRtbCA9IHN0cmlwSWdub3JlVGFnQm9keS5yZW1vdmUocmV0SHRtbCk7XG4gIH1cblxuICByZXR1cm4gcmV0SHRtbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyWFNTO1xuXG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAqXHJcbiAqIFRoZXNlIGltcGxlbWVudGF0aW9ucyBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgb3V0c2lkZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJcclxuICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtanNkb2MsIHZhbGlkLWpzZG9jICovXHJcbnZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5kZXggaW4gcHJvdmlkZWQgYXJyYXkgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhcnJcclxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRJbmRleChhcnIsIGtleSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICBhcnIuc29tZShmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeVswXSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc18xLnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2VudHJpZXNfXy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleCh0aGlzLl9fZW50cmllc19fLCBrZXkpO1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzFdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfX1tpbmRleF1bMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX18ucHVzaChba2V5LCB2YWx1ZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLl9fZW50cmllc19fO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChlbnRyaWVzLCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbY3R4PW51bGxdXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChjdHggPT09IHZvaWQgMCkgeyBjdHggPSBudWxsOyB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVudHJ5WzFdLCBlbnRyeVswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBjbGFzc18xO1xyXG4gICAgfSgpKTtcclxufSkoKTtcblxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gKi9cclxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ID09PSBkb2N1bWVudDtcblxuLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxudmFyIGdsb2JhbCQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gKiBmaXJzdCBvbmUgaXMgbm90IHN1cHBvcnRlZC5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAqL1xyXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBJdCdzIHJlcXVpcmVkIHRvIHVzZSBhIGJvdW5kZWQgZnVuY3Rpb24gYmVjYXVzZSBJRSBzb21ldGltZXMgdGhyb3dzXHJcbiAgICAgICAgLy8gYW4gXCJJbnZhbGlkIGNhbGxpbmcgb2JqZWN0XCIgZXJyb3IgaWYgckFGIGlzIGludm9rZWQgd2l0aG91dCB0aGUgZ2xvYmFsXHJcbiAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZ2xvYmFsJDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxufSkoKTtcblxuLy8gRGVmaW5lcyBtaW5pbXVtIHRpbWVvdXQgYmVmb3JlIGFkZGluZyBhIHRyYWlsaW5nIGNhbGwuXHJcbnZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggZW5zdXJlcyB0aGF0IHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmVcclxuICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGRlbGF5IHBlcmlvZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICB2YXIgbGVhZGluZ0NhbGwgPSBmYWxzZSwgdHJhaWxpbmdDYWxsID0gZmFsc2UsIGxhc3RDYWxsVGltZSA9IDA7XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAqIHRoZSBcInByb3h5XCIgd2FzIGNhbGxlZCBkdXJpbmcgY3VycmVudCByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByZXNvbHZlUGVuZGluZygpIHtcclxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgbGVhZGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyYWlsaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICBwcm94eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAqIGludm9jYXRpb24gb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGRlbGVnYXRpbmcgaXQgdG8gdGhlXHJcbiAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShyZXNvbHZlUGVuZGluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcHJveHkoKSB7XHJcbiAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFJlamVjdCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgY2FsbHMuXHJcbiAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgXCJ0cmFuc2l0aW9uc1wiIHdoaWNoIG5ldmVyIGFjdHVhbGx5IHN0YXJ0XHJcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNvIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgd2UgbWlnaHQgbWlzcyBvbmUgaWYgY2hhbmdlXHJcbiAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhaWxpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWVTdGFtcDtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxuXG4vLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxudmFyIFJFRlJFU0hfREVMQVkgPSAyMDtcclxuLy8gQSBsaXN0IG9mIHN1YnN0cmluZ3Mgb2YgQ1NTIHByb3BlcnRpZXMgdXNlZCB0byBmaW5kIHRyYW5zaXRpb24gZXZlbnRzIHRoYXRcclxuLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbnZhciB0cmFuc2l0aW9uS2V5cyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0JywgJ3dpZHRoJywgJ2hlaWdodCcsICdzaXplJywgJ3dlaWdodCddO1xyXG4vLyBDaGVjayBpZiBNdXRhdGlvbk9ic2VydmVyIGlzIGF2YWlsYWJsZS5cclxudmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gY29udHJvbGxlciBjbGFzcyB3aGljaCBoYW5kbGVzIHVwZGF0ZXMgb2YgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2VzLlxyXG4gKi9cclxudmFyIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge011dGF0aW9uT2JzZXJ2ZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmVyU1BJPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmVyc18gPSBbXTtcclxuICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZF8gPSB0aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmFkZE9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzXy5wdXNoKG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgdmFyIGluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBvYnNlcnZlciBpZiBpdCdzIHByZXNlbnQgaW4gcmVnaXN0cnkuXHJcbiAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGlmICghb2JzZXJ2ZXJzLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAqIGl0IGRldGVjdHMgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAvLyBDb250aW51ZSBydW5uaW5nIHVwZGF0ZXMgaWYgY2hhbmdlcyBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXMgdGhlcmUgbWlnaHRcclxuICAgICAgICAvLyBiZSBmdXR1cmUgb25lcyBjYXVzZWQgYnkgQ1NTIHRyYW5zaXRpb25zLlxyXG4gICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBldmVyeSBvYnNlcnZlciBmcm9tIG9ic2VydmVycyBsaXN0IGFuZCBub3RpZmllcyB0aGVtIG9mIHF1ZXVlZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgaXQncyBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENvbGxlY3Qgb2JzZXJ2ZXJzIHRoYXQgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHZhciBhY3RpdmVPYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERlbGl2ZXIgbm90aWZpY2F0aW9ucyBpbiBhIHNlcGFyYXRlIGN5Y2xlIGluIG9yZGVyIHRvIGF2b2lkIGFueVxyXG4gICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAvLyBSZXNpemVPYnNlcnZlciBhcmUgdHJhY2tpbmcgdGhlIHNhbWUgZWxlbWVudCBhbmQgdGhlIGNhbGxiYWNrIG9mIG9uZVxyXG4gICAgICAgIC8vIG9mIHRoZW0gY2hhbmdlcyBjb250ZW50IGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIHRhcmdldC4gU29tZXRpbWVzXHJcbiAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgIGFjdGl2ZU9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikgeyByZXR1cm4gb2JzZXJ2ZXIuYnJvYWRjYXN0QWN0aXZlKCk7IH0pO1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVPYnNlcnZlcnMubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmNvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgIGlmICghaXNCcm93c2VyIHx8IHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiB0byB0aGUgXCJUcmFuc2l0aW9uZW5kXCIgZXZlbnQgaXMgdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yXHJcbiAgICAgICAgLy8gZGVsYXllZCB0cmFuc2l0aW9ucy4gVGhpcyB3YXkgaXQncyBwb3NzaWJsZSB0byBjYXB0dXJlIGF0IGxlYXN0IHRoZVxyXG4gICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5vYnNlcnZlKGRvY3VtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01TdWJ0cmVlTW9kaWZpZWQnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gaGF2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8pIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VHJhbnNpdGlvbkV2ZW50fSBldmVudFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUub25UcmFuc2l0aW9uRW5kXyA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICB2YXIgaXNSZWZsb3dQcm9wZXJ0eSA9IHRyYW5zaXRpb25LZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF+cHJvcGVydHlOYW1lLmluZGV4T2Yoa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNSZWZsb3dQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Jlc2l6ZU9ic2VydmVyQ29udHJvbGxlcn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZV8pIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlXztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIHJlZmVyZW5jZSB0byB0aGUgY29udHJvbGxlcidzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcjtcclxufSgpKTtcblxuLyoqXHJcbiAqIERlZmluZXMgbm9uLXdyaXRhYmxlL2VudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BlcnRpZXMgdG8gYmUgZGVmaW5lZC5cclxuICogQHJldHVybnMge09iamVjdH0gVGFyZ2V0IG9iamVjdC5cclxuICovXHJcbnZhciBkZWZpbmVDb25maWd1cmFibGUgPSAoZnVuY3Rpb24gKHRhcmdldCwgcHJvcHMpIHtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhwcm9wcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IHByb3BzW2tleV0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnbG9iYWwgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCBwcm92aWRlZCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqL1xyXG52YXIgZ2V0V2luZG93T2YgPSAoZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgdGhlIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgTm9kZSwgd2hpY2ggbWVhbnMgdGhhdCBpdFxyXG4gICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAvLyBjb3JyZXNwb25kaW5nIGdsb2JhbCBvYmplY3QuXHJcbiAgICB2YXIgb3duZXJHbG9iYWwgPSB0YXJnZXQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQgJiYgdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgLy8gcHJvdmlkZWQgZWxlbWVudC5cclxuICAgIHJldHVybiBvd25lckdsb2JhbCB8fCBnbG9iYWwkMTtcclxufSk7XG5cbi8vIFBsYWNlaG9sZGVyIG9mIGFuIGVtcHR5IGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG52YXIgZW1wdHlSZWN0ID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBwcm92aWRlZCBzdHJpbmcgdG8gYSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBib3JkZXJzIHNpemUgZnJvbSBwcm92aWRlZCBzdHlsZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBwb3NpdGlvbnMgLSBCb3JkZXJzIHBvc2l0aW9ucyAodG9wLCByaWdodCwgLi4uKVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHBvc2l0aW9uc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlc1snYm9yZGVyLScgKyBwb3NpdGlvbiArICctd2lkdGgnXTtcclxuICAgICAgICByZXR1cm4gc2l6ZSArIHRvRmxvYXQodmFsdWUpO1xyXG4gICAgfSwgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYWRkaW5ncyhzdHlsZXMpIHtcclxuICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgdmFyIHBhZGRpbmdzID0ge307XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHBvc2l0aW9uc18xID0gcG9zaXRpb25zOyBfaSA8IHBvc2l0aW9uc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ3BhZGRpbmctJyArIHBvc2l0aW9uXTtcclxuICAgICAgICBwYWRkaW5nc1twb3NpdGlvbl0gPSB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWRkaW5ncztcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBjb250ZW50IHJlY3RhbmdsZSBvZiBwcm92aWRlZCBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICogICAgICB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIHZhciBiYm94ID0gdGFyZ2V0LmdldEJCb3goKTtcclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgY29udGVudCByZWN0YW5nbGUuXHJcbiAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICovXHJcbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgLy8gdXNlZCBleGNsdXNpdmVseSBhcyB0aGV5IHByb3ZpZGUgcm91bmRlZCB2YWx1ZXMuXHJcbiAgICB2YXIgY2xpZW50V2lkdGggPSB0YXJnZXQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgIC8vIGRldGFjaGVkIGVsZW1lbnRzLiBUaG91Z2ggZWxlbWVudHMgd2l0aCB3aWR0aCAmIGhlaWdodCBwcm9wZXJ0aWVzIGxlc3NcclxuICAgIC8vIHRoYW4gMC41IHdpbGwgYmUgZGlzY2FyZGVkIGFzIHdlbGwuXHJcbiAgICAvL1xyXG4gICAgLy8gV2l0aG91dCBpdCB3ZSB3b3VsZCBuZWVkIHRvIGltcGxlbWVudCBzZXBhcmF0ZSBtZXRob2RzIGZvciBlYWNoIG9mXHJcbiAgICAvLyB0aG9zZSBjYXNlcyBhbmQgaXQncyBub3QgcG9zc2libGUgdG8gcGVyZm9ybSBhIHByZWNpc2UgYW5kIHBlcmZvcm1hbmNlXHJcbiAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgIC8vIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgbGVzcyB0aGFuIDAuNS5cclxuICAgIGlmICghY2xpZW50V2lkdGggJiYgIWNsaWVudEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICB2YXIgc3R5bGVzID0gZ2V0V2luZG93T2YodGFyZ2V0KS5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XHJcbiAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgdmFyIGhvcml6UGFkID0gcGFkZGluZ3MubGVmdCArIHBhZGRpbmdzLnJpZ2h0O1xyXG4gICAgdmFyIHZlcnRQYWQgPSBwYWRkaW5ncy50b3AgKyBwYWRkaW5ncy5ib3R0b207XHJcbiAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgIC8vIG9ubHkgZGltZW5zaW9ucyBhdmFpbGFibGUgdG8gSlMgdGhhdCBjb250YWluIG5vbi1yb3VuZGVkIHZhbHVlcy4gSXQgY291bGRcclxuICAgIC8vIGJlIHBvc3NpYmxlIHRvIHV0aWxpemUgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpZiBvbmx5IGl0J3MgZGF0YSB3YXNuJ3RcclxuICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgIHZhciB3aWR0aCA9IHRvRmxvYXQoc3R5bGVzLndpZHRoKSwgaGVpZ2h0ID0gdG9GbG9hdChzdHlsZXMuaGVpZ2h0KTtcclxuICAgIC8vIFdpZHRoICYgaGVpZ2h0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgd2hlbiB0aGUgJ2JvcmRlci1ib3gnIGJveFxyXG4gICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICBpZiAoc3R5bGVzLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnKSB7XHJcbiAgICAgICAgLy8gRm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHJlcXVpcmVkIHRvIGhhbmRsZSBJbnRlcm5ldCBFeHBsb3JlciB3aGljaFxyXG4gICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdlIGNhbiBzYXkgdGhhdCBpZiBDU1MgZGltZW5zaW9ucyArIHBhZGRpbmdzIGFyZSBlcXVhbCB0byB0aGUgXCJjbGllbnRcIlxyXG4gICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgIC8vIGFueXRoaW5nLCBvciBhbiBlbGVtZW50IG1lcmVseSBkb2Vzbid0IGhhdmUgcGFkZGluZ3MvYm9yZGVycyBzdHlsZXMuXHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQod2lkdGggKyBob3JpelBhZCkgIT09IGNsaWVudFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAhPT0gY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgIC8vIGNsaWVudFtXaWR0aC9IZWlnaHRdIHByb3BlcnRpZXMgcmVwcmVzZW50IHZpZXdwb3J0IGFyZWEgb2YgdGhlIHdpbmRvdy5cclxuICAgIC8vIEJlc2lkZXMsIGl0J3MgYXMgd2VsbCBub3QgbmVjZXNzYXJ5IGFzIHRoZSA8aHRtbD4gaXRzZWxmIG5laXRoZXIgaGFzXHJcbiAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICBpZiAoIWlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIChvbmx5IGluIEZpcmVmb3gsIGFjdHVhbGx5KSBDU1Mgd2lkdGggJiBoZWlnaHRcclxuICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgIC8vIGJhcnMgYXJlIHRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiByb3VuZGVkIGRpbWVuc2lvbnMgKyBwYWRkaW5nc1xyXG4gICAgICAgIC8vIGFuZCBcImNsaWVudFwiIHByb3BlcnRpZXMsIHRob3VnaCB0aGF0IGlzIG5vdCBhbHdheXMgdHJ1ZSBpbiBDaHJvbWUuXHJcbiAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgdmFyIGhvcml6U2Nyb2xsYmFyID0gTWF0aC5yb3VuZChoZWlnaHQgKyB2ZXJ0UGFkKSAtIGNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBDaHJvbWUgaGFzIGEgcmF0aGVyIHdlaXJkIHJvdW5kaW5nIG9mIFwiY2xpZW50XCIgcHJvcGVydGllcy5cclxuICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgIC8vIHRoZSBjbGllbnQgd2lkdGggb2YgMzE1cHggYW5kIGZvciB0aGUgd2lkdGggb2YgMzE0LjdweCBpdCBtYXkgZ2l2ZVxyXG4gICAgICAgIC8vIDMxNHB4LiBBbmQgaXQgZG9lc24ndCBoYXBwZW4gYWxsIHRoZSB0aW1lLiBTbyBqdXN0IGlnbm9yZSB0aGlzIGRlbHRhXHJcbiAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZlcnRTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHdpZHRoIC09IHZlcnRTY3JvbGxiYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChNYXRoLmFicyhob3JpelNjcm9sbGJhcikgIT09IDEpIHtcclxuICAgICAgICAgICAgaGVpZ2h0IC09IGhvcml6U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdChwYWRkaW5ncy5sZWZ0LCBwYWRkaW5ncy50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBTVkdHcmFwaGljc0VsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbnZhciBpc1NWR0dyYXBoaWNzRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBTb21lIGJyb3dzZXJzLCBuYW1lbHkgSUUgYW5kIEVkZ2UsIGRvbid0IGhhdmUgdGhlIFNWR0dyYXBoaWNzRWxlbWVudFxyXG4gICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgaWYgKHR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuU1ZHR3JhcGhpY3NFbGVtZW50OyB9O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgaXQncyBzbywgdGhlbiBjaGVjayB0aGF0IGVsZW1lbnQgaXMgYXQgbGVhc3QgYW4gaW5zdGFuY2Ugb2YgdGhlXHJcbiAgICAvLyBTVkdFbGVtZW50IGFuZCB0aGF0IGl0IGhhcyB0aGUgXCJnZXRCQm94XCIgbWV0aG9kLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuICh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0VsZW1lbnQgJiZcclxuICAgICAgICB0eXBlb2YgdGFyZ2V0LmdldEJCb3ggPT09ICdmdW5jdGlvbicpOyB9O1xyXG59KSgpO1xyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhIGRvY3VtZW50IGVsZW1lbnQgKDxodG1sPikuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBjaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRFbGVtZW50KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHRhcmdldCA9PT0gZ2V0V2luZG93T2YodGFyZ2V0KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgYW4gYXBwcm9wcmlhdGUgY29udGVudCByZWN0YW5nbGUgZm9yIHByb3ZpZGVkIGh0bWwgb3Igc3ZnIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBjb250ZW50IHJlY3RhbmdsZSBvZiB3aGljaCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgIGlmICghaXNCcm93c2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgIH1cclxuICAgIGlmIChpc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIHJlY3RhbmdsZSB3aXRoIGFuIGludGVyZmFjZSBvZiB0aGUgRE9NUmVjdFJlYWRPbmx5LlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gT2JqZWN0IHdpdGggcmVjdGFuZ2xlJ3MgeC95IGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVhZE9ubHlSZWN0KF9hKSB7XHJcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAvLyBJZiBET01SZWN0UmVhZE9ubHkgaXMgYXZhaWxhYmxlIHVzZSBpdCBhcyBhIHByb3RvdHlwZSBmb3IgdGhlIHJlY3RhbmdsZS5cclxuICAgIHZhciBDb25zdHIgPSB0eXBlb2YgRE9NUmVjdFJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJyA/IERPTVJlY3RSZWFkT25seSA6IE9iamVjdDtcclxuICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgIC8vIFJlY3RhbmdsZSdzIHByb3BlcnRpZXMgYXJlIG5vdCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUuXHJcbiAgICBkZWZpbmVDb25maWd1cmFibGUocmVjdCwge1xyXG4gICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgdG9wOiB5LFxyXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgIGxlZnQ6IHhcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZGljdGRlZi1kb21yZWN0aW5pdFxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFJlY3RhbmdsZSdzIHdpZHRoLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcbn1cblxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGNvbXB1dGF0aW9ucyBvZiB0aGUgY29udGVudCByZWN0YW5nbGUgb2ZcclxuICogcHJvdmlkZWQgRE9NIGVsZW1lbnQgYW5kIGZvciBrZWVwaW5nIHRyYWNrIG9mIGl0J3MgY2hhbmdlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmF0aW9uKHRhcmdldCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7RE9NUmVjdEluaXR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjb250ZW50IHJlY3RhbmdsZSBhbmQgdGVsbHMgd2hldGhlciBpdCdzIHdpZHRoIG9yIGhlaWdodCBwcm9wZXJ0aWVzXHJcbiAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBnZXRDb250ZW50UmVjdCh0aGlzLnRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgIHJldHVybiAocmVjdC53aWR0aCAhPT0gdGhpcy5icm9hZGNhc3RXaWR0aCB8fFxyXG4gICAgICAgICAgICByZWN0LmhlaWdodCAhPT0gdGhpcy5icm9hZGNhc3RIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyAnYnJvYWRjYXN0V2lkdGgnIGFuZCAnYnJvYWRjYXN0SGVpZ2h0JyBwcm9wZXJ0aWVzIHdpdGggYSBkYXRhXHJcbiAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fSBMYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZhdGlvbi5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudFJlY3RfO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmF0aW9uO1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0aGF0IGlzIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBEYXRhIG9mIHRoZSBlbGVtZW50J3MgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyRW50cnkodGFyZ2V0LCByZWN0SW5pdCkge1xyXG4gICAgICAgIHZhciBjb250ZW50UmVjdCA9IGNyZWF0ZVJlYWRPbmx5UmVjdChyZWN0SW5pdCk7XHJcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAvLyBhbmQgYXJlIGFsc28gbm90IGVudW1lcmFibGUgaW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAvLyBwcml2YXRlIFdlYWtNYXAgc3RvcmFnZSB3aGljaCBtYXkgY2F1c2UgbWVtb3J5IGxlYWtzIGluIGJyb3dzZXJzIHRoYXRcclxuICAgICAgICAvLyBkb24ndCBzdXBwb3J0IHRoaXMgdHlwZSBvZiBjb2xsZWN0aW9ucy5cclxuICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyRW50cnk7XHJcbn0oKSk7XG5cbnZhciBSZXNpemVPYnNlcnZlclNQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXHJcbiAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9IGNvbnRyb2xsZXIgLSBDb250cm9sbGVyIGluc3RhbmNlIHdoaWNoXHJcbiAgICAgKiAgICAgIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgdXBkYXRlcyBvZiBvYnNlcnZlci5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAqICAgICAgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2Ugd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgcmVzaXplIG9ic2VydmF0aW9ucyB0aGF0IGhhdmUgZGV0ZWN0ZWQgY2hhbmdlcyBpbiBkaW1lbnNpb25zXHJcbiAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7TWFwPEVsZW1lbnQsIFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18gPSBuZXcgTWFwU2hpbSgpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDdHhfID0gY2FsbGJhY2tDdHg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBvYnNlcnZpbmcgcHJvdmlkZWQgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAob2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLnNldCh0YXJnZXQsIG5ldyBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSB0aGUgRWxlbWVudCBpbnRlcmZhY2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyB8fCAhKEVsZW1lbnQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9ic2VydmF0aW9ucyA9IHRoaXMub2JzZXJ2YXRpb25zXztcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLmhhcyh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JzZXJ2YXRpb25zLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghb2JzZXJ2YXRpb25zLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBvYnNlcnZpbmcgYWxsIGVsZW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbGxlY3RzIG9ic2VydmF0aW9uIGluc3RhbmNlcyB0aGUgYXNzb2NpYXRlZCBlbGVtZW50IG9mIHdoaWNoIGhhcyBjaGFuZ2VkXHJcbiAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuZ2F0aGVyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob2JzZXJ2YXRpb24uaXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlcyBpbml0aWFsIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBsaXN0IG9mIFJlc2l6ZU9ic2VydmVyRW50cnlcclxuICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9ic2VydmVyIGRvZXNuJ3QgaGF2ZSBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAvLyBDcmVhdGUgUmVzaXplT2JzZXJ2ZXJFbnRyeSBpbnN0YW5jZSBmb3IgZXZlcnkgYWN0aXZlIG9ic2VydmF0aW9uLlxyXG4gICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKGN0eCwgZW50cmllcywgY3R4KTtcclxuICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmNsZWFyQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5zcGxpY2UoMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZWxscyB3aGV0aGVyIG9ic2VydmVyIGhhcyBhY3RpdmUgb2JzZXJ2YXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbn0oKSk7XG5cbi8vIFJlZ2lzdHJ5IG9mIGludGVybmFsIG9ic2VydmVycy4gSWYgV2Vha01hcCBpcyBub3QgYXZhaWxhYmxlIHVzZSBjdXJyZW50IHNoaW1cclxuLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4vLyBjYW4ndCBiZSBmdWxseSBwb2x5ZmlsbGVkIGFueXdheS5cclxudmFyIG9ic2VydmVycyA9IHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyA/IG5ldyBXZWFrTWFwKCkgOiBuZXcgTWFwU2hpbSgpO1xyXG4vKipcclxuICogUmVzaXplT2JzZXJ2ZXIgQVBJLiBFbmNhcHN1bGF0ZXMgdGhlIFJlc2l6ZU9ic2VydmVyIFNQSSBpbXBsZW1lbnRhdGlvblxyXG4gKiBleHBvc2luZyBvbmx5IHRob3NlIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgdGhhdCBhcmUgZGVmaW5lZCBpbiB0aGUgc3BlYy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyQ2FsbGJhY2t9IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW5cclxuICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcihjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgdGhpcyk7XHJcbiAgICAgICAgb2JzZXJ2ZXJzLnNldCh0aGlzLCBvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXI7XHJcbn0oKSk7XHJcbi8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuW1xyXG4gICAgJ29ic2VydmUnLFxyXG4gICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAnZGlzY29ubmVjdCdcclxuXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gb2JzZXJ2ZXJzLmdldCh0aGlzKSlbbWV0aG9kXS5hcHBseShfYSwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn0pO1xuXG52YXIgaW5kZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGluZGV4KTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oODYpKSlcblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gY3JlYXRlRWRpdG9yOyB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy91dGlscy9sYW5nLmpzICsgMSBtb2R1bGVzXG52YXIgdXRpbHNfbGFuZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sYW5nL3poLUNOLmpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB6aF9DTiA9ICh7XG4gIHVuZG86IHtcbiAgICB0b29sYmFyOiAn5pKk6ZSAJ1xuICB9LFxuICByZWRvOiB7XG4gICAgdG9vbGJhcjogJ+mHjeWBmidcbiAgfSxcbiAgY2xlYXI6IHtcbiAgICB0b29sYmFyOiAn5riF56m6J1xuICB9LFxuICBoOiB7XG4gICAgdG9vbGJhcjogJ+agh+mimCdcbiAgfSxcbiAgaDE6IHtcbiAgICB0b29sYmFyOiAn5LiA57qn5qCH6aKYJyxcbiAgICBwbGFjZWhvbGRlcjogJ+S4gOe6p+agh+mimCdcbiAgfSxcbiAgaDI6IHtcbiAgICB0b29sYmFyOiAn5LqM57qn5qCH6aKYJyxcbiAgICBwbGFjZWhvbGRlcjogJ+S6jOe6p+agh+mimCdcbiAgfSxcbiAgaDM6IHtcbiAgICB0b29sYmFyOiAn5LiJ57qn5qCH6aKYJyxcbiAgICBwbGFjZWhvbGRlcjogJ+S4iee6p+agh+mimCdcbiAgfSxcbiAgaDQ6IHtcbiAgICB0b29sYmFyOiAn5Zub57qn5qCH6aKYJyxcbiAgICBwbGFjZWhvbGRlcjogJ+Wbm+e6p+agh+mimCdcbiAgfSxcbiAgaDU6IHtcbiAgICB0b29sYmFyOiAn5LqU57qn5qCH6aKYJyxcbiAgICBwbGFjZWhvbGRlcjogJ+S6lOe6p+agh+mimCdcbiAgfSxcbiAgaDY6IHtcbiAgICB0b29sYmFyOiAn5YWt57qn5qCH6aKYJyxcbiAgICBwbGFjZWhvbGRlcjogJ+WFree6p+agh+mimCdcbiAgfSxcbiAgYm9sZDoge1xuICAgIHRvb2xiYXI6ICfnspfkvZMnLFxuICAgIHBsYWNlaG9sZGVyOiAn57KX5L2TJ1xuICB9LFxuICBpdGFsaWM6IHtcbiAgICB0b29sYmFyOiAn5pac5L2TJyxcbiAgICBwbGFjZWhvbGRlcjogJ+aWnOS9kydcbiAgfSxcbiAgc3RyaWtldGhyb3VnaDoge1xuICAgIHRvb2xiYXI6ICfliKDpmaTnur8nLFxuICAgIHBsYWNlaG9sZGVyOiAn5Yig6Zmk57q/J1xuICB9LFxuICBxdW90ZToge1xuICAgIHRvb2xiYXI6ICfmj5LlhaXlvJXnlKgnLFxuICAgIHBsYWNlaG9sZGVyOiAn5byV55SoJ1xuICB9LFxuICB1bDoge1xuICAgIHRvb2xiYXI6ICfml6Dluo/liJfooagnLFxuICAgIHBsYWNlaG9sZGVyOiAn5peg5bqP5YiX6KGoJ1xuICB9LFxuICBvbDoge1xuICAgIHRvb2xiYXI6ICfmnInluo/liJfooagnLFxuICAgIHBsYWNlaG9sZGVyOiAn5pyJ5bqP5YiX6KGoJ1xuICB9LFxuICB0YWJsZToge1xuICAgIHRvb2xiYXI6ICfooajmoLwnXG4gIH0sXG4gIGhyOiB7XG4gICAgdG9vbGJhcjogJ+aPkuWFpeWIhuWJsue6vydcbiAgfSxcbiAgbGluazoge1xuICAgIHRvb2xiYXI6ICfmj5LlhaXpk77mjqUnLFxuICAgIGRlc2NQbGFjZWhvbGRlcjogJ+mTvuaOpSdcbiAgfSxcbiAgaW1hZ2U6IHtcbiAgICB0b29sYmFyOiAn5o+S5YWl5Zu+54mHJ1xuICB9LFxuICBpbWFnZUxpbms6IHtcbiAgICB0b29sYmFyOiAn5re75Yqg5Zu+54mH6ZO+5o6lJ1xuICB9LFxuICB1cGxvYWRJbWFnZToge1xuICAgIHRvb2xiYXI6ICfkuIrkvKDmnKzlnLDlm77niYcnXG4gIH0sXG4gIGNvZGU6IHtcbiAgICB0b29sYmFyOiAn5o+S5YWl5Luj56CB5Z2XJ1xuICB9LFxuICBzYXZlOiB7XG4gICAgdG9vbGJhcjogJ+S/neWtmCdcbiAgfSxcbiAgcHJldmlldzoge1xuICAgIGVuYWJsZWQ6ICflvIDlkK/pooTop4gnLFxuICAgIGRpc2FibGVkOiAn5YWz6Zet6aKE6KeIJ1xuICB9LFxuICB0b2M6IHtcbiAgICB0aXRsZTogJ+ebruW9leWvvOiIqicsXG4gICAgZW5hYmxlZDogJ+W8gOWQr+ebruW9leWvvOiIqicsXG4gICAgZGlzYWJsZWQ6ICflhbPpl63nm67lvZXlr7zoiKonXG4gIH0sXG4gIHN5bmNTY3JvbGw6IHtcbiAgICBlbmFibGVkOiAn5byA5ZCv5ZCM5q2l5rua5YqoJyxcbiAgICBkaXNhYmxlZDogJ+WFs+mXreWQjOatpea7muWKqCdcbiAgfSxcbiAgZnVsbHNjcmVlbjoge1xuICAgIGVuYWJsZWQ6ICflhajlsY/vvIjmjIlFU0Pov5jljp/vvIknLFxuICAgIGRpc2FibGVkOiAn6YCA5Ye65YWo5bGPJ1xuICB9XG59KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wicm9vdFwiOlwiVnVlXCIsXCJjb21tb25qc1wiOlwidnVlXCIsXCJjb21tb25qczJcIjpcInZ1ZVwiLFwiYW1kXCI6XCJ2dWVcIn1cbnZhciBleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvdXRpbHMvdXRpbC5qc1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9jb21tYW5kLmpzXG5cbnZhciBkZWZhdWx0Q29tbWFuZHMgPSB7fTtcbk9iamVjdCh1dGlsW1wiY1wiIC8qIGltcG9ydEFsbCAqL10pKGRlZmF1bHRDb21tYW5kcywgX193ZWJwYWNrX3JlcXVpcmVfXygzOCkpO1xuZnVuY3Rpb24gY29tbWFuZF9yZWdpc3RlckNvbW1hbmQodGFyZ2V0LCBjb21tYW5kTmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNvbW1hbmROYW1lKSB7XG4gICAgaWYgKCF0YXJnZXRbY29tbWFuZE5hbWVdKSB7XG4gICAgICB0YXJnZXRbY29tbWFuZE5hbWVdID0gY2FsbGJhY2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgY29tbWFuZCBuYW1lIGlzIGFscmVhZHkgaW4gdXNlOiBcIiArIGNvbW1hbmROYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignQ29tbWFuZCBuYW1lIGlzIHJlcXVpcmVkJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1hbmRXcmFwcGVyKGNvbXBvbmVudCkge1xuICBjb21wb25lbnQuY29tbWFuZHMgPSB7fTtcblxuICBjb21wb25lbnQuY29tbWFuZCA9IGZ1bmN0aW9uIChjb21tYW5kTmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb21tYW5kX3JlZ2lzdGVyQ29tbWFuZChjb21wb25lbnQuY29tbWFuZHMsIGNvbW1hbmROYW1lLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgT2JqZWN0LmtleXMoZGVmYXVsdENvbW1hbmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgbW9kdWxlID0gZGVmYXVsdENvbW1hbmRzW2tleV07XG4gICAgdmFyIG5hbWUgPSBtb2R1bGUubmFtZSxcbiAgICAgICAgY2FsbGJhY2sgPSBtb2R1bGUuZGVmYXVsdDtcbiAgICBjb21wb25lbnQuY29tbWFuZChuYW1lLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzXG52YXIgZXNtX2V4dGVuZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy90b29sYmFyLmpzXG5cblxudmFyIGRlZmF1bHRUb29sYmFycyA9IHt9O1xuT2JqZWN0KHV0aWxbXCJjXCIgLyogaW1wb3J0QWxsICovXSkoZGVmYXVsdFRvb2xiYXJzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKSk7XG5mdW5jdGlvbiB0b29sYmFyX3JlZ2lzdGVyVG9vbGJhcih0YXJnZXQsIG5hbWUsIGNvbmZpZykge1xuICBpZiAobmFtZSkge1xuICAgIHRhcmdldFtuYW1lXSA9IE9iamVjdChlc21fZXh0ZW5kc1tcImFcIiAvKiBkZWZhdWx0ICovXSkoe30sIGNvbmZpZyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignVG9vbGJhciBuYW1lIGlzIHJlcXVpcmVkJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvb2xiYXJXcmFwcGVyKGNvbXBvbmVudCkge1xuICBjb21wb25lbnQudG9vbGJhcnMgPSB7fTtcblxuICBjb21wb25lbnQudG9vbGJhciA9IGZ1bmN0aW9uIChuYW1lLCBjb25maWcpIHtcbiAgICB0b29sYmFyX3JlZ2lzdGVyVG9vbGJhcihjb21wb25lbnQudG9vbGJhcnMsIG5hbWUsIGNvbmZpZyk7XG4gIH07XG5cbiAgT2JqZWN0LmtleXMoZGVmYXVsdFRvb2xiYXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgbW9kdWxlID0gZGVmYXVsdFRvb2xiYXJzW2tleV07XG4gICAgdmFyIGNvbmZpZyA9IG1vZHVsZS5kZWZhdWx0O1xuICAgIGNvbXBvbmVudC50b29sYmFyKGNvbmZpZy5uYW1lLCBjb25maWcpO1xuICB9KTtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvc3R5bGVzL2luZGV4LnNjc3NcbnZhciBzdHlsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9wcmV2aWV3LmpzICsgNiBtb2R1bGVzXG52YXIgcHJldmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3JlZi0tNiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Q/P3JlZi0tMi0wIS4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02YWMwOGQ5NSZiaW5kaW5ncz17XCJsZWZ0VG9vbGJhclwiOlwicHJvcHNcIixcInJpZ2h0VG9vbGJhclwiOlwicHJvcHNcIixcInRvb2xiYXJzXCI6XCJwcm9wc1wiLFwiZnVsbHNjcmVlblwiOlwicHJvcHNcIixcImhlaWdodFwiOlwicHJvcHNcIixcIm5vcmVzaXplXCI6XCJwcm9wc1wiLFwiZGlzYWJsZWRNZW51c1wiOlwicHJvcHNcIixcImxlZnRBcmVhVmlzaWJsZVwiOlwicHJvcHNcIixcImxlZnRBcmVhVGl0bGVcIjpcInByb3BzXCIsXCJsZWZ0QXJlYVJldmVyc2VcIjpcInByb3BzXCIsXCJsZWZ0QXJlYVdpZHRoXCI6XCJwcm9wc1wiLFwibW9kZVwiOlwicHJvcHNcIixcInRvb2xiYXJIZWlnaHRcIjpcImRhdGFcIixcImhlaWdodEdldHRlclwiOlwib3B0aW9uc1wiLFwibGVmdFRvb2xiYXJHcm91cFwiOlwib3B0aW9uc1wiLFwicmlnaHRUb29sYmFyR3JvdXBcIjpcIm9wdGlvbnNcIixcImlzUHJldmlld01vZGVcIjpcIm9wdGlvbnNcIixcImlzRWRpdE1vZGVcIjpcIm9wdGlvbnNcIixcImhhbmRsZVJlc2l6ZVwiOlwib3B0aW9uc1wiLFwiaGFuZGxlVG9vbGJhcldyYXBwZXJSZXNpemVcIjpcIm9wdGlvbnNcIixcImdldFRvb2xiYXJDb25maWdcIjpcIm9wdGlvbnNcIixcImhhbmRsZUVkaXRvcldyYXBwZXJDbGlja1wiOlwib3B0aW9uc1wiLFwiaGFuZGxlVG9vbGJhckl0ZW1DbGlja1wiOlwib3B0aW9uc1wiLFwiaGFuZGxlVG9vbGJhck1lbnVDbGlja1wiOlwib3B0aW9uc1wifVxuXG52YXIgX2hvaXN0ZWRfMSA9IHtcbiAgY2xhc3M6IFwidi1tZC1lZGl0b3JfX2xlZnQtYXJlYS1ib2R5XCJcbn07XG52YXIgX2hvaXN0ZWRfMiA9IHtcbiAgY2xhc3M6IFwidi1tZC1lZGl0b3JfX3JpZ2h0LWFyZWFcIlxufTtcbnZhciBfaG9pc3RlZF8zID0ge1xuICBjbGFzczogXCJ2LW1kLWVkaXRvcl9fdG9vbGJhclwiLFxuICByZWY6IFwidG9vbGJhcldyYXBwZXJcIlxufTtcbnZhciBfaG9pc3RlZF80ID0ge1xuICBjbGFzczogXCJ2LW1kLWVkaXRvcl9fdG9vbGJhci1sZWZ0LXdyYXBwZXJcIlxufTtcbnZhciBfaG9pc3RlZF81ID0ge1xuICBjbGFzczogXCJ2LW1kLWVkaXRvcl9fdG9vbGJhci1yaWdodC13cmFwcGVyXCJcbn07XG52YXIgX2hvaXN0ZWRfNiA9IHtcbiAgY2xhc3M6IFwidi1tZC1lZGl0b3JfX21haW5cIlxufTtcbnZhciBfaG9pc3RlZF83ID0ge1xuICBjbGFzczogXCJ2LW1kLWVkaXRvcl9fcHJldmlldy13cmFwcGVyXCIsXG4gIHJlZjogXCJwcmV2aWV3V3JhcHBlclwiXG59O1xuZnVuY3Rpb24gY29udGFpbmVydnVlX3R5cGVfdGVtcGxhdGVfaWRfNmFjMDhkOTVfYmluZGluZ3NfbGVmdFRvb2xiYXJfcHJvcHNfcmlnaHRUb29sYmFyX3Byb3BzX3Rvb2xiYXJzX3Byb3BzX2Z1bGxzY3JlZW5fcHJvcHNfaGVpZ2h0X3Byb3BzX25vcmVzaXplX3Byb3BzX2Rpc2FibGVkTWVudXNfcHJvcHNfbGVmdEFyZWFWaXNpYmxlX3Byb3BzX2xlZnRBcmVhVGl0bGVfcHJvcHNfbGVmdEFyZWFSZXZlcnNlX3Byb3BzX2xlZnRBcmVhV2lkdGhfcHJvcHNfbW9kZV9wcm9wc190b29sYmFySGVpZ2h0X2RhdGFfaGVpZ2h0R2V0dGVyX29wdGlvbnNfbGVmdFRvb2xiYXJHcm91cF9vcHRpb25zX3JpZ2h0VG9vbGJhckdyb3VwX29wdGlvbnNfaXNQcmV2aWV3TW9kZV9vcHRpb25zX2lzRWRpdE1vZGVfb3B0aW9uc19oYW5kbGVSZXNpemVfb3B0aW9uc19oYW5kbGVUb29sYmFyV3JhcHBlclJlc2l6ZV9vcHRpb25zX2dldFRvb2xiYXJDb25maWdfb3B0aW9uc19oYW5kbGVFZGl0b3JXcmFwcGVyQ2xpY2tfb3B0aW9uc19oYW5kbGVUb29sYmFySXRlbUNsaWNrX29wdGlvbnNfaGFuZGxlVG9vbGJhck1lbnVDbGlja19vcHRpb25zX3JlbmRlcihfY3R4LCBfY2FjaGUsICRwcm9wcywgJHNldHVwLCAkZGF0YSwgJG9wdGlvbnMpIHtcbiAgdmFyIF9jb21wb25lbnRfZWRpdG9yX3Rvb2xiYXIgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZXNvbHZlQ29tcG9uZW50XCJdKShcImVkaXRvci10b29sYmFyXCIpO1xuXG4gIHJldHVybiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKCksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUJsb2NrXCJdKShcImRpdlwiLCB7XG4gICAgY2xhc3M6IFtcInYtbWQtZWRpdG9yXCIsIFtcInYtbWQtZWRpdG9yLS1cIiArICRwcm9wcy5tb2RlLCB7XG4gICAgICAndi1tZC1lZGl0b3ItLWZ1bGxzY3JlZW4nOiAkcHJvcHMuZnVsbHNjcmVlbixcbiAgICAgICd2LW1kLWVkaXRvci0tbGVmdC1hcmVhLXJldmVyc2UnOiAkcHJvcHMubGVmdEFyZWFSZXZlcnNlXG4gICAgfV1dLFxuICAgIHN0eWxlOiB7XG4gICAgICBoZWlnaHQ6ICRvcHRpb25zLmhlaWdodEdldHRlclxuICAgIH1cbiAgfSwgW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhEaXJlY3RpdmVzXCJdKShPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoXCJkaXZcIiwge1xuICAgIGNsYXNzOiBcInYtbWQtZWRpdG9yX19sZWZ0LWFyZWFcIixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6ICRwcm9wcy5sZWZ0QXJlYVZpc2libGUgPyAkcHJvcHMubGVmdEFyZWFXaWR0aCA6IDAsXG4gICAgICBib3JkZXJXaWR0aDogJHByb3BzLmxlZnRBcmVhVmlzaWJsZSA/ICcxcHgnIDogMFxuICAgIH1cbiAgfSwgW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcImRpdlwiLCB7XG4gICAgY2xhc3M6IFwidi1tZC1lZGl0b3JfX2xlZnQtYXJlYS10aXRsZVwiLFxuICAgIHN0eWxlOiB7XG4gICAgICBoZWlnaHQ6ICRkYXRhLnRvb2xiYXJIZWlnaHQgKyBcInB4XCIsXG4gICAgICBsaW5lSGVpZ2h0OiAkZGF0YS50b29sYmFySGVpZ2h0ICsgXCJweFwiXG4gICAgfVxuICB9LCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ0b0Rpc3BsYXlTdHJpbmdcIl0pKCRwcm9wcy5sZWZ0QXJlYVRpdGxlKSwgNVxuICAvKiBURVhULCBTVFlMRSAqL1xuICApLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoXCJkaXZcIiwgX2hvaXN0ZWRfMSwgW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInJlbmRlclNsb3RcIl0pKF9jdHguJHNsb3RzLCBcImxlZnQtYXJlYVwiKV0pXSwgNFxuICAvKiBTVFlMRSAqL1xuICApLCBbW2V4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1widlNob3dcIl0sICEkb3B0aW9ucy5pc1ByZXZpZXdNb2RlXV0pLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoXCJkaXZcIiwgX2hvaXN0ZWRfMiwgW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhEaXJlY3RpdmVzXCJdKShPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoXCJkaXZcIiwgX2hvaXN0ZWRfMywgW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcImRpdlwiLCBfaG9pc3RlZF80LCBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyU2xvdFwiXSkoX2N0eC4kc2xvdHMsIFwibGVmdC10b29sYmFyXCIsIHt9LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoX2NvbXBvbmVudF9lZGl0b3JfdG9vbGJhciwge1xuICAgICAgY2xhc3M6IFwidi1tZC1lZGl0b3JfX3Rvb2xiYXItbGVmdFwiLFxuICAgICAgZ3JvdXBzOiAkb3B0aW9ucy5sZWZ0VG9vbGJhckdyb3VwLFxuICAgICAgdG9vbGJhcnM6ICRwcm9wcy50b29sYmFycyxcbiAgICAgIFwiZGlzYWJsZWQtbWVudXNcIjogJHByb3BzLmRpc2FibGVkTWVudXMsXG4gICAgICBvbkl0ZW1DbGljazogJG9wdGlvbnMuaGFuZGxlVG9vbGJhckl0ZW1DbGljayxcbiAgICAgIG9uVG9vbGJhck1lbnVDbGljazogJG9wdGlvbnMuaGFuZGxlVG9vbGJhck1lbnVDbGlja1xuICAgIH0sIG51bGwsIDhcbiAgICAvKiBQUk9QUyAqL1xuICAgICwgW1wiZ3JvdXBzXCIsIFwidG9vbGJhcnNcIiwgXCJkaXNhYmxlZC1tZW51c1wiLCBcIm9uSXRlbUNsaWNrXCIsIFwib25Ub29sYmFyTWVudUNsaWNrXCJdKV07XG4gIH0pXSksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcImRpdlwiLCBfaG9pc3RlZF81LCBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyU2xvdFwiXSkoX2N0eC4kc2xvdHMsIFwicmlnaHQtdG9vbGJhclwiLCB7fSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKF9jb21wb25lbnRfZWRpdG9yX3Rvb2xiYXIsIHtcbiAgICAgIGNsYXNzOiBcInYtbWQtZWRpdG9yX190b29sYmFyLXJpZ2h0XCIsXG4gICAgICBncm91cHM6ICRvcHRpb25zLnJpZ2h0VG9vbGJhckdyb3VwLFxuICAgICAgdG9vbGJhcnM6ICRwcm9wcy50b29sYmFycyxcbiAgICAgIFwiZGlzYWJsZWQtbWVuc1wiOiAkcHJvcHMuZGlzYWJsZWRNZW51cyxcbiAgICAgIG9uSXRlbUNsaWNrOiAkb3B0aW9ucy5oYW5kbGVUb29sYmFySXRlbUNsaWNrLFxuICAgICAgb25Ub29sYmFyTWVudUNsaWNrOiAkb3B0aW9ucy5oYW5kbGVUb29sYmFyTWVudUNsaWNrXG4gICAgfSwgbnVsbCwgOFxuICAgIC8qIFBST1BTICovXG4gICAgLCBbXCJncm91cHNcIiwgXCJ0b29sYmFyc1wiLCBcImRpc2FibGVkLW1lbnNcIiwgXCJvbkl0ZW1DbGlja1wiLCBcIm9uVG9vbGJhck1lbnVDbGlja1wiXSldO1xuICB9KV0pXSwgNTEyXG4gIC8qIE5FRURfUEFUQ0ggKi9cbiAgKSwgW1tleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInZTaG93XCJdLCAhJG9wdGlvbnMuaXNQcmV2aWV3TW9kZV1dKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKFwiZGl2XCIsIF9ob2lzdGVkXzYsIFtPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoRGlyZWN0aXZlc1wiXSkoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKFwiZGl2XCIsIHtcbiAgICByZWY6IFwiZWRpdG9yV3JhcHBlclwiLFxuICAgIGNsYXNzOiBcInYtbWQtZWRpdG9yX19lZGl0b3Itd3JhcHBlclwiLFxuICAgIG9uQ2xpY2s6IF9jYWNoZVsxXSB8fCAoX2NhY2hlWzFdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICRvcHRpb25zLmhhbmRsZUVkaXRvcldyYXBwZXJDbGljay5hcHBseSgkb3B0aW9ucywgYXJndW1lbnRzKTtcbiAgICB9KVxuICB9LCBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyU2xvdFwiXSkoX2N0eC4kc2xvdHMsIFwiZWRpdG9yXCIpXSwgNTEyXG4gIC8qIE5FRURfUEFUQ0ggKi9cbiAgKSwgW1tleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInZTaG93XCJdLCAhJG9wdGlvbnMuaXNQcmV2aWV3TW9kZV1dKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aERpcmVjdGl2ZXNcIl0pKE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcImRpdlwiLCBfaG9pc3RlZF83LCBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyU2xvdFwiXSkoX2N0eC4kc2xvdHMsIFwicHJldmlld1wiKV0sIDUxMlxuICAvKiBORUVEX1BBVENIICovXG4gICksIFtbZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ2U2hvd1wiXSwgISRvcHRpb25zLmlzRWRpdE1vZGVdXSksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInJlbmRlclNsb3RcIl0pKF9jdHguJHNsb3RzLCBcImRlZmF1bHRcIildKV0pXSwgNlxuICAvKiBDTEFTUywgU1RZTEUgKi9cbiAgKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02YWMwOGQ5NSZiaW5kaW5ncz17XCJsZWZ0VG9vbGJhclwiOlwicHJvcHNcIixcInJpZ2h0VG9vbGJhclwiOlwicHJvcHNcIixcInRvb2xiYXJzXCI6XCJwcm9wc1wiLFwiZnVsbHNjcmVlblwiOlwicHJvcHNcIixcImhlaWdodFwiOlwicHJvcHNcIixcIm5vcmVzaXplXCI6XCJwcm9wc1wiLFwiZGlzYWJsZWRNZW51c1wiOlwicHJvcHNcIixcImxlZnRBcmVhVmlzaWJsZVwiOlwicHJvcHNcIixcImxlZnRBcmVhVGl0bGVcIjpcInByb3BzXCIsXCJsZWZ0QXJlYVJldmVyc2VcIjpcInByb3BzXCIsXCJsZWZ0QXJlYVdpZHRoXCI6XCJwcm9wc1wiLFwibW9kZVwiOlwicHJvcHNcIixcInRvb2xiYXJIZWlnaHRcIjpcImRhdGFcIixcImhlaWdodEdldHRlclwiOlwib3B0aW9uc1wiLFwibGVmdFRvb2xiYXJHcm91cFwiOlwib3B0aW9uc1wiLFwicmlnaHRUb29sYmFyR3JvdXBcIjpcIm9wdGlvbnNcIixcImlzUHJldmlld01vZGVcIjpcIm9wdGlvbnNcIixcImlzRWRpdE1vZGVcIjpcIm9wdGlvbnNcIixcImhhbmRsZVJlc2l6ZVwiOlwib3B0aW9uc1wiLFwiaGFuZGxlVG9vbGJhcldyYXBwZXJSZXNpemVcIjpcIm9wdGlvbnNcIixcImdldFRvb2xiYXJDb25maWdcIjpcIm9wdGlvbnNcIixcImhhbmRsZUVkaXRvcldyYXBwZXJDbGlja1wiOlwib3B0aW9uc1wiLFwiaGFuZGxlVG9vbGJhckl0ZW1DbGlja1wiOlwib3B0aW9uc1wiLFwiaGFuZGxlVG9vbGJhck1lbnVDbGlja1wiOlwib3B0aW9uc1wifVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9yZWYtLTYhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTE5N2YzYTNiJmJpbmRpbmdzPXtcIm1hcmtkb3duRWRpdG9yXCI6XCJvcHRpb25zXCIsXCJncm91cHNcIjpcInByb3BzXCIsXCJ0b29sYmFyc1wiOlwicHJvcHNcIixcImRpc2FibGVkTWVudXNcIjpcInByb3BzXCIsXCJnZXRDb25maWdcIjpcIm9wdGlvbnNcIn1cblxudmFyIHRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8xOTdmM2EzYl9iaW5kaW5nc19tYXJrZG93bkVkaXRvcl9vcHRpb25zX2dyb3Vwc19wcm9wc190b29sYmFyc19wcm9wc19kaXNhYmxlZE1lbnVzX3Byb3BzX2dldENvbmZpZ19vcHRpb25zX2hvaXN0ZWRfMSA9IHtcbiAga2V5OiAwXG59O1xudmFyIHRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8xOTdmM2EzYl9iaW5kaW5nc19tYXJrZG93bkVkaXRvcl9vcHRpb25zX2dyb3Vwc19wcm9wc190b29sYmFyc19wcm9wc19kaXNhYmxlZE1lbnVzX3Byb3BzX2dldENvbmZpZ19vcHRpb25zX2hvaXN0ZWRfMiA9IHtcbiAga2V5OiAwLFxuICBjbGFzczogXCJ2LW1kLWVkaXRvcl9fdG9vbGJhci1kaXZpZGVyXCJcbn07XG5mdW5jdGlvbiB0b29sYmFydnVlX3R5cGVfdGVtcGxhdGVfaWRfMTk3ZjNhM2JfYmluZGluZ3NfbWFya2Rvd25FZGl0b3Jfb3B0aW9uc19ncm91cHNfcHJvcHNfdG9vbGJhcnNfcHJvcHNfZGlzYWJsZWRNZW51c19wcm9wc19nZXRDb25maWdfb3B0aW9uc19yZW5kZXIoX2N0eCwgX2NhY2hlLCAkcHJvcHMsICRzZXR1cCwgJGRhdGEsICRvcHRpb25zKSB7XG4gIHZhciBfY29tcG9uZW50X3Rvb2xiYXJfaXRlbSA9IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInJlc29sdmVDb21wb25lbnRcIl0pKFwidG9vbGJhci1pdGVtXCIpO1xuXG4gIHJldHVybiAkcHJvcHMuZ3JvdXBzLmxlbmd0aCA/IChPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKCksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUJsb2NrXCJdKShcInVsXCIsIHRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8xOTdmM2EzYl9iaW5kaW5nc19tYXJrZG93bkVkaXRvcl9vcHRpb25zX2dyb3Vwc19wcm9wc190b29sYmFyc19wcm9wc19kaXNhYmxlZE1lbnVzX3Byb3BzX2dldENvbmZpZ19vcHRpb25zX2hvaXN0ZWRfMSwgWyhPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKHRydWUpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJGcmFnbWVudFwiXSwgbnVsbCwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyTGlzdFwiXSkoJHByb3BzLmdyb3VwcywgZnVuY3Rpb24gKGdyb3VwLCBpZHgpIHtcbiAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJGcmFnbWVudFwiXSwgbnVsbCwgWyhPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKHRydWUpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJGcmFnbWVudFwiXSwgbnVsbCwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyTGlzdFwiXSkoZ3JvdXAsIGZ1bmN0aW9uICh0b29sYmFyTmFtZSkge1xuICAgICAgcmV0dXJuIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIm9wZW5CbG9ja1wiXSkoKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlQmxvY2tcIl0pKF9jb21wb25lbnRfdG9vbGJhcl9pdGVtLCB7XG4gICAgICAgIGtleTogdG9vbGJhck5hbWUsXG4gICAgICAgIG5hbWU6IHRvb2xiYXJOYW1lLFxuICAgICAgICB0aXRsZTogJG9wdGlvbnMuZ2V0Q29uZmlnKHRvb2xiYXJOYW1lLCAndGl0bGUnKSxcbiAgICAgICAgaWNvbjogJG9wdGlvbnMuZ2V0Q29uZmlnKHRvb2xiYXJOYW1lLCAnaWNvbicpLFxuICAgICAgICB0ZXh0OiAkb3B0aW9ucy5nZXRDb25maWcodG9vbGJhck5hbWUsICd0ZXh0JyksXG4gICAgICAgIGFjdGl2ZTogJG9wdGlvbnMuZ2V0Q29uZmlnKHRvb2xiYXJOYW1lLCAnYWN0aXZlJyksXG4gICAgICAgIG1lbnVzOiAkb3B0aW9ucy5nZXRDb25maWcodG9vbGJhck5hbWUsICdtZW51cycpLFxuICAgICAgICBcImRpc2FibGVkLW1lbnVzXCI6ICRwcm9wcy5kaXNhYmxlZE1lbnVzLFxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCRldmVudCkge1xuICAgICAgICAgIHJldHVybiBfY3R4LiRlbWl0KCdpdGVtLWNsaWNrJywgJHByb3BzLnRvb2xiYXJzW3Rvb2xiYXJOYW1lXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTWVudUNsaWNrOiBfY2FjaGVbMV0gfHwgKF9jYWNoZVsxXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX2N0eC4kZW1pdCgndG9vbGJhci1tZW51LWNsaWNrJywgJGV2ZW50KTtcbiAgICAgICAgfSlcbiAgICAgIH0sIG51bGwsIDhcbiAgICAgIC8qIFBST1BTICovXG4gICAgICAsIFtcIm5hbWVcIiwgXCJ0aXRsZVwiLCBcImljb25cIiwgXCJ0ZXh0XCIsIFwiYWN0aXZlXCIsIFwibWVudXNcIiwgXCJkaXNhYmxlZC1tZW51c1wiLCBcIm9uQ2xpY2tcIl0pO1xuICAgIH0pLCAxMjhcbiAgICAvKiBLRVlFRF9GUkFHTUVOVCAqL1xuICAgICkpLCBpZHggIT09ICRwcm9wcy5ncm91cHMubGVuZ3RoIC0gMSA/IChPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKCksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUJsb2NrXCJdKShcImxpXCIsIHRvb2xiYXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8xOTdmM2EzYl9iaW5kaW5nc19tYXJrZG93bkVkaXRvcl9vcHRpb25zX2dyb3Vwc19wcm9wc190b29sYmFyc19wcm9wc19kaXNhYmxlZE1lbnVzX3Byb3BzX2dldENvbmZpZ19vcHRpb25zX2hvaXN0ZWRfMikpIDogT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlQ29tbWVudFZOb2RlXCJdKShcInYtaWZcIiwgdHJ1ZSldLCA2NFxuICAgIC8qIFNUQUJMRV9GUkFHTUVOVCAqL1xuICAgICk7XG4gIH0pLCAyNTZcbiAgLyogVU5LRVlFRF9GUkFHTUVOVCAqL1xuICApKV0pKSA6IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUNvbW1lbnRWTm9kZVwiXSkoXCJ2LWlmXCIsIHRydWUpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90b29sYmFyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xOTdmM2EzYiZiaW5kaW5ncz17XCJtYXJrZG93bkVkaXRvclwiOlwib3B0aW9uc1wiLFwiZ3JvdXBzXCI6XCJwcm9wc1wiLFwidG9vbGJhcnNcIjpcInByb3BzXCIsXCJkaXNhYmxlZE1lbnVzXCI6XCJwcm9wc1wiLFwiZ2V0Q29uZmlnXCI6XCJvcHRpb25zXCJ9XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3JlZi0tNiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Q/P3JlZi0tMi0wIS4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci1pdGVtL2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zMGY2MTc2ZCZiaW5kaW5ncz17XCJuYW1lXCI6XCJwcm9wc1wiLFwidGl0bGVcIjpcInByb3BzXCIsXCJhY3RpdmVcIjpcInByb3BzXCIsXCJ0ZXh0XCI6XCJwcm9wc1wiLFwiaWNvblwiOlwicHJvcHNcIixcIm1lbnVzXCI6XCJwcm9wc1wiLFwiZGlzYWJsZWRNZW51c1wiOlwicHJvcHNcIixcIm1lbnVBY3RpdmVcIjpcImRhdGFcIixcImhhc01lbnVcIjpcIm9wdGlvbnNcIixcIm1lbnVJdGVtc1wiOlwib3B0aW9uc1wiLFwibWVudU1vZGVcIjpcIm9wdGlvbnNcIixcImhpZGVNZW51XCI6XCJvcHRpb25zXCIsXCJzaG93TWVudVwiOlwib3B0aW9uc1wiLFwiaGFuZGxlQ2xpY2tcIjpcIm9wdGlvbnNcIixcInNob3dUb29sdGlwXCI6XCJvcHRpb25zXCIsXCJoYW5kbGVIaWRlVG9vbHRpcFwiOlwib3B0aW9uc1wifVxuXG52YXIgdG9vbGJhcl9pdGVtdnVlX3R5cGVfdGVtcGxhdGVfaWRfMzBmNjE3NmRfYmluZGluZ3NfbmFtZV9wcm9wc190aXRsZV9wcm9wc19hY3RpdmVfcHJvcHNfdGV4dF9wcm9wc19pY29uX3Byb3BzX21lbnVzX3Byb3BzX2Rpc2FibGVkTWVudXNfcHJvcHNfbWVudUFjdGl2ZV9kYXRhX2hhc01lbnVfb3B0aW9uc19tZW51SXRlbXNfb3B0aW9uc19tZW51TW9kZV9vcHRpb25zX2hpZGVNZW51X29wdGlvbnNfc2hvd01lbnVfb3B0aW9uc19oYW5kbGVDbGlja19vcHRpb25zX3Nob3dUb29sdGlwX29wdGlvbnNfaGFuZGxlSGlkZVRvb2x0aXBfb3B0aW9uc19ob2lzdGVkXzEgPSB7XG4gIGtleTogMSxcbiAgY2xhc3M6IFwidi1tZC1pY29uLWFycm93LWRvd24gdi1tZC1lZGl0b3JfX21lbnUtY3RybFwiLFxuICByZWY6IFwibWVudUN0cmxcIlxufTtcbmZ1bmN0aW9uIHRvb2xiYXJfaXRlbXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzMwZjYxNzZkX2JpbmRpbmdzX25hbWVfcHJvcHNfdGl0bGVfcHJvcHNfYWN0aXZlX3Byb3BzX3RleHRfcHJvcHNfaWNvbl9wcm9wc19tZW51c19wcm9wc19kaXNhYmxlZE1lbnVzX3Byb3BzX21lbnVBY3RpdmVfZGF0YV9oYXNNZW51X29wdGlvbnNfbWVudUl0ZW1zX29wdGlvbnNfbWVudU1vZGVfb3B0aW9uc19oaWRlTWVudV9vcHRpb25zX3Nob3dNZW51X29wdGlvbnNfaGFuZGxlQ2xpY2tfb3B0aW9uc19zaG93VG9vbHRpcF9vcHRpb25zX2hhbmRsZUhpZGVUb29sdGlwX29wdGlvbnNfcmVuZGVyKF9jdHgsIF9jYWNoZSwgJHByb3BzLCAkc2V0dXAsICRkYXRhLCAkb3B0aW9ucykge1xuICB2YXIgX2NvbXBvbmVudF92X21kX3Rvb2x0aXAgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZXNvbHZlQ29tcG9uZW50XCJdKShcInYtbWQtdG9vbHRpcFwiKTtcblxuICB2YXIgX2NvbXBvbmVudF92X21kX21lbnUgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZXNvbHZlQ29tcG9uZW50XCJdKShcInYtbWQtbWVudVwiKTtcblxuICB2YXIgX2RpcmVjdGl2ZV9jbGlja291dHNpZGUgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZXNvbHZlRGlyZWN0aXZlXCJdKShcImNsaWNrb3V0c2lkZVwiKTtcblxuICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aERpcmVjdGl2ZXNcIl0pKChPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKCksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUJsb2NrXCJdKShcImxpXCIsIHtcbiAgICBjbGFzczogW1widi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbVwiLCBbJHByb3BzLmljb24sIFwidi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbS1cIiArICRwcm9wcy5uYW1lLCB7XG4gICAgICAndi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbS0tYWN0aXZlJzogJHByb3BzLmFjdGl2ZSB8fCAkZGF0YS5tZW51QWN0aXZlXG4gICAgfSwge1xuICAgICAgJ3YtbWQtZWRpdG9yX190b29sYmFyLWl0ZW0tLW1lbnUnOiAkb3B0aW9ucy5oYXNNZW51XG4gICAgfV1dLFxuICAgIG9uTW91c2Vkb3duOiBfY2FjaGVbM10gfHwgKF9jYWNoZVszXSA9IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhNb2RpZmllcnNcIl0pKGZ1bmN0aW9uICgpIHt9LCBbXCJwcmV2ZW50XCJdKSksXG4gICAgb25Nb3VzZWxlYXZlOiBfY2FjaGVbNF0gfHwgKF9jYWNoZVs0XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAkb3B0aW9ucy5oYW5kbGVIaWRlVG9vbHRpcC5hcHBseSgkb3B0aW9ucywgYXJndW1lbnRzKTtcbiAgICB9KSxcbiAgICBvbk1vdXNlbW92ZTogX2NhY2hlWzVdIHx8IChfY2FjaGVbNV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJG9wdGlvbnMuc2hvd1Rvb2x0aXAuYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSksXG4gICAgb25DbGljazogX2NhY2hlWzZdIHx8IChfY2FjaGVbNl0gPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoTW9kaWZpZXJzXCJdKShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJG9wdGlvbnMuaGFuZGxlQ2xpY2suYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSwgW1wic3RvcFwiXSkpXG4gIH0sIFtPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVUZXh0Vk5vZGVcIl0pKE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInRvRGlzcGxheVN0cmluZ1wiXSkoJHByb3BzLnRleHQpICsgXCIgXCIsIDFcbiAgLyogVEVYVCAqL1xuICApLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoX2NvbXBvbmVudF92X21kX3Rvb2x0aXAsIHtcbiAgICByZWY6IFwidG9vbHRpcFwiLFxuICAgIHRleHQ6ICRwcm9wcy50aXRsZVxuICB9LCBudWxsLCA4XG4gIC8qIFBST1BTICovXG4gICwgW1widGV4dFwiXSksICRvcHRpb25zLmhhc01lbnUgPyAoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoX2NvbXBvbmVudF92X21kX21lbnUsIHtcbiAgICBrZXk6IDAsXG4gICAgcmVmOiBcIm1lbnVcIixcbiAgICBtb2RlOiAkb3B0aW9ucy5tZW51TW9kZSxcbiAgICBtZW51czogJG9wdGlvbnMubWVudUl0ZW1zLFxuICAgIFwiaXRlbS13aWR0aFwiOiAkcHJvcHMubWVudXMuaXRlbVdpZHRoLFxuICAgIFwicm93LW51bVwiOiAkcHJvcHMubWVudXMucm93TnVtLFxuICAgIHZpc2libGU6ICRkYXRhLm1lbnVBY3RpdmUsXG4gICAgXCJvblVwZGF0ZTp2aXNpYmxlXCI6IF9jYWNoZVsxXSB8fCAoX2NhY2hlWzFdID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgcmV0dXJuICRkYXRhLm1lbnVBY3RpdmUgPSAkZXZlbnQ7XG4gICAgfSksXG4gICAgb25JdGVtQ2xpY2s6IF9jYWNoZVsyXSB8fCAoX2NhY2hlWzJdID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgcmV0dXJuIF9jdHguJGVtaXQoJ21lbnUtY2xpY2snLCAkZXZlbnQpO1xuICAgIH0pXG4gIH0sIG51bGwsIDhcbiAgLyogUFJPUFMgKi9cbiAgLCBbXCJtb2RlXCIsIFwibWVudXNcIiwgXCJpdGVtLXdpZHRoXCIsIFwicm93LW51bVwiLCBcInZpc2libGVcIl0pKSA6IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUNvbW1lbnRWTm9kZVwiXSkoXCJ2LWlmXCIsIHRydWUpLCAkb3B0aW9ucy5oYXNNZW51ID8gKE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIm9wZW5CbG9ja1wiXSkoKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlQmxvY2tcIl0pKFwiaVwiLCB0b29sYmFyX2l0ZW12dWVfdHlwZV90ZW1wbGF0ZV9pZF8zMGY2MTc2ZF9iaW5kaW5nc19uYW1lX3Byb3BzX3RpdGxlX3Byb3BzX2FjdGl2ZV9wcm9wc190ZXh0X3Byb3BzX2ljb25fcHJvcHNfbWVudXNfcHJvcHNfZGlzYWJsZWRNZW51c19wcm9wc19tZW51QWN0aXZlX2RhdGFfaGFzTWVudV9vcHRpb25zX21lbnVJdGVtc19vcHRpb25zX21lbnVNb2RlX29wdGlvbnNfaGlkZU1lbnVfb3B0aW9uc19zaG93TWVudV9vcHRpb25zX2hhbmRsZUNsaWNrX29wdGlvbnNfc2hvd1Rvb2x0aXBfb3B0aW9uc19oYW5kbGVIaWRlVG9vbHRpcF9vcHRpb25zX2hvaXN0ZWRfMSwgbnVsbCwgNTEyXG4gIC8qIE5FRURfUEFUQ0ggKi9cbiAgKSkgOiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVDb21tZW50Vk5vZGVcIl0pKFwidi1pZlwiLCB0cnVlKV0sIDM0XG4gIC8qIENMQVNTLCBIWURSQVRFX0VWRU5UUyAqL1xuICApKSwgW1tfZGlyZWN0aXZlX2NsaWNrb3V0c2lkZSwgJG9wdGlvbnMuaGlkZU1lbnUsIFwiaGlkZU1lbnVcIl1dKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci1pdGVtL2luZGV4LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zMGY2MTc2ZCZiaW5kaW5ncz17XCJuYW1lXCI6XCJwcm9wc1wiLFwidGl0bGVcIjpcInByb3BzXCIsXCJhY3RpdmVcIjpcInByb3BzXCIsXCJ0ZXh0XCI6XCJwcm9wc1wiLFwiaWNvblwiOlwicHJvcHNcIixcIm1lbnVzXCI6XCJwcm9wc1wiLFwiZGlzYWJsZWRNZW51c1wiOlwicHJvcHNcIixcIm1lbnVBY3RpdmVcIjpcImRhdGFcIixcImhhc01lbnVcIjpcIm9wdGlvbnNcIixcIm1lbnVJdGVtc1wiOlwib3B0aW9uc1wiLFwibWVudU1vZGVcIjpcIm9wdGlvbnNcIixcImhpZGVNZW51XCI6XCJvcHRpb25zXCIsXCJzaG93TWVudVwiOlwib3B0aW9uc1wiLFwiaGFuZGxlQ2xpY2tcIjpcIm9wdGlvbnNcIixcInNob3dUb29sdGlwXCI6XCJvcHRpb25zXCIsXCJoYW5kbGVIaWRlVG9vbHRpcFwiOlwib3B0aW9uc1wifVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9yZWYtLTYhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXItaXRlbS90b29sdGlwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wNDdiYjk0ZSZiaW5kaW5ncz17XCJ0ZXh0XCI6XCJwcm9wc1wiLFwicG9zaXRpb25cIjpcImRhdGFcIixcInZpc2libGVcIjpcImRhdGFcIixcInNob3dcIjpcIm9wdGlvbnNcIixcImhpZGVcIjpcIm9wdGlvbnNcIixcImNhbGN1bGF0ZUxheW91dFwiOlwib3B0aW9uc1wifVxuXG5mdW5jdGlvbiB0b29sdGlwdnVlX3R5cGVfdGVtcGxhdGVfaWRfMDQ3YmI5NGVfYmluZGluZ3NfdGV4dF9wcm9wc19wb3NpdGlvbl9kYXRhX3Zpc2libGVfZGF0YV9zaG93X29wdGlvbnNfaGlkZV9vcHRpb25zX2NhbGN1bGF0ZUxheW91dF9vcHRpb25zX3JlbmRlcihfY3R4LCBfY2FjaGUsICRwcm9wcywgJHNldHVwLCAkZGF0YSwgJG9wdGlvbnMpIHtcbiAgcmV0dXJuIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIm9wZW5CbG9ja1wiXSkoKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlQmxvY2tcIl0pKGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiVHJhbnNpdGlvblwiXSwge1xuICAgIG5hbWU6IFwidi1tZC1mYWRlLWluXCJcbiAgfSwge1xuICAgIGRlZmF1bHQ6IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhDdHhcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aERpcmVjdGl2ZXNcIl0pKE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgbGVmdDogJGRhdGEucG9zaXRpb24ueCArIFwicHhcIixcbiAgICAgICAgICB0b3A6ICRkYXRhLnBvc2l0aW9uLnkgKyBcInB4XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3M6IFwidi1tZC1lZGl0b3JfX3Rvb2x0aXBcIlxuICAgICAgfSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1widG9EaXNwbGF5U3RyaW5nXCJdKSgkcHJvcHMudGV4dCksIDVcbiAgICAgIC8qIFRFWFQsIFNUWUxFICovXG4gICAgICApLCBbW2V4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1widlNob3dcIl0sICRkYXRhLnZpc2libGVdXSldO1xuICAgIH0pLFxuICAgIF86IDFcbiAgfSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXItaXRlbS90b29sdGlwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wNDdiYjk0ZSZiaW5kaW5ncz17XCJ0ZXh0XCI6XCJwcm9wc1wiLFwicG9zaXRpb25cIjpcImRhdGFcIixcInZpc2libGVcIjpcImRhdGFcIixcInNob3dcIjpcIm9wdGlvbnNcIixcImhpZGVcIjpcIm9wdGlvbnNcIixcImNhbGN1bGF0ZUxheW91dFwiOlwib3B0aW9uc1wifVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXItaXRlbS90b29sdGlwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdG9vbHRpcHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzID0gKHtcbiAgbmFtZTogJ3YtbWQtdG9vbHRpcCcsXG4gIHByb3BzOiB7XG4gICAgdGV4dDogU3RyaW5nXG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KHBvc2l0aW9uKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICB4OiBwb3NpdGlvbi54LFxuICAgICAgICB5OiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMuY2FsY3VsYXRlTGF5b3V0KTtcbiAgICB9LFxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB9LFxuICAgIGNhbGN1bGF0ZUxheW91dDogZnVuY3Rpb24gY2FsY3VsYXRlTGF5b3V0KCkge1xuICAgICAgLy8g5a655Zmo5Y+z6L655qGG6Led56a75Y+v6KeG5Yy65Z+f5bem5L6n55qE6Led56a7XG4gICAgICB2YXIgX3RoaXMkJGVsJGdldEJvdW5kaW5nID0gdGhpcy4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgcmlnaHQgPSBfdGhpcyQkZWwkZ2V0Qm91bmRpbmcucmlnaHQ7XG5cbiAgICAgIHZhciB3aW5kb3dXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcblxuICAgICAgaWYgKHdpbmRvd1dpZHRoIC0gcmlnaHQgPCAwKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueCAtPSByaWdodCAtIHdpbmRvd1dpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXItaXRlbS90b29sdGlwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1xuIFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXItaXRlbS90b29sdGlwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9c2Nzc1xudmFyIHRvb2x0aXB2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2NzcyA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXItaXRlbS90b29sdGlwLnZ1ZVxuXG5cblxuXG5cbnRvb2x0aXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcy5yZW5kZXIgPSB0b29sdGlwdnVlX3R5cGVfdGVtcGxhdGVfaWRfMDQ3YmI5NGVfYmluZGluZ3NfdGV4dF9wcm9wc19wb3NpdGlvbl9kYXRhX3Zpc2libGVfZGF0YV9zaG93X29wdGlvbnNfaGlkZV9vcHRpb25zX2NhbGN1bGF0ZUxheW91dF9vcHRpb25zX3JlbmRlclxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0b29sdGlwID0gKHRvb2x0aXB2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9yZWYtLTYhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXItaXRlbS9tZW51LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00NTNhNGMzYyZiaW5kaW5ncz17XCJtYXJrZG93bkVkaXRvclwiOlwib3B0aW9uc1wiLFwibW9kZVwiOlwicHJvcHNcIixcIm1lbnVzXCI6XCJwcm9wc1wiLFwiaXRlbVdpZHRoXCI6XCJwcm9wc1wiLFwicm93TnVtXCI6XCJwcm9wc1wiLFwidmlzaWJsZVwiOlwicHJvcHNcIixcInN0eWxlXCI6XCJkYXRhXCIsXCJyb3dDb3VudFwiOlwib3B0aW9uc1wiLFwiaXNMaXN0TW9kZVwiOlwib3B0aW9uc1wiLFwiY2FsY3VsYXRlTGF5b3V0XCI6XCJvcHRpb25zXCIsXCJnZXRSb3dNZW51c1wiOlwib3B0aW9uc1wiLFwiZ2V0VGV4dFwiOlwib3B0aW9uc1wiLFwiaGlkZVwiOlwib3B0aW9uc1wiLFwiaGFuZGxlQ2xpY2tcIjpcIm9wdGlvbnNcIn1cblxudmFyIG1lbnV2dWVfdHlwZV90ZW1wbGF0ZV9pZF80NTNhNGMzY19iaW5kaW5nc19tYXJrZG93bkVkaXRvcl9vcHRpb25zX21vZGVfcHJvcHNfbWVudXNfcHJvcHNfaXRlbVdpZHRoX3Byb3BzX3Jvd051bV9wcm9wc192aXNpYmxlX3Byb3BzX3N0eWxlX2RhdGFfcm93Q291bnRfb3B0aW9uc19pc0xpc3RNb2RlX29wdGlvbnNfY2FsY3VsYXRlTGF5b3V0X29wdGlvbnNfZ2V0Um93TWVudXNfb3B0aW9uc19nZXRUZXh0X29wdGlvbnNfaGlkZV9vcHRpb25zX2hhbmRsZUNsaWNrX29wdGlvbnNfaG9pc3RlZF8xID0ge1xuICBrZXk6IDFcbn07XG52YXIgbWVudXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzQ1M2E0YzNjX2JpbmRpbmdzX21hcmtkb3duRWRpdG9yX29wdGlvbnNfbW9kZV9wcm9wc19tZW51c19wcm9wc19pdGVtV2lkdGhfcHJvcHNfcm93TnVtX3Byb3BzX3Zpc2libGVfcHJvcHNfc3R5bGVfZGF0YV9yb3dDb3VudF9vcHRpb25zX2lzTGlzdE1vZGVfb3B0aW9uc19jYWxjdWxhdGVMYXlvdXRfb3B0aW9uc19nZXRSb3dNZW51c19vcHRpb25zX2dldFRleHRfb3B0aW9uc19oaWRlX29wdGlvbnNfaGFuZGxlQ2xpY2tfb3B0aW9uc19ob2lzdGVkXzIgPSB7XG4gIGNsYXNzOiBcInYtbWQtZWRpdG9yX19tZW51LXJvd1wiXG59O1xuZnVuY3Rpb24gbWVudXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzQ1M2E0YzNjX2JpbmRpbmdzX21hcmtkb3duRWRpdG9yX29wdGlvbnNfbW9kZV9wcm9wc19tZW51c19wcm9wc19pdGVtV2lkdGhfcHJvcHNfcm93TnVtX3Byb3BzX3Zpc2libGVfcHJvcHNfc3R5bGVfZGF0YV9yb3dDb3VudF9vcHRpb25zX2lzTGlzdE1vZGVfb3B0aW9uc19jYWxjdWxhdGVMYXlvdXRfb3B0aW9uc19nZXRSb3dNZW51c19vcHRpb25zX2dldFRleHRfb3B0aW9uc19oaWRlX29wdGlvbnNfaGFuZGxlQ2xpY2tfb3B0aW9uc19yZW5kZXIoX2N0eCwgX2NhY2hlLCAkcHJvcHMsICRzZXR1cCwgJGRhdGEsICRvcHRpb25zKSB7XG4gIHZhciBfY29tcG9uZW50X3ZfbWRfcmVuZGVyID0gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVzb2x2ZUNvbXBvbmVudFwiXSkoXCJ2LW1kLXJlbmRlclwiKTtcblxuICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJUcmFuc2l0aW9uXCJdLCB7XG4gICAgbmFtZTogXCJ2LW1kLXpvb20taW4tdG9wXCJcbiAgfSwge1xuICAgIGRlZmF1bHQ6IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhDdHhcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aERpcmVjdGl2ZXNcIl0pKE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcInVsXCIsIHtcbiAgICAgICAgY2xhc3M6IFtcInYtbWQtZWRpdG9yX19tZW51XCIsIFtcInYtbWQtZWRpdG9yX19tZW51LS1cIiArICRwcm9wcy5tb2RlXV0sXG4gICAgICAgIHN0eWxlOiAkZGF0YS5zdHlsZSxcbiAgICAgICAgb25Nb3VzZW1vdmU6IF9jYWNoZVsxXSB8fCAoX2NhY2hlWzFdID0gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aE1vZGlmaWVyc1wiXSkoZnVuY3Rpb24gKCkge30sIFtcInN0b3BcIl0pKSxcbiAgICAgICAgb25DbGljazogX2NhY2hlWzJdIHx8IChfY2FjaGVbMl0gPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoTW9kaWZpZXJzXCJdKShmdW5jdGlvbiAoKSB7fSwgW1wic3RvcFwiXSkpXG4gICAgICB9LCBbJG9wdGlvbnMuaXNMaXN0TW9kZSA/IChPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKHRydWUpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJGcmFnbWVudFwiXSwge1xuICAgICAgICBrZXk6IDBcbiAgICAgIH0sIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInJlbmRlckxpc3RcIl0pKCRwcm9wcy5tZW51cywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIm9wZW5CbG9ja1wiXSkoKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlQmxvY2tcIl0pKFwibGlcIiwge1xuICAgICAgICAgIGtleTogaXRlbS5uYW1lLFxuICAgICAgICAgIGNsYXNzOiBbXCJ2LW1kLWVkaXRvcl9fbWVudS1pdGVtXCIsIFtcInYtbWQtZWRpdG9yX19tZW51LWl0ZW0tXCIgKyBpdGVtLm5hbWUsIGl0ZW0uY2xhc3NdXSxcbiAgICAgICAgICBvbkNsaWNrOiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoTW9kaWZpZXJzXCJdKShmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJG9wdGlvbnMuaGFuZGxlQ2xpY2soaXRlbSk7XG4gICAgICAgICAgfSwgW1wic3RvcFwiXSlcbiAgICAgICAgfSwgW2l0ZW0ucmVuZGVyID8gKE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIm9wZW5CbG9ja1wiXSkoKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlQmxvY2tcIl0pKF9jb21wb25lbnRfdl9tZF9yZW5kZXIsIHtcbiAgICAgICAgICBrZXk6IDAsXG4gICAgICAgICAgcmVuZGVyOiBpdGVtLnJlbmRlclxuICAgICAgICB9LCBudWxsLCA4XG4gICAgICAgIC8qIFBST1BTICovXG4gICAgICAgICwgW1wicmVuZGVyXCJdKSkgOiAoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJGcmFnbWVudFwiXSwge1xuICAgICAgICAgIGtleTogMVxuICAgICAgICB9LCBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVGV4dFZOb2RlXCJdKShPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ0b0Rpc3BsYXlTdHJpbmdcIl0pKCRvcHRpb25zLmdldFRleHQoaXRlbS50ZXh0KSksIDFcbiAgICAgICAgLyogVEVYVCAqL1xuICAgICAgICApXSwgNjRcbiAgICAgICAgLyogU1RBQkxFX0ZSQUdNRU5UICovXG4gICAgICAgICkpXSwgMTBcbiAgICAgICAgLyogQ0xBU1MsIFBST1BTICovXG4gICAgICAgICwgW1wib25DbGlja1wiXSk7XG4gICAgICB9KSwgMTI4XG4gICAgICAvKiBLRVlFRF9GUkFHTUVOVCAqL1xuICAgICAgKSkgOiAoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoXCJsaVwiLCBtZW51dnVlX3R5cGVfdGVtcGxhdGVfaWRfNDUzYTRjM2NfYmluZGluZ3NfbWFya2Rvd25FZGl0b3Jfb3B0aW9uc19tb2RlX3Byb3BzX21lbnVzX3Byb3BzX2l0ZW1XaWR0aF9wcm9wc19yb3dOdW1fcHJvcHNfdmlzaWJsZV9wcm9wc19zdHlsZV9kYXRhX3Jvd0NvdW50X29wdGlvbnNfaXNMaXN0TW9kZV9vcHRpb25zX2NhbGN1bGF0ZUxheW91dF9vcHRpb25zX2dldFJvd01lbnVzX29wdGlvbnNfZ2V0VGV4dF9vcHRpb25zX2hpZGVfb3B0aW9uc19oYW5kbGVDbGlja19vcHRpb25zX2hvaXN0ZWRfMSwgWyhPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKHRydWUpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJGcmFnbWVudFwiXSwgbnVsbCwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyTGlzdFwiXSkoJG9wdGlvbnMucm93Q291bnQsIGZ1bmN0aW9uIChyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoXCJkaXZcIiwgbWVudXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzQ1M2E0YzNjX2JpbmRpbmdzX21hcmtkb3duRWRpdG9yX29wdGlvbnNfbW9kZV9wcm9wc19tZW51c19wcm9wc19pdGVtV2lkdGhfcHJvcHNfcm93TnVtX3Byb3BzX3Zpc2libGVfcHJvcHNfc3R5bGVfZGF0YV9yb3dDb3VudF9vcHRpb25zX2lzTGlzdE1vZGVfb3B0aW9uc19jYWxjdWxhdGVMYXlvdXRfb3B0aW9uc19nZXRSb3dNZW51c19vcHRpb25zX2dldFRleHRfb3B0aW9uc19oaWRlX29wdGlvbnNfaGFuZGxlQ2xpY2tfb3B0aW9uc19ob2lzdGVkXzIsIFsoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSh0cnVlKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlQmxvY2tcIl0pKGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiRnJhZ21lbnRcIl0sIG51bGwsIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInJlbmRlckxpc3RcIl0pKCRvcHRpb25zLmdldFJvd01lbnVzKHJvd0luZGV4KSwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGtleTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgd2lkdGg6ICRwcm9wcy5pdGVtV2lkdGhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczogW1widi1tZC1lZGl0b3JfX21lbnUtaXRlbVwiLCBbXCJ2LW1kLWVkaXRvcl9fbWVudS1pdGVtLVwiICsgaXRlbS5uYW1lLCBpdGVtLmNsYXNzXV0sXG4gICAgICAgICAgICBvbkNsaWNrOiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoTW9kaWZpZXJzXCJdKShmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiAkb3B0aW9ucy5oYW5kbGVDbGljayhpdGVtKTtcbiAgICAgICAgICAgIH0sIFtcInN0b3BcIl0pXG4gICAgICAgICAgfSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1widG9EaXNwbGF5U3RyaW5nXCJdKShpdGVtLnRleHQpLCAxNVxuICAgICAgICAgIC8qIFRFWFQsIENMQVNTLCBTVFlMRSwgUFJPUFMgKi9cbiAgICAgICAgICAsIFtcIm9uQ2xpY2tcIl0pO1xuICAgICAgICB9KSwgMTI4XG4gICAgICAgIC8qIEtFWUVEX0ZSQUdNRU5UICovXG4gICAgICAgICkpXSk7XG4gICAgICB9KSwgMjU2XG4gICAgICAvKiBVTktFWUVEX0ZSQUdNRU5UICovXG4gICAgICApKV0pKV0sIDM4XG4gICAgICAvKiBDTEFTUywgU1RZTEUsIEhZRFJBVEVfRVZFTlRTICovXG4gICAgICApLCBbW2V4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1widlNob3dcIl0sICRwcm9wcy52aXNpYmxlXV0pXTtcbiAgICB9KSxcbiAgICBfOiAxXG4gIH0pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90b29sYmFyLWl0ZW0vbWVudS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NDUzYTRjM2MmYmluZGluZ3M9e1wibWFya2Rvd25FZGl0b3JcIjpcIm9wdGlvbnNcIixcIm1vZGVcIjpcInByb3BzXCIsXCJtZW51c1wiOlwicHJvcHNcIixcIml0ZW1XaWR0aFwiOlwicHJvcHNcIixcInJvd051bVwiOlwicHJvcHNcIixcInZpc2libGVcIjpcInByb3BzXCIsXCJzdHlsZVwiOlwiZGF0YVwiLFwicm93Q291bnRcIjpcIm9wdGlvbnNcIixcImlzTGlzdE1vZGVcIjpcIm9wdGlvbnNcIixcImNhbGN1bGF0ZUxheW91dFwiOlwib3B0aW9uc1wiLFwiZ2V0Um93TWVudXNcIjpcIm9wdGlvbnNcIixcImdldFRleHRcIjpcIm9wdGlvbnNcIixcImhpZGVcIjpcIm9wdGlvbnNcIixcImhhbmRsZUNsaWNrXCI6XCJvcHRpb25zXCJ9XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvcmVuZGVyLmpzXG52YXIgcmVuZGVyRm4gPSBmdW5jdGlvbiByZW5kZXJGbihwcm9wcywgX3JlZikge1xuICB2YXIgYXR0cnMgPSBfcmVmLmF0dHJzO1xuICByZXR1cm4gcHJvcHMucmVuZGVyLmFwcGx5KHByb3BzLCBhdHRycyk7XG59O1xuXG5yZW5kZXJGbi5wcm9wcyA9IFsncmVuZGVyJ107XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX3JlbmRlciA9IChyZW5kZXJGbik7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9jb25zdGFudHMvbWVudS1tb2RlLmpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtZW51X21vZGUgPSAoe1xuICBMSVNUOiAnbGlzdCcsXG4gIFBBTkVMOiAncGFuZWwnXG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Q/P3JlZi0tMi0wIS4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci1pdGVtL21lbnUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbWVudXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzID0gKHtcbiAgbmFtZTogJ3YtbWQtbWVudScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBWTWRSZW5kZXI6IGNvbXBvbmVudHNfcmVuZGVyXG4gIH0sXG4gIGluamVjdDogWydtYXJrZG93bkVkaXRvciddLFxuICBwcm9wczoge1xuICAgIG1vZGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG1lbnVfbW9kZS5QQU5FTFxuICAgIH0sXG4gICAgbWVudXM6IEFycmF5LFxuICAgIGl0ZW1XaWR0aDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJzMwcHgnXG4gICAgfSxcbiAgICByb3dOdW06IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDEwXG4gICAgfSxcbiAgICB2aXNpYmxlOiBCb29sZWFuXG4gIH0sXG4gIGVtaXRzOiBbJ3VwZGF0ZTp2aXNpYmxlJywgJ2l0ZW0tY2xpY2snXSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbGVmdDogMFxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgcm93Q291bnQ6IGZ1bmN0aW9uIHJvd0NvdW50KCkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLm1lbnVzLmxlbmd0aCAvIHRoaXMucm93TnVtKTtcbiAgICB9LFxuICAgIGlzTGlzdE1vZGU6IGZ1bmN0aW9uIGlzTGlzdE1vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlID09PSBtZW51X21vZGUuTElTVDtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmlzaWJsZTogZnVuY3Rpb24gdmlzaWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLnZpc2libGUpIHRoaXMuJG5leHRUaWNrKHRoaXMuY2FsY3VsYXRlTGF5b3V0KTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBjYWxjdWxhdGVMYXlvdXQ6IGZ1bmN0aW9uIGNhbGN1bGF0ZUxheW91dCgpIHtcbiAgICAgIC8vIOWuueWZqOWPs+i+ueahhui3neemu+WPr+inhuWMuuWfn+W3puS+p+eahOi3neemu1xuICAgICAgdmFyIF90aGlzJCRlbCRnZXRCb3VuZGluZyA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIHJpZ2h0ID0gX3RoaXMkJGVsJGdldEJvdW5kaW5nLnJpZ2h0O1xuXG4gICAgICB2YXIgd2luZG93V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICBpZiAod2luZG93V2lkdGggLSByaWdodCA8IDApIHRoaXMuc3R5bGUgPSB7XG4gICAgICAgIHJpZ2h0OiAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0Um93TWVudXM6IGZ1bmN0aW9uIGdldFJvd01lbnVzKHJvd0luZGV4KSB7XG4gICAgICB2YXIgZW5kID0gcm93SW5kZXggKiB0aGlzLnJvd051bTtcbiAgICAgIHZhciBzdGFydCA9IGVuZCAtIHRoaXMucm93TnVtO1xuICAgICAgcmV0dXJuIHRoaXMubWVudXMuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfSxcbiAgICBnZXRUZXh0OiBmdW5jdGlvbiBnZXRUZXh0KHRleHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGV4dCh0aGlzLm1hcmtkb3duRWRpdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnZpc2libGUnLCBmYWxzZSk7XG4gICAgfSxcbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2soaXRlbSkge1xuICAgICAgdGhpcy4kZW1pdCgnaXRlbS1jbGljaycsIGl0ZW0pO1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci1pdGVtL21lbnUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG4gXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci1pdGVtL21lbnUudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1zY3NzXG52YXIgbWVudXZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci1pdGVtL21lbnUudnVlXG5cblxuXG5cblxubWVudXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzLnJlbmRlciA9IG1lbnV2dWVfdHlwZV90ZW1wbGF0ZV9pZF80NTNhNGMzY19iaW5kaW5nc19tYXJrZG93bkVkaXRvcl9vcHRpb25zX21vZGVfcHJvcHNfbWVudXNfcHJvcHNfaXRlbVdpZHRoX3Byb3BzX3Jvd051bV9wcm9wc192aXNpYmxlX3Byb3BzX3N0eWxlX2RhdGFfcm93Q291bnRfb3B0aW9uc19pc0xpc3RNb2RlX29wdGlvbnNfY2FsY3VsYXRlTGF5b3V0X29wdGlvbnNfZ2V0Um93TWVudXNfb3B0aW9uc19nZXRUZXh0X29wdGlvbnNfaGlkZV9vcHRpb25zX2hhbmRsZUNsaWNrX29wdGlvbnNfcmVuZGVyXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1lbnUgPSAobWVudXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL2NsaWNrb3V0c2lkZS5qc1xuLy8gTW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vRWxlbWVGRS9lbGVtZW50L2Jsb2IvZGV2L3NyYy91dGlscy9jbGlja291dHNpZGUuanNcblxudmFyIG5vZGVMaXN0ID0gW107XG52YXIgY3R4ID0gJ0BAY2xpY2tvdXRzaWRlQ29udGV4dCc7XG52YXIgc3RhcnRDbGljaztcbnZhciBzZWVkID0gMDtcblxuaWYgKHV0aWxbXCJkXCIgLyogaW5Ccm93c2VyICovXSkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIHN0YXJ0Q2xpY2sgPSBlO1xuICB9KTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgbm9kZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGVbY3R4XS5kb2N1bWVudEhhbmRsZXIoZSwgc3RhcnRDbGljayk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudEhhbmRsZXIoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobW91c2V1cCwgbW91c2Vkb3duKSB7XG4gICAgaWYgKG1vdXNldXAgPT09IHZvaWQgMCkge1xuICAgICAgbW91c2V1cCA9IHt9O1xuICAgIH1cblxuICAgIGlmIChtb3VzZWRvd24gPT09IHZvaWQgMCkge1xuICAgICAgbW91c2Vkb3duID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF2bm9kZSB8fCAhYmluZGluZyB8fCAhYmluZGluZy5pbnN0YW5jZSB8fCAhbW91c2V1cC50YXJnZXQgfHwgIW1vdXNlZG93bi50YXJnZXQgfHwgZWwuY29udGFpbnMobW91c2V1cC50YXJnZXQpIHx8IGVsLmNvbnRhaW5zKG1vdXNlZG93bi50YXJnZXQpIHx8IGVsID09PSBtb3VzZXVwLnRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChiaW5kaW5nLmFyZyAmJiBlbFtjdHhdLm1ldGhvZE5hbWUgJiYgYmluZGluZy5pbnN0YW5jZVtlbFtjdHhdLm1ldGhvZE5hbWVdKSB7XG4gICAgICBiaW5kaW5nLmluc3RhbmNlW2VsW2N0eF0ubWV0aG9kTmFtZV0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxbY3R4XS5iaW5kaW5nRm4gJiYgZWxbY3R4XS5iaW5kaW5nRm4oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWNrb3V0c2lkZSA9ICh7XG4gIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBub2RlTGlzdC5wdXNoKGVsKTtcbiAgICB2YXIgaWQgPSBzZWVkKys7XG4gICAgZWxbY3R4XSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRvY3VtZW50SGFuZGxlcjogY3JlYXRlRG9jdW1lbnRIYW5kbGVyKGVsLCBiaW5kaW5nLCB2bm9kZSksXG4gICAgICBtZXRob2ROYW1lOiBiaW5kaW5nLmFyZyxcbiAgICAgIGJpbmRpbmdGbjogYmluZGluZy52YWx1ZVxuICAgIH07XG4gIH0sXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgZWxbY3R4XS5kb2N1bWVudEhhbmRsZXIgPSBjcmVhdGVEb2N1bWVudEhhbmRsZXIoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICBlbFtjdHhdLm1ldGhvZE5hbWUgPSBiaW5kaW5nLmFyZztcbiAgICBlbFtjdHhdLmJpbmRpbmdGbiA9IGJpbmRpbmcudmFsdWU7XG4gIH0sXG4gIHVubW91bnRlZDogZnVuY3Rpb24gdW5tb3VudGVkKGVsKSB7XG4gICAgdmFyIGxlbiA9IG5vZGVMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChub2RlTGlzdFtpXVtjdHhdLmlkID09PSBlbFtjdHhdLmlkKSB7XG4gICAgICAgIG5vZGVMaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlIGVsW2N0eF07XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYj8/cmVmLS0zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdD8/cmVmLS0yLTAhLi9zcmMvY29tcG9uZW50cy90b29sYmFyLWl0ZW0vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG52YXIgX2NvbXBvbmVudHM7XG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0b29sYmFyX2l0ZW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyA9ICh7XG4gIG5hbWU6ICd0b29sYmFyLWl0ZW0nLFxuICBkaXJlY3RpdmVzOiB7XG4gICAgQ2xpY2tvdXRzaWRlOiBjbGlja291dHNpZGVcbiAgfSxcbiAgY29tcG9uZW50czogKF9jb21wb25lbnRzID0ge30sIF9jb21wb25lbnRzW3Rvb2x0aXAubmFtZV0gPSB0b29sdGlwLCBfY29tcG9uZW50c1ttZW51Lm5hbWVdID0gbWVudSwgX2NvbXBvbmVudHMpLFxuICBwcm9wczoge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIGFjdGl2ZTogQm9vbGVhbixcbiAgICB0ZXh0OiBTdHJpbmcsXG4gICAgaWNvbjogU3RyaW5nLFxuICAgIG1lbnVzOiBbQXJyYXksIE9iamVjdF0sXG4gICAgZGlzYWJsZWRNZW51czogQXJyYXlcbiAgfSxcbiAgZW1pdHM6IFsnY2xpY2snLCAnbWVudS1jbGljayddLFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZW51QWN0aXZlOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTWVudTogZnVuY3Rpb24gaGFzTWVudSgpIHtcbiAgICAgIHZhciBfdGhpcyRtZW51SXRlbXM7XG5cbiAgICAgIHJldHVybiAoX3RoaXMkbWVudUl0ZW1zID0gdGhpcy5tZW51SXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZW51SXRlbXMubGVuZ3RoO1xuICAgIH0sXG4gICAgbWVudUl0ZW1zOiBmdW5jdGlvbiBtZW51SXRlbXMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgbWVudXMgPSBPYmplY3QodXRpbFtcImZcIiAvKiBpc09iamVjdCAqL10pKHRoaXMubWVudXMpID8gdGhpcy5tZW51cy5pdGVtcyA6IHRoaXMubWVudXM7XG4gICAgICByZXR1cm4gbWVudXMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lbnVzLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3RoaXMkZGlzYWJsZWRNZW51cztcblxuICAgICAgICB2YXIgbWVudU5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgIHJldHVybiAhKChfdGhpcyRkaXNhYmxlZE1lbnVzID0gX3RoaXMuZGlzYWJsZWRNZW51cykgIT0gbnVsbCAmJiBfdGhpcyRkaXNhYmxlZE1lbnVzLmluY2x1ZGVzKF90aGlzLm5hbWUgKyBcIi9cIiArIG1lbnVOYW1lKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1lbnVNb2RlOiBmdW5jdGlvbiBtZW51TW9kZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QodXRpbFtcImZcIiAvKiBpc09iamVjdCAqL10pKHRoaXMubWVudXMpID8gdGhpcy5tZW51cy5tb2RlIDogbWVudV9tb2RlLkxJU1Q7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaGlkZU1lbnU6IGZ1bmN0aW9uIGhpZGVNZW51KCkge1xuICAgICAgaWYgKHRoaXMuaGFzTWVudSkge1xuICAgICAgICB0aGlzLm1lbnVBY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dNZW51OiBmdW5jdGlvbiBzaG93TWVudSgpIHtcbiAgICAgIGlmICh0aGlzLmhhc01lbnUpIHtcbiAgICAgICAgdGhpcy5tZW51QWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiBoYW5kbGVDbGljayhlKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjbGljaycpO1xuICAgICAgdGhpcy5tZW51QWN0aXZlID8gdGhpcy5oaWRlTWVudSgpIDogdGhpcy5zaG93TWVudSgpO1xuXG4gICAgICBpZiAodGhpcy5oYXNNZW51KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSGlkZVRvb2x0aXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXAoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93VG9vbHRpcDogZnVuY3Rpb24gc2hvd1Rvb2x0aXAoZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzZWxmRWwgPSB0aGlzLiRlbDtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIHZhciBtZW51Q3RybCA9IHRoaXMuJHJlZnMubWVudUN0cmw7XG5cbiAgICAgIGlmICh0YXJnZXQgIT09IHNlbGZFbCAmJiB0YXJnZXQgIT09IG1lbnVDdHJsIHx8IHRoaXMubWVudUFjdGl2ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUhpZGVUb29sdGlwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGltbWVyKSBjbGVhclRpbWVvdXQodGhpcy50aW1tZXIpO1xuICAgICAgdmFyIHNlbGZFbFJlY3QgPSBzZWxmRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgeCA9IGUuY2xpZW50WCAtIHNlbGZFbFJlY3QubGVmdDtcbiAgICAgIHZhciB5ID0gZS5jbGllbnRZIC0gc2VsZkVsUmVjdC50b3A7XG4gICAgICB0aGlzLnRpbW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMyJCRyZWZzJHRvb2x0aXA7XG5cbiAgICAgICAgKF90aGlzMiQkcmVmcyR0b29sdGlwID0gX3RoaXMyLiRyZWZzLnRvb2x0aXApID09IG51bGwgPyB2b2lkIDAgOiBfdGhpczIkJHJlZnMkdG9vbHRpcC5zaG93KHtcbiAgICAgICAgICB4OiB4IC0gMixcbiAgICAgICAgICB5OiB5ICsgMjBcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMDApO1xuICAgIH0sXG4gICAgaGFuZGxlSGlkZVRvb2x0aXA6IGZ1bmN0aW9uIGhhbmRsZUhpZGVUb29sdGlwKCkge1xuICAgICAgaWYgKHRoaXMudGltbWVyKSBjbGVhclRpbWVvdXQodGhpcy50aW1tZXIpO1xuICAgICAgdGhpcy4kcmVmcy50b29sdGlwLmhpZGUoKTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90b29sYmFyLWl0ZW0vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG4gXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci1pdGVtL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9c2Nzc1xudmFyIHRvb2xiYXJfaXRlbXZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci1pdGVtL2luZGV4LnZ1ZVxuXG5cblxuXG5cbnRvb2xiYXJfaXRlbXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzLnJlbmRlciA9IHRvb2xiYXJfaXRlbXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzMwZjYxNzZkX2JpbmRpbmdzX25hbWVfcHJvcHNfdGl0bGVfcHJvcHNfYWN0aXZlX3Byb3BzX3RleHRfcHJvcHNfaWNvbl9wcm9wc19tZW51c19wcm9wc19kaXNhYmxlZE1lbnVzX3Byb3BzX21lbnVBY3RpdmVfZGF0YV9oYXNNZW51X29wdGlvbnNfbWVudUl0ZW1zX29wdGlvbnNfbWVudU1vZGVfb3B0aW9uc19oaWRlTWVudV9vcHRpb25zX3Nob3dNZW51X29wdGlvbnNfaGFuZGxlQ2xpY2tfb3B0aW9uc19zaG93VG9vbHRpcF9vcHRpb25zX2hhbmRsZUhpZGVUb29sdGlwX29wdGlvbnNfcmVuZGVyXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRvb2xiYXJfaXRlbSA9ICh0b29sYmFyX2l0ZW12dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG52YXIgdG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NvbXBvbmVudHM7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzID0gKHtcbiAgbmFtZTogJ2VkaXRvci10b29sYmFyJyxcbiAgY29tcG9uZW50czogKHRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jb21wb25lbnRzID0ge30sIHRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jb21wb25lbnRzW3Rvb2xiYXJfaXRlbS5uYW1lXSA9IHRvb2xiYXJfaXRlbSwgdG9vbGJhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NvbXBvbmVudHMpLFxuICBpbmplY3Q6IFsnbWFya2Rvd25FZGl0b3InXSxcbiAgcHJvcHM6IHtcbiAgICBncm91cHM6IEFycmF5LFxuICAgIHRvb2xiYXJzOiBPYmplY3QsXG4gICAgZGlzYWJsZWRNZW51czogQXJyYXlcbiAgfSxcbiAgZW1pdHM6IFsnaXRlbS1jbGljaycsICd0b29sYmFyLW1lbnUtY2xpY2snXSxcbiAgbWV0aG9kczoge1xuICAgIGdldENvbmZpZzogZnVuY3Rpb24gZ2V0Q29uZmlnKHRvb2xiYXJOYW1lLCBjb25maWdOYW1lKSB7XG4gICAgICB2YXIgdG9vbGJhckNvbmZpZyA9IHRoaXMudG9vbGJhcnNbdG9vbGJhck5hbWVdO1xuICAgICAgdmFyIHZhbHVlID0gdG9vbGJhckNvbmZpZ1tjb25maWdOYW1lXTtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSh0aGlzLm1hcmtkb3duRWRpdG9yKSA6IHZhbHVlO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3Rvb2xiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG4gXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9vbGJhci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3NcbnZhciB0b29sYmFydnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90b29sYmFyLnZ1ZVxuXG5cblxuXG5cbnRvb2xiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcy5yZW5kZXIgPSB0b29sYmFydnVlX3R5cGVfdGVtcGxhdGVfaWRfMTk3ZjNhM2JfYmluZGluZ3NfbWFya2Rvd25FZGl0b3Jfb3B0aW9uc19ncm91cHNfcHJvcHNfdG9vbGJhcnNfcHJvcHNfZGlzYWJsZWRNZW51c19wcm9wc19nZXRDb25maWdfb3B0aW9uc19yZW5kZXJcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdG9vbGJhciA9ICh0b29sYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qc1xudmFyIFJlc2l6ZU9ic2VydmVyX2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL3Jlc2l6ZS1ldmVudC5qc1xuLy8gTW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vRWxlbWVGRS9lbGVtZW50L2Jsb2IvZGV2L3NyYy91dGlscy9yZXNpemUtZXZlbnQuanNcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxudmFyIGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG52YXIgcmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uIHJlc2l6ZUhhbmRsZXIoZW50cmllcykge1xuICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IGVudHJ5LnRhcmdldC5fX3Jlc2l6ZUxpc3RlbmVyc19fIHx8IFtdO1xuXG4gICAgaWYgKGxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbnZhciByZXNpemVfZXZlbnRfYWRkUmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRSZXNpemVMaXN0ZW5lcihlbGVtZW50LCBmbikge1xuICBpZiAoaXNTZXJ2ZXIpIHJldHVybjtcblxuICBpZiAoIWVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXykge1xuICAgIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXyA9IFtdO1xuICAgIGVsZW1lbnQuX19yb19fID0gbmV3IFJlc2l6ZU9ic2VydmVyX2VzW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgZWxlbWVudC5fX3JvX18ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuXG4gIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5wdXNoKGZuKTtcbn07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG52YXIgcmVtb3ZlUmVzaXplTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVSZXNpemVMaXN0ZW5lcihlbGVtZW50LCBmbikge1xuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXykgcmV0dXJuO1xuXG4gIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5zcGxpY2UoZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fLmluZGV4T2YoZm4pLCAxKTtcblxuICBpZiAoIWVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5sZW5ndGgpIHtcbiAgICBlbGVtZW50Ll9fcm9fXy5kaXNjb25uZWN0KCk7XG4gIH1cbn07XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWxzL2NvbnN0YW50cy9lZGl0b3ItbW9kZS5qc1xudmFyIGVkaXRvcl9tb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYj8/cmVmLS0zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdD8/cmVmLS0yLTAhLi9zcmMvY29tcG9uZW50cy9jb250YWluZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG52YXIgY29udGFpbmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY29tcG9uZW50cztcblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29udGFpbmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanMgPSAoe1xuICBuYW1lOiAndi1tZC1jb250YWluZXInLFxuICBjb21wb25lbnRzOiAoY29udGFpbmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY29tcG9uZW50cyA9IHt9LCBjb250YWluZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jb21wb25lbnRzW3Rvb2xiYXIubmFtZV0gPSB0b29sYmFyLCBjb250YWluZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jb21wb25lbnRzKSxcbiAgcHJvcHM6IHtcbiAgICBsZWZ0VG9vbGJhcjogU3RyaW5nLFxuICAgIHJpZ2h0VG9vbGJhcjogU3RyaW5nLFxuICAgIHRvb2xiYXJzOiBPYmplY3QsXG4gICAgZnVsbHNjcmVlbjogQm9vbGVhbixcbiAgICBoZWlnaHQ6IFN0cmluZyxcbiAgICBub3Jlc2l6ZTogQm9vbGVhbixcbiAgICBkaXNhYmxlZE1lbnVzOiBBcnJheSxcbiAgICBsZWZ0QXJlYVZpc2libGU6IEJvb2xlYW4sXG4gICAgbGVmdEFyZWFUaXRsZTogU3RyaW5nLFxuICAgIGxlZnRBcmVhUmV2ZXJzZTogQm9vbGVhbixcbiAgICBsZWZ0QXJlYVdpZHRoOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnMjAwcHgnXG4gICAgfSxcbiAgICBtb2RlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBlZGl0b3JfbW9kZVtcImFcIiAvKiBkZWZhdWx0ICovXS5FRElUQUJMRVxuICAgIH1cbiAgfSxcbiAgZW1pdHM6IFsncmVzaXplJywgJ2VkaXRvci13cmFwcGVyLWNsaWNrJywgJ3Rvb2xiYXItaXRlbS1jbGljaycsICd0b29sYmFyLW1lbnUtY2xpY2snXSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbGJhckhlaWdodDogMFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGVpZ2h0R2V0dGVyOiBmdW5jdGlvbiBoZWlnaHRHZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mdWxsc2NyZWVuID8gJ2F1dG8nIDogdGhpcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBsZWZ0VG9vbGJhckdyb3VwOiBmdW5jdGlvbiBsZWZ0VG9vbGJhckdyb3VwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9vbGJhckNvbmZpZyh0aGlzLmxlZnRUb29sYmFyKTtcbiAgICB9LFxuICAgIHJpZ2h0VG9vbGJhckdyb3VwOiBmdW5jdGlvbiByaWdodFRvb2xiYXJHcm91cCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRvb2xiYXJDb25maWcodGhpcy5yaWdodFRvb2xiYXIpO1xuICAgIH0sXG4gICAgaXNQcmV2aWV3TW9kZTogZnVuY3Rpb24gaXNQcmV2aWV3TW9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09IGVkaXRvcl9tb2RlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlBSRVZJRVc7XG4gICAgfSxcbiAgICBpc0VkaXRNb2RlOiBmdW5jdGlvbiBpc0VkaXRNb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gZWRpdG9yX21vZGVbXCJhXCIgLyogZGVmYXVsdCAqL10uRURJVDtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgaWYgKCF0aGlzLm5vcmVzaXplKSB7XG4gICAgICByZXNpemVfZXZlbnRfYWRkUmVzaXplTGlzdGVuZXIodGhpcy4kcmVmcy5lZGl0b3JXcmFwcGVyLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICByZXNpemVfZXZlbnRfYWRkUmVzaXplTGlzdGVuZXIodGhpcy4kcmVmcy50b29sYmFyV3JhcHBlciwgdGhpcy5oYW5kbGVUb29sYmFyV3JhcHBlclJlc2l6ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVbm1vdW50OiBmdW5jdGlvbiBiZWZvcmVVbm1vdW50KCkge1xuICAgIGlmICghdGhpcy5ub3Jlc2l6ZSkge1xuICAgICAgcmVtb3ZlUmVzaXplTGlzdGVuZXIodGhpcy4kcmVmcy5lZGl0b3JXcmFwcGVyLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICByZW1vdmVSZXNpemVMaXN0ZW5lcih0aGlzLiRyZWZzLnRvb2xiYXJXcmFwcGVyLCB0aGlzLmhhbmRsZVRvb2xiYXJXcmFwcGVyUmVzaXplKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVSZXNpemU6IGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3Jlc2l6ZScpO1xuICAgIH0sXG4gICAgaGFuZGxlVG9vbGJhcldyYXBwZXJSZXNpemU6IGZ1bmN0aW9uIGhhbmRsZVRvb2xiYXJXcmFwcGVyUmVzaXplKCkge1xuICAgICAgdmFyIHRvb2xiYXJXcmFwcGVyID0gdGhpcy4kcmVmcy50b29sYmFyV3JhcHBlcjtcbiAgICAgIGlmICh0b29sYmFyV3JhcHBlcikgdGhpcy50b29sYmFySGVpZ2h0ID0gdG9vbGJhcldyYXBwZXIub2Zmc2V0SGVpZ2h0O1xuICAgIH0sXG4gICAgZ2V0VG9vbGJhckNvbmZpZzogZnVuY3Rpb24gZ2V0VG9vbGJhckNvbmZpZyh0b29sYmFyU3RyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdG9vbGJhclN0ci5zcGxpdCgnfCcpLm1hcChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwLnNwbGl0KCcgJykuZmlsdGVyKGZ1bmN0aW9uICh0b29sYmFyTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0b29sYmFyTmFtZSAmJiBfdGhpcy50b29sYmFyc1t0b29sYmFyTmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBoYW5kbGVFZGl0b3JXcmFwcGVyQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZUVkaXRvcldyYXBwZXJDbGljayhlKSB7XG4gICAgICB0aGlzLiRlbWl0KCdlZGl0b3Itd3JhcHBlci1jbGljaycsIGUpO1xuICAgIH0sXG4gICAgaGFuZGxlVG9vbGJhckl0ZW1DbGljazogZnVuY3Rpb24gaGFuZGxlVG9vbGJhckl0ZW1DbGljayh0b29sYmFyKSB7XG4gICAgICB0aGlzLiRlbWl0KCd0b29sYmFyLWl0ZW0tY2xpY2snLCB0b29sYmFyKTtcbiAgICB9LFxuICAgIGhhbmRsZVRvb2xiYXJNZW51Q2xpY2s6IGZ1bmN0aW9uIGhhbmRsZVRvb2xiYXJNZW51Q2xpY2sobWVudSkge1xuICAgICAgdGhpcy4kZW1pdCgndG9vbGJhci1tZW51LWNsaWNrJywgbWVudSk7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvY29udGFpbmVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1xuIFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3NcbnZhciBjb250YWluZXJ2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2NzcyA9IF9fd2VicGFja19yZXF1aXJlX18oODcpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL2NvbnRhaW5lci52dWVcblxuXG5cblxuXG5jb250YWluZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcy5yZW5kZXIgPSBjb250YWluZXJ2dWVfdHlwZV90ZW1wbGF0ZV9pZF82YWMwOGQ5NV9iaW5kaW5nc19sZWZ0VG9vbGJhcl9wcm9wc19yaWdodFRvb2xiYXJfcHJvcHNfdG9vbGJhcnNfcHJvcHNfZnVsbHNjcmVlbl9wcm9wc19oZWlnaHRfcHJvcHNfbm9yZXNpemVfcHJvcHNfZGlzYWJsZWRNZW51c19wcm9wc19sZWZ0QXJlYVZpc2libGVfcHJvcHNfbGVmdEFyZWFUaXRsZV9wcm9wc19sZWZ0QXJlYVJldmVyc2VfcHJvcHNfbGVmdEFyZWFXaWR0aF9wcm9wc19tb2RlX3Byb3BzX3Rvb2xiYXJIZWlnaHRfZGF0YV9oZWlnaHRHZXR0ZXJfb3B0aW9uc19sZWZ0VG9vbGJhckdyb3VwX29wdGlvbnNfcmlnaHRUb29sYmFyR3JvdXBfb3B0aW9uc19pc1ByZXZpZXdNb2RlX29wdGlvbnNfaXNFZGl0TW9kZV9vcHRpb25zX2hhbmRsZVJlc2l6ZV9vcHRpb25zX2hhbmRsZVRvb2xiYXJXcmFwcGVyUmVzaXplX29wdGlvbnNfZ2V0VG9vbGJhckNvbmZpZ19vcHRpb25zX2hhbmRsZUVkaXRvcldyYXBwZXJDbGlja19vcHRpb25zX2hhbmRsZVRvb2xiYXJJdGVtQ2xpY2tfb3B0aW9uc19oYW5kbGVUb29sYmFyTWVudUNsaWNrX29wdGlvbnNfcmVuZGVyXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbnRhaW5lciA9IChjb250YWluZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9zY3JvbGxiYXItd2lkdGguanNcbi8vIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0VsZW1lRkUvZWxlbWVudC9ibG9iL2Rldi9zcmMvdXRpbHMvc2Nyb2xsYmFyLXdpZHRoLmpzXG52YXIgc2Nyb2xsQmFyV2lkdGg7XG52YXIgc2Nyb2xsYmFyX3dpZHRoX2lzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzY3JvbGxiYXJfd2lkdGggPSAoZnVuY3Rpb24gKCkge1xuICBpZiAoc2Nyb2xsYmFyX3dpZHRoX2lzU2VydmVyKSByZXR1cm4gMDtcbiAgaWYgKHNjcm9sbEJhcldpZHRoICE9PSB1bmRlZmluZWQpIHJldHVybiBzY3JvbGxCYXJXaWR0aDtcbiAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG91dGVyLmNsYXNzTmFtZSA9ICdzY3JvbGxiYXJfX3dyYXAnO1xuICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIG91dGVyLnN0eWxlLndpZHRoID0gJzEwMHB4JztcbiAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBvdXRlci5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuICB2YXIgd2lkdGhOb1Njcm9sbCA9IG91dGVyLm9mZnNldFdpZHRoO1xuICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICB2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgdmFyIHdpZHRoV2l0aFNjcm9sbCA9IGlubmVyLm9mZnNldFdpZHRoO1xuICBvdXRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG91dGVyKTtcbiAgc2Nyb2xsQmFyV2lkdGggPSB3aWR0aE5vU2Nyb2xsIC0gd2lkdGhXaXRoU2Nyb2xsO1xuICByZXR1cm4gc2Nyb2xsQmFyV2lkdGg7XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvc2Nyb2xsYmFyL3V0aWwuanNcbi8vIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0VsZW1lRkUvZWxlbWVudC90cmVlL2Rldi9wYWNrYWdlcy9zY3JvbGxiYXJcbnZhciBCQVJfTUFQID0ge1xuICB2ZXJ0aWNhbDoge1xuICAgIG9mZnNldDogJ29mZnNldEhlaWdodCcsXG4gICAgc2Nyb2xsOiAnc2Nyb2xsVG9wJyxcbiAgICBzY3JvbGxTaXplOiAnc2Nyb2xsSGVpZ2h0JyxcbiAgICBzaXplOiAnaGVpZ2h0JyxcbiAgICBrZXk6ICd2ZXJ0aWNhbCcsXG4gICAgYXhpczogJ1knLFxuICAgIGNsaWVudDogJ2NsaWVudFknLFxuICAgIGRpcmVjdGlvbjogJ3RvcCdcbiAgfSxcbiAgaG9yaXpvbnRhbDoge1xuICAgIG9mZnNldDogJ29mZnNldFdpZHRoJyxcbiAgICBzY3JvbGw6ICdzY3JvbGxMZWZ0JyxcbiAgICBzY3JvbGxTaXplOiAnc2Nyb2xsV2lkdGgnLFxuICAgIHNpemU6ICd3aWR0aCcsXG4gICAga2V5OiAnaG9yaXpvbnRhbCcsXG4gICAgYXhpczogJ1gnLFxuICAgIGNsaWVudDogJ2NsaWVudFgnLFxuICAgIGRpcmVjdGlvbjogJ2xlZnQnXG4gIH1cbn07XG5mdW5jdGlvbiByZW5kZXJUaHVtYlN0eWxlKF9yZWYpIHtcbiAgdmFyIG1vdmUgPSBfcmVmLm1vdmUsXG4gICAgICBzaXplID0gX3JlZi5zaXplLFxuICAgICAgYmFyID0gX3JlZi5iYXI7XG4gIHZhciBzdHlsZSA9IHt9O1xuICB2YXIgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGVcIiArIGJhci5heGlzICsgXCIoXCIgKyBtb3ZlICsgXCIlKVwiO1xuICBzdHlsZVtiYXIuc2l6ZV0gPSBzaXplO1xuICBzdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGU7XG4gIHN0eWxlLm1zVHJhbnNmb3JtID0gdHJhbnNsYXRlO1xuICBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2xhdGU7XG4gIHJldHVybiBzdHlsZTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvc2Nyb2xsYmFyL2Jhci5qc1xuXG4vLyBNb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9FbGVtZUZFL2VsZW1lbnQvdHJlZS9kZXYvcGFja2FnZXMvc2Nyb2xsYmFyXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNjcm9sbGJhcl9iYXIgPSAoe1xuICBuYW1lOiAnQmFyJyxcbiAgcHJvcHM6IHtcbiAgICB2ZXJ0aWNhbDogQm9vbGVhbixcbiAgICBzaXplOiBTdHJpbmcsXG4gICAgbW92ZTogTnVtYmVyXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgYmFyOiBmdW5jdGlvbiBiYXIoKSB7XG4gICAgICByZXR1cm4gQkFSX01BUFt0aGlzLnZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJ107XG4gICAgfSxcbiAgICB3cmFwOiBmdW5jdGlvbiB3cmFwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudC53cmFwO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemUsXG4gICAgICAgIG1vdmUgPSB0aGlzLm1vdmUsXG4gICAgICAgIGJhciA9IHRoaXMuYmFyO1xuICAgIHJldHVybiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoXCJkaXZcIiwge1xuICAgICAgXCJjbGFzc1wiOiBbJ3Njcm9sbGJhcl9fYmFyJywgJ2lzLScgKyBiYXIua2V5XSxcbiAgICAgIFwib25Nb3VzZWRvd25cIjogdGhpcy5jbGlja1RyYWNrSGFuZGxlcixcbiAgICAgIFwib25DbGlja1wiOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfSwgW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcImRpdlwiLCB7XG4gICAgICBcInJlZlwiOiBcInRodW1iXCIsXG4gICAgICBcImNsYXNzXCI6IFwic2Nyb2xsYmFyX190aHVtYlwiLFxuICAgICAgXCJvbk1vdXNlZG93blwiOiB0aGlzLmNsaWNrVGh1bWJIYW5kbGVyLFxuICAgICAgXCJzdHlsZVwiOiByZW5kZXJUaHVtYlN0eWxlKHtcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgbW92ZTogbW92ZSxcbiAgICAgICAgYmFyOiBiYXJcbiAgICAgIH0pXG4gICAgfSwgbnVsbCldKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGNsaWNrVGh1bWJIYW5kbGVyOiBmdW5jdGlvbiBjbGlja1RodW1iSGFuZGxlcihlKSB7XG4gICAgICAvLyBwcmV2ZW50IGNsaWNrIGV2ZW50IG9mIHJpZ2h0IGJ1dHRvblxuICAgICAgaWYgKGUuY3RybEtleSB8fCBlLmJ1dHRvbiA9PT0gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnREcmFnKGUpO1xuICAgICAgdGhpc1t0aGlzLmJhci5heGlzXSA9IGUuY3VycmVudFRhcmdldFt0aGlzLmJhci5vZmZzZXRdIC0gKGVbdGhpcy5iYXIuY2xpZW50XSAtIGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVt0aGlzLmJhci5kaXJlY3Rpb25dKTtcbiAgICB9LFxuICAgIGNsaWNrVHJhY2tIYW5kbGVyOiBmdW5jdGlvbiBjbGlja1RyYWNrSGFuZGxlcihlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5hYnMoZS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdGhpcy5iYXIuZGlyZWN0aW9uXSAtIGVbdGhpcy5iYXIuY2xpZW50XSk7XG4gICAgICB2YXIgdGh1bWJIYWxmID0gdGhpcy4kcmVmcy50aHVtYlt0aGlzLmJhci5vZmZzZXRdIC8gMjtcbiAgICAgIHZhciB0aHVtYlBvc2l0aW9uUGVyY2VudGFnZSA9IChvZmZzZXQgLSB0aHVtYkhhbGYpICogMTAwIC8gdGhpcy4kZWxbdGhpcy5iYXIub2Zmc2V0XTtcbiAgICAgIHRoaXMud3JhcFt0aGlzLmJhci5zY3JvbGxdID0gdGh1bWJQb3NpdGlvblBlcmNlbnRhZ2UgKiB0aGlzLndyYXBbdGhpcy5iYXIuc2Nyb2xsU2l6ZV0gLyAxMDA7XG4gICAgfSxcbiAgICBzdGFydERyYWc6IGZ1bmN0aW9uIHN0YXJ0RHJhZyhlKSB7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5jdXJzb3JEb3duID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlRG9jdW1lbnRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5tb3VzZVVwRG9jdW1lbnRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgIGRvY3VtZW50Lm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBtb3VzZU1vdmVEb2N1bWVudEhhbmRsZXI6IGZ1bmN0aW9uIG1vdXNlTW92ZURvY3VtZW50SGFuZGxlcihlKSB7XG4gICAgICBpZiAodGhpcy5jdXJzb3JEb3duID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgdmFyIHByZXZQYWdlID0gdGhpc1t0aGlzLmJhci5heGlzXTtcbiAgICAgIGlmICghcHJldlBhZ2UpIHJldHVybjtcbiAgICAgIHZhciBvZmZzZXQgPSAodGhpcy4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdGhpcy5iYXIuZGlyZWN0aW9uXSAtIGVbdGhpcy5iYXIuY2xpZW50XSkgKiAtMTtcbiAgICAgIHZhciB0aHVtYkNsaWNrUG9zaXRpb24gPSB0aGlzLiRyZWZzLnRodW1iW3RoaXMuYmFyLm9mZnNldF0gLSBwcmV2UGFnZTtcbiAgICAgIHZhciB0aHVtYlBvc2l0aW9uUGVyY2VudGFnZSA9IChvZmZzZXQgLSB0aHVtYkNsaWNrUG9zaXRpb24pICogMTAwIC8gdGhpcy4kZWxbdGhpcy5iYXIub2Zmc2V0XTtcbiAgICAgIHRoaXMud3JhcFt0aGlzLmJhci5zY3JvbGxdID0gdGh1bWJQb3NpdGlvblBlcmNlbnRhZ2UgKiB0aGlzLndyYXBbdGhpcy5iYXIuc2Nyb2xsU2l6ZV0gLyAxMDA7XG4gICAgfSxcbiAgICBtb3VzZVVwRG9jdW1lbnRIYW5kbGVyOiBmdW5jdGlvbiBtb3VzZVVwRG9jdW1lbnRIYW5kbGVyKCkge1xuICAgICAgdGhpcy5jdXJzb3JEb3duID0gZmFsc2U7XG4gICAgICB0aGlzW3RoaXMuYmFyLmF4aXNdID0gMDtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlRG9jdW1lbnRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5vbnNlbGVjdHN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIHVubW91bnRlZDogZnVuY3Rpb24gdW5tb3VudGVkKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm1vdXNlVXBEb2N1bWVudEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3V0aWxzL3Ntb290aC1zY3JvbGwuanNcbnZhciBzbW9vdGhfc2Nyb2xsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYj8/cmVmLS0zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdD8/cmVmLS0yLTAhLi9zcmMvY29tcG9uZW50cy9zY3JvbGxiYXIvaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG5cbi8vIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0VsZW1lRkUvZWxlbWVudC90cmVlL2Rldi9wYWNrYWdlcy9zY3JvbGxiYXJcblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzY3JvbGxiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyA9ICh7XG4gIG5hbWU6ICdzY3JvbGxiYXInLFxuICBjb21wb25lbnRzOiB7XG4gICAgQmFyOiBzY3JvbGxiYXJfYmFyXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbmF0aXZlOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIHdyYXBTdHlsZTogbnVsbCxcbiAgICB3cmFwQ2xhc3M6IG51bGwsXG4gICAgdmlld0NsYXNzOiBudWxsLFxuICAgIHZpZXdTdHlsZTogbnVsbCxcbiAgICBub3Jlc2l6ZTogQm9vbGVhbixcbiAgICAvLyDlpoLmnpwgY29udGFpbmVyIOWwuuWvuOS4jeS8muWPkeeUn+WPmOWMlu+8jOacgOWlveiuvue9ruWug+WPr+S7peS8mOWMluaAp+iDvVxuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICB9XG4gIH0sXG4gIGVtaXRzOiBbJ3Njcm9sbCddLFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaXplV2lkdGg6ICcwJyxcbiAgICAgIHNpemVIZWlnaHQ6ICcwJyxcbiAgICAgIG1vdmVYOiAwLFxuICAgICAgbW92ZVk6IDBcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHdyYXA6IGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcmVmcy53cmFwO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICBpZiAodGhpcy5uYXRpdmUgfHwgdGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIHRoaXMuJG5leHRUaWNrKHRoaXMudXBkYXRlKTtcbiAgICAhdGhpcy5ub3Jlc2l6ZSAmJiByZXNpemVfZXZlbnRfYWRkUmVzaXplTGlzdGVuZXIodGhpcy4kcmVmcy5yZXNpemUsIHRoaXMudXBkYXRlKTtcbiAgfSxcbiAgYmVmb3JlVW5tb3VudDogZnVuY3Rpb24gYmVmb3JlVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5uYXRpdmUgfHwgdGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICF0aGlzLm5vcmVzaXplICYmIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKHRoaXMuJHJlZnMucmVzaXplLCB0aGlzLnVwZGF0ZSk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiBnZXRTY3JvbGxJbmZvKCkge1xuICAgICAgdmFyIHdyYXAgPSB0aGlzLndyYXA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiB3cmFwLnNjcm9sbExlZnQsXG4gICAgICAgIHRvcDogd3JhcC5zY3JvbGxUb3AsXG4gICAgICAgIHdpZHRoOiB3cmFwLnNjcm9sbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdyYXAuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBjbGllbnRXaWR0aDogd3JhcC5jbGllbnRXaWR0aCxcbiAgICAgICAgY2xpZW50SGVpZ2h0OiB3cmFwLmNsaWVudEhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNjcm9sbFRvOiBmdW5jdGlvbiBzY3JvbGxUbyhzY3JvbGxUb3ApIHtcbiAgICAgIE9iamVjdChzbW9vdGhfc2Nyb2xsW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh7XG4gICAgICAgIHNjcm9sbFRhcmdldDogdGhpcy53cmFwLFxuICAgICAgICBzY3JvbGxUb1RvcDogc2Nyb2xsVG9wXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGhhbmRsZVNjcm9sbDogZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCkge1xuICAgICAgdmFyIHdyYXAgPSB0aGlzLndyYXA7XG4gICAgICB0aGlzLm1vdmVZID0gd3JhcC5zY3JvbGxUb3AgKiAxMDAgLyB3cmFwLmNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMubW92ZVggPSB3cmFwLnNjcm9sbExlZnQgKiAxMDAgLyB3cmFwLmNsaWVudFdpZHRoO1xuICAgICAgdGhpcy4kZW1pdCgnc2Nyb2xsJyk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciB3cmFwID0gdGhpcy53cmFwO1xuICAgICAgaWYgKCF3cmFwKSByZXR1cm47XG4gICAgICB2YXIgaGVpZ2h0UGVyY2VudGFnZSA9IHdyYXAuY2xpZW50SGVpZ2h0ICogMTAwIC8gd3JhcC5zY3JvbGxIZWlnaHQ7XG4gICAgICB2YXIgd2lkdGhQZXJjZW50YWdlID0gd3JhcC5jbGllbnRXaWR0aCAqIDEwMCAvIHdyYXAuc2Nyb2xsV2lkdGg7XG4gICAgICB0aGlzLnNpemVIZWlnaHQgPSBoZWlnaHRQZXJjZW50YWdlIDwgMTAwID8gaGVpZ2h0UGVyY2VudGFnZSArICclJyA6ICcnO1xuICAgICAgdGhpcy5zaXplV2lkdGggPSB3aWR0aFBlcmNlbnRhZ2UgPCAxMDAgPyB3aWR0aFBlcmNlbnRhZ2UgKyAnJScgOiAnJztcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm4gdGhpcy4kc2xvdHMuZGVmYXVsdCgpO1xuICAgIHZhciBndXR0ZXIgPSBzY3JvbGxiYXJfd2lkdGgoKTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLndyYXBTdHlsZTtcblxuICAgIGlmIChndXR0ZXIpIHtcbiAgICAgIHZhciBzY3JvbGxWaWV3ID0gdGhpcy4kcmVmcy5yZXNpemU7XG4gICAgICB2YXIgd3JhcHBlciA9IHRoaXMuJHJlZnMud3JhcDtcbiAgICAgIHZhciBzY3JvbGxWaWV3SGVpZ2h0ID0gc2Nyb2xsVmlldyA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsVmlldy5zY3JvbGxIZWlnaHQ7XG4gICAgICB2YXIgc2Nyb2xsVmlld1dpZHRoID0gc2Nyb2xsVmlldyA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsVmlldy5zY3JvbGxXaWR0aDtcbiAgICAgIHZhciB3cmFwcGVySGVpZ2h0ID0gd3JhcHBlciA9PSBudWxsID8gdm9pZCAwIDogd3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgd3JhcHBlcldpZHRoID0gd3JhcHBlciA9PSBudWxsID8gdm9pZCAwIDogd3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgIHZhciBndXR0ZXJXaXRoID0gXCItXCIgKyBndXR0ZXIgKyBcInB4XCI7XG4gICAgICB2YXIgbWFyZ2luQm90dG9tID0gc2Nyb2xsVmlld1dpZHRoID4gd3JhcHBlcldpZHRoID8gZ3V0dGVyV2l0aCA6IDA7XG4gICAgICB2YXIgbWFyZ2luUmlnaHQgPSBzY3JvbGxWaWV3SGVpZ2h0ID4gd3JhcHBlckhlaWdodCA/IGd1dHRlcldpdGggOiAwO1xuICAgICAgdmFyIGd1dHRlclN0eWxlID0gXCJtYXJnaW4tYm90dG9tOiBcIiArIG1hcmdpbkJvdHRvbSArIFwiOyBtYXJnaW4tcmlnaHQ6IFwiICsgbWFyZ2luUmlnaHQgKyBcIjtcIjtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy53cmFwU3R5bGUpKSB7XG4gICAgICAgIHN0eWxlID0gT2JqZWN0KHV0aWxbXCJhXCIgLyogYXJyYXl0b09iamVjdCAqL10pKHRoaXMud3JhcFN0eWxlKTtcbiAgICAgICAgc3R5bGUubWFyZ2luUmlnaHQgPSBndXR0ZXJXaXRoO1xuICAgICAgICBzdHlsZS5tYXJnaW5Cb3R0b20gPSBndXR0ZXJXaXRoO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy53cmFwU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0eWxlICs9IGd1dHRlclN0eWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBndXR0ZXJTdHlsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmlldyA9IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImhcIl0pKHRoaXMudGFnLCB7XG4gICAgICBjbGFzczogWydzY3JvbGxiYXJfX3ZpZXcnLCB0aGlzLnZpZXdDbGFzc10sXG4gICAgICBzdHlsZTogdGhpcy52aWV3U3R5bGUsXG4gICAgICByZWY6ICdyZXNpemUnXG4gICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCgpKTtcbiAgICB2YXIgd3JhcCA9IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcImRpdlwiLCB7XG4gICAgICBcInJlZlwiOiBcIndyYXBcIixcbiAgICAgIFwic3R5bGVcIjogc3R5bGUsXG4gICAgICBcIm9uU2Nyb2xsXCI6IHRoaXMuaGFuZGxlU2Nyb2xsLFxuICAgICAgXCJjbGFzc1wiOiBbdGhpcy53cmFwQ2xhc3MsICdzY3JvbGxiYXJfX3dyYXAnLCBndXR0ZXIgPyAnJyA6ICdzY3JvbGxiYXJfX3dyYXAtLWhpZGRlbi1kZWZhdWx0J11cbiAgICB9LCBbW3ZpZXddXSk7XG4gICAgdmFyIG5vZGVzO1xuXG4gICAgaWYgKCF0aGlzLm5hdGl2ZSkge1xuICAgICAgbm9kZXMgPSBbd3JhcCwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKHNjcm9sbGJhcl9iYXIsIHtcbiAgICAgICAgXCJtb3ZlXCI6IHRoaXMubW92ZVgsXG4gICAgICAgIFwic2l6ZVwiOiB0aGlzLnNpemVXaWR0aFxuICAgICAgfSwgbnVsbCksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShzY3JvbGxiYXJfYmFyLCB7XG4gICAgICAgIFwidmVydGljYWxcIjogdHJ1ZSxcbiAgICAgICAgXCJtb3ZlXCI6IHRoaXMubW92ZVksXG4gICAgICAgIFwic2l6ZVwiOiB0aGlzLnNpemVIZWlnaHRcbiAgICAgIH0sIG51bGwpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMgPSBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKFwiZGl2XCIsIHtcbiAgICAgICAgXCJyZWZcIjogXCJ3cmFwXCIsXG4gICAgICAgIFwiY2xhc3NcIjogW3RoaXMud3JhcENsYXNzLCAnc2Nyb2xsYmFyX193cmFwJ10sXG4gICAgICAgIFwic3R5bGVcIjogc3R5bGVcbiAgICAgIH0sIFtbdmlld11dKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImhcIl0pKCdkaXYnLCB7XG4gICAgICBjbGFzczogJ3Njcm9sbGJhcidcbiAgICB9LCBub2Rlcyk7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9zY3JvbGxiYXIvaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG4gXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvc2Nyb2xsYmFyL2luZGV4LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9c2Nzc1xudmFyIHNjcm9sbGJhcnZ1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvc2Nyb2xsYmFyL2luZGV4LnZ1ZVxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNjcm9sbGJhciA9IChzY3JvbGxiYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3RlbXBsYXRlTG9hZGVyLmpzPz9yZWYtLTYhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9jb21wb25lbnRzL3RvYy1uYXYudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTAzNWIwZDUyJmJpbmRpbmdzPXtcInRpdGxlc1wiOlwicHJvcHNcIixcImluZGVudFwiOlwicHJvcHNcIn1cblxudmFyIHRvY19uYXZ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wMzViMGQ1Ml9iaW5kaW5nc190aXRsZXNfcHJvcHNfaW5kZW50X3Byb3BzX2hvaXN0ZWRfMSA9IHtcbiAgY2xhc3M6IFwidi1tZC1lZGl0b3JfX3RvYy1uYXZcIlxufTtcbnZhciB0b2NfbmF2dnVlX3R5cGVfdGVtcGxhdGVfaWRfMDM1YjBkNTJfYmluZGluZ3NfdGl0bGVzX3Byb3BzX2luZGVudF9wcm9wc19ob2lzdGVkXzIgPSB7XG4gIGNsYXNzOiBcInYtbWQtZWRpdG9yX190b2MtbmF2LXRpdGxlXCJcbn07XG5mdW5jdGlvbiB0b2NfbmF2dnVlX3R5cGVfdGVtcGxhdGVfaWRfMDM1YjBkNTJfYmluZGluZ3NfdGl0bGVzX3Byb3BzX2luZGVudF9wcm9wc19yZW5kZXIoX2N0eCwgX2NhY2hlLCAkcHJvcHMsICRzZXR1cCwgJGRhdGEsICRvcHRpb25zKSB7XG4gIHJldHVybiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKCksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUJsb2NrXCJdKShcInVsXCIsIHRvY19uYXZ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wMzViMGQ1Ml9iaW5kaW5nc190aXRsZXNfcHJvcHNfaW5kZW50X3Byb3BzX2hvaXN0ZWRfMSwgWyhPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKHRydWUpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJGcmFnbWVudFwiXSwgbnVsbCwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyTGlzdFwiXSkoJHByb3BzLnRpdGxlcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoXCJsaVwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBwYWRkaW5nTGVmdDogJHByb3BzLmluZGVudCAqIGl0ZW0uaW5kZW50ICsgXCJweFwiXG4gICAgICB9LFxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygkZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF9jdHguJGVtaXQoJ25hdi1jbGljaycsIGl0ZW0pO1xuICAgICAgfSxcbiAgICAgIGNsYXNzOiBcInYtbWQtZWRpdG9yX190b2MtbmF2LWl0ZW1cIlxuICAgIH0sIFtPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoXCJzcGFuXCIsIHRvY19uYXZ2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wMzViMGQ1Ml9iaW5kaW5nc190aXRsZXNfcHJvcHNfaW5kZW50X3Byb3BzX2hvaXN0ZWRfMiwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1widG9EaXNwbGF5U3RyaW5nXCJdKShpdGVtLnRpdGxlKSwgMVxuICAgIC8qIFRFWFQgKi9cbiAgICApXSwgMTJcbiAgICAvKiBTVFlMRSwgUFJPUFMgKi9cbiAgICAsIFtcIm9uQ2xpY2tcIl0pO1xuICB9KSwgMjU2XG4gIC8qIFVOS0VZRURfRlJBR01FTlQgKi9cbiAgKSldKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9jLW5hdi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MDM1YjBkNTImYmluZGluZ3M9e1widGl0bGVzXCI6XCJwcm9wc1wiLFwiaW5kZW50XCI6XCJwcm9wc1wifVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9jb21wb25lbnRzL3RvYy1uYXYudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0b2NfbmF2dnVlX3R5cGVfc2NyaXB0X2xhbmdfanMgPSAoe1xuICBuYW1lOiAndG9jLW5hdicsXG4gIHByb3BzOiB7XG4gICAgdGl0bGVzOiBBcnJheSxcbiAgICBpbmRlbnQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDE2XG4gICAgfVxuICB9LFxuICBlbWl0czogWyduYXYtY2xpY2snXVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3RvYy1uYXYudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXG4gXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdG9jLW5hdi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3NcbnZhciB0b2NfbmF2dnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90b2MtbmF2LnZ1ZVxuXG5cblxuXG5cbnRvY19uYXZ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcy5yZW5kZXIgPSB0b2NfbmF2dnVlX3R5cGVfdGVtcGxhdGVfaWRfMDM1YjBkNTJfYmluZGluZ3NfdGl0bGVzX3Byb3BzX2luZGVudF9wcm9wc19yZW5kZXJcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdG9jX25hdiA9ICh0b2NfbmF2dnVlX3R5cGVfc2NyaXB0X2xhbmdfanMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL2NvbW1vbi5qc1xudmFyIGNvbW1vbl9jb21wb25lbnRzO1xuXG4vLyBiYXNlIGNzc1xuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tbW9uID0gKHtcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgY29tcG9uZW50czogKGNvbW1vbl9jb21wb25lbnRzID0ge30sIGNvbW1vbl9jb21wb25lbnRzW3ByZXZpZXdbXCJkZWZhdWx0XCJdLm5hbWVdID0gcHJldmlld1tcImRlZmF1bHRcIl0sIGNvbW1vbl9jb21wb25lbnRzW2NvbnRhaW5lci5uYW1lXSA9IGNvbnRhaW5lciwgY29tbW9uX2NvbXBvbmVudHNbc2Nyb2xsYmFyLm5hbWVdID0gc2Nyb2xsYmFyLCBjb21tb25fY29tcG9uZW50c1t0b2NfbmF2Lm5hbWVdID0gdG9jX25hdiwgY29tbW9uX2NvbXBvbmVudHMpLFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXJrZG93bkVkaXRvcjogdGhpc1xuICAgIH07XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgaGVpZ2h0OiBTdHJpbmcsXG4gICAgdGhlbWU6IE9iamVjdCxcbiAgICBtb2RlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBlZGl0b3JfbW9kZVtcImFcIiAvKiBkZWZhdWx0ICovXS5FRElUQUJMRVxuICAgIH0sXG4gICAgYXV0b2ZvY3VzOiBCb29sZWFuLFxuICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgdG9jTmF2UG9zaXRpb25SaWdodDogQm9vbGVhbixcbiAgICB0YWJTaXplOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAyXG4gICAgfSxcbiAgICBiZWZvcmVQcmV2aWV3Q2hhbmdlOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KHRleHQsIG5leHQpIHtcbiAgICAgICAgbmV4dCh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVtaXRzOiBbJ2JsdXInLCAnY2hhbmdlJywgJ3NhdmUnLCAnaW1hZ2UtY2xpY2snXSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudE1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHVwbG9hZENvbmZpZzoge31cbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgIG1vZGU6IGZ1bmN0aW9uIG1vZGUoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRNb2RlID0gdGhpcy5tb2RlO1xuICAgIH0sXG4gICAgY3VycmVudE1vZGU6IGZ1bmN0aW9uIGN1cnJlbnRNb2RlKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudE1vZGUgPT09IGVkaXRvcl9tb2RlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkVESVRBQkxFICYmIHRoaXMuZW5hYmxlU3luY1Njcm9sbCkge1xuICAgICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnByZXZpZXdTeW5jU2Nyb2xsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgaWYgKHRoaXMudGhlbWUpIHRoaXMuJG9wdGlvbnMudXNlKHRoaXMudGhlbWUpO1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzUHJldmlld01vZGU6IGZ1bmN0aW9uIGlzUHJldmlld01vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TW9kZSA9PT0gZWRpdG9yX21vZGVbXCJhXCIgLyogZGVmYXVsdCAqL10uUFJFVklFVztcbiAgICB9LFxuICAgIGlzRWRpdE1vZGU6IGZ1bmN0aW9uIGlzRWRpdE1vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TW9kZSA9PT0gZWRpdG9yX21vZGVbXCJhXCIgLyogZGVmYXVsdCAqL10uRURJVDtcbiAgICB9LFxuICAgIHByb3h5U2xvdHM6IGZ1bmN0aW9uIHByb3h5U2xvdHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gWydsZWZ0LXRvb2xiYXInLCAncmlnaHQtdG9vbGJhciddLmZpbHRlcihmdW5jdGlvbiAoc2xvdE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLiRzbG90c1tzbG90TmFtZV07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMuYXV0b2ZvY3VzKSB7XG4gICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnNldEZvY3VzRW5kKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXRGb2N1c0VuZDogZnVuY3Rpb24gc2V0Rm9jdXNFbmQoKSB7XG4gICAgICB0aGlzLmVkaXRvckZvY3VzRW5kKCk7XG4gICAgICB0aGlzLmVkaXRvclNjcm9sbFRvVG9wKDk5OTkpO1xuICAgICAgdGhpcy5wcmV2aWV3U2Nyb2xsVG8oOTk5OSk7XG4gICAgfSxcbiAgICAvLyBjaGFuZ2UgZXZlbnRcbiAgICBoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSh0ZXh0LCBodG1sKSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0ZXh0LCBodG1sKTtcbiAgICB9LFxuICAgIGhhbmRsZUJsdXI6IGZ1bmN0aW9uIGhhbmRsZUJsdXIoZSkge1xuICAgICAgdGhpcy4kZW1pdCgnYmx1cicsIGUpO1xuICAgIH0sXG4gICAgaGFuZGxlUHJldmlld0ltYWdlQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZVByZXZpZXdJbWFnZUNsaWNrKGltYWdlcywgY3VycmVudEluZGV4KSB7XG4gICAgICB0aGlzLiRlbWl0KCdpbWFnZS1jbGljaycsIGltYWdlcywgY3VycmVudEluZGV4KTtcbiAgICB9LFxuICAgIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgICB0aGlzLiRlbWl0KCdzYXZlJywgdGhpcy50ZXh0LCB0aGlzLiRyZWZzLnByZXZpZXcuaHRtbCk7XG4gICAgfSxcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChnZXRJbnNlcnRDb250ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgdmFyIGN1cnJlbnRTZWxlY3RlZFN0ciA9IHRoaXMuZ2V0Q3VycmVudFNlbGVjdGVkU3RyKCk7XG5cbiAgICAgIHZhciBfZ2V0SW5zZXJ0Q29udGVudCA9IGdldEluc2VydENvbnRlbnQoY3VycmVudFNlbGVjdGVkU3RyKSxcbiAgICAgICAgICBzZWxlY3RlZCA9IF9nZXRJbnNlcnRDb250ZW50LnNlbGVjdGVkLFxuICAgICAgICAgIHRleHQgPSBfZ2V0SW5zZXJ0Q29udGVudC50ZXh0O1xuXG4gICAgICB0aGlzLnJlcGxhY2VTZWxlY3Rpb25UZXh0KHRleHQpO1xuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuY2hhbmdlU2VsY3Rpb25Ubyh0ZXh0LCBzZWxlY3RlZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWl4aW5zL3YtbW9kZWwuanNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHZfbW9kZWwgPSAoe1xuICBwcm9wczoge1xuICAgIG1vZGVsVmFsdWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfVxuICB9LFxuICBlbWl0czogWyd1cGRhdGU6bW9kZWxWYWx1ZSddLFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0aGlzLm1vZGVsVmFsdWVcbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaGFuZGxlSW5wdXQ6IGZ1bmN0aW9uIGhhbmRsZUlucHV0KHZhbCkge1xuICAgICAgdGhpcy50ZXh0ID0gdmFsO1xuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm1vZGVsVmFsdWUnLCB2YWwpO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvZnVsbHNjcmVlbi5qc1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZnVsbHNjcmVlbiA9ICh7XG4gIHByb3BzOiB7XG4gICAgZGVmYXVsdEZ1bGxzY3JlZW46IEJvb2xlYW5cbiAgfSxcbiAgZW1pdHM6IFsnZnVsbHNjcmVlbi1jaGFuZ2UnXSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnVsbHNjcmVlbjogZmFsc2VcbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgIGZ1bGxzY3JlZW46IGZ1bmN0aW9uIGZ1bGxzY3JlZW4oKSB7XG4gICAgICB0aGlzLiRlbWl0KCdmdWxsc2NyZWVuLWNoYW5nZScsIHRoaXMuZnVsbHNjcmVlbik7XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlV2luZG93S2V5dXAsIGZhbHNlKTtcblxuICAgIGlmICh0aGlzLmRlZmF1bHRGdWxsc2NyZWVuKSB7XG4gICAgICB0aGlzLnRvZ2dsZUZ1bGxTY3JlZW4oKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZVVubW91bnQ6IGZ1bmN0aW9uIGJlZm9yZVVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5oYW5kbGVXaW5kb3dLZXl1cCwgZmFsc2UpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaGFuZGxlV2luZG93S2V5dXA6IGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0tleXVwKGUpIHtcbiAgICAgIC8vIGVzY1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcgJiYgdGhpcy5mdWxsc2NyZWVuKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbihmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b2dnbGVGdWxsU2NyZWVuOiBmdW5jdGlvbiB0b2dnbGVGdWxsU2NyZWVuKGZ1bGxzY3JlZW4pIHtcbiAgICAgIGlmIChmdWxsc2NyZWVuID09PSB2b2lkIDApIHtcbiAgICAgICAgZnVsbHNjcmVlbiA9ICF0aGlzLmZ1bGxzY3JlZW47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnVsbHNjcmVlbiA9IGZ1bGxzY3JlZW47XG5cbiAgICAgIHZhciBfZG9jdW1lbnQkcXVlcnlTZWxlY3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdodG1sLCBib2R5JyksXG4gICAgICAgICAgaHRtbCA9IF9kb2N1bWVudCRxdWVyeVNlbGVjdFswXSxcbiAgICAgICAgICBib2R5ID0gX2RvY3VtZW50JHF1ZXJ5U2VsZWN0WzFdO1xuXG4gICAgICB2YXIgb3ZlcmZsb3cgPSB0aGlzLmZ1bGxzY3JlZW4gPyAnaGlkZGVuJyA6IG51bGw7XG4gICAgICBib2R5LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICBodG1sLnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3JlZi0tNiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Q/P3JlZi0tMi0wIS4vc3JjL2NvbXBvbmVudHMvdXBsb2FkLWZpbGUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWUyNzQ2NGQ2JmJpbmRpbmdzPXtcInVwbG9hZENvbmZpZ1wiOlwicHJvcHNcIixcImhhbmRsZVVwbG9hZFwiOlwiZGF0YVwiLFwia2V5XCI6XCJkYXRhXCIsXCJ1cGxvYWRcIjpcIm9wdGlvbnNcIixcImNob29zZUZpbGVcIjpcIm9wdGlvbnNcIn1cblxuZnVuY3Rpb24gdXBsb2FkX2ZpbGV2dWVfdHlwZV90ZW1wbGF0ZV9pZF9lMjc0NjRkNl9iaW5kaW5nc191cGxvYWRDb25maWdfcHJvcHNfaGFuZGxlVXBsb2FkX2RhdGFfa2V5X2RhdGFfdXBsb2FkX29wdGlvbnNfY2hvb3NlRmlsZV9vcHRpb25zX3JlbmRlcihfY3R4LCBfY2FjaGUsICRwcm9wcywgJHNldHVwLCAkZGF0YSwgJG9wdGlvbnMpIHtcbiAgcmV0dXJuIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIm9wZW5CbG9ja1wiXSkoKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlQmxvY2tcIl0pKFwiaW5wdXRcIiwge1xuICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgIHN0eWxlOiB7XG4gICAgICBcImRpc3BsYXlcIjogXCJub25lXCJcbiAgICB9LFxuICAgIGtleTogJGRhdGEua2V5LFxuICAgIGFjY2VwdDogJHByb3BzLnVwbG9hZENvbmZpZy5hY2NlcHQsXG4gICAgbXVsdGlwbGU6ICRwcm9wcy51cGxvYWRDb25maWcubXVsdGlwbGUsXG4gICAgb25JbnB1dDogX2NhY2hlWzFdIHx8IChfY2FjaGVbMV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJGRhdGEuaGFuZGxlVXBsb2FkLmFwcGx5KCRkYXRhLCBhcmd1bWVudHMpO1xuICAgIH0pLFxuICAgIHJlZjogXCJmaWxlSW5wdXRcIlxuICB9LCBudWxsLCA0MFxuICAvKiBQUk9QUywgSFlEUkFURV9FVkVOVFMgKi9cbiAgLCBbXCJhY2NlcHRcIiwgXCJtdWx0aXBsZVwiXSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3VwbG9hZC1maWxlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1lMjc0NjRkNiZiaW5kaW5ncz17XCJ1cGxvYWRDb25maWdcIjpcInByb3BzXCIsXCJoYW5kbGVVcGxvYWRcIjpcImRhdGFcIixcImtleVwiOlwiZGF0YVwiLFwidXBsb2FkXCI6XCJvcHRpb25zXCIsXCJjaG9vc2VGaWxlXCI6XCJvcHRpb25zXCJ9XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcbnZhciByZWdlbmVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIHJlZ2VuZXJhdG9yX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlZ2VuZXJhdG9yKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzXG52YXIgYXN5bmNUb0dlbmVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9jb21wb25lbnRzL3VwbG9hZC1maWxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHVwbG9hZF9maWxldnVlX3R5cGVfc2NyaXB0X2xhbmdfanMgPSAoe1xuICBuYW1lOiAndi1tZC11cGxvYWQtZmlsZScsXG4gIHByb3BzOiB7XG4gICAgdXBsb2FkQ29uZmlnOiBPYmplY3RcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFuZGxlVXBsb2FkOiBmdW5jdGlvbiBoYW5kbGVVcGxvYWQoKSB7fSxcbiAgICAgIGtleTogMFxuICAgIH07XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB1cGxvYWQ6IGZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBPYmplY3QoYXN5bmNUb0dlbmVyYXRvcltcImFcIiAvKiBkZWZhdWx0ICovXSkoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvcl9kZWZhdWx0LmEubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgZXZlbnQ7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvcl9kZWZhdWx0LmEud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2hvb3NlRmlsZSgpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGV2ZW50ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBldmVudCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpKCk7XG4gICAgfSxcbiAgICBjaG9vc2VGaWxlOiBmdW5jdGlvbiBjaG9vc2VGaWxlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfdGhpczIuaGFuZGxlVXBsb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXNvbHZlKGUpOyAvLyDop6PlhrPkuIrkvKDlkIzkuIDmlofku7bkuI3op6blj5FjaGFuZ2Xkuovku7bnmoTpl67pophcblxuICAgICAgICAgIF90aGlzMi5rZXkrKztcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpczIuJHJlZnMuZmlsZUlucHV0LmNsaWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy91cGxvYWQtZmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcbiBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdXBsb2FkLWZpbGUudnVlXG5cblxuXG51cGxvYWRfZmlsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzLnJlbmRlciA9IHVwbG9hZF9maWxldnVlX3R5cGVfdGVtcGxhdGVfaWRfZTI3NDY0ZDZfYmluZGluZ3NfdXBsb2FkQ29uZmlnX3Byb3BzX2hhbmRsZVVwbG9hZF9kYXRhX2tleV9kYXRhX3VwbG9hZF9vcHRpb25zX2Nob29zZUZpbGVfb3B0aW9uc19yZW5kZXJcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXBsb2FkX2ZpbGUgPSAodXBsb2FkX2ZpbGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3Rvb2xiYXIvaW1hZ2UuanNcbnZhciB0b29sYmFyX2ltYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvdXRpbHMvZmlsZS5qc1xudmFyIGZpbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy91dGlscy9jb25zdGFudHMvY29tbWFuZC5qc1xudmFyIGNvbW1hbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvdXBsb2FkLWltYWdlLmpzXG5cblxudmFyIHVwbG9hZF9pbWFnZV9jb21wb25lbnRzO1xuXG5cblxuXG5cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuICBhY2NlcHQ6ICdpbWFnZS8qJyxcbiAgbXVsdGlwbGU6IGZhbHNlXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXBsb2FkX2ltYWdlID0gKHtcbiAgY29tcG9uZW50czogKHVwbG9hZF9pbWFnZV9jb21wb25lbnRzID0ge30sIHVwbG9hZF9pbWFnZV9jb21wb25lbnRzW3VwbG9hZF9maWxlLm5hbWVdID0gdXBsb2FkX2ZpbGUsIHVwbG9hZF9pbWFnZV9jb21wb25lbnRzKSxcbiAgcHJvcHM6IHtcbiAgICB1cGxvYWRJbWFnZUNvbmZpZzogT2JqZWN0XG4gIH0sXG4gIGVtaXRzOiBbJ3VwbG9hZC1pbWFnZSddLFxuICBjb21wdXRlZDoge1xuICAgIHVwbG9hZEltZ0NvbmZpZzogZnVuY3Rpb24gdXBsb2FkSW1nQ29uZmlnKCkge1xuICAgICAgcmV0dXJuIE9iamVjdChlc21fZXh0ZW5kc1tcImFcIiAvKiBkZWZhdWx0ICovXSkoe30sIGRlZmF1bHRDb25maWcsIHRoaXMudXBsb2FkSW1hZ2VDb25maWcpO1xuICAgIH0sXG4gICAgaGFzVXBsb2FkSW1hZ2U6IGZ1bmN0aW9uIGhhc1VwbG9hZEltYWdlKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVkTWVudXMuaW5jbHVkZXModG9vbGJhcl9pbWFnZVtcImRlZmF1bHRcIl0ubmFtZSArIFwiL3VwbG9hZC1pbWFnZVwiKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVEcm9wOiBmdW5jdGlvbiBoYW5kbGVEcm9wKGUpIHtcbiAgICAgIHZhciBmaWxlcyA9IE9iamVjdChmaWxlW1wiYVwiIC8qIGZpbGVzRmlsdGVyICovXSkoZS5kYXRhVHJhbnNmZXIuZmlsZXMsIHRoaXMudXBsb2FkSW1nQ29uZmlnKTtcbiAgICAgIHRoaXMuZW1pdFVwbG9hZEltYWdlKGUsIGZpbGVzKTtcbiAgICB9LFxuICAgIGhhbmRsZVBhc3RlOiBmdW5jdGlvbiBoYW5kbGVQYXN0ZShlKSB7XG4gICAgICB2YXIgY2xpcGJvYXJkRGF0YSA9IGUuY2xpcGJvYXJkRGF0YTtcbiAgICAgIGlmICghY2xpcGJvYXJkRGF0YSkgcmV0dXJuO1xuICAgICAgdmFyIGZpbGVzID0gT2JqZWN0KGZpbGVbXCJhXCIgLyogZmlsZXNGaWx0ZXIgKi9dKShPYmplY3QoZmlsZVtcImJcIiAvKiBnZXRGaWxlc0Zyb21DbGlwYm9hcmREYXRhICovXSkoY2xpcGJvYXJkRGF0YSksIHRoaXMudXBsb2FkSW1nQ29uZmlnKTtcbiAgICAgIHRoaXMuZW1pdFVwbG9hZEltYWdlKGUsIGZpbGVzKTtcbiAgICB9LFxuICAgIGVtaXRVcGxvYWRJbWFnZTogZnVuY3Rpb24gZW1pdFVwbG9hZEltYWdlKGUsIGZpbGVzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5oYXNVcGxvYWRJbWFnZSAmJiBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLiRlbWl0KCd1cGxvYWQtaW1hZ2UnLCBlLCBmdW5jdGlvbiAoaW1hZ2VDb25maWcpIHtcbiAgICAgICAgICBfdGhpcy5leGVjQ29tbWFuZChjb21tYW5kW1wibFwiIC8qIGltYWdlICovXSwgaW1hZ2VDb25maWcpO1xuICAgICAgICB9LCBmaWxlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvdXRpbHMvY29uc3RhbnRzL21hcmt1cC5qc1xudmFyIG1hcmt1cCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9zeW5jLXNjcm9sbC5qc1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzeW5jX3Njcm9sbCA9ICh7XG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuYWJsZVN5bmNTY3JvbGw6IHRydWVcbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlU3luY1Njcm9sbDogZnVuY3Rpb24gdG9nZ2xlU3luY1Njcm9sbChpc0VuYWJsZSkge1xuICAgICAgaWYgKGlzRW5hYmxlID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNFbmFibGUgPSAhdGhpcy5lbmFibGVTeW5jU2Nyb2xsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVuYWJsZVN5bmNTY3JvbGwgPSBpc0VuYWJsZTtcbiAgICAgIGlmIChpc0VuYWJsZSkgdGhpcy5wcmV2aWV3U3luY1Njcm9sbCgpO1xuICAgIH0sXG4gICAgcHJldmlld1N5bmNTY3JvbGw6IGZ1bmN0aW9uIHByZXZpZXdTeW5jU2Nyb2xsKCkge1xuICAgICAgaWYgKHRoaXMuaXNFZGl0TW9kZSkgcmV0dXJuO1xuICAgICAgdmFyIHByZXZpZXdFbCA9IHRoaXMuJHJlZnMucHJldmlldy4kZWw7XG4gICAgICB2YXIgcHJldmlld1Njcm9sbGVyRWwgPSB0aGlzLiRyZWZzLnByZXZpZXdTY3JvbGxlci4kZWw7XG4gICAgICB2YXIgcHJldmlld0xpbmVzID0gcHJldmlld0VsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIgKyBtYXJrdXBbXCJjXCIgLyogTElORV9NQVJLVVAgKi9dICsgXCJdXCIpO1xuXG4gICAgICB2YXIgX3RoaXMkZ2V0U2Nyb2xsSW5mbyA9IHRoaXMuZ2V0U2Nyb2xsSW5mbygpLFxuICAgICAgICAgIGVkaXRvckNsaWVudEhlaWdodCA9IF90aGlzJGdldFNjcm9sbEluZm8uY2xpZW50SGVpZ2h0LFxuICAgICAgICAgIGVkaXRvclNjcm9sbFRvcCA9IF90aGlzJGdldFNjcm9sbEluZm8udG9wLFxuICAgICAgICAgIGVkaXRvclNjcm9sbEhlaWdodCA9IF90aGlzJGdldFNjcm9sbEluZm8uaGVpZ2h0O1xuXG4gICAgICB2YXIgcHJldmlld1Njcm9sbFdyYXBwZXIgPSBwcmV2aWV3U2Nyb2xsZXJFbC5xdWVyeVNlbGVjdG9yKCcuc2Nyb2xsYmFyX193cmFwJyk7XG5cbiAgICAgIGlmIChlZGl0b3JDbGllbnRIZWlnaHQgKyBlZGl0b3JTY3JvbGxUb3AgPT09IGVkaXRvclNjcm9sbEhlaWdodCkge1xuICAgICAgICB2YXIgY2xpZW50SGVpZ2h0ID0gcHJldmlld1Njcm9sbFdyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gcHJldmlld1Njcm9sbFdyYXBwZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB0aGlzLnByZXZpZXdTY3JvbGxUbyhzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgbmV4dExpbmU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2aWV3TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHByZXZpZXdMaW5lc1tpXS5nZXRBdHRyaWJ1dGUobWFya3VwW1wiY1wiIC8qIExJTkVfTUFSS1VQICovXSk7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0QXRMaW5lKGxpbmVOdW1iZXIgLSAxLCAnbG9jYWwnKTtcblxuICAgICAgICAgIGlmIChoZWlnaHQgPCBlZGl0b3JTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dExpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBlcmNlbnQgPSAwO1xuXG4gICAgICAgIGlmIChjdXJyZW50TGluZSAmJiBuZXh0TGluZSAmJiBjdXJyZW50TGluZSAhPT0gbmV4dExpbmUpIHtcbiAgICAgICAgICB2YXIgY3VycmVudExpbmVUb3AgPSB0aGlzLmhlaWdodEF0TGluZShjdXJyZW50TGluZSAtIDEsICdsb2NhbCcpO1xuICAgICAgICAgIHZhciBuZXh0TGluZVRvcCA9IHRoaXMuaGVpZ2h0QXRMaW5lKG5leHRMaW5lIC0gMSwgJ2xvY2FsJyk7XG4gICAgICAgICAgcGVyY2VudCA9IChlZGl0b3JTY3JvbGxUb3AgLSBjdXJyZW50TGluZVRvcCkgLyAobmV4dExpbmVUb3AgLSBjdXJyZW50TGluZVRvcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3TGluZVRvcCA9IDA7XG4gICAgICAgIHZhciBuZXdOZXh0TGluZVRvcCA9IHByZXZpZXdTY3JvbGxXcmFwcGVyLnNjcm9sbEhlaWdodCAtIHByZXZpZXdTY3JvbGxXcmFwcGVyLmNsaWVudEhlaWdodDtcblxuICAgICAgICBpZiAoY3VycmVudExpbmUpIHtcbiAgICAgICAgICBuZXdMaW5lVG9wID0gcHJldmlld0VsLnF1ZXJ5U2VsZWN0b3IoXCJbXCIgKyBtYXJrdXBbXCJjXCIgLyogTElORV9NQVJLVVAgKi9dICsgXCI9XFxcIlwiICsgY3VycmVudExpbmUgKyBcIlxcXCJdXCIpLm9mZnNldFRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0TGluZSkge1xuICAgICAgICAgIG5ld05leHRMaW5lVG9wID0gcHJldmlld0VsLnF1ZXJ5U2VsZWN0b3IoXCJbXCIgKyBtYXJrdXBbXCJjXCIgLyogTElORV9NQVJLVVAgKi9dICsgXCI9XFxcIlwiICsgbmV4dExpbmUgKyBcIlxcXCJdXCIpLm9mZnNldFRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdTY3JvbGxUb3AgPSBuZXdMaW5lVG9wICsgKG5ld05leHRMaW5lVG9wIC0gbmV3TGluZVRvcCkgKiBwZXJjZW50O1xuICAgICAgICB0aGlzLnByZXZpZXdTY3JvbGxUbyhuZXdTY3JvbGxUb3ApO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlRWRpdG9yU2Nyb2xsOiBmdW5jdGlvbiBoYW5kbGVFZGl0b3JTY3JvbGwoKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlU3luY1Njcm9sbCB8fCB0aGlzLmlnbm9yZVN5bmNTY3JvbGwpIHJldHVybjtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbFRpbW1lcik7XG4gICAgICB0aGlzLnNjcm9sbFRpbW1lciA9IHNldFRpbWVvdXQodGhpcy5wcmV2aWV3U3luY1Njcm9sbCwgNjApO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvdG9vbGJhci5qc1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtaXhpbnNfdG9vbGJhciA9IChmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIHJldHVybiB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGxlZnRUb29sYmFyOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3VuZG8gcmVkbyBjbGVhciB8IGggYm9sZCBpdGFsaWMgc3RyaWtldGhyb3VnaCBxdW90ZSB8IHVsIG9sIHRhYmxlIGhyIHwgbGluayBpbWFnZSBjb2RlIHwgc2F2ZSdcbiAgICAgIH0sXG4gICAgICByaWdodFRvb2xiYXI6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAncHJldmlldyB0b2Mgc3luYy1zY3JvbGwgZnVsbHNjcmVlbidcbiAgICAgIH0sXG4gICAgICB0b29sYmFyOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzYWJsZWRNZW51czoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIFsnaW1hZ2UvdXBsb2FkLWltYWdlJ107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b29sYmFyQ29uZmlnOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHRvb2xiYXJzID0gQ29tcG9uZW50LnRvb2xiYXJzO1xuICAgICAgdGhpcy50b29sYmFycyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXModG9vbGJhcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJUb29sYmFyKG5hbWUsIHRvb2xiYXJzW25hbWVdKTtcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmtleXModGhpcy50b29sYmFyKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyVG9vbGJhcihuYW1lLCBfdGhpcy50b29sYmFyW25hbWVdKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgcmVnaXN0ZXJUb29sYmFyOiBmdW5jdGlvbiByZWdpc3RlclRvb2xiYXIobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIHRvb2xiYXJfcmVnaXN0ZXJUb29sYmFyKHRoaXMudG9vbGJhcnMsIG5hbWUsIGNvbmZpZyk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbGJhckl0ZW1DbGljazogZnVuY3Rpb24gaGFuZGxlVG9vbGJhckl0ZW1DbGljayh0b29sYmFyKSB7XG4gICAgICAgIHZhciBfdG9vbGJhciRtZW51cztcblxuICAgICAgICBpZiAodG9vbGJhci5hY3Rpb24gJiYgISgoX3Rvb2xiYXIkbWVudXMgPSB0b29sYmFyLm1lbnVzKSAhPSBudWxsICYmIF90b29sYmFyJG1lbnVzLmxlbmd0aCkgJiYgdHlwZW9mIHRvb2xiYXIuYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdG9vbGJhci5hY3Rpb24uY2FsbCh0b29sYmFyLCB0aGlzLCB0aGlzLnRvb2xiYXJDb25maWdbdG9vbGJhci5uYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sYmFyTWVudUNsaWNrOiBmdW5jdGlvbiBoYW5kbGVUb29sYmFyTWVudUNsaWNrKG1lbnUpIHtcbiAgICAgICAgaWYgKG1lbnUuYWN0aW9uICYmIHR5cGVvZiBtZW51LmFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1lbnUuYWN0aW9uLmNhbGwobWVudSwgdGhpcywgdGhpcy50b29sYmFyQ29uZmlnW21lbnUubmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvY29tbWFuZC5qc1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtaXhpbnNfY29tbWFuZCA9IChmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb21tYW5kcyA9IENvbXBvbmVudC5jb21tYW5kcztcbiAgICAgIHRoaXMuY29tbWFuZHMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGNvbW1hbmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyQ29tbWFuZChuYW1lLCBjb21tYW5kc1tuYW1lXSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlZ2lzdGVyQ29tbWFuZDogZnVuY3Rpb24gcmVnaXN0ZXJDb21tYW5kKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbW1hbmRfcmVnaXN0ZXJDb21tYW5kKHRoaXMuY29tbWFuZHMsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICBleGVjQ29tbWFuZDogZnVuY3Rpb24gZXhlY0NvbW1hbmQobmFtZSkge1xuICAgICAgICB2YXIgY29tbWFuZENhbGxCYWNrID0gdGhpcy5jb21tYW5kc1tuYW1lXTtcblxuICAgICAgICBpZiAoY29tbWFuZENhbGxCYWNrKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBhcmdbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1hbmRDYWxsQmFjay5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQoYXJnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvbW1hbmQgbm90IGZvdW5kOiBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9taXhpbnMvdG9jLmpzXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRvYyA9ICh7XG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvY1Zpc2libGU6IHRoaXMuZGVmYXVsdFNob3dUb2MsXG4gICAgICB0aXRsZXM6IFtdXG4gICAgfTtcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlTGV2ZWw6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbMiwgM107XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWZhdWx0U2hvd1RvYzogQm9vbGVhblxuICB9LFxuICB3YXRjaDoge1xuICAgIHRleHQ6IHtcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobmV3dmFsLCBvbGRWYWwpIHtcbiAgICAgICAgLy8gcmVuZGVyIGluIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKHRoaXMudXBkYXRlVG9jTmF2KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy51cGRhdGVUb2NOYXZUaW1tZXIpIGNsZWFyVGltZW91dCh0aGlzLnVwZGF0ZVRvY05hdlRpbW1lcik7XG4gICAgICAgIHRoaXMudXBkYXRlVG9jTmF2VGltbWVyID0gc2V0VGltZW91dCh0aGlzLnVwZGF0ZVRvY05hdiwgODAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgYW5jaG9yc1NlbGVjdG9yOiBmdW5jdGlvbiBhbmNob3JzU2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmNsdWRlTGV2ZWwubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICByZXR1cm4gXCJoXCIgKyBsZXZlbDtcbiAgICAgIH0pLmpvaW4oJywnKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB0b2dnbGVUb2M6IGZ1bmN0aW9uIHRvZ2dsZVRvYyh2aXNpYmxlKSB7XG4gICAgICBpZiAodmlzaWJsZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZpc2libGUgPSAhdGhpcy50b2NWaXNpYmxlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRvY1Zpc2libGUgPSB2aXNpYmxlO1xuICAgIH0sXG4gICAgdXBkYXRlVG9jTmF2OiBmdW5jdGlvbiB1cGRhdGVUb2NOYXYoKSB7XG4gICAgICB2YXIgX3RoaXMkJHJlZnMkcHJldmlldztcblxuICAgICAgdmFyIHByZXZpZXdFbCA9IChfdGhpcyQkcmVmcyRwcmV2aWV3ID0gdGhpcy4kcmVmcy5wcmV2aWV3KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkJHJlZnMkcHJldmlldy4kZWw7XG4gICAgICBpZiAoIXByZXZpZXdFbCkgcmV0dXJuO1xuICAgICAgdmFyIGFuY2hvcnMgPSBwcmV2aWV3RWwucXVlcnlTZWxlY3RvckFsbCh0aGlzLmFuY2hvcnNTZWxlY3Rvcik7XG4gICAgICB2YXIgdGl0bGVzID0gQXJyYXkuZnJvbShhbmNob3JzKS5maWx0ZXIoZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICAgIHJldHVybiAhIXRpdGxlLmlubmVyVGV4dC50cmltKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aXRsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGl0bGVzID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhUYWdzID0gQXJyYXkuZnJvbShuZXcgU2V0KHRpdGxlcy5tYXAoZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICAgIHJldHVybiB0aXRsZS50YWdOYW1lO1xuICAgICAgfSkpKS5zb3J0KCk7XG4gICAgICB0aGlzLnRpdGxlcyA9IHRpdGxlcy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGl0bGU6IGVsLmlubmVyVGV4dCxcbiAgICAgICAgICBsaW5lSW5kZXg6IGVsLmdldEF0dHJpYnV0ZShtYXJrdXBbXCJjXCIgLyogTElORV9NQVJLVVAgKi9dKSxcbiAgICAgICAgICBpbmRlbnQ6IGhUYWdzLmluZGV4T2YoZWwudGFnTmFtZSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaGFuZGxlTmF2Q2xpY2s6IGZ1bmN0aW9uIGhhbmRsZU5hdkNsaWNrKF9yZWYpIHtcbiAgICAgIHZhciBsaW5lSW5kZXggPSBfcmVmLmxpbmVJbmRleDtcbiAgICAgIHRoaXMuc2Nyb2xsVG9MaW5lKGxpbmVJbmRleCk7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9zY3JvbGwuanNcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1peGluc19zY3JvbGwgPSAoe1xuICBwcm9wczoge1xuICAgIHByZXZpZXdTY3JvbGxDb250YWluZXI6IEZ1bmN0aW9uXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgZ2V0UHJldmlld1Njcm9sbENvbnRhaW5lcjogZnVuY3Rpb24gZ2V0UHJldmlld1Njcm9sbENvbnRhaW5lcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2aWV3U2Nyb2xsQ29udGFpbmVyID0gX3RoaXMuJHJlZnMucHJldmlld1Njcm9sbGVyLiRlbC5xdWVyeVNlbGVjdG9yKCcuc2Nyb2xsYmFyX193cmFwJyk7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRDb250YWluZXIgPSBfdGhpcy5pc1ByZXZpZXdNb2RlID8gd2luZG93IDogcHJldmlld1Njcm9sbENvbnRhaW5lcjtcbiAgICAgICAgcmV0dXJuIF90aGlzLnByZXZpZXdTY3JvbGxDb250YWluZXIgPyBfdGhpcy5wcmV2aWV3U2Nyb2xsQ29udGFpbmVyKCkgOiBkZWZhdWx0Q29udGFpbmVyO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBwcmV2aWV3U2Nyb2xsVG86IGZ1bmN0aW9uIHByZXZpZXdTY3JvbGxUbyhzY3JvbGxUb3ApIHtcbiAgICAgIHRoaXMuJHJlZnMucHJldmlld1Njcm9sbGVyLnNjcm9sbFRvKHNjcm9sbFRvcCk7XG4gICAgfSxcbiAgICBzY3JvbGxUb0xpbmU6IGZ1bmN0aW9uIHNjcm9sbFRvTGluZShsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3TW9kZSkge1xuICAgICAgICB0aGlzLmVkaXRvclNjcm9sbFRvTGluZShsaW5lSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNFZGl0TW9kZSkge1xuICAgICAgICB0aGlzLmlnbm9yZVN5bmNTY3JvbGwgPSB0cnVlO1xuICAgICAgICB0aGlzLnByZXZpZXdTY3JvbGxUb0xpbmUoe1xuICAgICAgICAgIGxpbmVJbmRleDogbGluZUluZGV4LFxuICAgICAgICAgIG9uU2Nyb2xsRW5kOiBmdW5jdGlvbiBvblNjcm9sbEVuZCgpIHtcbiAgICAgICAgICAgIF90aGlzMi5pZ25vcmVTeW5jU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVkaXRvclNjcm9sbFRvTGluZTogZnVuY3Rpb24gZWRpdG9yU2Nyb2xsVG9MaW5lKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG9mZnNldFRvcCA9IHRoaXMuaGVpZ2h0QXRMaW5lKGxpbmVJbmRleCAtIDEsICdsb2NhbCcpO1xuICAgICAgdGhpcy5lZGl0b3JTY3JvbGxUb1RvcChvZmZzZXRUb3ApO1xuICAgIH0sXG4gICAgcHJldmlld1Njcm9sbFRvVGFyZ2V0OiBmdW5jdGlvbiBwcmV2aWV3U2Nyb2xsVG9UYXJnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMkJHJlZnMkcHJldmlldztcblxuICAgICAgKF90aGlzJCRyZWZzJHByZXZpZXcgPSB0aGlzLiRyZWZzLnByZXZpZXcpLnNjcm9sbFRvVGFyZ2V0LmFwcGx5KF90aGlzJCRyZWZzJHByZXZpZXcsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBwcmV2aWV3U2Nyb2xsVG9MaW5lOiBmdW5jdGlvbiBwcmV2aWV3U2Nyb2xsVG9MaW5lKF9yZWYpIHtcbiAgICAgIHZhciBsaW5lSW5kZXggPSBfcmVmLmxpbmVJbmRleCxcbiAgICAgICAgICBvblNjcm9sbEVuZCA9IF9yZWYub25TY3JvbGxFbmQ7XG4gICAgICB0aGlzLiRyZWZzLnByZXZpZXcuc2Nyb2xsVG9MaW5lKHtcbiAgICAgICAgbGluZUluZGV4OiBsaW5lSW5kZXgsXG4gICAgICAgIG9uU2Nyb2xsRW5kOiBvblNjcm9sbEVuZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9ob3RrZXlzLmpzXG5cbnZhciBkZWZhdWx0SG90a2V5cyA9IHt9O1xuT2JqZWN0KHV0aWxbXCJjXCIgLyogaW1wb3J0QWxsICovXSkoZGVmYXVsdEhvdGtleXMsIF9fd2VicGFja19yZXF1aXJlX18oOTApKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGhvdGtleXMgPSAoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICByZXR1cm4ge1xuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5pc1ByZXZpZXdNb2RlKSByZXR1cm47XG4gICAgICB2YXIgaG90a2V5cyA9IENvbXBvbmVudC5ob3RrZXlzO1xuICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdEhvdGtleXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfdGhpcy5yZWdpc3RlckhvdGtleXMoZGVmYXVsdEhvdGtleXNba2V5XS5kZWZhdWx0KTtcbiAgICAgIH0pO1xuICAgICAgaG90a2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJIb3RrZXlzKGNvbmZpZyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlZ2lzdGVySG90a2V5czogZnVuY3Rpb24gcmVnaXN0ZXJIb3RrZXlzKF9yZWYpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG1vZGlmaWVyID0gX3JlZi5tb2RpZmllcixcbiAgICAgICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICAgICAgX2FjdGlvbiA9IF9yZWYuYWN0aW9uLFxuICAgICAgICAgICAgX3JlZiRwcmV2ZW50RGVmYXVsdCA9IF9yZWYucHJldmVudERlZmF1bHQsXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IF9yZWYkcHJldmVudERlZmF1bHQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHByZXZlbnREZWZhdWx0O1xuICAgICAgICB0aGlzLmVkaXRvclJlZ2lzdGVySG90a2V5cyh7XG4gICAgICAgICAgbW9kaWZpZXI6IG1vZGlmaWVyLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmcgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgIGFyZ1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9hY3Rpb24uYXBwbHkodm9pZCAwLCBbX3RoaXMyXS5jb25jYXQoYXJnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9saXN0LmpzXG52YXIgb2wgPSAvXlxccyooW1xcZF0rXFwuKSggXFxbWyB4WF1dKT8gLztcbnZhciB1bCA9IC9eXFxzKihbLSpdKSggXFxbWyB4WF1dKT8gLztcbnZhciB1bFN5bnRheCA9IC8oWyotXSB8W1xcZF0rXFwuICkvO1xudmFyIG9sU3ludGF4ID0gLyhbXFxkXSkrXFwuKCBcXFtbIHhYXV0pPyAvO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGlzdCA9ICh7XG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzUHJldmlld01vZGUpIHJldHVybjtcbiAgICB0aGlzLnJlZ2lzdGVySG90a2V5cyh7XG4gICAgICBrZXk6ICdlbnRlcicsXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IsIGUpIHtcbiAgICAgICAgaWYgKGUuaXNDb21wb3NpbmcpIHJldHVybjtcblxuICAgICAgICB2YXIgY3Vyc29yTGluZUxlZnRUZXh0ID0gX3RoaXMuZ2V0Q3Vyc29yTGluZUxlZnRUZXh0KCk7XG5cbiAgICAgICAgdmFyIHN1ZmZpeDtcbiAgICAgICAgdmFyIHN5bnRheDtcblxuICAgICAgICBpZiAob2wudGVzdChjdXJzb3JMaW5lTGVmdFRleHQpKSB7XG4gICAgICAgICAgc3VmZml4ID0gJ3guICc7XG4gICAgICAgICAgc3ludGF4ID0gb2xTeW50YXg7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHVsLnRlc3QoY3Vyc29yTGluZUxlZnRUZXh0KSkge1xuICAgICAgICAgIHN1ZmZpeCA9ICctICc7XG4gICAgICAgICAgc3ludGF4ID0gdWxTeW50YXg7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRlbnQgPSBjdXJzb3JMaW5lTGVmdFRleHQuc2VhcmNoKHN5bnRheCk7XG4gICAgICAgIHZhciBzdWZmaXhJbmRleCA9IGluZGVudCArIHN1ZmZpeC5sZW5ndGg7XG4gICAgICAgIHZhciBiZWZvcmVUZXh0ID0gY3Vyc29yTGluZUxlZnRUZXh0LnNsaWNlKDAsIHN1ZmZpeEluZGV4KTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBjdXJzb3JMaW5lTGVmdFRleHQuc2xpY2Uoc3VmZml4SW5kZXgsIGN1cnNvckxpbmVMZWZ0VGV4dC5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgaWYgKHN1ZmZpeCA9PT0gJ3guICcpIHtcbiAgICAgICAgICAgIGJlZm9yZVRleHQgPSBiZWZvcmVUZXh0LnJlcGxhY2UoLyhcXGQrKS8sIHdpbmRvdy5wYXJzZUludChiZWZvcmVUZXh0KSArIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLnJlcGxhY2VTZWxlY3Rpb25UZXh0KFwiXFxuXCIgKyBiZWZvcmVUZXh0LCAnZW5kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnJlYWtcbiAgICAgICAgICBfdGhpcy5kZWxMaW5lTGVmdCgpO1xuXG4gICAgICAgICAgX3RoaXMucmVwbGFjZVNlbGVjdGlvblRleHQoJ1xcbicsICdlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21peGlucy9sYW5nLmpzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtaXhpbnNfbGFuZyA9ICh7XG4gIGNvbXB1dGVkOiB7XG4gICAgbGFuZ0NvbmZpZzogZnVuY3Rpb24gbGFuZ0NvbmZpZygpIHtcbiAgICAgIHZhciBsYW5nID0gdGhpcy4kb3B0aW9ucy5sYW5nLmNvbmZpZztcbiAgICAgIHJldHVybiBsYW5nLmxhbmdDb25maWdbbGFuZy5sYW5nXTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY3JlYXRlLWVkaXRvci5qc1xuXG5cblxuXG4gLy8gbWl4aW5zXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNyZWF0ZV9lZGl0b3JfbGFuZyA9IG5ldyB1dGlsc19sYW5nW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHtcbiAgYWZ0ZXJVc2U6IGZ1bmN0aW9uIGFmdGVyVXNlKGxhbmcpIHtcbiAgICBwcmV2aWV3W1wiZGVmYXVsdFwiXS52TWRQYXJzZXIubGFuZy5jb25maWcubGFuZyA9IGxhbmc7XG4gIH1cbn0pO1xuY3JlYXRlX2VkaXRvcl9sYW5nLmNvbmZpZyA9IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInJlYWN0aXZlXCJdKShjcmVhdGVfZWRpdG9yX2xhbmcuY29uZmlnKTtcbmNyZWF0ZV9lZGl0b3JfbGFuZy5hZGQoe1xuICAnemgtQ04nOiB6aF9DTlxufSk7XG5mdW5jdGlvbiBjcmVhdGVFZGl0b3IoY29tcG9uZW50KSB7XG4gIGNvbW1hbmRXcmFwcGVyKGNvbXBvbmVudCk7XG4gIHRvb2xiYXJXcmFwcGVyKGNvbXBvbmVudCk7XG4gIGNvbXBvbmVudC5uYW1lID0gJ3YtbWQtZWRpdG9yJztcbiAgY29tcG9uZW50LmxhbmcgPSBjcmVhdGVfZWRpdG9yX2xhbmc7XG4gIGNvbXBvbmVudC52TWRQYXJzZXIgPSBwcmV2aWV3W1wiZGVmYXVsdFwiXS52TWRQYXJzZXI7XG4gIGNvbXBvbmVudC5QcmV2aWV3ID0gcHJldmlld1tcImRlZmF1bHRcIl07XG4gIGNvbXBvbmVudC5ob3RrZXlzID0gW107XG5cbiAgY29tcG9uZW50LmhvdGtleSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBjb21wb25lbnQuaG90a2V5cy5wdXNoKGNvbmZpZyk7XG4gIH07XG5cbiAgY29tcG9uZW50Lm1peGlucyA9IFtjb21tb24sIHZfbW9kZWwsIG1peGluc190b29sYmFyKGNvbXBvbmVudCksIG1peGluc19jb21tYW5kKGNvbXBvbmVudCksIGhvdGtleXMoY29tcG9uZW50KSwgZnVsbHNjcmVlbiwgdXBsb2FkX2ltYWdlLCBzeW5jX3Njcm9sbCwgdG9jLCBtaXhpbnNfc2Nyb2xsLCBsaXN0LCBtaXhpbnNfbGFuZ107XG59XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3V0aWxzL2tleS1jb2Rlcy5qc1xudmFyIGtleUNvZGVzVG9OYW1lID0ge1xuICAvLyBOdW1iZXJzIGFuZCBsZXR0ZXJzXG4gIDQ4OiAwLFxuICA0OTogMSxcbiAgNTA6IDIsXG4gIDUxOiAzLFxuICA1MjogNCxcbiAgNTM6IDUsXG4gIDU0OiA2LFxuICA1NTogNyxcbiAgNTY6IDgsXG4gIDU3OiA5LFxuICA2NTogJ2EnLFxuICA2NjogJ2InLFxuICA2NzogJ2MnLFxuICA2ODogJ2QnLFxuICA2OTogJ2UnLFxuICA3MDogJ2YnLFxuICA3MTogJ2cnLFxuICA3MjogJ2gnLFxuICA3MzogJ2knLFxuICA3NDogJ2onLFxuICA3NTogJ2snLFxuICA3NjogJ2wnLFxuICA3NzogJ20nLFxuICA3ODogJ24nLFxuICA3OTogJ28nLFxuICA4MDogJ3AnLFxuICA4MTogJ3EnLFxuICA4MjogJ3InLFxuICA4MzogJ3MnLFxuICA4NDogJ3QnLFxuICA4NTogJ3UnLFxuICA4NjogJ3YnLFxuICA4NzogJ3cnLFxuICA4ODogJ3gnLFxuICA4OTogJ3knLFxuICA5MDogJ3onLFxuICAvLyBGdW5jdGlvbiBrZXlzXG4gIDExMjogJ0YxJyxcbiAgMTEzOiAnRjInLFxuICAxMTQ6ICdGMycsXG4gIDExNTogJ0Y0JyxcbiAgMTE2OiAnRjUnLFxuICAxMTc6ICdGNicsXG4gIDExODogJ0Y3JyxcbiAgMTE5OiAnRjgnLFxuICAxMjA6ICdGOScsXG4gIDEyMTogJ0YxMCcsXG4gIDEyMjogJ0YxMScsXG4gIDEyMzogJ0YxMidcbn07XG52YXIga2V5TmFtZXMgPSB7XG4gIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gIHRhYjogJ1RhYicsXG4gIGVudGVyOiAnRW50ZXInLFxuICBzcGFjZTogWycgJywgJ1NwYWNlYmFyJ10sXG4gIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgbGVmdDogWydMZWZ0JywgJ0Fycm93TGVmdCddLFxuICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgZGVsZXRlOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9ob3RrZXlzLmpzXG5cblxudmFyIGhvdGtleXNfSG90a2V5cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhvdGtleXMoKSB7XG4gICAgdGhpcy5ob3RrZXlzID0ge1xuICAgICAgY3RybDoge30sXG4gICAgICBzaGlmdDoge30sXG4gICAgICBjdHJsQWx0OiB7fSxcbiAgICAgIGN0cmxTaGlmdDoge30sXG4gICAgICBrZXlzOiB7fVxuICAgIH07XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSG90a2V5cy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goZSkge1xuICAgIHZhciBrZXlOYW1lID0gdGhpcy5nZXRLZXlOYW1lKGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9wdDtcbiAgICBpZiAoIWtleU5hbWUpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmlzS2V5RW50ZXJFeGFjdChlKSkge1xuICAgICAgb3B0ID0gdGhpcy5ob3RrZXlzLmtleXNba2V5TmFtZV07XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ3RybEVudGVyRXhhY3QoZSkpIHtcbiAgICAgIG9wdCA9IHRoaXMuaG90a2V5cy5jdHJsW2tleU5hbWVdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1NoaWZ0RW50ZXJFeGFjdChlKSkge1xuICAgICAgb3B0ID0gdGhpcy5ob3RrZXlzLnNoaWZ0W2tleU5hbWVdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0N0cmxBbHRFbnRlckV4YWN0KGUpKSB7XG4gICAgICBvcHQgPSB0aGlzLmhvdGtleXMuY3RybEFsdFtrZXlOYW1lXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDdHJsU2hpZnRFbnRlckV4YWN0KGUpKSB7XG4gICAgICBvcHQgPSB0aGlzLmhvdGtleXMuY3RybFNoaWZ0W2tleU5hbWVdO1xuICAgIH1cblxuICAgIGlmIChvcHQpIHtcbiAgICAgIHZhciBfb3B0MiA9IG9wdCxcbiAgICAgICAgICBhY3Rpb24gPSBfb3B0Mi5hY3Rpb24sXG4gICAgICAgICAgcHJldmVudERlZmF1bHQgPSBfb3B0Mi5wcmV2ZW50RGVmYXVsdDtcbiAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYWN0aW9uKGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaXNLZXlFbnRlckV4YWN0ID0gZnVuY3Rpb24gaXNLZXlFbnRlckV4YWN0KGUpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNDdHJsRW50ZXIoZSkgJiYgIXRoaXMuaXNTaGlmdEVudGVyKGUpICYmICF0aGlzLmlzQWx0RW50ZXIoZSk7XG4gIH07XG5cbiAgX3Byb3RvLmlzQ3RybFNoaWZ0RW50ZXJFeGFjdCA9IGZ1bmN0aW9uIGlzQ3RybFNoaWZ0RW50ZXJFeGFjdChlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDdHJsRW50ZXIoZSkgJiYgdGhpcy5pc1NoaWZ0RW50ZXIoZSkgJiYgIXRoaXMuaXNBbHRFbnRlcihlKTtcbiAgfTtcblxuICBfcHJvdG8uaXNDdHJsQWx0RW50ZXJFeGFjdCA9IGZ1bmN0aW9uIGlzQ3RybEFsdEVudGVyRXhhY3QoZSkge1xuICAgIHJldHVybiB0aGlzLmlzQ3RybEVudGVyKGUpICYmIHRoaXMuaXNBbHRFbnRlcihlKSAmJiAhdGhpcy5pc1NoaWZ0RW50ZXIoZSk7XG4gIH07XG5cbiAgX3Byb3RvLmlzQ3RybEVudGVyRXhhY3QgPSBmdW5jdGlvbiBpc0N0cmxFbnRlckV4YWN0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0N0cmxFbnRlcihlKSAmJiAhdGhpcy5pc1NoaWZ0RW50ZXIoZSkgJiYgIXRoaXMuaXNBbHRFbnRlcihlKTtcbiAgfTtcblxuICBfcHJvdG8uaXNTaGlmdEVudGVyRXhhY3QgPSBmdW5jdGlvbiBpc1NoaWZ0RW50ZXJFeGFjdChlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTaGlmdEVudGVyKGUpICYmICF0aGlzLmlzQ3RybEVudGVyKGUpICYmICF0aGlzLmlzQWx0RW50ZXIoZSk7XG4gIH07XG5cbiAgX3Byb3RvLmlzQ3RybEVudGVyID0gZnVuY3Rpb24gaXNDdHJsRW50ZXIoZSkge1xuICAgIHJldHVybiBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5O1xuICB9O1xuXG4gIF9wcm90by5pc1NoaWZ0RW50ZXIgPSBmdW5jdGlvbiBpc1NoaWZ0RW50ZXIoZSkge1xuICAgIHJldHVybiBlLnNoaWZ0S2V5O1xuICB9O1xuXG4gIF9wcm90by5pc0FsdEVudGVyID0gZnVuY3Rpb24gaXNBbHRFbnRlcihlKSB7XG4gICAgcmV0dXJuIGUuYWx0S2V5O1xuICB9O1xuXG4gIF9wcm90by5yZWdpc3RlckhvdGtleXMgPSBmdW5jdGlvbiByZWdpc3RlckhvdGtleXMoX3JlZikge1xuICAgIHZhciBtb2RpZmllciA9IF9yZWYubW9kaWZpZXIsXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBfcmVmJHByZXZlbnREZWZhdWx0ID0gX3JlZi5wcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSBfcmVmJHByZXZlbnREZWZhdWx0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRwcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgYWN0aW9uID0gX3JlZi5hY3Rpb247XG5cbiAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgIHRoaXMuaG90a2V5c1ttb2RpZmllcl1ba2V5XSA9IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0LFxuICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ob3RrZXlzLmtleXNba2V5XSA9IHtcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IHByZXZlbnREZWZhdWx0LFxuICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldEtleU5hbWUgPSBmdW5jdGlvbiBnZXRLZXlOYW1lKGUpIHtcbiAgICB2YXIga2V5ID0gZS5rZXksXG4gICAgICAgIGtleUNvZGUgPSBlLmtleUNvZGU7XG5cbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBrZXlOYW1lID0gT2JqZWN0LmtleXMoa2V5TmFtZXMpLmZpbmQoZnVuY3Rpb24gKGtleU5hbWUpIHtcbiAgICAgICAgdmFyIHZhbGlkTmFtZXMgPSBrZXlOYW1lc1trZXlOYW1lXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWxpZE5hbWVzID09PSAnc3RyaW5nJyA/IHZhbGlkTmFtZXMgPT09IGtleSA6IHZhbGlkTmFtZXMuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleU5hbWUgfHwga2V5O1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDb2Rlc1RvTmFtZVtrZXlDb2RlXTtcbiAgfTtcblxuICByZXR1cm4gSG90a2V5cztcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaG90a2V5cyA9IF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGhvdGtleXNfSG90a2V5cyk7XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gICB0cnVlID8gbW9kdWxlLmV4cG9ydHMgOiB1bmRlZmluZWRcbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtYXAgPSB7XG5cdFwiLi9ib2xkLmpzXCI6IDM5LFxuXHRcIi4vY2xlYXIuanNcIjogNDAsXG5cdFwiLi9jb2RlLmpzXCI6IDQxLFxuXHRcIi4vZnVsbHNjcmVlbi5qc1wiOiA0Mixcblx0XCIuL2gxLmpzXCI6IDQzLFxuXHRcIi4vaDIuanNcIjogNDQsXG5cdFwiLi9oMy5qc1wiOiA0NSxcblx0XCIuL2g0LmpzXCI6IDQ2LFxuXHRcIi4vaDUuanNcIjogNDcsXG5cdFwiLi9oNi5qc1wiOiA0OCxcblx0XCIuL2hyLmpzXCI6IDQ5LFxuXHRcIi4vaW1hZ2UuanNcIjogNTAsXG5cdFwiLi9pdGFsaWMuanNcIjogNTEsXG5cdFwiLi9saW5rLmpzXCI6IDUyLFxuXHRcIi4vb2wuanNcIjogNTMsXG5cdFwiLi9xdW90ZS5qc1wiOiA1NCxcblx0XCIuL3JlZG8uanNcIjogNTUsXG5cdFwiLi9zdHJpa2V0aHJvdWdoLmpzXCI6IDU2LFxuXHRcIi4vc3luYy1zY3JvbGwuanNcIjogNTcsXG5cdFwiLi90YWJsZS5qc1wiOiA1OCxcblx0XCIuL3VsLmpzXCI6IDU5LFxuXHRcIi4vdW5kby5qc1wiOiA2MFxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDM4O1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImFcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci5pbnNlcnQoZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgdmFyIHByZWZpeCA9ICcqKic7XG4gICAgdmFyIHN1ZmZpeCA9ICcqKic7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gZWRpdG9yLmxhbmdDb25maWcuYm9sZC5wbGFjZWhvbGRlcjtcblxuICAgIHZhciBzZWxlY3RlZEdldHRlciA9IGZ1bmN0aW9uIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQgfHwgcGxhY2Vob2xkZXI7XG4gICAgfTtcblxuICAgIHZhciBfZ2VuZXJhdG9yVGV4dCA9IE9iamVjdChfdXRpbHNfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdlbmVyYXRvclRleHQgKi8gXCJiXCJdKSh7XG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBJbnNlcnRHZXR0ZXI6IGZ1bmN0aW9uIEluc2VydEdldHRlcihzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKSArIHN1ZmZpeDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZEdldHRlcjogc2VsZWN0ZWRHZXR0ZXJcbiAgICB9KSxcbiAgICAgICAgaW5zZXJ0Q29udGVudCA9IF9nZW5lcmF0b3JUZXh0Lmluc2VydENvbnRlbnQsXG4gICAgICAgIG5ld1NlbGVjdGVkID0gX2dlbmVyYXRvclRleHQubmV3U2VsZWN0ZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogaW5zZXJ0Q29udGVudCxcbiAgICAgIHNlbGVjdGVkOiBuZXdTZWxlY3RlZFxuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYlwiXTsgfSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci5jbGVhcigpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY1wiXTsgfSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci5pbnNlcnQoZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgdmFyIHByZWZpeCA9ICdgYGAgbGFuZ3VhZ2UnO1xuICAgIHZhciBzdWZmaXggPSAnYGBgJztcbiAgICB2YXIgdGV4dCA9IHByZWZpeCArIFwiXFxuXCIgKyBzdWZmaXg7XG5cbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRleHQgPSBwcmVmaXggKyBcIlxcbiAgXCIgKyBzZWxlY3RlZCArIFwiXFxuXCIgKyBzdWZmaXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBzZWxlY3RlZDogJ2xhbmd1YWdlJ1xuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZFwiXTsgfSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yLCBmdWxsU2NyZWVuKSB7XG4gIGVkaXRvci50b2dnbGVGdWxsU2NyZWVuKGZ1bGxTY3JlZW4pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZVwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgZWRpdG9yLmluc2VydChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgcHJlZml4ID0gJyMnO1xuICAgIHZhciBwbGFjZWhvbGRlciA9IGVkaXRvci5sYW5nQ29uZmlnLmgxLnBsYWNlaG9sZGVyO1xuXG4gICAgdmFyIHNlbGVjdGVkR2V0dGVyID0gZnVuY3Rpb24gc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZCB8fCBwbGFjZWhvbGRlcjtcbiAgICB9O1xuXG4gICAgdmFyIF9nZW5lcmF0b3JUZXh0ID0gT2JqZWN0KF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2VuZXJhdG9yVGV4dCAqLyBcImJcIl0pKHtcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIEluc2VydEdldHRlcjogZnVuY3Rpb24gSW5zZXJ0R2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBcIiBcIiArIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZEdldHRlcjogc2VsZWN0ZWRHZXR0ZXJcbiAgICB9KSxcbiAgICAgICAgaW5zZXJ0Q29udGVudCA9IF9nZW5lcmF0b3JUZXh0Lmluc2VydENvbnRlbnQsXG4gICAgICAgIG5ld1NlbGVjdGVkID0gX2dlbmVyYXRvclRleHQubmV3U2VsZWN0ZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogaW5zZXJ0Q29udGVudCxcbiAgICAgIHNlbGVjdGVkOiBuZXdTZWxlY3RlZFxuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZlwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgZWRpdG9yLmluc2VydChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgcHJlZml4ID0gJyMjJztcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBlZGl0b3IubGFuZ0NvbmZpZy5oMi5wbGFjZWhvbGRlcjtcblxuICAgIHZhciBzZWxlY3RlZEdldHRlciA9IGZ1bmN0aW9uIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQgfHwgcGxhY2Vob2xkZXI7XG4gICAgfTtcblxuICAgIHZhciBfZ2VuZXJhdG9yVGV4dCA9IE9iamVjdChfdXRpbHNfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdlbmVyYXRvclRleHQgKi8gXCJiXCJdKSh7XG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBJbnNlcnRHZXR0ZXI6IGZ1bmN0aW9uIEluc2VydEdldHRlcihzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgXCIgXCIgKyBzZWxlY3RlZEdldHRlcihzZWxlY3RlZCk7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWRHZXR0ZXI6IHNlbGVjdGVkR2V0dGVyXG4gICAgfSksXG4gICAgICAgIGluc2VydENvbnRlbnQgPSBfZ2VuZXJhdG9yVGV4dC5pbnNlcnRDb250ZW50LFxuICAgICAgICBuZXdTZWxlY3RlZCA9IF9nZW5lcmF0b3JUZXh0Lm5ld1NlbGVjdGVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGluc2VydENvbnRlbnQsXG4gICAgICBzZWxlY3RlZDogbmV3U2VsZWN0ZWRcbiAgICB9O1xuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci5pbnNlcnQoZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgdmFyIHByZWZpeCA9ICcjIyMnO1xuICAgIHZhciBwbGFjZWhvbGRlciA9IGVkaXRvci5sYW5nQ29uZmlnLmgzLnBsYWNlaG9sZGVyO1xuXG4gICAgdmFyIHNlbGVjdGVkR2V0dGVyID0gZnVuY3Rpb24gc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZCB8fCBwbGFjZWhvbGRlcjtcbiAgICB9O1xuXG4gICAgdmFyIF9nZW5lcmF0b3JUZXh0ID0gT2JqZWN0KF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2VuZXJhdG9yVGV4dCAqLyBcImJcIl0pKHtcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIEluc2VydEdldHRlcjogZnVuY3Rpb24gSW5zZXJ0R2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBcIiBcIiArIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZEdldHRlcjogc2VsZWN0ZWRHZXR0ZXJcbiAgICB9KSxcbiAgICAgICAgaW5zZXJ0Q29udGVudCA9IF9nZW5lcmF0b3JUZXh0Lmluc2VydENvbnRlbnQsXG4gICAgICAgIG5ld1NlbGVjdGVkID0gX2dlbmVyYXRvclRleHQubmV3U2VsZWN0ZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogaW5zZXJ0Q29udGVudCxcbiAgICAgIHNlbGVjdGVkOiBuZXdTZWxlY3RlZFxuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiaFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgZWRpdG9yLmluc2VydChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgcHJlZml4ID0gJyMjIyMnO1xuICAgIHZhciBwbGFjZWhvbGRlciA9IGVkaXRvci5sYW5nQ29uZmlnLmg0LnBsYWNlaG9sZGVyO1xuXG4gICAgdmFyIHNlbGVjdGVkR2V0dGVyID0gZnVuY3Rpb24gc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZCB8fCBwbGFjZWhvbGRlcjtcbiAgICB9O1xuXG4gICAgdmFyIF9nZW5lcmF0b3JUZXh0ID0gT2JqZWN0KF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2VuZXJhdG9yVGV4dCAqLyBcImJcIl0pKHtcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIEluc2VydEdldHRlcjogZnVuY3Rpb24gSW5zZXJ0R2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBcIiBcIiArIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZEdldHRlcjogc2VsZWN0ZWRHZXR0ZXJcbiAgICB9KSxcbiAgICAgICAgaW5zZXJ0Q29udGVudCA9IF9nZW5lcmF0b3JUZXh0Lmluc2VydENvbnRlbnQsXG4gICAgICAgIG5ld1NlbGVjdGVkID0gX2dlbmVyYXRvclRleHQubmV3U2VsZWN0ZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogaW5zZXJ0Q29udGVudCxcbiAgICAgIHNlbGVjdGVkOiBuZXdTZWxlY3RlZFxuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiaVwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgZWRpdG9yLmluc2VydChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgcHJlZml4ID0gJyMjIyMjJztcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBlZGl0b3IubGFuZ0NvbmZpZy5oNS5wbGFjZWhvbGRlcjtcblxuICAgIHZhciBzZWxlY3RlZEdldHRlciA9IGZ1bmN0aW9uIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQgfHwgcGxhY2Vob2xkZXI7XG4gICAgfTtcblxuICAgIHZhciBfZ2VuZXJhdG9yVGV4dCA9IE9iamVjdChfdXRpbHNfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdlbmVyYXRvclRleHQgKi8gXCJiXCJdKSh7XG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBJbnNlcnRHZXR0ZXI6IGZ1bmN0aW9uIEluc2VydEdldHRlcihzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgXCIgXCIgKyBzZWxlY3RlZEdldHRlcihzZWxlY3RlZCk7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWRHZXR0ZXI6IHNlbGVjdGVkR2V0dGVyXG4gICAgfSksXG4gICAgICAgIGluc2VydENvbnRlbnQgPSBfZ2VuZXJhdG9yVGV4dC5pbnNlcnRDb250ZW50LFxuICAgICAgICBuZXdTZWxlY3RlZCA9IF9nZW5lcmF0b3JUZXh0Lm5ld1NlbGVjdGVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGluc2VydENvbnRlbnQsXG4gICAgICBzZWxlY3RlZDogbmV3U2VsZWN0ZWRcbiAgICB9O1xuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImpcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci5pbnNlcnQoZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgdmFyIHByZWZpeCA9ICcjIyMjIyMnO1xuICAgIHZhciBwbGFjZWhvbGRlciA9IGVkaXRvci5sYW5nQ29uZmlnLmg2LnBsYWNlaG9sZGVyO1xuXG4gICAgdmFyIHNlbGVjdGVkR2V0dGVyID0gZnVuY3Rpb24gc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZCB8fCBwbGFjZWhvbGRlcjtcbiAgICB9O1xuXG4gICAgdmFyIF9nZW5lcmF0b3JUZXh0ID0gT2JqZWN0KF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2VuZXJhdG9yVGV4dCAqLyBcImJcIl0pKHtcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIEluc2VydEdldHRlcjogZnVuY3Rpb24gSW5zZXJ0R2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBcIiBcIiArIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZEdldHRlcjogc2VsZWN0ZWRHZXR0ZXJcbiAgICB9KSxcbiAgICAgICAgaW5zZXJ0Q29udGVudCA9IF9nZW5lcmF0b3JUZXh0Lmluc2VydENvbnRlbnQsXG4gICAgICAgIG5ld1NlbGVjdGVkID0gX2dlbmVyYXRvclRleHQubmV3U2VsZWN0ZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogaW5zZXJ0Q29udGVudCxcbiAgICAgIHNlbGVjdGVkOiBuZXdTZWxlY3RlZFxuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wia1wiXTsgfSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci5pbnNlcnQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1xuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wibFwiXTsgfSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yLCBfdGVtcCkge1xuICB2YXIgX3JlZiA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wLFxuICAgICAgdXJsID0gX3JlZi51cmwsXG4gICAgICBkZXNjID0gX3JlZi5kZXNjLFxuICAgICAgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgZWRpdG9yLmluc2VydChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVybFBsYWNlaG9sZGVyID0gJ2h0dHA6Ly8nO1xuICAgIHZhciBkZXNjUGxhY2Vob2xkZXIgPSAnRGVzY3JpcHRpb24nO1xuICAgIHZhciBzZWxlY3RlZCA9IHVybFBsYWNlaG9sZGVyO1xuICAgIHZhciB0ZXh0ID0gXCIhW1wiICsgKGRlc2MgfHwgZGVzY1BsYWNlaG9sZGVyKSArIFwiXShcIiArICh1cmwgfHwgdXJsUGxhY2Vob2xkZXIpICsgXCIpXCI7XG4gICAgdmFyIHN0eWxlID0gW107XG5cbiAgICBpZiAod2lkdGgpIHtcbiAgICAgIHN0eWxlLnB1c2goXCJ3aWR0aD1cXFwiXCIgKyB3aWR0aCArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICBzdHlsZS5wdXNoKFwiaGVpZ2h0PVxcXCJcIiArIGhlaWdodCArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUubGVuZ3RoKSB7XG4gICAgICB0ZXh0ICs9IFwie3t7XCIgKyBzdHlsZS5qb2luKCcgJykgKyBcIn19fVwiO1xuICAgIH1cblxuICAgIGlmICh1cmwgJiYgZGVzYykge1xuICAgICAgc2VsZWN0ZWQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodXJsKSB7XG4gICAgICBzZWxlY3RlZCA9IGRlc2NQbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKGRlc2MpIHtcbiAgICAgIHNlbGVjdGVkID0gdXJsUGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWRcbiAgICB9O1xuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIm1cIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci5pbnNlcnQoZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgdmFyIHByZWZpeCA9ICcqJztcbiAgICB2YXIgc3VmZml4ID0gJyonO1xuICAgIHZhciBwbGFjZWhvbGRlciA9IGVkaXRvci5sYW5nQ29uZmlnLml0YWxpYy5wbGFjZWhvbGRlcjtcblxuICAgIHZhciBzZWxlY3RlZEdldHRlciA9IGZ1bmN0aW9uIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQgfHwgcGxhY2Vob2xkZXI7XG4gICAgfTtcblxuICAgIHZhciBfZ2VuZXJhdG9yVGV4dCA9IE9iamVjdChfdXRpbHNfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdlbmVyYXRvclRleHQgKi8gXCJiXCJdKSh7XG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBJbnNlcnRHZXR0ZXI6IGZ1bmN0aW9uIEluc2VydEdldHRlcihzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIHByZWZpeCArIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKSArIHN1ZmZpeDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZEdldHRlcjogc2VsZWN0ZWRHZXR0ZXJcbiAgICB9KSxcbiAgICAgICAgaW5zZXJ0Q29udGVudCA9IF9nZW5lcmF0b3JUZXh0Lmluc2VydENvbnRlbnQsXG4gICAgICAgIG5ld1NlbGVjdGVkID0gX2dlbmVyYXRvclRleHQubmV3U2VsZWN0ZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogaW5zZXJ0Q29udGVudCxcbiAgICAgIHNlbGVjdGVkOiBuZXdTZWxlY3RlZFxuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiblwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgZWRpdG9yLmluc2VydChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgZGVzY1BsYWNlaG9sZGVyID0gZWRpdG9yLmxhbmdDb25maWcubGluay5kZXNjUGxhY2Vob2xkZXI7XG4gICAgdmFyIGxpbmtQbGFjZWhvbGRlciA9ICdodHRwOi8vJztcblxuICAgIHZhciBfZ2VuZXJhdG9yVGV4dCA9IE9iamVjdChfdXRpbHNfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdlbmVyYXRvclRleHQgKi8gXCJiXCJdKSh7XG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBJbnNlcnRHZXR0ZXI6IGZ1bmN0aW9uIEluc2VydEdldHRlcihzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gXCJbXCIgKyAoc2VsZWN0ZWQgfHwgZGVzY1BsYWNlaG9sZGVyKSArIFwiXShcIiArIGxpbmtQbGFjZWhvbGRlciArIFwiKVwiO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkR2V0dGVyOiBmdW5jdGlvbiBzZWxlY3RlZEdldHRlcihzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWQgPyBsaW5rUGxhY2Vob2xkZXIgOiBkZXNjUGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgfSksXG4gICAgICAgIGluc2VydENvbnRlbnQgPSBfZ2VuZXJhdG9yVGV4dC5pbnNlcnRDb250ZW50LFxuICAgICAgICBuZXdTZWxlY3RlZCA9IF9nZW5lcmF0b3JUZXh0Lm5ld1NlbGVjdGVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGluc2VydENvbnRlbnQsXG4gICAgICBzZWxlY3RlZDogbmV3U2VsZWN0ZWRcbiAgICB9O1xuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIm9cIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci5pbnNlcnQoZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyID0gZWRpdG9yLmxhbmdDb25maWcub2wucGxhY2Vob2xkZXI7XG5cbiAgICB2YXIgc2VsZWN0ZWRHZXR0ZXIgPSBmdW5jdGlvbiBzZWxlY3RlZEdldHRlcihzZWxlY3RlZCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkIHx8IHBsYWNlaG9sZGVyO1xuICAgIH07XG5cbiAgICB2YXIgX2dlbmVyYXRvclRleHQgPSBPYmplY3QoX3V0aWxzX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBnZW5lcmF0b3JUZXh0ICovIFwiYlwiXSkoe1xuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgSW5zZXJ0R2V0dGVyOiBmdW5jdGlvbiBJbnNlcnRHZXR0ZXIoc2VsZWN0ZWQsIHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiByb3dJbmRleCArIFwiLiBcIiArIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKTtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZEdldHRlcjogc2VsZWN0ZWRHZXR0ZXIsXG4gICAgICBpZ25vcmVFbXB0eUxpbmU6IGZhbHNlXG4gICAgfSksXG4gICAgICAgIGluc2VydENvbnRlbnQgPSBfZ2VuZXJhdG9yVGV4dC5pbnNlcnRDb250ZW50LFxuICAgICAgICBuZXdTZWxlY3RlZCA9IF9nZW5lcmF0b3JUZXh0Lm5ld1NlbGVjdGVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGluc2VydENvbnRlbnQsXG4gICAgICBzZWxlY3RlZDogbmV3U2VsZWN0ZWRcbiAgICB9O1xuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInBcIl07IH0pO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKGVkaXRvcikge1xuICBlZGl0b3IuaW5zZXJ0KGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgIHZhciBwcmVmaXggPSAnPic7XG4gICAgdmFyIGNvbnRlbnQgPSBzZWxlY3RlZCB8fCBlZGl0b3IubGFuZ0NvbmZpZy5xdW90ZS5wbGFjZWhvbGRlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogcHJlZml4ICsgXCIgXCIgKyBjb250ZW50LFxuICAgICAgc2VsZWN0ZWQ6IGNvbnRlbnRcbiAgICB9O1xuICB9KTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInFcIl07IH0pO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKGVkaXRvcikge1xuICBlZGl0b3IucmVkbygpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiclwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgZWRpdG9yLmluc2VydChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgcHJlZml4ID0gJ35+JztcbiAgICB2YXIgc3VmZml4ID0gJ35+JztcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBlZGl0b3IubGFuZ0NvbmZpZy5zdHJpa2V0aHJvdWdoLnBsYWNlaG9sZGVyO1xuXG4gICAgdmFyIHNlbGVjdGVkR2V0dGVyID0gZnVuY3Rpb24gc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZCB8fCBwbGFjZWhvbGRlcjtcbiAgICB9O1xuXG4gICAgdmFyIF9nZW5lcmF0b3JUZXh0ID0gT2JqZWN0KF91dGlsc191dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZ2VuZXJhdG9yVGV4dCAqLyBcImJcIl0pKHtcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIEluc2VydEdldHRlcjogZnVuY3Rpb24gSW5zZXJ0R2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgcHJlZml4ICsgc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpICsgc3VmZml4O1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkR2V0dGVyOiBzZWxlY3RlZEdldHRlclxuICAgIH0pLFxuICAgICAgICBpbnNlcnRDb250ZW50ID0gX2dlbmVyYXRvclRleHQuaW5zZXJ0Q29udGVudCxcbiAgICAgICAgbmV3U2VsZWN0ZWQgPSBfZ2VuZXJhdG9yVGV4dC5uZXdTZWxlY3RlZDtcblxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBpbnNlcnRDb250ZW50LFxuICAgICAgc2VsZWN0ZWQ6IG5ld1NlbGVjdGVkXG4gICAgfTtcbiAgfSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJuYW1lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJzXCJdOyB9KTtcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uIChlZGl0b3IsIGlzRW5hYmxlKSB7XG4gIGVkaXRvci50b2dnbGVTeW5jU2Nyb2xsKGlzRW5hYmxlKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm5hbWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInRcIl07IH0pO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKGVkaXRvcikge1xuICBlZGl0b3IuaW5zZXJ0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGVudCA9ICd8Y29sdW1uMXxjb2x1bW4yfGNvbHVtbjN8XFxufC18LXwtfFxcbnxjb250ZW50MXxjb250ZW50Mnxjb250ZW50M3wnO1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgc2VsZWN0ZWQ6ICdjb2x1bW4xJ1xuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1widVwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgZWRpdG9yLmluc2VydChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBlZGl0b3IubGFuZ0NvbmZpZy51bC5wbGFjZWhvbGRlcjtcblxuICAgIHZhciBzZWxlY3RlZEdldHRlciA9IGZ1bmN0aW9uIHNlbGVjdGVkR2V0dGVyKHNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQgfHwgcGxhY2Vob2xkZXI7XG4gICAgfTtcblxuICAgIHZhciBfZ2VuZXJhdG9yVGV4dCA9IE9iamVjdChfdXRpbHNfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGdlbmVyYXRvclRleHQgKi8gXCJiXCJdKSh7XG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBJbnNlcnRHZXR0ZXI6IGZ1bmN0aW9uIEluc2VydEdldHRlcihzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gXCItIFwiICsgc2VsZWN0ZWRHZXR0ZXIoc2VsZWN0ZWQpO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkR2V0dGVyOiBzZWxlY3RlZEdldHRlcixcbiAgICAgIGlnbm9yZUVtcHR5TGluZTogZmFsc2VcbiAgICB9KSxcbiAgICAgICAgaW5zZXJ0Q29udGVudCA9IF9nZW5lcmF0b3JUZXh0Lmluc2VydENvbnRlbnQsXG4gICAgICAgIG5ld1NlbGVjdGVkID0gX2dlbmVyYXRvclRleHQubmV3U2VsZWN0ZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogaW5zZXJ0Q29udGVudCxcbiAgICAgIHNlbGVjdGVkOiBuZXdTZWxlY3RlZFxuICAgIH07XG4gIH0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmFtZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1widlwiXTsgfSk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZWRpdG9yKSB7XG4gIGVkaXRvci51bmRvKCk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbWFwID0ge1xuXHRcIi4vYm9sZC5qc1wiOiA2Mixcblx0XCIuL2NsZWFyLmpzXCI6IDYzLFxuXHRcIi4vY29kZS5qc1wiOiA2NCxcblx0XCIuL2Z1bGxzY3JlZW4uanNcIjogNjUsXG5cdFwiLi9oLmpzXCI6IDY2LFxuXHRcIi4vaHIuanNcIjogNjcsXG5cdFwiLi9pbWFnZS5qc1wiOiAyMyxcblx0XCIuL2l0YWxpYy5qc1wiOiA2OCxcblx0XCIuL2xpbmsuanNcIjogNjksXG5cdFwiLi9vbC5qc1wiOiA3MCxcblx0XCIuL3ByZXZpZXcuanNcIjogNzEsXG5cdFwiLi9xdW90ZS5qc1wiOiA3Mixcblx0XCIuL3JlZG8uanNcIjogNzMsXG5cdFwiLi9zYXZlLmpzXCI6IDc0LFxuXHRcIi4vc3RyaWtldGhyb3VnaC5qc1wiOiA3NSxcblx0XCIuL3N5bmMtc2Nyb2xsLmpzXCI6IDc2LFxuXHRcIi4vdGFibGUuanNcIjogNzcsXG5cdFwiLi90b2MuanNcIjogNzgsXG5cdFwiLi91bC5qc1wiOiA3OSxcblx0XCIuL3VuZG8uanNcIjogODBcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSA2MTtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBib2xkICovIFwiYVwiXSxcbiAgaWNvbjogJ3YtbWQtaWNvbi1ib2xkJyxcbiAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5ib2xkLnRvb2xiYXIgKyBcIlxcdUZGMDhDdHJsK0JcXHVGRjA5XCI7XG4gIH0sXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBib2xkICovIFwiYVwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6IF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGNsZWFyICovIFwiYlwiXSxcbiAgaWNvbjogJ3YtbWQtaWNvbi1jbGVhcicsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhbmdDb25maWcuY2xlYXIudG9vbGJhcjtcbiAgfSxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGNsZWFyICovIFwiYlwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6IF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGNvZGUgKi8gXCJjXCJdLFxuICBpY29uOiAndi1tZC1pY29uLWNvZGUnLFxuICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sYW5nQ29uZmlnLmNvZGUudG9vbGJhcjtcbiAgfSxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGNvZGUgKi8gXCJjXCJdKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbmFtZTogX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZnVsbHNjcmVlbiAqLyBcImRcIl0sXG4gIGljb246ICd2LW1kLWljb24tZnVsbHNjcmVlbicsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICB2YXIgZnVsbHNjcmVlbkxhbmcgPSBlZGl0b3IubGFuZ0NvbmZpZy5mdWxsc2NyZWVuO1xuICAgIHJldHVybiBlZGl0b3IuZnVsbHNjcmVlbiA/IGZ1bGxzY3JlZW5MYW5nLmRpc2FibGVkIDogZnVsbHNjcmVlbkxhbmcuZW5hYmxlZDtcbiAgfSxcbiAgYWN0aXZlOiBmdW5jdGlvbiBhY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5mdWxsc2NyZWVuO1xuICB9LFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZnVsbHNjcmVlbiAqLyBcImRcIl0sICFlZGl0b3IuZnVsbHNjcmVlbik7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6ICdoJyxcbiAgdGV4dDogJ0gnLFxuICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sYW5nQ29uZmlnLmgudG9vbGJhciArIFwiXFx1RkYwOEN0cmwrMX42XFx1RkYwOVwiO1xuICB9LFxuICBtZW51czogW3tcbiAgICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBoMSAqLyBcImVcIl0sXG4gICAgdGV4dDogZnVuY3Rpb24gdGV4dChlZGl0b3IpIHtcbiAgICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5oMS50b29sYmFyO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaDEgKi8gXCJlXCJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBoMiAqLyBcImZcIl0sXG4gICAgdGV4dDogZnVuY3Rpb24gdGV4dChlZGl0b3IpIHtcbiAgICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5oMi50b29sYmFyO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaDIgKi8gXCJmXCJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBoMyAqLyBcImdcIl0sXG4gICAgdGV4dDogZnVuY3Rpb24gdGV4dChlZGl0b3IpIHtcbiAgICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5oMy50b29sYmFyO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaDMgKi8gXCJnXCJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBoNCAqLyBcImhcIl0sXG4gICAgdGV4dDogZnVuY3Rpb24gdGV4dChlZGl0b3IpIHtcbiAgICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5oNC50b29sYmFyO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaDQgKi8gXCJoXCJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBoNSAqLyBcImlcIl0sXG4gICAgdGV4dDogZnVuY3Rpb24gdGV4dChlZGl0b3IpIHtcbiAgICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5oNS50b29sYmFyO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaDUgKi8gXCJpXCJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBoNiAqLyBcImpcIl0sXG4gICAgdGV4dDogZnVuY3Rpb24gdGV4dChlZGl0b3IpIHtcbiAgICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5oNi50b29sYmFyO1xuICAgIH0sXG4gICAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaDYgKi8gXCJqXCJdKTtcbiAgICB9XG4gIH1dXG59KTtcblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBociAqLyBcImtcIl0sXG4gIGljb246ICd2LW1kLWljb24taG9yaXpvbnRhbCcsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhbmdDb25maWcuaHIudG9vbGJhcjtcbiAgfSxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGhyICovIFwia1wiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6IF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGl0YWxpYyAqLyBcIm1cIl0sXG4gIGljb246ICd2LW1kLWljb24taXRhbGljJyxcbiAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5pdGFsaWMudG9vbGJhciArIFwiXFx1RkYwOEN0cmwrSVxcdUZGMDlcIjtcbiAgfSxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGl0YWxpYyAqLyBcIm1cIl0pO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBsaW5rICovIFwiblwiXSxcbiAgaWNvbjogJ3YtbWQtaWNvbi1saW5rJyxcbiAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5saW5rLnRvb2xiYXIgKyBcIlxcdUZGMDhDdHJsK0xcXHVGRjA5XCI7XG4gIH0sXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBsaW5rICovIFwiblwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDcwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6IF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIG9sICovIFwib1wiXSxcbiAgaWNvbjogJ3YtbWQtaWNvbi1vbCcsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhbmdDb25maWcub2wudG9vbGJhciArIFwiXFx1RkYwOEN0cmwrT1xcdUZGMDlcIjtcbiAgfSxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIG9sICovIFwib1wiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfZWRpdG9yX21vZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBuYW1lOiAncHJldmlldycsXG4gIGljb246ICd2LW1kLWljb24tcHJldmlldycsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICB2YXIgcHJldmlld0xhbmcgPSBlZGl0b3IubGFuZ0NvbmZpZy5wcmV2aWV3O1xuICAgIHJldHVybiBlZGl0b3IuY3VycmVudE1vZGUgPT09IF91dGlsc19jb25zdGFudHNfZWRpdG9yX21vZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5FRElUQUJMRSA/IHByZXZpZXdMYW5nLmRpc2FibGVkIDogcHJldmlld0xhbmcuZW5hYmxlZDtcbiAgfSxcbiAgYWN0aXZlOiBmdW5jdGlvbiBhY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5jdXJyZW50TW9kZSA9PT0gX3V0aWxzX2NvbnN0YW50c19lZGl0b3JfbW9kZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkVESVRBQkxFO1xuICB9LFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuY3VycmVudE1vZGUgPSBlZGl0b3IuY3VycmVudE1vZGUgPT09IF91dGlsc19jb25zdGFudHNfZWRpdG9yX21vZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5FRElUQUJMRSA/IF91dGlsc19jb25zdGFudHNfZWRpdG9yX21vZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5FRElUIDogX3V0aWxzX2NvbnN0YW50c19lZGl0b3JfbW9kZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkVESVRBQkxFO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBxdW90ZSAqLyBcInBcIl0sXG4gIGljb246ICd2LW1kLWljb24tcXVvdGUnLFxuICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sYW5nQ29uZmlnLnF1b3RlLnRvb2xiYXIgKyBcIlxcdUZGMDhDdHJsK1FcXHVGRjA5XCI7XG4gIH0sXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBxdW90ZSAqLyBcInBcIl0pO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiA3MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBuYW1lOiBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiByZWRvICovIFwicVwiXSxcbiAgaWNvbjogJ3YtbWQtaWNvbi1yZWRvJyxcbiAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5yZWRvLnRvb2xiYXIgKyBcIlxcdUZGMDhDdHJsK1lcXHVGRjA5XCI7XG4gIH0sXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiByZWRvICovIFwicVwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6ICdzYXZlJyxcbiAgaWNvbjogJ3YtbWQtaWNvbi1zYXZlJyxcbiAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy5zYXZlLnRvb2xiYXIgKyBcIlxcdUZGMDhDdHJsK1NcXHVGRjA5XCI7XG4gIH0sXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5zYXZlKCk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6IF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIHN0cmlrZXRocm91Z2ggKi8gXCJyXCJdLFxuICBpY29uOiAndi1tZC1pY29uLXN0cmlrZXRocm91Z2gnLFxuICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sYW5nQ29uZmlnLnN0cmlrZXRocm91Z2gudG9vbGJhcjtcbiAgfSxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIHN0cmlrZXRocm91Z2ggKi8gXCJyXCJdKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbmFtZTogX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogc3luY1Njcm9sbCAqLyBcInNcIl0sXG4gIGljb246ICd2LW1kLWljb24tc3luYycsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICB2YXIgc3luY1Njcm9sbExhbmcgPSBlZGl0b3IubGFuZ0NvbmZpZy5zeW5jU2Nyb2xsO1xuICAgIHJldHVybiBlZGl0b3IuZW5hYmxlU3luY1Njcm9sbCA/IHN5bmNTY3JvbGxMYW5nLmRpc2FibGVkIDogc3luY1Njcm9sbExhbmcuZW5hYmxlZDtcbiAgfSxcbiAgYWN0aXZlOiBmdW5jdGlvbiBhY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5lbmFibGVTeW5jU2Nyb2xsO1xuICB9LFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogc3luY1Njcm9sbCAqLyBcInNcIl0sICFlZGl0b3IuZW5hYmxlU3luY1Njcm9sbCk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6IF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIHRhYmxlICovIFwidFwiXSxcbiAgaWNvbjogJ3YtbWQtaWNvbi10YWJsZScsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhbmdDb25maWcudGFibGUudG9vbGJhcjtcbiAgfSxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIHRhYmxlICovIFwidFwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG5hbWU6ICd0b2MnLFxuICBpY29uOiAndi1tZC1pY29uLXRvYycsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICB2YXIgdG9jTGFuZyA9IGVkaXRvci5sYW5nQ29uZmlnLnRvYztcbiAgICByZXR1cm4gZWRpdG9yLnRvY1Zpc2libGUgPyB0b2NMYW5nLmRpc2FibGVkIDogdG9jTGFuZy5lbmFibGVkO1xuICB9LFxuICBhY3RpdmU6IGZ1bmN0aW9uIGFjdGl2ZShlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnRvY1Zpc2libGU7XG4gIH0sXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci50b2dnbGVUb2MoKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbmFtZTogX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogdWwgKi8gXCJ1XCJdLFxuICBpY29uOiAndi1tZC1pY29uLXVsJyxcbiAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IubGFuZ0NvbmZpZy51bC50b29sYmFyICsgXCJcXHVGRjA4Q3RybCtVXFx1RkYwOVwiO1xuICB9LFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogdWwgKi8gXCJ1XCJdKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbmFtZTogX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogdW5kbyAqLyBcInZcIl0sXG4gIGljb246ICd2LW1kLWljb24tdW5kbycsXG4gIHRpdGxlOiBmdW5jdGlvbiB0aXRsZShlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhbmdDb25maWcudW5kby50b29sYmFyICsgXCJcXHVGRjA4Q3RybCtaXFx1RkYwOVwiO1xuICB9LFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogdW5kbyAqLyBcInZcIl0pO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiA4MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF90b29sdGlwX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X2luZGV4X2pzX3JlZl8yXzBfdG9vbHRpcF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF90b29sdGlwX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cblxuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9pbmRleF9qc19yZWZfMl8wX21lbnVfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF9tZW51X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9pbmRleF9qc19yZWZfMl8wX21lbnVfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogdW51c2VkIGhhcm1vbnkgcmVleHBvcnQgKiAqL1xuXG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X2luZGV4X2pzX3JlZl8yXzBfaW5kZXhfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF9pbmRleF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF9pbmRleF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG5cblxuLyoqKi8gfSksXG4vKiA4NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF90b29sYmFyX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X2luZGV4X2pzX3JlZl8yXzBfdG9vbGJhcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF90b29sYmFyX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cblxuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KSxcbi8qIDg3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9pbmRleF9qc19yZWZfMl8wX2NvbnRhaW5lcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9pbmRleF9qc19yZWZfMl8wX2NvbnRhaW5lcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF9jb250YWluZXJfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogdW51c2VkIGhhcm1vbnkgcmVleHBvcnQgKiAqL1xuXG5cbi8qKiovIH0pLFxuLyogODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X2luZGV4X2pzX3JlZl8yXzBfaW5kZXhfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF9pbmRleF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF9pbmRleF92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiB1bnVzZWQgaGFybW9ueSByZWV4cG9ydCAqICovXG5cblxuLyoqKi8gfSksXG4vKiA4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF90b2NfbmF2X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X2luZGV4X2pzX3JlZl8yXzBfdG9jX25hdl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF90b2NfbmF2X3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIHVudXNlZCBoYXJtb255IHJlZXhwb3J0ICogKi9cblxuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtYXAgPSB7XG5cdFwiLi9ib2xkLmpzXCI6IDkxLFxuXHRcIi4vaDEuanNcIjogOTIsXG5cdFwiLi9oMi5qc1wiOiA5Myxcblx0XCIuL2gzLmpzXCI6IDk0LFxuXHRcIi4vaDQuanNcIjogOTUsXG5cdFwiLi9oNS5qc1wiOiA5Nixcblx0XCIuL2g2LmpzXCI6IDk3LFxuXHRcIi4vaXRhbGljLmpzXCI6IDk4LFxuXHRcIi4vbGluay5qc1wiOiA5OSxcblx0XCIuL29sLmpzXCI6IDEwMCxcblx0XCIuL3F1b3RlLmpzXCI6IDEwMSxcblx0XCIuL3NhdmUuanNcIjogMTAyLFxuXHRcIi4vdWwuanNcIjogMTAzXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gOTA7XG5cbi8qKiovIH0pLFxuLyogOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbW9kaWZpZXI6ICdjdHJsJyxcbiAga2V5OiAnYicsXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBib2xkICovIFwiYVwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG1vZGlmaWVyOiAnY3RybCcsXG4gIGtleTogJzEnLFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaDEgKi8gXCJlXCJdKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbW9kaWZpZXI6ICdjdHJsJyxcbiAga2V5OiAnMicsXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBoMiAqLyBcImZcIl0pO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiA5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBtb2RpZmllcjogJ2N0cmwnLFxuICBrZXk6ICczJyxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGgzICovIFwiZ1wiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG1vZGlmaWVyOiAnY3RybCcsXG4gIGtleTogJzQnLFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaDQgKi8gXCJoXCJdKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogOTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbW9kaWZpZXI6ICdjdHJsJyxcbiAga2V5OiAnNScsXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBoNSAqLyBcImlcIl0pO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBtb2RpZmllcjogJ2N0cmwnLFxuICBrZXk6ICc2JyxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGg2ICovIFwialwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG1vZGlmaWVyOiAnY3RybCcsXG4gIGtleTogJ2knLFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogaXRhbGljICovIFwibVwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIG1vZGlmaWVyOiAnY3RybCcsXG4gIGtleTogJ2wnLFxuICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbihlZGl0b3IpIHtcbiAgICBlZGl0b3IuZXhlY0NvbW1hbmQoX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogbGluayAqLyBcIm5cIl0pO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbW9kaWZpZXI6ICdjdHJsJyxcbiAga2V5OiAnbycsXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBvbCAqLyBcIm9cIl0pO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2NvbnN0YW50c19jb21tYW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbW9kaWZpZXI6ICdjdHJsJyxcbiAga2V5OiAncScsXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5leGVjQ29tbWFuZChfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBxdW90ZSAqLyBcInBcIl0pO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgbW9kaWZpZXI6ICdjdHJsJyxcbiAga2V5OiAncycsXG4gIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5zYXZlKCk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfY29uc3RhbnRzX2NvbW1hbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBtb2RpZmllcjogJ2N0cmwnLFxuICBrZXk6ICd1JyxcbiAgYWN0aW9uOiBmdW5jdGlvbiBhY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmV4ZWNDb21tYW5kKF91dGlsc19jb25zdGFudHNfY29tbWFuZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIHVsICovIFwidVwiXSk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxMDUgKi8sXG4vKiAxMDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19taW5pX2Nzc19leHRyYWN0X3BsdWdpbl9kaXN0X2xvYWRlcl9qc19ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X3N0eWxlUG9zdExvYWRlcl9qc19ub2RlX21vZHVsZXNfcG9zdGNzc19sb2FkZXJfc3JjX2luZGV4X2pzX25vZGVfbW9kdWxlc19zYXNzX2xvYWRlcl9kaXN0X2Nqc19qc19ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9kaXN0X2luZGV4X2pzX3JlZl8yXzBfdGV4dGFyZWFfZWRpdG9yX3Z1ZV92dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2Nzc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfbWluaV9jc3NfZXh0cmFjdF9wbHVnaW5fZGlzdF9sb2FkZXJfanNfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9zdHlsZVBvc3RMb2FkZXJfanNfbm9kZV9tb2R1bGVzX3Bvc3Rjc3NfbG9hZGVyX3NyY19pbmRleF9qc19ub2RlX21vZHVsZXNfc2Fzc19sb2FkZXJfZGlzdF9janNfanNfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfZGlzdF9pbmRleF9qc19yZWZfMl8wX3RleHRhcmVhX2VkaXRvcl92dWVfdnVlX3R5cGVfc3R5bGVfaW5kZXhfMF9sYW5nX3Njc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX21pbmlfY3NzX2V4dHJhY3RfcGx1Z2luX2Rpc3RfbG9hZGVyX2pzX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3Rfc3R5bGVQb3N0TG9hZGVyX2pzX25vZGVfbW9kdWxlc19wb3N0Y3NzX2xvYWRlcl9zcmNfaW5kZXhfanNfbm9kZV9tb2R1bGVzX3Nhc3NfbG9hZGVyX2Rpc3RfY2pzX2pzX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2Rpc3RfaW5kZXhfanNfcmVmXzJfMF90ZXh0YXJlYV9lZGl0b3JfdnVlX3Z1ZV90eXBlX3N0eWxlX2luZGV4XzBfbGFuZ19zY3NzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogdW51c2VkIGhhcm1vbnkgcmVleHBvcnQgKiAqL1xuXG5cbi8qKiovIH0pLFxuLyogMTA3ICovLFxuLyogMTA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wicm9vdFwiOlwiVnVlXCIsXCJjb21tb25qc1wiOlwidnVlXCIsXCJjb21tb25qczJcIjpcInZ1ZVwiLFwiYW1kXCI6XCJ2dWVcIn1cbnZhciBleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3JlZi0tNiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Q/P3JlZi0tMi0wIS4vc3JjL2Jhc2UtZWRpdG9yLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1hNmFjMWM4NCZiaW5kaW5ncz17fVxuXG5mdW5jdGlvbiByZW5kZXIoX2N0eCwgX2NhY2hlLCAkcHJvcHMsICRzZXR1cCwgJGRhdGEsICRvcHRpb25zKSB7XG4gIHZhciBfY29tcG9uZW50X3RvY19uYXYgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZXNvbHZlQ29tcG9uZW50XCJdKShcInRvYy1uYXZcIik7XG5cbiAgdmFyIF9jb21wb25lbnRfc2Nyb2xsYmFyID0gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVzb2x2ZUNvbXBvbmVudFwiXSkoXCJzY3JvbGxiYXJcIik7XG5cbiAgdmFyIF9jb21wb25lbnRfdl9tZF90ZXh0YXJlYV9lZGl0b3IgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZXNvbHZlQ29tcG9uZW50XCJdKShcInYtbWQtdGV4dGFyZWEtZWRpdG9yXCIpO1xuXG4gIHZhciBfY29tcG9uZW50X3ZfbWRfcHJldmlldyA9IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcInJlc29sdmVDb21wb25lbnRcIl0pKFwidi1tZC1wcmV2aWV3XCIpO1xuXG4gIHZhciBfY29tcG9uZW50X3ZfbWRfdXBsb2FkX2ZpbGUgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZXNvbHZlQ29tcG9uZW50XCJdKShcInYtbWQtdXBsb2FkLWZpbGVcIik7XG5cbiAgdmFyIF9jb21wb25lbnRfdl9tZF9jb250YWluZXIgPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJyZXNvbHZlQ29tcG9uZW50XCJdKShcInYtbWQtY29udGFpbmVyXCIpO1xuXG4gIHJldHVybiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKCksIE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZUJsb2NrXCJdKShfY29tcG9uZW50X3ZfbWRfY29udGFpbmVyLCB7XG4gICAgXCJsZWZ0LXRvb2xiYXJcIjogX2N0eC5sZWZ0VG9vbGJhcixcbiAgICBcInJpZ2h0LXRvb2xiYXJcIjogX2N0eC5yaWdodFRvb2xiYXIsXG4gICAgdG9vbGJhcnM6IF9jdHgudG9vbGJhcnMsXG4gICAgXCJkaXNhYmxlZC1tZW51c1wiOiBfY3R4LmRpc2FibGVkTWVudXMsXG4gICAgaGVpZ2h0OiBfY3R4LmhlaWdodCxcbiAgICBmdWxsc2NyZWVuOiBfY3R4LmZ1bGxzY3JlZW4sXG4gICAgXCJsZWZ0LWFyZWEtdmlzaWJsZVwiOiBfY3R4LnRvY1Zpc2libGUsXG4gICAgXCJsZWZ0LWFyZWEtdGl0bGVcIjogX2N0eC5sYW5nQ29uZmlnLnRvYy50aXRsZSxcbiAgICBcImxlZnQtYXJlYS1yZXZlcnNlXCI6IF9jdHgudG9jTmF2UG9zaXRpb25SaWdodCxcbiAgICBtb2RlOiBfY3R4LmN1cnJlbnRNb2RlLFxuICAgIG9uRWRpdG9yV3JhcHBlckNsaWNrOiBfY3R4LmhhbmRsZUVkaXRvcldyYXBwZXJDbGljayxcbiAgICBvblRvb2xiYXJJdGVtQ2xpY2s6IF9jdHguaGFuZGxlVG9vbGJhckl0ZW1DbGljayxcbiAgICBvblRvb2xiYXJNZW51Q2xpY2s6IF9jdHguaGFuZGxlVG9vbGJhck1lbnVDbGljayxcbiAgICByZWY6IFwiY29udGFuZXJcIlxuICB9LCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVTbG90c1wiXSkoe1xuICAgIFwibGVmdC1hcmVhXCI6IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhDdHhcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKF9jb21wb25lbnRfc2Nyb2xsYmFyLCBudWxsLCB7XG4gICAgICAgIGRlZmF1bHQ6IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhDdHhcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShfY29tcG9uZW50X3RvY19uYXYsIHtcbiAgICAgICAgICAgIHRpdGxlczogX2N0eC50aXRsZXMsXG4gICAgICAgICAgICBvbk5hdkNsaWNrOiBfY3R4LmhhbmRsZU5hdkNsaWNrXG4gICAgICAgICAgfSwgbnVsbCwgOFxuICAgICAgICAgIC8qIFBST1BTICovXG4gICAgICAgICAgLCBbXCJ0aXRsZXNcIiwgXCJvbk5hdkNsaWNrXCJdKV07XG4gICAgICAgIH0pLFxuICAgICAgICBfOiAxXG4gICAgICB9KV07XG4gICAgfSksXG4gICAgZWRpdG9yOiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoQ3R4XCJdKShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShfY29tcG9uZW50X3Njcm9sbGJhciwge1xuICAgICAgICBvblNjcm9sbDogX2N0eC5oYW5kbGVFZGl0b3JTY3JvbGwsXG4gICAgICAgIHJlZjogXCJlZGl0b3JTY3JvbGxlclwiXG4gICAgICB9LCB7XG4gICAgICAgIGRlZmF1bHQ6IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhDdHhcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShfY29tcG9uZW50X3ZfbWRfdGV4dGFyZWFfZWRpdG9yLCB7XG4gICAgICAgICAgICBcIm1vZGVsLXZhbHVlXCI6IF9jdHgudGV4dCxcbiAgICAgICAgICAgIFwibWluLWhlaWdodFwiOiBfY3R4LnRleHRFZGl0b3JNaW5IZWlnaHQsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogX2N0eC5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiBfY3R4LmhhbmRsZUlucHV0LFxuICAgICAgICAgICAgb25DbGljazogX2NhY2hlWzFdIHx8IChfY2FjaGVbMV0gPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoTW9kaWZpZXJzXCJdKShmdW5jdGlvbiAoKSB7fSwgW1wic3RvcFwiXSkpLFxuICAgICAgICAgICAgb25Ecm9wOiBfY3R4LmhhbmRsZURyb3AsXG4gICAgICAgICAgICBvblBhc3RlOiBfY3R4LmhhbmRsZVBhc3RlLFxuICAgICAgICAgICAgb25CbHVyOiBfY3R4LmhhbmRsZUJsdXIsXG4gICAgICAgICAgICByZWY6IFwiZWRpdG9yRWdpbmVcIlxuICAgICAgICAgIH0sIG51bGwsIDhcbiAgICAgICAgICAvKiBQUk9QUyAqL1xuICAgICAgICAgICwgW1wibW9kZWwtdmFsdWVcIiwgXCJtaW4taGVpZ2h0XCIsIFwicGxhY2Vob2xkZXJcIiwgXCJvblVwZGF0ZTptb2RlbFZhbHVlXCIsIFwib25Ecm9wXCIsIFwib25QYXN0ZVwiLCBcIm9uQmx1clwiXSldO1xuICAgICAgICB9KSxcbiAgICAgICAgXzogMVxuICAgICAgfSwgOFxuICAgICAgLyogUFJPUFMgKi9cbiAgICAgICwgW1wib25TY3JvbGxcIl0pXTtcbiAgICB9KSxcbiAgICBwcmV2aWV3OiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoQ3R4XCJdKShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShfY29tcG9uZW50X3Njcm9sbGJhciwge1xuICAgICAgICByZWY6IFwicHJldmlld1Njcm9sbGVyXCJcbiAgICAgIH0sIHtcbiAgICAgICAgZGVmYXVsdDogT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aEN0eFwiXSkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKF9jb21wb25lbnRfdl9tZF9wcmV2aWV3LCB7XG4gICAgICAgICAgICB0ZXh0OiBfY3R4LnRleHQsXG4gICAgICAgICAgICBcInRhYi1zaXplXCI6IF9jdHgudGFiU2l6ZSxcbiAgICAgICAgICAgIFwic2Nyb2xsLWNvbnRhaW5lclwiOiBfY3R4LmdldFByZXZpZXdTY3JvbGxDb250YWluZXIsXG4gICAgICAgICAgICBcImJlZm9yZS1jaGFuZ2VcIjogX2N0eC5iZWZvcmVQcmV2aWV3Q2hhbmdlLFxuICAgICAgICAgICAgb25DaGFuZ2U6IF9jdHguaGFuZGxlQ2hhbmdlLFxuICAgICAgICAgICAgb25JbWFnZUNsaWNrOiBfY3R4LmhhbmRsZVByZXZpZXdJbWFnZUNsaWNrLFxuICAgICAgICAgICAgcmVmOiBcInByZXZpZXdcIlxuICAgICAgICAgIH0sIG51bGwsIDhcbiAgICAgICAgICAvKiBQUk9QUyAqL1xuICAgICAgICAgICwgW1widGV4dFwiLCBcInRhYi1zaXplXCIsIFwic2Nyb2xsLWNvbnRhaW5lclwiLCBcImJlZm9yZS1jaGFuZ2VcIiwgXCJvbkNoYW5nZVwiLCBcIm9uSW1hZ2VDbGlja1wiXSldO1xuICAgICAgICB9KSxcbiAgICAgICAgXzogMVxuICAgICAgfSwgNTEyXG4gICAgICAvKiBORUVEX1BBVENIICovXG4gICAgICApXTtcbiAgICB9KSxcbiAgICBkZWZhdWx0OiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoQ3R4XCJdKShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW19jdHguaGFzVXBsb2FkSW1hZ2UgPyAoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoX2NvbXBvbmVudF92X21kX3VwbG9hZF9maWxlLCB7XG4gICAgICAgIGtleTogMCxcbiAgICAgICAgXCJ1cGxvYWQtY29uZmlnXCI6IF9jdHgudXBsb2FkQ29uZmlnLFxuICAgICAgICByZWY6IFwidXBsb2FkRmlsZVwiXG4gICAgICB9LCBudWxsLCA4XG4gICAgICAvKiBQUk9QUyAqL1xuICAgICAgLCBbXCJ1cGxvYWQtY29uZmlnXCJdKSkgOiBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVDb21tZW50Vk5vZGVcIl0pKFwidi1pZlwiLCB0cnVlKV07XG4gICAgfSksXG4gICAgXzogMlxuICB9LCBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyTGlzdFwiXSkoX2N0eC5wcm94eVNsb3RzLCBmdW5jdGlvbiAoc2xvdE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogc2xvdE5hbWUsXG4gICAgICBmbjogT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aEN0eFwiXSkoZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyU2xvdFwiXSkoX2N0eC4kc2xvdHMsIHNsb3ROYW1lLCBzY29wZSldO1xuICAgICAgfSlcbiAgICB9O1xuICB9KV0pLCAxMDMyXG4gIC8qIFBST1BTLCBEWU5BTUlDX1NMT1RTICovXG4gICwgW1wibGVmdC10b29sYmFyXCIsIFwicmlnaHQtdG9vbGJhclwiLCBcInRvb2xiYXJzXCIsIFwiZGlzYWJsZWQtbWVudXNcIiwgXCJoZWlnaHRcIiwgXCJmdWxsc2NyZWVuXCIsIFwibGVmdC1hcmVhLXZpc2libGVcIiwgXCJsZWZ0LWFyZWEtdGl0bGVcIiwgXCJsZWZ0LWFyZWEtcmV2ZXJzZVwiLCBcIm1vZGVcIiwgXCJvbkVkaXRvcldyYXBwZXJDbGlja1wiLCBcIm9uVG9vbGJhckl0ZW1DbGlja1wiLCBcIm9uVG9vbGJhck1lbnVDbGlja1wiXSk7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9iYXNlLWVkaXRvci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YTZhYzFjODQmYmluZGluZ3M9e31cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xudmFyIHJlZ2VuZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgcmVnZW5lcmF0b3JfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3IpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanNcbnZhciBhc3luY1RvR2VuZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3JlZi0tNiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Q/P3JlZi0tMi0wIS4vc3JjL2NvbXBvbmVudHMvdGV4dGFyZWEtZWRpdG9yLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zMWZlZDFlYSZiaW5kaW5ncz17XCJtb2RlbFZhbHVlXCI6XCJwcm9wc1wiLFwibWluSGVpZ2h0XCI6XCJwcm9wc1wiLFwicGxhY2Vob2xkZXJcIjpcInByb3BzXCIsXCJoaXN0b3J5RGVib3VuY2VcIjpcInByb3BzXCIsXCJoaXN0b3J5TWF4XCI6XCJwcm9wc1wiLFwiaXNDb21wb3NpbmdcIjpcImRhdGFcIixcInRleHRhcmVhRWxcIjpcIm9wdGlvbnNcIixcImhhbmRsZUNvbXBvc2l0aW9uU3RhcnRcIjpcIm9wdGlvbnNcIixcImhhbmRsZUNvbXBvc2l0aW9uVXBkYXRlXCI6XCJvcHRpb25zXCIsXCJoYW5kbGVDb21wb3NpdGlvbkVuZFwiOlwib3B0aW9uc1wiLFwiaGFuZGxlUGFzdGVcIjpcIm9wdGlvbnNcIixcImhhbmRsZUJsdXJcIjpcIm9wdGlvbnNcIixcInJlZ2lzdGVySG90a2V5c1wiOlwib3B0aW9uc1wiLFwiaGFuZGxlS2V5ZG93blwiOlwib3B0aW9uc1wiLFwiaGVpZ2h0QXRMaW5lXCI6XCJvcHRpb25zXCIsXCJjbGVhclRpbWVvdXRcIjpcIm9wdGlvbnNcIixcInVwZGF0ZUN1cnJlbnRIaXN0b3J5UmFuZ2VcIjpcIm9wdGlvbnNcIixcImhhbmRsZUlucHV0XCI6XCJvcHRpb25zXCIsXCJzYXZlSGlzdG9yeVwiOlwib3B0aW9uc1wiLFwidXBkYXRlSGlzdG9yeVwiOlwib3B0aW9uc1wiLFwiZ29IaXN0b3J5XCI6XCJvcHRpb25zXCIsXCJnZXRSYW5nZVwiOlwib3B0aW9uc1wiLFwic2V0UmFuZ2VcIjpcIm9wdGlvbnNcIixcImZvY3VzXCI6XCJvcHRpb25zXCIsXCJpbnNlcnRUZXh0XCI6XCJvcHRpb25zXCIsXCJ1bmRvXCI6XCJvcHRpb25zXCIsXCJyZWRvXCI6XCJvcHRpb25zXCJ9XG5cbnZhciBfaG9pc3RlZF8xID0ge1xuICBjbGFzczogXCJ2LW1kLXRleHRhcmVhLWVkaXRvclwiXG59O1xuXG52YXIgX2hvaXN0ZWRfMiA9IC8qI19fUFVSRV9fKi9PYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVWTm9kZVwiXSkoXCJiclwiLCBudWxsLCBudWxsLCAtMVxuLyogSE9JU1RFRCAqL1xuKTtcblxuZnVuY3Rpb24gdGV4dGFyZWFfZWRpdG9ydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzFmZWQxZWFfYmluZGluZ3NfbW9kZWxWYWx1ZV9wcm9wc19taW5IZWlnaHRfcHJvcHNfcGxhY2Vob2xkZXJfcHJvcHNfaGlzdG9yeURlYm91bmNlX3Byb3BzX2hpc3RvcnlNYXhfcHJvcHNfaXNDb21wb3NpbmdfZGF0YV90ZXh0YXJlYUVsX29wdGlvbnNfaGFuZGxlQ29tcG9zaXRpb25TdGFydF9vcHRpb25zX2hhbmRsZUNvbXBvc2l0aW9uVXBkYXRlX29wdGlvbnNfaGFuZGxlQ29tcG9zaXRpb25FbmRfb3B0aW9uc19oYW5kbGVQYXN0ZV9vcHRpb25zX2hhbmRsZUJsdXJfb3B0aW9uc19yZWdpc3RlckhvdGtleXNfb3B0aW9uc19oYW5kbGVLZXlkb3duX29wdGlvbnNfaGVpZ2h0QXRMaW5lX29wdGlvbnNfY2xlYXJUaW1lb3V0X29wdGlvbnNfdXBkYXRlQ3VycmVudEhpc3RvcnlSYW5nZV9vcHRpb25zX2hhbmRsZUlucHV0X29wdGlvbnNfc2F2ZUhpc3Rvcnlfb3B0aW9uc191cGRhdGVIaXN0b3J5X29wdGlvbnNfZ29IaXN0b3J5X29wdGlvbnNfZ2V0UmFuZ2Vfb3B0aW9uc19zZXRSYW5nZV9vcHRpb25zX2ZvY3VzX29wdGlvbnNfaW5zZXJ0VGV4dF9vcHRpb25zX3VuZG9fb3B0aW9uc19yZWRvX29wdGlvbnNfcmVuZGVyKF9jdHgsIF9jYWNoZSwgJHByb3BzLCAkc2V0dXAsICRkYXRhLCAkb3B0aW9ucykge1xuICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoXCJkaXZcIiwgX2hvaXN0ZWRfMSwgW09iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcImNyZWF0ZVZOb2RlXCJdKShcInByZVwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIG1pbkhlaWdodDogJHByb3BzLm1pbkhlaWdodFxuICAgIH1cbiAgfSwgWyhPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJvcGVuQmxvY2tcIl0pKHRydWUpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJGcmFnbWVudFwiXSwgbnVsbCwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wicmVuZGVyTGlzdFwiXSkoJHByb3BzLm1vZGVsVmFsdWUuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiAocm93LCBpZHgpIHtcbiAgICByZXR1cm4gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wib3BlbkJsb2NrXCJdKSgpLCBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJjcmVhdGVCbG9ja1wiXSkoXCJzZWN0aW9uXCIsIHtcbiAgICAgIFwiZGF0YS1saW5lXCI6IGlkeCArIDFcbiAgICB9LCBbT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVGV4dFZOb2RlXCJdKShPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ0b0Rpc3BsYXlTdHJpbmdcIl0pKHJvdyB8fCAnICcpLCAxXG4gICAgLyogVEVYVCAqL1xuICAgICksIF9ob2lzdGVkXzJdLCA4XG4gICAgLyogUFJPUFMgKi9cbiAgICAsIFtcImRhdGEtbGluZVwiXSk7XG4gIH0pLCAyNTZcbiAgLyogVU5LRVlFRF9GUkFHTUVOVCAqL1xuICApKV0sIDRcbiAgLyogU1RZTEUgKi9cbiAgKSwgT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wiY3JlYXRlVk5vZGVcIl0pKFwidGV4dGFyZWFcIiwge1xuICAgIHJlZjogXCJ0ZXh0YXJlYVwiLFxuICAgIHZhbHVlOiAkcHJvcHMubW9kZWxWYWx1ZSxcbiAgICBwbGFjZWhvbGRlcjogJHByb3BzLnBsYWNlaG9sZGVyLFxuICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICBvbkNvbXBvc2l0aW9uc3RhcnQ6IF9jYWNoZVsxXSB8fCAoX2NhY2hlWzFdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICRvcHRpb25zLmhhbmRsZUNvbXBvc2l0aW9uU3RhcnQuYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSksXG4gICAgb25Db21wb3NpdGlvbnVwZGF0ZTogX2NhY2hlWzJdIHx8IChfY2FjaGVbMl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJG9wdGlvbnMuaGFuZGxlQ29tcG9zaXRpb25VcGRhdGUuYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSksXG4gICAgb25Db21wb3NpdGlvbmVuZDogX2NhY2hlWzNdIHx8IChfY2FjaGVbM10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJG9wdGlvbnMuaGFuZGxlQ29tcG9zaXRpb25FbmQuYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSksXG4gICAgb25JbnB1dDogX2NhY2hlWzRdIHx8IChfY2FjaGVbNF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJG9wdGlvbnMuaGFuZGxlSW5wdXQuYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSksXG4gICAgb25DbGljazogX2NhY2hlWzVdIHx8IChfY2FjaGVbNV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJG9wdGlvbnMudXBkYXRlQ3VycmVudEhpc3RvcnlSYW5nZS5hcHBseSgkb3B0aW9ucywgYXJndW1lbnRzKTtcbiAgICB9KSxcbiAgICBvblBhc3RlOiBfY2FjaGVbNl0gfHwgKF9jYWNoZVs2XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAkb3B0aW9ucy5oYW5kbGVQYXN0ZS5hcHBseSgkb3B0aW9ucywgYXJndW1lbnRzKTtcbiAgICB9KSxcbiAgICBvbkJsdXI6IF9jYWNoZVs3XSB8fCAoX2NhY2hlWzddID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICRvcHRpb25zLmhhbmRsZUJsdXIuYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSksXG4gICAgb25LZXlkb3duOiBbX2NhY2hlWzhdIHx8IChfY2FjaGVbOF0gPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoS2V5c1wiXSkoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aE1vZGlmaWVyc1wiXSkoZnVuY3Rpb24gKCkge30sIFtcInByZXZlbnRcIl0pLCBbXCJ0YWJcIl0pKSwgX2NhY2hlWzldIHx8IChfY2FjaGVbOV0gPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoS2V5c1wiXSkoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aE1vZGlmaWVyc1wiXSkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICRvcHRpb25zLnVuZG8uYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSwgW1wiY3RybFwiLCBcInByZXZlbnRcIiwgXCJleGFjdFwiXSksIFtcInpcIl0pKSwgX2NhY2hlWzEwXSB8fCAoX2NhY2hlWzEwXSA9IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhLZXlzXCJdKShPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoTW9kaWZpZXJzXCJdKShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJG9wdGlvbnMudW5kby5hcHBseSgkb3B0aW9ucywgYXJndW1lbnRzKTtcbiAgICB9LCBbXCJtZXRhXCIsIFwicHJldmVudFwiLCBcImV4YWN0XCJdKSwgW1wielwiXSkpLCBfY2FjaGVbMTFdIHx8IChfY2FjaGVbMTFdID0gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aEtleXNcIl0pKE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhNb2RpZmllcnNcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAkb3B0aW9ucy5yZWRvLmFwcGx5KCRvcHRpb25zLCBhcmd1bWVudHMpO1xuICAgIH0sIFtcImN0cmxcIiwgXCJwcmV2ZW50XCIsIFwiZXhhY3RcIl0pLCBbXCJ5XCJdKSksIF9jYWNoZVsxMl0gfHwgKF9jYWNoZVsxMl0gPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoS2V5c1wiXSkoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aE1vZGlmaWVyc1wiXSkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICRvcHRpb25zLnJlZG8uYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSwgW1wibWV0YVwiLCBcInByZXZlbnRcIiwgXCJleGFjdFwiXSksIFtcInlcIl0pKV0sXG4gICAgb25LZXl1cDogW19jYWNoZVsxM10gfHwgKF9jYWNoZVsxM10gPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoS2V5c1wiXSkoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aE1vZGlmaWVyc1wiXSkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICRvcHRpb25zLnVwZGF0ZUN1cnJlbnRIaXN0b3J5UmFuZ2UuYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSwgW1wic2hpZnRcIiwgXCJleGFjdFwiXSksIFtcInVwXCJdKSksIF9jYWNoZVsxNF0gfHwgKF9jYWNoZVsxNF0gPSBPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoS2V5c1wiXSkoT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aE1vZGlmaWVyc1wiXSkoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICRvcHRpb25zLnVwZGF0ZUN1cnJlbnRIaXN0b3J5UmFuZ2UuYXBwbHkoJG9wdGlvbnMsIGFyZ3VtZW50cyk7XG4gICAgfSwgW1wic2hpZnRcIiwgXCJleGFjdFwiXSksIFtcImRvd25cIl0pKSwgX2NhY2hlWzE1XSB8fCAoX2NhY2hlWzE1XSA9IE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhLZXlzXCJdKShPYmplY3QoZXh0ZXJuYWxfcm9vdF9WdWVfY29tbW9uanNfdnVlX2NvbW1vbmpzMl92dWVfYW1kX3Z1ZV9bXCJ3aXRoTW9kaWZpZXJzXCJdKShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJG9wdGlvbnMudXBkYXRlQ3VycmVudEhpc3RvcnlSYW5nZS5hcHBseSgkb3B0aW9ucywgYXJndW1lbnRzKTtcbiAgICB9LCBbXCJzaGlmdFwiLCBcImV4YWN0XCJdKSwgW1wibGVmdFwiXSkpLCBfY2FjaGVbMTZdIHx8IChfY2FjaGVbMTZdID0gT2JqZWN0KGV4dGVybmFsX3Jvb3RfVnVlX2NvbW1vbmpzX3Z1ZV9jb21tb25qczJfdnVlX2FtZF92dWVfW1wid2l0aEtleXNcIl0pKE9iamVjdChleHRlcm5hbF9yb290X1Z1ZV9jb21tb25qc192dWVfY29tbW9uanMyX3Z1ZV9hbWRfdnVlX1tcIndpdGhNb2RpZmllcnNcIl0pKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAkb3B0aW9ucy51cGRhdGVDdXJyZW50SGlzdG9yeVJhbmdlLmFwcGx5KCRvcHRpb25zLCBhcmd1bWVudHMpO1xuICAgIH0sIFtcInNoaWZ0XCIsIFwiZXhhY3RcIl0pLCBbXCJyaWdodFwiXSkpXVxuICB9LCBudWxsLCA0MFxuICAvKiBQUk9QUywgSFlEUkFURV9FVkVOVFMgKi9cbiAgLCBbXCJ2YWx1ZVwiLCBcInBsYWNlaG9sZGVyXCJdKV0pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90ZXh0YXJlYS1lZGl0b3IudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTMxZmVkMWVhJmJpbmRpbmdzPXtcIm1vZGVsVmFsdWVcIjpcInByb3BzXCIsXCJtaW5IZWlnaHRcIjpcInByb3BzXCIsXCJwbGFjZWhvbGRlclwiOlwicHJvcHNcIixcImhpc3RvcnlEZWJvdW5jZVwiOlwicHJvcHNcIixcImhpc3RvcnlNYXhcIjpcInByb3BzXCIsXCJpc0NvbXBvc2luZ1wiOlwiZGF0YVwiLFwidGV4dGFyZWFFbFwiOlwib3B0aW9uc1wiLFwiaGFuZGxlQ29tcG9zaXRpb25TdGFydFwiOlwib3B0aW9uc1wiLFwiaGFuZGxlQ29tcG9zaXRpb25VcGRhdGVcIjpcIm9wdGlvbnNcIixcImhhbmRsZUNvbXBvc2l0aW9uRW5kXCI6XCJvcHRpb25zXCIsXCJoYW5kbGVQYXN0ZVwiOlwib3B0aW9uc1wiLFwiaGFuZGxlQmx1clwiOlwib3B0aW9uc1wiLFwicmVnaXN0ZXJIb3RrZXlzXCI6XCJvcHRpb25zXCIsXCJoYW5kbGVLZXlkb3duXCI6XCJvcHRpb25zXCIsXCJoZWlnaHRBdExpbmVcIjpcIm9wdGlvbnNcIixcImNsZWFyVGltZW91dFwiOlwib3B0aW9uc1wiLFwidXBkYXRlQ3VycmVudEhpc3RvcnlSYW5nZVwiOlwib3B0aW9uc1wiLFwiaGFuZGxlSW5wdXRcIjpcIm9wdGlvbnNcIixcInNhdmVIaXN0b3J5XCI6XCJvcHRpb25zXCIsXCJ1cGRhdGVIaXN0b3J5XCI6XCJvcHRpb25zXCIsXCJnb0hpc3RvcnlcIjpcIm9wdGlvbnNcIixcImdldFJhbmdlXCI6XCJvcHRpb25zXCIsXCJzZXRSYW5nZVwiOlwib3B0aW9uc1wiLFwiZm9jdXNcIjpcIm9wdGlvbnNcIixcImluc2VydFRleHRcIjpcIm9wdGlvbnNcIixcInVuZG9cIjpcIm9wdGlvbnNcIixcInJlZG9cIjpcIm9wdGlvbnNcIn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzXG52YXIgZXNtX2V4dGVuZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9pbnNlcnQtdGV4dC1hdC1jdXJzb3IvZGlzdC9pbmRleC5lc20uanNcbnZhciBicm93c2VyU3VwcG9ydHNUZXh0YXJlYVRleHROb2Rlcztcbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaW5wdXRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gY2FuTWFuaXB1bGF0ZVZpYVRleHROb2RlcyhpbnB1dCkge1xuICBpZiAoaW5wdXQubm9kZU5hbWUgIT09IFwiVEVYVEFSRUFcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnJvd3NlclN1cHBvcnRzVGV4dGFyZWFUZXh0Tm9kZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgdGV4dGFyZWEudmFsdWUgPSAxO1xuICAgIGJyb3dzZXJTdXBwb3J0c1RleHRhcmVhVGV4dE5vZGVzID0gISF0ZXh0YXJlYS5maXJzdENoaWxkO1xuICB9XG5cbiAgcmV0dXJuIGJyb3dzZXJTdXBwb3J0c1RleHRhcmVhVGV4dE5vZGVzO1xufVxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZXh0QXJlYUVsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4X2VzbV9pbmRleCAoaW5wdXQsIHRleHQpIHtcbiAgLy8gTW9zdCBvZiB0aGUgdXNlZCBBUElzIG9ubHkgd29yayB3aXRoIHRoZSBmaWVsZCBzZWxlY3RlZFxuICBpbnB1dC5mb2N1cygpOyAvLyBJRSA4LTEwXG5cbiAgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciBpZVJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgaWVSYW5nZS50ZXh0ID0gdGV4dDsgLy8gTW92ZSBjdXJzb3IgYWZ0ZXIgdGhlIGluc2VydGVkIHRleHRcblxuICAgIGllUmFuZ2UuY29sbGFwc2UoZmFsc2VcbiAgICAvKiB0byB0aGUgZW5kICovXG4gICAgKTtcbiAgICBpZVJhbmdlLnNlbGVjdCgpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXZWJraXQgKyBFZGdlXG5cblxuICB2YXIgaXNTdWNjZXNzID0gZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbnNlcnRUZXh0XCIsIGZhbHNlLCB0ZXh0KTtcblxuICBpZiAoIWlzU3VjY2Vzcykge1xuICAgIHZhciBzdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgIHZhciBlbmQgPSBpbnB1dC5zZWxlY3Rpb25FbmQ7IC8vIEZpcmVmb3ggKG5vbi1zdGFuZGFyZCBtZXRob2QpXG5cbiAgICBpZiAodHlwZW9mIGlucHV0LnNldFJhbmdlVGV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpbnB1dC5zZXRSYW5nZVRleHQodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvIG1ha2UgYSBjaGFuZ2Ugd2UganVzdCBuZWVkIGEgUmFuZ2UsIG5vdCBhIFNlbGVjdGlvblxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuXG4gICAgICBpZiAoY2FuTWFuaXB1bGF0ZVZpYVRleHROb2RlcyhpbnB1dCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBpbnB1dC5maXJzdENoaWxkOyAvLyBJZiB0ZXh0YXJlYSBpcyBlbXB0eSwganVzdCBpbnNlcnQgdGhlIHRleHRcblxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICBpbnB1dC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gZmluZCBhIG5vZGVzIGZvciBzdGFydCBhbmQgZW5kXG4gICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgdmFyIGVuZE5vZGUgPSBudWxsO1xuXG4gICAgICAgICAgd2hpbGUgKG5vZGUgJiYgKHN0YXJ0Tm9kZSA9PT0gbnVsbCB8fCBlbmROb2RlID09PSBudWxsKSkge1xuICAgICAgICAgICAgdmFyIG5vZGVMZW5ndGggPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7IC8vIGlmIHN0YXJ0IG9mIHRoZSBzZWxlY3Rpb24gZmFsbHMgaW50byBjdXJyZW50IG5vZGVcblxuICAgICAgICAgICAgaWYgKHN0YXJ0ID49IG9mZnNldCAmJiBzdGFydCA8PSBvZmZzZXQgKyBub2RlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Tm9kZSA9IG5vZGUsIHN0YXJ0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgIH0gLy8gaWYgZW5kIG9mIHRoZSBzZWxlY3Rpb24gZmFsbHMgaW50byBjdXJyZW50IG5vZGVcblxuXG4gICAgICAgICAgICBpZiAoZW5kID49IG9mZnNldCAmJiBlbmQgPD0gb2Zmc2V0ICsgbm9kZUxlbmd0aCkge1xuICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoZW5kTm9kZSA9IG5vZGUsIGVuZCAtIG9mZnNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9mZnNldCArPSBub2RlTGVuZ3RoO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfSAvLyBJZiB0aGVyZSBpcyBzb21lIHRleHQgc2VsZWN0ZWQsIHJlbW92ZSBpdCBhcyB3ZSBzaG91bGQgcmVwbGFjZSBpdFxuXG5cbiAgICAgICAgICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgdGhlIG5vZGUgaXMgYSB0ZXh0YXJlYSBhbmQgdGhlIHJhbmdlIGRvZXNuJ3Qgc3BhbiBvdXRzaWRlIHRoZSBlbGVtZW50XG4gICAgICAvL1xuICAgICAgLy8gR2V0IHRoZSBjb21tb25BbmNlc3RvckNvbnRhaW5lciBvZiB0aGUgc2VsZWN0ZWQgcmFuZ2UgYW5kIHRlc3QgaXRzIHR5cGVcbiAgICAgIC8vIElmIHRoZSBub2RlIGlzIG9mIHR5cGUgYCN0ZXh0YCBpdCBtZWFucyB0aGF0IHdlJ3JlIHN0aWxsIHdvcmtpbmcgd2l0aCB0ZXh0IG5vZGVzIHdpdGhpbiBvdXIgdGV4dGFyZWEgZWxlbWVudFxuICAgICAgLy8gb3RoZXJ3aXNlLCBpZiBpdCdzIG9mIHR5cGUgYCNkb2N1bWVudGAgZm9yIGV4YW1wbGUgaXQgbWVhbnMgb3VyIHNlbGVjdGlvbiBzcGFucyBvdXRzaWRlIHRoZSB0ZXh0YXJlYS5cblxuXG4gICAgICBpZiAoY2FuTWFuaXB1bGF0ZVZpYVRleHROb2RlcyhpbnB1dCkgJiYgcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIubm9kZU5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICAvLyBGaW5hbGx5IGluc2VydCBhIG5ldyBub2RlLiBUaGUgYnJvd3NlciB3aWxsIGF1dG9tYXRpY2FsbHkgc3BsaXQgc3RhcnQgYW5kIGVuZCBub2RlcyBpbnRvIHR3byBpZiBuZWNlc3NhcnlcbiAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZSh0ZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyBub3QgYSB0ZXh0YXJlYSBvciB0aGUgcmFuZ2Ugc3BhbnMgb3V0c2lkZSBhIHRleHRhcmVhIHRoZSBvbmx5IHdheSBpcyB0byByZXBsYWNlIHRoZSB3aG9sZSB2YWx1ZVxuICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBzdGFydCkgKyB0ZXh0ICsgdmFsdWUuc2xpY2UoZW5kKTtcbiAgICAgIH1cbiAgICB9IC8vIENvcnJlY3QgdGhlIGN1cnNvciBwb3NpdGlvbiB0byBiZSBhdCB0aGUgZW5kIG9mIHRoZSBpbnNlcnRpb25cblxuXG4gICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQgKyB0ZXh0Lmxlbmd0aCwgc3RhcnQgKyB0ZXh0Lmxlbmd0aCk7IC8vIE5vdGlmeSBhbnkgcG9zc2libGUgbGlzdGVuZXJzIG9mIHRoZSBjaGFuZ2VcblxuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJVSUV2ZW50XCIpO1xuICAgIGUuaW5pdEV2ZW50KFwiaW5wdXRcIiwgdHJ1ZSwgZmFsc2UpO1xuICAgIGlucHV0LmRpc3BhdGNoRXZlbnQoZSk7XG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaW5kZXhfZXNtID0gKGluZGV4X2VzbV9pbmRleCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvdXRpbHMvaG90a2V5cy5qcyArIDEgbW9kdWxlc1xudmFyIGhvdGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy91dGlscy91dGlsLmpzXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Q/P3JlZi0tMi0wIS4vc3JjL2NvbXBvbmVudHMvdGV4dGFyZWEtZWRpdG9yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0ZXh0YXJlYV9lZGl0b3J2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyA9ICh7XG4gIG5hbWU6ICd2LW1kLXRleHRhcmVhLWVkaXRvcicsXG4gIHByb3BzOiB7XG4gICAgbW9kZWxWYWx1ZTogU3RyaW5nLFxuICAgIG1pbkhlaWdodDogU3RyaW5nLFxuICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgaGlzdG9yeURlYm91bmNlOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiA0MDBcbiAgICB9LFxuICAgIGhpc3RvcnlNYXg6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDMwXG4gICAgfVxuICB9LFxuICBlbWl0czogWydibHVyJywgJ3Bhc3RlJywgJ3VwZGF0ZTptb2RlbFZhbHVlJ10sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQ29tcG9zaW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdGV4dGFyZWFFbDogZnVuY3Rpb24gdGV4dGFyZWFFbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRyZWZzLnRleHRhcmVhO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtb2RlbFZhbHVlOiBmdW5jdGlvbiBtb2RlbFZhbHVlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICAgICAgaWYgKCF0aGlzLnRyaWdnZXJJbnB1dEJ5U2V0SGlzdG9yeSkge1xuICAgICAgICB0aGlzLnRpbW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnNhdmVIaXN0b3J5KCk7XG5cbiAgICAgICAgICBfdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgfSwgdGhpcy5oaXN0b3J5RGVib3VuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLmhpc3RvcnlTdGFjayA9IFtdO1xuICAgIHRoaXMuaGlzdG9yeUluZGV4ID0gMDtcbiAgICB0aGlzLmhvdGtleXNNYW5hZ2VyID0gbmV3IGhvdGtleXNbXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLnNhdmVIaXN0b3J5KCk7XG4gICAgdGhpcy50ZXh0YXJlYUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24sIGZhbHNlKTtcbiAgfSxcbiAgYmVmb3JlVW5tb3VudDogZnVuY3Rpb24gYmVmb3JlVW5tb3VudCgpIHtcbiAgICB0aGlzLnRleHRhcmVhRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93biwgZmFsc2UpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaGFuZGxlQ29tcG9zaXRpb25TdGFydDogZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb25TdGFydCgpIHtcbiAgICAgIHRoaXMuaXNDb21wb3NpbmcgPSB0cnVlO1xuICAgIH0sXG4gICAgaGFuZGxlQ29tcG9zaXRpb25VcGRhdGU6IGZ1bmN0aW9uIGhhbmRsZUNvbXBvc2l0aW9uVXBkYXRlKGV2ZW50KSB7XG4gICAgICB2YXIgdGV4dCA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgIHZhciBsYXN0Q2hhcmFjdGVyID0gdGV4dFt0ZXh0Lmxlbmd0aCAtIDFdIHx8ICcnO1xuICAgICAgdGhpcy5pc0NvbXBvc2luZyA9ICFPYmplY3QodXRpbFtcImVcIiAvKiBpc0tvcmVhbiAqL10pKGxhc3RDaGFyYWN0ZXIpO1xuICAgIH0sXG4gICAgaGFuZGxlQ29tcG9zaXRpb25FbmQ6IGZ1bmN0aW9uIGhhbmRsZUNvbXBvc2l0aW9uRW5kKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5pc0NvbXBvc2luZykge1xuICAgICAgICB0aGlzLmlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5wdXQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlUGFzdGU6IGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3Bhc3RlJywgZSk7XG4gICAgfSxcbiAgICBoYW5kbGVCbHVyOiBmdW5jdGlvbiBoYW5kbGVCbHVyKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2JsdXInLCBlKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVySG90a2V5czogZnVuY3Rpb24gcmVnaXN0ZXJIb3RrZXlzKCkge1xuICAgICAgdmFyIF90aGlzJGhvdGtleXNNYW5hZ2VyO1xuXG4gICAgICAoX3RoaXMkaG90a2V5c01hbmFnZXIgPSB0aGlzLmhvdGtleXNNYW5hZ2VyKS5yZWdpc3RlckhvdGtleXMuYXBwbHkoX3RoaXMkaG90a2V5c01hbmFnZXIsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBoYW5kbGVLZXlkb3duOiBmdW5jdGlvbiBoYW5kbGVLZXlkb3duKGUpIHtcbiAgICAgIHRoaXMuaG90a2V5c01hbmFnZXIuZGlzcGF0Y2goZSk7XG4gICAgfSxcbiAgICBoZWlnaHRBdExpbmU6IGZ1bmN0aW9uIGhlaWdodEF0TGluZShsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXCJzZWN0aW9uW2RhdGEtbGluZT1cXFwiXCIgKyBsaW5lSW5kZXggKyBcIlxcXCJdXCIpO1xuICAgICAgcmV0dXJuIGVsID8gZWwub2Zmc2V0VG9wICsgZWwub2Zmc2V0SGVpZ2h0IDogMDtcbiAgICB9LFxuICAgIGNsZWFyVGltZW91dDogZnVuY3Rpb24gKF9jbGVhclRpbWVvdXQpIHtcbiAgICAgIGZ1bmN0aW9uIGNsZWFyVGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIF9jbGVhclRpbWVvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2NsZWFyVGltZW91dC50b1N0cmluZygpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGNsZWFyVGltZW91dDtcbiAgICB9KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnRpbW1lcikgY2xlYXJUaW1lb3V0KHRoaXMudGltbWVyKTtcbiAgICAgIHRoaXMudGltbWVyID0gbnVsbDtcbiAgICB9KSxcbiAgICB1cGRhdGVDdXJyZW50SGlzdG9yeVJhbmdlOiBmdW5jdGlvbiB1cGRhdGVDdXJyZW50SGlzdG9yeVJhbmdlKCkge1xuICAgICAgaWYgKCF0aGlzLnRpbW1lcikge1xuICAgICAgICB0aGlzLnVwZGF0ZUhpc3RvcnkodGhpcy5oaXN0b3J5SW5kZXgsIHtcbiAgICAgICAgICByYW5nZTogdGhpcy5nZXRSYW5nZSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlSW5wdXQ6IGZ1bmN0aW9uIGhhbmRsZUlucHV0KGUpIHtcbiAgICAgIGlmICh0aGlzLmlzQ29tcG9zaW5nKSByZXR1cm47XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bW9kZWxWYWx1ZScsIGUudGFyZ2V0LnZhbHVlKTtcbiAgICB9LFxuICAgIHNhdmVIaXN0b3J5OiBmdW5jdGlvbiBzYXZlSGlzdG9yeSgpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgIHZhciBoaXN0b3J5ID0ge1xuICAgICAgICB2YWx1ZTogdGhpcy5tb2RlbFZhbHVlLFxuICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgIH07XG4gICAgICB0aGlzLmhpc3RvcnlTdGFjayA9IHRoaXMuaGlzdG9yeVN0YWNrLnNsaWNlKDAsIHRoaXMuaGlzdG9yeUluZGV4ICsgMSk7XG4gICAgICB0aGlzLmhpc3RvcnlTdGFjay5wdXNoKGhpc3RvcnkpO1xuICAgICAgaWYgKHRoaXMuaGlzdG9yeVN0YWNrLmxlbmd0aCA+IHRoaXMuaGlzdG9yeU1heCkgdGhpcy5oaXN0b3J5U3RhY2suc2hpZnQoKTtcbiAgICAgIHRoaXMuaGlzdG9yeUluZGV4ID0gdGhpcy5oaXN0b3J5U3RhY2subGVuZ3RoIC0gMTtcbiAgICB9LFxuICAgIHVwZGF0ZUhpc3Rvcnk6IGZ1bmN0aW9uIHVwZGF0ZUhpc3RvcnkoaW5kZXgsIGRhdGEpIHtcbiAgICAgIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5U3RhY2tbaW5kZXhdO1xuICAgICAgaWYgKCd2YWx1ZScgaW4gZGF0YSkgaGlzdG9yeS52YWx1ZSA9IGRhdGEudmFsdWU7XG5cbiAgICAgIE9iamVjdChlc21fZXh0ZW5kc1tcImFcIiAvKiBkZWZhdWx0ICovXSkoaGlzdG9yeS5yYW5nZSwgZGF0YS5yYW5nZSk7XG4gICAgfSxcbiAgICBnb0hpc3Rvcnk6IGZ1bmN0aW9uIGdvSGlzdG9yeShpbmRleCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyRoaXN0b3J5U3RhY2skaW4gPSB0aGlzLmhpc3RvcnlTdGFja1tpbmRleF0sXG4gICAgICAgICAgdmFsdWUgPSBfdGhpcyRoaXN0b3J5U3RhY2skaW4udmFsdWUsXG4gICAgICAgICAgcmFuZ2UgPSBfdGhpcyRoaXN0b3J5U3RhY2skaW4ucmFuZ2U7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bW9kZWxWYWx1ZScsIHZhbHVlKTtcbiAgICAgIHRoaXMudHJpZ2dlcklucHV0QnlTZXRIaXN0b3J5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnRyaWdnZXJJbnB1dEJ5U2V0SGlzdG9yeSA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzMi5zZXRSYW5nZShyYW5nZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiBmdW5jdGlvbiBnZXRSYW5nZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLnRleHRhcmVhRWwuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogdGhpcy50ZXh0YXJlYUVsLnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldFJhbmdlOiBmdW5jdGlvbiBzZXRSYW5nZShfcmVmKSB7XG4gICAgICB2YXIgc3RhcnQgPSBfcmVmLnN0YXJ0LFxuICAgICAgICAgIGVuZCA9IF9yZWYuZW5kO1xuICAgICAgdGhpcy50ZXh0YXJlYUVsLnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgdGhpcy51cGRhdGVDdXJyZW50SGlzdG9yeVJhbmdlKCk7XG4gICAgfSxcbiAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICB0aGlzLnRleHRhcmVhRWwuZm9jdXMoKTtcbiAgICB9LFxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uIGluc2VydFRleHQodGV4dCkge1xuICAgICAgaW5kZXhfZXNtKHRoaXMudGV4dGFyZWFFbCwgdGV4dCk7XG4gICAgfSxcbiAgICB1bmRvOiBmdW5jdGlvbiB1bmRvKCkge1xuICAgICAgaWYgKHRoaXMuaGlzdG9yeUluZGV4ID4gMCkge1xuICAgICAgICB0aGlzLmhpc3RvcnlJbmRleC0tO1xuICAgICAgICB0aGlzLmdvSGlzdG9yeSh0aGlzLmhpc3RvcnlJbmRleCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWRvOiBmdW5jdGlvbiByZWRvKCkge1xuICAgICAgaWYgKHRoaXMuaGlzdG9yeUluZGV4IDwgdGhpcy5oaXN0b3J5U3RhY2subGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLmhpc3RvcnlJbmRleCsrO1xuICAgICAgICB0aGlzLmdvSGlzdG9yeSh0aGlzLmhpc3RvcnlJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvdGV4dGFyZWEtZWRpdG9yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1xuIFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL3RleHRhcmVhLWVkaXRvci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPXNjc3NcbnZhciB0ZXh0YXJlYV9lZGl0b3J2dWVfdHlwZV9zdHlsZV9pbmRleF8wX2xhbmdfc2NzcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy90ZXh0YXJlYS1lZGl0b3IudnVlXG5cblxuXG5cblxudGV4dGFyZWFfZWRpdG9ydnVlX3R5cGVfc2NyaXB0X2xhbmdfanMucmVuZGVyID0gdGV4dGFyZWFfZWRpdG9ydnVlX3R5cGVfdGVtcGxhdGVfaWRfMzFmZWQxZWFfYmluZGluZ3NfbW9kZWxWYWx1ZV9wcm9wc19taW5IZWlnaHRfcHJvcHNfcGxhY2Vob2xkZXJfcHJvcHNfaGlzdG9yeURlYm91bmNlX3Byb3BzX2hpc3RvcnlNYXhfcHJvcHNfaXNDb21wb3NpbmdfZGF0YV90ZXh0YXJlYUVsX29wdGlvbnNfaGFuZGxlQ29tcG9zaXRpb25TdGFydF9vcHRpb25zX2hhbmRsZUNvbXBvc2l0aW9uVXBkYXRlX29wdGlvbnNfaGFuZGxlQ29tcG9zaXRpb25FbmRfb3B0aW9uc19oYW5kbGVQYXN0ZV9vcHRpb25zX2hhbmRsZUJsdXJfb3B0aW9uc19yZWdpc3RlckhvdGtleXNfb3B0aW9uc19oYW5kbGVLZXlkb3duX29wdGlvbnNfaGVpZ2h0QXRMaW5lX29wdGlvbnNfY2xlYXJUaW1lb3V0X29wdGlvbnNfdXBkYXRlQ3VycmVudEhpc3RvcnlSYW5nZV9vcHRpb25zX2hhbmRsZUlucHV0X29wdGlvbnNfc2F2ZUhpc3Rvcnlfb3B0aW9uc191cGRhdGVIaXN0b3J5X29wdGlvbnNfZ29IaXN0b3J5X29wdGlvbnNfZ2V0UmFuZ2Vfb3B0aW9uc19zZXRSYW5nZV9vcHRpb25zX2ZvY3VzX29wdGlvbnNfaW5zZXJ0VGV4dF9vcHRpb25zX3VuZG9fb3B0aW9uc19yZWRvX29wdGlvbnNfcmVuZGVyXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRleHRhcmVhX2VkaXRvciA9ICh0ZXh0YXJlYV9lZGl0b3J2dWVfdHlwZV9zY3JpcHRfbGFuZ19qcyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL2NyZWF0ZS1lZGl0b3IuanMgKyA2MCBtb2R1bGVzXG52YXIgY3JlYXRlX2VkaXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0Pz9yZWYtLTItMCEuL3NyYy9iYXNlLWVkaXRvci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcblxuXG5cbnZhciBfY29tcG9uZW50cztcblxuXG5cblxudmFyIGNvbXBvbmVudCA9IHtcbiAgY29tcG9uZW50czogKF9jb21wb25lbnRzID0ge30sIF9jb21wb25lbnRzW3RleHRhcmVhX2VkaXRvci5uYW1lXSA9IHRleHRhcmVhX2VkaXRvciwgX2NvbXBvbmVudHMpLFxuICB3YXRjaDoge1xuICAgIG1vZGVsVmFsdWU6IGZ1bmN0aW9uIG1vZGVsVmFsdWUoKSB7XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLm1vZGVsVmFsdWU7XG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdChhc3luY1RvR2VuZXJhdG9yW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yX2RlZmF1bHQuYS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgdmFyIGVkaXRvcldyYXBwZXI7XG4gICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yX2RlZmF1bHQuYS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxbXCJkXCIgLyogaW5Ccm93c2VyICovXSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgIGVkaXRvcldyYXBwZXIgPSBfdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnYtbWQtZWRpdG9yX19lZGl0b3Itd3JhcHBlcicpO1xuICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dEVkaXRvck1pbkhlaWdodCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVkaXRvcldyYXBwZXIpLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dEVkaXRvck1pbkhlaWdodCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICB9KSkoKTtcbiAgICAgIH0sXG4gICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHRFZGl0b3JNaW5IZWlnaHQ6ICcnXG4gICAgfTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZUVkaXRvcldyYXBwZXJDbGljazogZnVuY3Rpb24gaGFuZGxlRWRpdG9yV3JhcHBlckNsaWNrKCkge1xuICAgICAgdGhpcy5zZXRGb2N1c0VuZCgpO1xuICAgIH0sXG4gICAgLy8gTXVzdCBpbXBsZW1lbnRcbiAgICBlZGl0b3JGb2N1c0VuZDogZnVuY3Rpb24gZWRpdG9yRm9jdXNFbmQoKSB7XG4gICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICB0aGlzLiRyZWZzLmVkaXRvckVnaW5lLnNldFJhbmdlKHtcbiAgICAgICAgc3RhcnQ6IHRoaXMudGV4dC5sZW5ndGgsXG4gICAgICAgIGVuZDogdGhpcy50ZXh0Lmxlbmd0aFxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBNdXN0IGltcGxlbWVudFxuICAgIGRlbExpbmVMZWZ0OiBmdW5jdGlvbiBkZWxMaW5lTGVmdCgpIHtcbiAgICAgIHZhciBlZGl0b3JFZ2luZSA9IHRoaXMuJHJlZnMuZWRpdG9yRWdpbmU7XG5cbiAgICAgIHZhciBfZWRpdG9yRWdpbmUkZ2V0UmFuZ2UgPSBlZGl0b3JFZ2luZS5nZXRSYW5nZSgpLFxuICAgICAgICAgIHN0YXJ0ID0gX2VkaXRvckVnaW5lJGdldFJhbmdlLnN0YXJ0O1xuXG4gICAgICB2YXIgbGVmdFRleHQgPSB0aGlzLmdldEN1cnNvckxpbmVMZWZ0VGV4dCgpO1xuICAgICAgZWRpdG9yRWdpbmUuc2V0UmFuZ2Uoe1xuICAgICAgICBzdGFydDogc3RhcnQgLSBsZWZ0VGV4dC5sZW5ndGggLSAxLFxuICAgICAgICBlbmQ6IHN0YXJ0XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvblRleHQoJ1xcbicpO1xuICAgIH0sXG4gICAgLy8gTXVzdCBpbXBsZW1lbnRcbiAgICBnZXRDdXJzb3JMaW5lTGVmdFRleHQ6IGZ1bmN0aW9uIGdldEN1cnNvckxpbmVMZWZ0VGV4dCgpIHtcbiAgICAgIHZhciBfdGhpcyQkcmVmcyRlZGl0b3JFZ2kgPSB0aGlzLiRyZWZzLmVkaXRvckVnaW5lLmdldFJhbmdlKCksXG4gICAgICAgICAgc3RhcnQgPSBfdGhpcyQkcmVmcyRlZGl0b3JFZ2kuc3RhcnQsXG4gICAgICAgICAgZW5kID0gX3RoaXMkJHJlZnMkZWRpdG9yRWdpLmVuZDtcblxuICAgICAgcmV0dXJuIHN0YXJ0ID09PSBlbmQgPyB0aGlzLnRleHQuc2xpY2UoMCwgc3RhcnQpLnNwbGl0KCdcXG4nKS5wb3AoKSA6IG51bGw7XG4gICAgfSxcbiAgICAvLyBNdXN0IGltcGxlbWVudFxuICAgIGVkaXRvclJlZ2lzdGVySG90a2V5czogZnVuY3Rpb24gZWRpdG9yUmVnaXN0ZXJIb3RrZXlzKCkge1xuICAgICAgdmFyIF90aGlzJCRyZWZzJGVkaXRvckVnaTI7XG5cbiAgICAgIChfdGhpcyQkcmVmcyRlZGl0b3JFZ2kyID0gdGhpcy4kcmVmcy5lZGl0b3JFZ2luZSkucmVnaXN0ZXJIb3RrZXlzLmFwcGx5KF90aGlzJCRyZWZzJGVkaXRvckVnaTIsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICAvLyBNdXN0IGltcGxlbWVudFxuICAgIGVkaXRvclNjcm9sbFRvVG9wOiBmdW5jdGlvbiBlZGl0b3JTY3JvbGxUb1RvcChzY3JvbGxUb3ApIHtcbiAgICAgIHRoaXMuJHJlZnMuZWRpdG9yU2Nyb2xsZXIuc2Nyb2xsVG8oc2Nyb2xsVG9wKTtcbiAgICB9LFxuICAgIC8vIE11c3QgaW1wbGVtZW50XG4gICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24gZ2V0U2Nyb2xsSW5mbygpIHtcbiAgICAgIHJldHVybiB0aGlzLiRyZWZzLmVkaXRvclNjcm9sbGVyLmdldFNjcm9sbEluZm8oKTtcbiAgICB9LFxuICAgIC8vIE11c3QgaW1wbGVtZW50XG4gICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbiBoZWlnaHRBdExpbmUoKSB7XG4gICAgICB2YXIgX3RoaXMkJHJlZnMkZWRpdG9yRWdpMztcblxuICAgICAgcmV0dXJuIChfdGhpcyQkcmVmcyRlZGl0b3JFZ2kzID0gdGhpcy4kcmVmcy5lZGl0b3JFZ2luZSkuaGVpZ2h0QXRMaW5lLmFwcGx5KF90aGlzJCRyZWZzJGVkaXRvckVnaTMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICAvLyBNdXN0IGltcGxlbWVudFxuICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICAgIHRoaXMuJHJlZnMuZWRpdG9yRWdpbmUuZm9jdXMoKTtcbiAgICB9LFxuICAgIC8vIE11c3QgaW1wbGVtZW50XG4gICAgdW5kbzogZnVuY3Rpb24gdW5kbygpIHtcbiAgICAgIHRoaXMuJHJlZnMuZWRpdG9yRWdpbmUudW5kbygpO1xuICAgIH0sXG4gICAgLy8gTXVzdCBpbXBsZW1lbnRcbiAgICByZWRvOiBmdW5jdGlvbiByZWRvKCkge1xuICAgICAgdGhpcy4kcmVmcy5lZGl0b3JFZ2luZS5yZWRvKCk7XG4gICAgfSxcbiAgICAvLyBNdXN0IGltcGxlbWVudFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgIHRoaXMuaGFuZGxlSW5wdXQoJycpO1xuICAgIH0sXG4gICAgLy8gTXVzdCBpbXBsZW1lbnRcbiAgICByZXBsYWNlU2VsZWN0aW9uVGV4dDogZnVuY3Rpb24gcmVwbGFjZVNlbGVjdGlvblRleHQodGV4dCkge1xuICAgICAgdGhpcy4kcmVmcy5lZGl0b3JFZ2luZS5pbnNlcnRUZXh0KHRleHQpO1xuICAgIH0sXG4gICAgLy8gTXVzdCBpbXBsZW1lbnRcbiAgICBnZXRDdXJyZW50U2VsZWN0ZWRTdHI6IGZ1bmN0aW9uIGdldEN1cnJlbnRTZWxlY3RlZFN0cigpIHtcbiAgICAgIHZhciBfdGhpcyQkcmVmcyRlZGl0b3JFZ2k0ID0gdGhpcy4kcmVmcy5lZGl0b3JFZ2luZS5nZXRSYW5nZSgpLFxuICAgICAgICAgIHN0YXJ0ID0gX3RoaXMkJHJlZnMkZWRpdG9yRWdpNC5zdGFydCxcbiAgICAgICAgICBlbmQgPSBfdGhpcyQkcmVmcyRlZGl0b3JFZ2k0LmVuZDtcblxuICAgICAgcmV0dXJuIGVuZCA+IHN0YXJ0ID8gdGhpcy50ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpIDogbnVsbDtcbiAgICB9LFxuICAgIC8vIE11c3QgaW1wbGVtZW50XG4gICAgY2hhbmdlU2VsY3Rpb25UbzogZnVuY3Rpb24gY2hhbmdlU2VsY3Rpb25UbyhpbnNlcnRUZXh0LCBzZWxlY3RlZFRleHQpIHtcbiAgICAgIHZhciBlZGl0b3JFZ2luZSA9IHRoaXMuJHJlZnMuZWRpdG9yRWdpbmU7XG4gICAgICB2YXIgc2VsZWN0ZWRJbmRleE9mU3RyID0gaW5zZXJ0VGV4dC5pbmRleE9mKHNlbGVjdGVkVGV4dCk7XG4gICAgICB2YXIgY3Vyc29yRW5kSW5kZXggPSBlZGl0b3JFZ2luZS5nZXRSYW5nZSgpLmVuZDtcbiAgICAgIGlmIChzZWxlY3RlZEluZGV4T2ZTdHIgPT09IC0xKSByZXR1cm47XG4gICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBjdXJzb3JFbmRJbmRleCk7XG4gICAgICB2YXIgaW5zZXJ0VGV4dEluZGV4ID0gdGV4dC5sZW5ndGggLSBpbnNlcnRUZXh0Lmxlbmd0aDtcbiAgICAgIHZhciByYW5nZVN0YXJ0SW5kZXggPSBpbnNlcnRUZXh0SW5kZXggKyBzZWxlY3RlZEluZGV4T2ZTdHI7XG4gICAgICB2YXIgcmFuZ2VFbmRJbmRleCA9IHJhbmdlU3RhcnRJbmRleCArIHNlbGVjdGVkVGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLiRyZWZzLmVkaXRvckVnaW5lLnNldFJhbmdlKHtcbiAgICAgICAgc3RhcnQ6IHJhbmdlU3RhcnRJbmRleCxcbiAgICAgICAgZW5kOiByYW5nZUVuZEluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5PYmplY3QoY3JlYXRlX2VkaXRvcltcImFcIiAvKiBkZWZhdWx0ICovXSkoY29tcG9uZW50KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJhc2VfZWRpdG9ydnVlX3R5cGVfc2NyaXB0X2xhbmdfanMgPSAoY29tcG9uZW50KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2Jhc2UtZWRpdG9yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1xuIFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYmFzZS1lZGl0b3IudnVlXG5cblxuXG5iYXNlX2VkaXRvcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzLnJlbmRlciA9IHJlbmRlclxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBiYXNlX2VkaXRvciA9IChiYXNlX2VkaXRvcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvdXRpbHMveHNzL2luZGV4LmpzICsgMyBtb2R1bGVzXG52YXIgeHNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9hc3NldHMvY3NzL2ZvbnQuY3NzXG52YXIgZm9udCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9iYXNlLWVkaXRvci5qc1xuLy8gVGhpcyBmaWxlIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IGJ1aWxkL2J1aWxkLWVudHJ5LmpzXG5cbiAvLyBmb250IGNzc1xuXG5cbnZhciB2ZXJzaW9uID0gJzIuMy4xOCc7XG5cbnZhciBiYXNlX2VkaXRvcl9pbnN0YWxsID0gZnVuY3Rpb24gaW5zdGFsbChhcHApIHtcbiAgYXBwLmNvbXBvbmVudChiYXNlX2VkaXRvci5uYW1lLCBiYXNlX2VkaXRvcik7XG59O1xuXG5iYXNlX2VkaXRvci52ZXJzaW9uID0gdmVyc2lvbjtcbmJhc2VfZWRpdG9yLmluc3RhbGwgPSBiYXNlX2VkaXRvcl9pbnN0YWxsO1xuYmFzZV9lZGl0b3IueHNzID0geHNzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuXG5iYXNlX2VkaXRvci51c2UgPSBmdW5jdGlvbiAob3B0aW9uc09ySW5zdGFsbCwgb3B0KSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9uc09ySW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnNPckluc3RhbGwoYmFzZV9lZGl0b3IsIG9wdCk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9uc09ySW5zdGFsbC5pbnN0YWxsKGJhc2VfZWRpdG9yLCBvcHQpO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VfZWRpdG9yO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2Jhc2VfZWRpdG9yID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoYmFzZV9lZGl0b3IpO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlbXCJkZWZhdWx0XCJdO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kangc/v-md-editor/lib/base-editor.js\n");

/***/ }),

/***/ "./node_modules/@kangc/v-md-editor/lib/theme/vuepress.js":
/*!***************************************************************!*\
  !*** ./node_modules/@kangc/v-md-editor/lib/theme/vuepress.js ***!
  \***************************************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(\"undefined\"!=typeof self?self:this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=86)}([function(e,t,r){\"use strict\";var n=Object.prototype.hasOwnProperty;function i(e,t){return n.call(e,t)}function s(e){return!(e>=55296&&e<=57343)&&(!(e>=64976&&e<=65007)&&(65535!=(65535&e)&&65534!=(65535&e)&&(!(e>=0&&e<=8)&&(11!==e&&(!(e>=14&&e<=31)&&(!(e>=127&&e<=159)&&!(e>1114111)))))))}function o(e){if(e>65535){var t=55296+((e-=65536)>>10),r=56320+(1023&e);return String.fromCharCode(t,r)}return String.fromCharCode(e)}var a=/\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g,c=new RegExp(a.source+\"|\"+/&([a-z#][a-z0-9]{1,31});/gi.source,\"gi\"),l=/^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i,u=r(7);var p=/[&<>\"]/,h=/[&<>\"]/g,f={\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\"};function d(e){return f[e]}var g=/[.?*+^$[\\]\\\\(){}|-]/g;var m=r(3);t.lib={},t.lib.mdurl=r(8),t.lib.ucmicro=r(26),t.assign=function(e){var t=Array.prototype.slice.call(arguments,1);return t.forEach((function(t){if(t){if(\"object\"!=typeof t)throw new TypeError(t+\"must be object\");Object.keys(t).forEach((function(r){e[r]=t[r]}))}})),e},t.isString=function(e){return\"[object String]\"===function(e){return Object.prototype.toString.call(e)}(e)},t.has=i,t.unescapeMd=function(e){return e.indexOf(\"\\\\\")<0?e:e.replace(a,\"$1\")},t.unescapeAll=function(e){return e.indexOf(\"\\\\\")<0&&e.indexOf(\"&\")<0?e:e.replace(c,(function(e,t,r){return t||function(e,t){var r=0;return i(u,t)?u[t]:35===t.charCodeAt(0)&&l.test(t)&&s(r=\"x\"===t[1].toLowerCase()?parseInt(t.slice(2),16):parseInt(t.slice(1),10))?o(r):e}(e,r)}))},t.isValidEntityCode=s,t.fromCodePoint=o,t.escapeHtml=function(e){return p.test(e)?e.replace(h,d):e},t.arrayReplaceAt=function(e,t,r){return[].concat(e.slice(0,t),r,e.slice(t+1))},t.isSpace=function(e){switch(e){case 9:case 32:return!0}return!1},t.isWhiteSpace=function(e){if(e>=8192&&e<=8202)return!0;switch(e){case 9:case 10:case 11:case 12:case 13:case 32:case 160:case 5760:case 8239:case 8287:case 12288:return!0}return!1},t.isMdAsciiPunct=function(e){switch(e){case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:case 41:case 42:case 43:case 44:case 45:case 46:case 47:case 58:case 59:case 60:case 61:case 62:case 63:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 124:case 125:case 126:return!0;default:return!1}},t.isPunctChar=function(e){return m.test(e)},t.escapeRE=function(e){return e.replace(g,\"\\\\$&\")},t.normalizeReference=function(e){return e=e.trim().replace(/\\s+/g,\" \"),\"Ṿ\"===\"ẞ\".toLowerCase()&&(e=e.replace(/ẞ/g,\"ß\")),e.toLowerCase().toUpperCase()}},function(e,t,r){\"use strict\";function n(){return(n=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}r.d(t,\"a\",(function(){return n}))},function(e,t,r){\"use strict\";r.d(t,\"a\",(function(){return o}));var n=r(16),i=r.n(n),s=r(0);function o(e){var t=e.codeHighlightExtensionMap,r=void 0===t?{}:t,n=e.hasLang,i=void 0===n?function(){return!0}:n,o=e.highlight,a=void 0===o?function(e){return e}:o,c=e.codeBlockClass;return function(e,t){var n=Object(s.escapeHtml)(e);return(t=r[t]||t)&&i(t)&&(n=a(e,t)),'<pre class=\"'+function(e){return c?c(e):\"language-\"+e}(t)+'\"><code>'+n+\"</code></pre>\"}}t.b=function(){var e=new i.a;return e.set({html:!0,breaks:!0,linkify:!1,typographer:!0}),e}},function(e,t){e.exports=/[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4E\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDF55-\\uDF59]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/},function(e,t,r){\"use strict\";function n(){this.__rules__=[],this.__cache__=null}n.prototype.__find__=function(e){for(var t=0;t<this.__rules__.length;t++)if(this.__rules__[t].name===e)return t;return-1},n.prototype.__compile__=function(){var e=this,t=[\"\"];e.__rules__.forEach((function(e){e.enabled&&e.alt.forEach((function(e){t.indexOf(e)<0&&t.push(e)}))})),e.__cache__={},t.forEach((function(t){e.__cache__[t]=[],e.__rules__.forEach((function(r){r.enabled&&(t&&r.alt.indexOf(t)<0||e.__cache__[t].push(r.fn))}))}))},n.prototype.at=function(e,t,r){var n=this.__find__(e),i=r||{};if(-1===n)throw new Error(\"Parser rule not found: \"+e);this.__rules__[n].fn=t,this.__rules__[n].alt=i.alt||[],this.__cache__=null},n.prototype.before=function(e,t,r,n){var i=this.__find__(e),s=n||{};if(-1===i)throw new Error(\"Parser rule not found: \"+e);this.__rules__.splice(i,0,{name:t,enabled:!0,fn:r,alt:s.alt||[]}),this.__cache__=null},n.prototype.after=function(e,t,r,n){var i=this.__find__(e),s=n||{};if(-1===i)throw new Error(\"Parser rule not found: \"+e);this.__rules__.splice(i+1,0,{name:t,enabled:!0,fn:r,alt:s.alt||[]}),this.__cache__=null},n.prototype.push=function(e,t,r){var n=r||{};this.__rules__.push({name:e,enabled:!0,fn:t,alt:n.alt||[]}),this.__cache__=null},n.prototype.enable=function(e,t){Array.isArray(e)||(e=[e]);var r=[];return e.forEach((function(e){var n=this.__find__(e);if(n<0){if(t)return;throw new Error(\"Rules manager: invalid rule name \"+e)}this.__rules__[n].enabled=!0,r.push(e)}),this),this.__cache__=null,r},n.prototype.enableOnly=function(e,t){Array.isArray(e)||(e=[e]),this.__rules__.forEach((function(e){e.enabled=!1})),this.enable(e,t)},n.prototype.disable=function(e,t){Array.isArray(e)||(e=[e]);var r=[];return e.forEach((function(e){var n=this.__find__(e);if(n<0){if(t)return;throw new Error(\"Rules manager: invalid rule name \"+e)}this.__rules__[n].enabled=!1,r.push(e)}),this),this.__cache__=null,r},n.prototype.getRules=function(e){return null===this.__cache__&&this.__compile__(),this.__cache__[e]||[]},e.exports=n},function(e,t,r){\"use strict\";function n(e,t,r){this.type=e,this.tag=t,this.attrs=null,this.map=null,this.nesting=r,this.level=0,this.children=null,this.content=\"\",this.markup=\"\",this.info=\"\",this.meta=null,this.block=!1,this.hidden=!1}n.prototype.attrIndex=function(e){var t,r,n;if(!this.attrs)return-1;for(r=0,n=(t=this.attrs).length;r<n;r++)if(t[r][0]===e)return r;return-1},n.prototype.attrPush=function(e){this.attrs?this.attrs.push(e):this.attrs=[e]},n.prototype.attrSet=function(e,t){var r=this.attrIndex(e),n=[e,t];r<0?this.attrPush(n):this.attrs[r]=n},n.prototype.attrGet=function(e){var t=this.attrIndex(e),r=null;return t>=0&&(r=this.attrs[t][1]),r},n.prototype.attrJoin=function(e,t){var r=this.attrIndex(e);r<0?this.attrPush([e,t]):this.attrs[r][1]=this.attrs[r][1]+\" \"+t},e.exports=n},function(e,t,r){\"use strict\";const n=/[\\u0000-\\u001f]/g,i=/[\\s~`!@#$%^&*()\\-_+=[\\]{}|\\\\;:\"'“”‘’–—<>,.?/]+/g,s=/[\\u0300-\\u036F]/g;e.exports=function(e){return e.normalize(\"NFKD\").replace(s,\"\").replace(n,\"\").replace(i,\"-\").replace(/\\-{2,}/g,\"-\").replace(/^\\-+|\\-+$/g,\"\").replace(/^(\\d)/,\"_$1\").toLowerCase()}},function(e,t,r){\"use strict\";e.exports=r(21)},function(e,t,r){\"use strict\";e.exports.encode=r(22),e.exports.decode=r(23),e.exports.format=r(24),e.exports.parse=r(25)},function(e,t){e.exports=/[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/},function(e,t){e.exports=/[\\0-\\x1F\\x7F-\\x9F]/},function(e,t){e.exports=/[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/},function(e,t,r){\"use strict\";var n=\"<[A-Za-z][A-Za-z0-9\\\\-]*(?:\\\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\\\s*=\\\\s*(?:[^\\\"'=<>`\\\\x00-\\\\x20]+|'[^']*'|\\\"[^\\\"]*\\\"))?)*\\\\s*\\\\/?>\",i=\"<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>\",s=new RegExp(\"^(?:\"+n+\"|\"+i+\"|\\x3c!----\\x3e|\\x3c!--(?:-?[^>-])(?:-?[^-])*--\\x3e|<[?][\\\\s\\\\S]*?[?]>|<![A-Z]+\\\\s+[^>]*>|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>)\"),o=new RegExp(\"^(?:\"+n+\"|\"+i+\")\");e.exports.HTML_TAG_RE=s,e.exports.HTML_OPEN_CLOSE_TAG_RE=o},function(e,t,r){\"use strict\";function n(e,t){var r,n,i,s,o,a=[],c=t.length;for(r=0;r<c;r++)126===(i=t[r]).marker&&-1!==i.end&&(s=t[i.end],(o=e.tokens[i.token]).type=\"s_open\",o.tag=\"s\",o.nesting=1,o.markup=\"~~\",o.content=\"\",(o=e.tokens[s.token]).type=\"s_close\",o.tag=\"s\",o.nesting=-1,o.markup=\"~~\",o.content=\"\",\"text\"===e.tokens[s.token-1].type&&\"~\"===e.tokens[s.token-1].content&&a.push(s.token-1));for(;a.length;){for(n=(r=a.pop())+1;n<e.tokens.length&&\"s_close\"===e.tokens[n].type;)n++;r!==--n&&(o=e.tokens[n],e.tokens[n]=e.tokens[r],e.tokens[r]=o)}}e.exports.tokenize=function(e,t){var r,n,i,s,o=e.pos,a=e.src.charCodeAt(o);if(t)return!1;if(126!==a)return!1;if(i=(n=e.scanDelims(e.pos,!0)).length,s=String.fromCharCode(a),i<2)return!1;for(i%2&&(e.push(\"text\",\"\",0).content=s,i--),r=0;r<i;r+=2)e.push(\"text\",\"\",0).content=s+s,e.delimiters.push({marker:a,length:0,token:e.tokens.length-1,end:-1,open:n.can_open,close:n.can_close});return e.pos+=n.length,!0},e.exports.postProcess=function(e){var t,r=e.tokens_meta,i=e.tokens_meta.length;for(n(e,e.delimiters),t=0;t<i;t++)r[t]&&r[t].delimiters&&n(e,r[t].delimiters)}},function(e,t,r){\"use strict\";function n(e,t){var r,n,i,s,o,a;for(r=t.length-1;r>=0;r--)95!==(n=t[r]).marker&&42!==n.marker||-1!==n.end&&(i=t[n.end],a=r>0&&t[r-1].end===n.end+1&&t[r-1].marker===n.marker&&t[r-1].token===n.token-1&&t[n.end+1].token===i.token+1,o=String.fromCharCode(n.marker),(s=e.tokens[n.token]).type=a?\"strong_open\":\"em_open\",s.tag=a?\"strong\":\"em\",s.nesting=1,s.markup=a?o+o:o,s.content=\"\",(s=e.tokens[i.token]).type=a?\"strong_close\":\"em_close\",s.tag=a?\"strong\":\"em\",s.nesting=-1,s.markup=a?o+o:o,s.content=\"\",a&&(e.tokens[t[r-1].token].content=\"\",e.tokens[t[n.end+1].token].content=\"\",r--))}e.exports.tokenize=function(e,t){var r,n,i=e.pos,s=e.src.charCodeAt(i);if(t)return!1;if(95!==s&&42!==s)return!1;for(n=e.scanDelims(e.pos,42===s),r=0;r<n.length;r++)e.push(\"text\",\"\",0).content=String.fromCharCode(s),e.delimiters.push({marker:s,length:n.length,token:e.tokens.length-1,end:-1,open:n.can_open,close:n.can_close});return e.pos+=n.length,!0},e.exports.postProcess=function(e){var t,r=e.tokens_meta,i=e.tokens_meta.length;for(n(e,e.delimiters),t=0;t<i;t++)r[t]&&r[t].delimiters&&n(e,r[t].delimiters)}},function(e,t,r){\"use strict\";const n=r(18),i={leftDelimiter:\"{\",rightDelimiter:\"}\",allowedAttributes:[]};function s(e,t,r){let n={match:!1,j:null},i=void 0!==r.shift?t+r.shift:r.position,l=(u=e,(p=i)>=0?u[p]:u[u.length+p]);var u,p;if(void 0===l)return n;for(let e in r)if(\"shift\"!==e&&\"position\"!==e){if(void 0===l[e])return n;if(\"children\"===e&&o(r.children)){if(0===l.children.length)return n;let e,t=r.children,i=l.children;if(t.every(e=>void 0!==e.position)){if(e=t.every(e=>s(i,e.position,e).match),e){let e=c(t).position;n.j=e>=0?e:i.length+e}}else for(let r=0;r<i.length;r++)if(e=t.every(e=>s(i,r,e).match),e){n.j=r;break}if(!1===e)return n}else switch(typeof r[e]){case\"boolean\":case\"number\":case\"string\":if(l[e]!==r[e])return n;break;case\"function\":if(!r[e](l[e]))return n;break;case\"object\":if(a(r[e])){if(!1===r[e].every(t=>t(l[e])))return n;break}default:throw new Error(`Unknown type of pattern test (key: ${e}). Test should be of type boolean, number, string, function or array of functions.`)}}return n.match=!0,n}function o(e){return Array.isArray(e)&&e.length&&e.every(e=>\"object\"==typeof e)}function a(e){return Array.isArray(e)&&e.length&&e.every(e=>\"function\"==typeof e)}function c(e){return e.slice(-1)[0]||{}}e.exports=function(e,t){let r=Object.assign({},i);r=Object.assign(r,t);const o=n(r);e.core.ruler.before(\"linkify\",\"curly_attributes\",(function(e){let t=e.tokens;for(let e=0;e<t.length;e++)for(let r=0;r<o.length;r++){let n=o[r],i=null;n.tests.every(r=>{let n=s(t,e,r);return null!==n.j&&(i=n.j),n.match})&&(n.transform(t,e,i),\"inline attributes\"!==n.name&&\"inline nesting 0\"!==n.name||r--)}}))}},function(e,t,r){\"use strict\";e.exports=r(20)},function(e,t,r){\"use strict\";r.r(t),r.d(t,\"default\",(function(){return g}));var n=r(1),i=r(15),s=r.n(i),o=function(e,t){var r=(void 0===t?{}:t).lineMarkup,n=void 0===r?\"data-line\":r,i=function(e,t,r,n,i){return i.renderToken(e,t,r)};function s(e){return function(t,r,i,s,o){var a=t[r];return a.attrPush([n,a.map[0]+1]),e(t,r,i,s,o)}}function o(e){return function(t,r,i,s,o){var a=e(t,r,i,s,o),c=t[r].map[0]+1;return\"<div \"+n+'=\"'+c+'\">'+a+\"</div>\"}}var a={table_open:s,blockquote_open:s,bullet_list_open:s,ordered_list_open:s,reference_open:s,heading_open:s,lheading_open:s,paragraph_open:s,hr:s,html_block:o,code_block:o,fence:o};Object.keys(a).forEach((function(t){var r=e.renderer.rules[t]||i;e.renderer.rules[t]=a[t](r)}))},a=function(e,t){void 0===t&&(t={});var r=t.getMarks;r&&e.core.ruler.push(\"anchor\",(function(e){var t={},n=e.tokens;n.filter((function(e){return\"heading_open\"===e.type})).forEach((function(e){var i=n[n.indexOf(e)+1].content,s=Number(e.tag.substr(1));t[i]=i in t?Number(t[i])+1:\"\";var o=r(i,s,t[i]);o&&o.forEach((function(t){var r=t.attr,n=t.value;e.attrPush([r,n])}))}))}))},c={includeLevel:[2,3],containerClass:\"table-of-contents\",listClass:\"table-of-content-list\",listItemClass:\"table-of-content-list-item\",markerPattern:/^\\[\\[toc\\]\\]/im,listType:\"ul\",getAnchorAttrs:function(){return[]},format:void 0,forceFullToc:!1,containerHeaderHtml:void 0,containerFooterHtml:void 0,transformLink:void 0},l=function(e,t){var r,i=Object(n.a)({},c,t),s=i.markerPattern;function o(e,t,r){for(var n,s,a=[],c=\"\",l=t.length,u=e;u<l;){var p=t[u],h=t[u-1],f=p.tag&&parseInt(p.tag.substr(1,1));if(\"heading_close\"===p.type&&-1!=i.includeLevel.indexOf(f)&&\"inline\"===h.type){if(n){if(f>n){c+=(s=o(u,t,r))[1],u=s[0];continue}if(f<n)return c+=\"</li>\",a.push(c),[u,\"<\"+i.listType+' class=\"'+i.listClass+'\">'+a.join(\"\")+\"</\"+i.listType+\">\"];f==n&&(c+=\"</li>\",a.push(c))}else n=f;var d=h.children.reduce((function(e,t){return e+t.content}),\"\"),g=h.content,m=r[g]=g in r?Number(r[g])+1:\"\",_=i.getAnchorAttrs(g,f,m);c='<li class=\"'+i.listItemClass+'\">\\n      <a '+_.map((function(e){return e.attr+'=\"'+e.value+'\"'})).join(\" \")+\">\",c+=d,c+=\"</a>\",u++}else u++}return c+=\"\"===c?\"\":\"</li>\",a.push(c),[u,\"<\"+i.listType+' class=\"'+i.listClass+'\">'+a.join(\"\")+\"</\"+i.listType+\">\"]}e.renderer.rules.toc_open=function(e,t){var r='<div class=\"'+i.containerClass+'\">';return i.containerHeaderHtml&&(r+=i.containerHeaderHtml),r},e.renderer.rules.toc_close=function(e,t){var r=\"\";return i.containerFooterHtml&&(r=i.containerFooterHtml),r+\"</div>\"},e.renderer.rules.toc_body=function(e,t){var n={};if(i.forceFullToc){for(var s=\"\",a=0,c=r&&r.tokens&&r.tokens.length;a<c;){var l=o(a,r.tokens,n);a=l[0],s+=l[1]}return s}return o(0,r.tokens,n)[1]},e.core.ruler.push(\"grab_state\",(function(e){r=e})),e.inline.ruler.after(\"emphasis\",\"toc\",(function(e,t){var r;if(91!==e.src.charCodeAt(e.pos))return!1;if(t)return!1;if((r=(r=s.exec(e.src.substr(e.pos)))?r.filter((function(e){return e})):[]).length<1)return!1;e.push(\"toc_open\",\"toc\",1).markup=\"[[toc]]\",e.push(\"toc_body\",\"\",0),e.push(\"toc_close\",\"toc\",-1);var n=e.src.indexOf(\"\\n\",e.pos);return e.pos=-1!==n?n:e.pos+e.posMax+1,!0}))},u=function(e,t){void 0===t&&(t={});var r=t.getWrapperClass,n=void 0===r?function(e){return\"language-\"+e}:r,i=function(e){return function(){for(var t=arguments.length,r=new Array(t),i=0;i<t;i++)r[i]=arguments[i];var s=r[0],o=r[1],a=s[o],c=e.apply(void 0,r);return'\\x3c!--beforebegin--\\x3e<div class=\"'+n(a.info.trim())+' extra-class\" extra-attr>\\x3c!--afterbegin--\\x3e'+c+\"\\x3c!--beforeend--\\x3e</div>\\x3c!--afterend--\\x3e\"}},s=e.renderer.rules,o=s.fence,a=s.code_block;e.renderer.rules.fence=i(o),e.renderer.rules.code_block=i(a)},p=function(e,t){var r=t.externalAttrs,n=t.openLinkIcon,i=t.openLinkIconClass,s=!1;e.renderer.rules.link_open=function(e,t,n,i,o){var a=e[t],c=a.attrIndex(\"href\");if(c>=0){var l=a.attrs[c][1];/^https?:/.test(l)&&(Object.keys(r).forEach((function(e){a.attrSet(e,r[e])})),/_blank/i.test(r.target)&&(s=!0))}return o.renderToken(e,t,n)},e.renderer.rules.link_close=function(e,t,r,o,a){return s&&(s=!1,n)?i?'<i class=\"'+i+'\"></i>'+a.renderToken(e,t,r):'<svg xmlns=\"http://www.w3.org/2000/svg\" aria-hidden=\"true\" focusable=\"false\" x=\"0px\" y=\"0px\" viewBox=\"0 0 100 100\" width=\"15\" height=\"15\" class=\"v-md-svg-outbound\"><path fill=\"currentColor\" d=\"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z\"></path> <polygon fill=\"currentColor\" points=\"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9\"></polygon></svg>'+a.renderToken(e,t,r):a.renderToken(e,t,r)}},h=r(6),f=r.n(h),d=r(2);function g(e){var t=void 0===e?{}:e,r=t.toc,i=t.link,c=t.attrs,h=Object(d.b)();return h.use(p,Object(n.a)({externalAttrs:{target:\"_blank\"}},i)).use(u,{getWrapperClass:function(e){return\"v-md-pre-wrapper v-md-pre-wrapper-\"+e}}).use(s.a,Object(n.a)({leftDelimiter:\"{{{\",rightDelimiter:\"}}}\"},c,{allowedAttributes:[\"width\",\"height\"].concat(null==c?void 0:c.allowedAttributes)})).use(a,{getMarks:function(e,t,r){return[{attr:\"data-v-md-heading\",value:f()(e)+(r?\"-\"+r:\"\")}]}}).use(l,Object(n.a)({listClass:\"v-md-toc\",listItemClass:\"v-md-toc-item\",getAnchorAttrs:function(e,t,r){return[{attr:\"data-v-md-anchor\",value:f()(e)+(r?\"-\"+r:\"\")}]}},r)).use(o,{lineMarkup:\"data-v-md-line\"}),{previewClass:\"markdown-body\",extend:function(e){e(h)},markdownParser:h}}},function(e,t,r){\"use strict\";const n=r(19);function i(e){return e.slice(-1)[0]}e.exports=e=>{const t=new RegExp(\"^ {0,3}[-*_]{3,} ?\"+n.escapeRegExp(e.leftDelimiter)+\"[^\"+n.escapeRegExp(e.rightDelimiter)+\"]\");return[{name:\"fenced code blocks\",tests:[{shift:0,block:!0,info:n.hasDelimiters(\"end\",e)}],transform:(t,r)=>{let i=t[r],s=i.info.lastIndexOf(e.leftDelimiter),o=n.getAttrs(i.info,s,e);n.addAttrs(o,i),i.info=n.removeDelimiter(i.info,e)}},{name:\"inline nesting 0\",tests:[{shift:0,type:\"inline\",children:[{shift:-1,type:e=>\"image\"===e||\"code_inline\"===e},{shift:0,type:\"text\",content:n.hasDelimiters(\"start\",e)}]}],transform:(t,r,i)=>{let s=t[r].children[i],o=s.content.indexOf(e.rightDelimiter),a=t[r].children[i-1],c=n.getAttrs(s.content,0,e);n.addAttrs(c,a),s.content.length===o+e.rightDelimiter.length?t[r].children.splice(i,1):s.content=s.content.slice(o+e.rightDelimiter.length)}},{name:\"tables\",tests:[{shift:0,type:\"table_close\"},{shift:1,type:\"paragraph_open\"},{shift:2,type:\"inline\",content:n.hasDelimiters(\"only\",e)}],transform:(t,r)=>{let i=t[r+2],s=n.getMatchingOpeningToken(t,r),o=n.getAttrs(i.content,0,e);n.addAttrs(o,s),t.splice(r+1,3)}},{name:\"inline attributes\",tests:[{shift:0,type:\"inline\",children:[{shift:-1,nesting:-1},{shift:0,type:\"text\",content:n.hasDelimiters(\"start\",e)}]}],transform:(t,r,i)=>{let s=t[r].children[i],o=s.content,a=n.getAttrs(o,0,e),c=n.getMatchingOpeningToken(t[r].children,i-1);n.addAttrs(a,c),s.content=o.slice(o.indexOf(e.rightDelimiter)+e.rightDelimiter.length)}},{name:\"list softbreak\",tests:[{shift:-2,type:\"list_item_open\"},{shift:0,type:\"inline\",children:[{position:-2,type:\"softbreak\"},{position:-1,type:\"text\",content:n.hasDelimiters(\"only\",e)}]}],transform:(t,r,i)=>{let s=t[r].children[i].content,o=n.getAttrs(s,0,e),a=r-2;for(;t[a-1]&&\"ordered_list_open\"!==t[a-1].type&&\"bullet_list_open\"!==t[a-1].type;)a--;n.addAttrs(o,t[a-1]),t[r].children=t[r].children.slice(0,-2)}},{name:\"list double softbreak\",tests:[{shift:0,type:e=>\"bullet_list_close\"===e||\"ordered_list_close\"===e},{shift:1,type:\"paragraph_open\"},{shift:2,type:\"inline\",content:n.hasDelimiters(\"only\",e),children:e=>1===e.length},{shift:3,type:\"paragraph_close\"}],transform:(t,r)=>{let i=t[r+2].content,s=n.getAttrs(i,0,e),o=n.getMatchingOpeningToken(t,r);n.addAttrs(s,o),t.splice(r+1,3)}},{name:\"list item end\",tests:[{shift:-2,type:\"list_item_open\"},{shift:0,type:\"inline\",children:[{position:-1,type:\"text\",content:n.hasDelimiters(\"end\",e)}]}],transform:(t,r,s)=>{let o=t[r].children[s],a=o.content,c=n.getAttrs(a,a.lastIndexOf(e.leftDelimiter),e);n.addAttrs(c,t[r-2]);let l=a.slice(0,a.lastIndexOf(e.leftDelimiter));o.content=\" \"!==i(l)?l:l.slice(0,-1)}},{name:\"\\n{.a} softbreak then curly in start\",tests:[{shift:0,type:\"inline\",children:[{position:-2,type:\"softbreak\"},{position:-1,type:\"text\",content:n.hasDelimiters(\"only\",e)}]}],transform:(t,r,i)=>{let s=t[r].children[i],o=n.getAttrs(s.content,0,e),a=r+1;for(;t[a+1]&&-1===t[a+1].nesting;)a++;let c=n.getMatchingOpeningToken(t,a);n.addAttrs(o,c),t[r].children=t[r].children.slice(0,-2)}},{name:\"horizontal rule\",tests:[{shift:0,type:\"paragraph_open\"},{shift:1,type:\"inline\",children:e=>1===e.length,content:e=>null!==e.match(t)},{shift:2,type:\"paragraph_close\"}],transform:(t,r)=>{let i=t[r];i.type=\"hr\",i.tag=\"hr\",i.nesting=0;let s=t[r+1].content,o=s.lastIndexOf(e.leftDelimiter);i.attrs=n.getAttrs(s,o,e),i.markup=s,t.splice(r+1,2)}},{name:\"end of block\",tests:[{shift:0,type:\"inline\",children:[{position:-1,content:n.hasDelimiters(\"end\",e),type:e=>\"code_inline\"!==e}]}],transform:(t,r,s)=>{let o=t[r].children[s],a=o.content,c=n.getAttrs(a,a.lastIndexOf(e.leftDelimiter),e),l=r+1;for(;t[l+1]&&-1===t[l+1].nesting;)l++;let u=n.getMatchingOpeningToken(t,l);n.addAttrs(c,u);let p=a.slice(0,a.lastIndexOf(e.leftDelimiter));o.content=\" \"!==i(p)?p:p.slice(0,-1)}}]}},function(e,t,r){\"use strict\";function n(e){return e.replace(/[-/\\\\^$*+?.()|[\\]{}]/g,\"\\\\$&\")}t.getAttrs=function(e,t,r){const n=/[^\\t\\n\\f />\"'=]/,i=[];let s=\"\",o=\"\",a=!0,c=!1;for(let l=t+r.leftDelimiter.length;l<e.length;l++){if(e.slice(l,l+r.rightDelimiter.length)===r.rightDelimiter){\"\"!==s&&i.push([s,o]);break}let t=e.charAt(l);if(\"=\"===t&&a)a=!1;else if(\".\"!==t||\"\"!==s)if(\"#\"!==t||\"\"!==s)if('\"'!==t||\"\"!==o)if('\"'===t&&c)c=!1;else if(\" \"!==t||c)a&&-1===t.search(n)||(a?s+=t:o+=t);else{if(\"\"===s)continue;i.push([s,o]),s=\"\",o=\"\",a=!0}else c=!0;else s=\"id\",a=!1;else\".\"===e.charAt(l+1)?(s=\"css-module\",l+=1):s=\"class\",a=!1}if(r.allowedAttributes&&r.allowedAttributes.length){let e=r.allowedAttributes;return i.filter((function(t){let r=t[0];return e.some((function(e){return r===e||e instanceof RegExp&&e.test(r)}))}))}return i},t.addAttrs=function(e,t){for(let r=0,n=e.length;r<n;++r){let n=e[r][0];\"class\"===n?t.attrJoin(\"class\",e[r][1]):\"css-module\"===n?t.attrJoin(\"css-module\",e[r][1]):t.attrPush(e[r])}return t},t.hasDelimiters=function(e,t){if(!e)throw new Error('Parameter `where` not passed. Should be \"start\", \"middle\", \"end\" or \"only\".');return function(r){let n,i,s,o,a=t.leftDelimiter.length+1+t.rightDelimiter.length;if(!r||\"string\"!=typeof r||r.length<a)return!1;let c=a-t.rightDelimiter.length;switch(e){case\"start\":s=r.slice(0,t.leftDelimiter.length),n=s===t.leftDelimiter?0:-1,i=-1===n?-1:r.indexOf(t.rightDelimiter,c),o=r.charAt(i+t.rightDelimiter.length),o&&-1!==t.rightDelimiter.indexOf(o)&&(i=-1);break;case\"end\":n=r.lastIndexOf(t.leftDelimiter),i=-1===n?-1:r.indexOf(t.rightDelimiter,n+c),i=i===r.length-t.rightDelimiter.length?i:-1;break;case\"only\":s=r.slice(0,t.leftDelimiter.length),n=s===t.leftDelimiter?0:-1,s=r.slice(r.length-t.rightDelimiter.length),i=s===t.rightDelimiter?r.length-t.rightDelimiter.length:-1}return-1!==n&&-1!==i&&function(e){let r=\".\"===e.charAt(t.leftDelimiter.length),n=\"#\"===e.charAt(t.leftDelimiter.length);return r||n?e.length>=a+1:e.length>=a}(r.substring(n,i+t.rightDelimiter.length))}},t.removeDelimiter=function(e,t){const r=n(t.leftDelimiter),i=n(t.rightDelimiter);let s=new RegExp(\"[ \\\\n]?\"+r+\"[^\"+r+i+\"]+\"+i+\"$\"),o=e.search(s);return-1!==o?e.slice(0,o):e},t.escapeRegExp=n,t.getMatchingOpeningToken=function(e,t){if(\"softbreak\"===e[t].type)return!1;if(0===e[t].nesting)return e[t];let r=e[t].level,n=e[t].type.replace(\"_close\",\"_open\");for(;t>=0;--t)if(e[t].type===n&&e[t].level===r)return e[t]};let i=/[&<>\"]/,s=/[&<>\"]/g,o={\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\"};function a(e){return o[e]}t.escapeHtml=function(e){return i.test(e)?e.replace(s,a):e}},function(e,t,r){\"use strict\";var n=r(0),i=r(28),s=r(32),o=r(33),a=r(41),c=r(55),l=r(68),u=r(8),p=r(70),h={default:r(73),zero:r(74),commonmark:r(75)},f=/^(vbscript|javascript|file|data):/,d=/^data:image\\/(gif|png|jpeg|webp);/;function g(e){var t=e.trim().toLowerCase();return!f.test(t)||!!d.test(t)}var m=[\"http:\",\"https:\",\"mailto:\"];function _(e){var t=u.parse(e,!0);if(t.hostname&&(!t.protocol||m.indexOf(t.protocol)>=0))try{t.hostname=p.toASCII(t.hostname)}catch(e){}return u.encode(u.format(t))}function b(e){var t=u.parse(e,!0);if(t.hostname&&(!t.protocol||m.indexOf(t.protocol)>=0))try{t.hostname=p.toUnicode(t.hostname)}catch(e){}return u.decode(u.format(t),u.decode.defaultChars+\"%\")}function k(e,t){if(!(this instanceof k))return new k(e,t);t||n.isString(e)||(t=e||{},e=\"default\"),this.inline=new c,this.block=new a,this.core=new o,this.renderer=new s,this.linkify=new l,this.validateLink=g,this.normalizeLink=_,this.normalizeLinkText=b,this.utils=n,this.helpers=n.assign({},i),this.options={},this.configure(e),t&&this.set(t)}k.prototype.set=function(e){return n.assign(this.options,e),this},k.prototype.configure=function(e){var t,r=this;if(n.isString(e)&&!(e=h[t=e]))throw new Error('Wrong `markdown-it` preset \"'+t+'\", check name');if(!e)throw new Error(\"Wrong `markdown-it` preset, can't be empty\");return e.options&&r.set(e.options),e.components&&Object.keys(e.components).forEach((function(t){e.components[t].rules&&r[t].ruler.enableOnly(e.components[t].rules),e.components[t].rules2&&r[t].ruler2.enableOnly(e.components[t].rules2)})),this},k.prototype.enable=function(e,t){var r=[];Array.isArray(e)||(e=[e]),[\"core\",\"block\",\"inline\"].forEach((function(t){r=r.concat(this[t].ruler.enable(e,!0))}),this),r=r.concat(this.inline.ruler2.enable(e,!0));var n=e.filter((function(e){return r.indexOf(e)<0}));if(n.length&&!t)throw new Error(\"MarkdownIt. Failed to enable unknown rule(s): \"+n);return this},k.prototype.disable=function(e,t){var r=[];Array.isArray(e)||(e=[e]),[\"core\",\"block\",\"inline\"].forEach((function(t){r=r.concat(this[t].ruler.disable(e,!0))}),this),r=r.concat(this.inline.ruler2.disable(e,!0));var n=e.filter((function(e){return r.indexOf(e)<0}));if(n.length&&!t)throw new Error(\"MarkdownIt. Failed to disable unknown rule(s): \"+n);return this},k.prototype.use=function(e){var t=[this].concat(Array.prototype.slice.call(arguments,1));return e.apply(e,t),this},k.prototype.parse=function(e,t){if(\"string\"!=typeof e)throw new Error(\"Input data should be a String\");var r=new this.core.State(e,this,t);return this.core.process(r),r.tokens},k.prototype.render=function(e,t){return t=t||{},this.renderer.render(this.parse(e,t),this.options,t)},k.prototype.parseInline=function(e,t){var r=new this.core.State(e,this,t);return r.inlineMode=!0,this.core.process(r),r.tokens},k.prototype.renderInline=function(e,t){return t=t||{},this.renderer.render(this.parseInline(e,t),this.options,t)},e.exports=k},function(e){e.exports=JSON.parse('{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"\\'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}')},function(e,t,r){\"use strict\";var n={};function i(e,t,r){var s,o,a,c,l,u=\"\";for(\"string\"!=typeof t&&(r=t,t=i.defaultChars),void 0===r&&(r=!0),l=function(e){var t,r,i=n[e];if(i)return i;for(i=n[e]=[],t=0;t<128;t++)r=String.fromCharCode(t),/^[0-9a-z]$/i.test(r)?i.push(r):i.push(\"%\"+(\"0\"+t.toString(16).toUpperCase()).slice(-2));for(t=0;t<e.length;t++)i[e.charCodeAt(t)]=e[t];return i}(t),s=0,o=e.length;s<o;s++)if(a=e.charCodeAt(s),r&&37===a&&s+2<o&&/^[0-9a-f]{2}$/i.test(e.slice(s+1,s+3)))u+=e.slice(s,s+3),s+=2;else if(a<128)u+=l[a];else if(a>=55296&&a<=57343){if(a>=55296&&a<=56319&&s+1<o&&(c=e.charCodeAt(s+1))>=56320&&c<=57343){u+=encodeURIComponent(e[s]+e[s+1]),s++;continue}u+=\"%EF%BF%BD\"}else u+=encodeURIComponent(e[s]);return u}i.defaultChars=\";/?:@&=+$,-_.!~*'()#\",i.componentChars=\"-_.!~*'()\",e.exports=i},function(e,t,r){\"use strict\";var n={};function i(e,t){var r;return\"string\"!=typeof t&&(t=i.defaultChars),r=function(e){var t,r,i=n[e];if(i)return i;for(i=n[e]=[],t=0;t<128;t++)r=String.fromCharCode(t),i.push(r);for(t=0;t<e.length;t++)i[r=e.charCodeAt(t)]=\"%\"+(\"0\"+r.toString(16).toUpperCase()).slice(-2);return i}(t),e.replace(/(%[a-f0-9]{2})+/gi,(function(e){var t,n,i,s,o,a,c,l=\"\";for(t=0,n=e.length;t<n;t+=3)(i=parseInt(e.slice(t+1,t+3),16))<128?l+=r[i]:192==(224&i)&&t+3<n&&128==(192&(s=parseInt(e.slice(t+4,t+6),16)))?(l+=(c=i<<6&1984|63&s)<128?\"��\":String.fromCharCode(c),t+=3):224==(240&i)&&t+6<n&&(s=parseInt(e.slice(t+4,t+6),16),o=parseInt(e.slice(t+7,t+9),16),128==(192&s)&&128==(192&o))?(l+=(c=i<<12&61440|s<<6&4032|63&o)<2048||c>=55296&&c<=57343?\"���\":String.fromCharCode(c),t+=6):240==(248&i)&&t+9<n&&(s=parseInt(e.slice(t+4,t+6),16),o=parseInt(e.slice(t+7,t+9),16),a=parseInt(e.slice(t+10,t+12),16),128==(192&s)&&128==(192&o)&&128==(192&a))?((c=i<<18&1835008|s<<12&258048|o<<6&4032|63&a)<65536||c>1114111?l+=\"����\":(c-=65536,l+=String.fromCharCode(55296+(c>>10),56320+(1023&c))),t+=9):l+=\"�\";return l}))}i.defaultChars=\";/?:@&=+$,#\",i.componentChars=\"\",e.exports=i},function(e,t,r){\"use strict\";e.exports=function(e){var t=\"\";return t+=e.protocol||\"\",t+=e.slashes?\"//\":\"\",t+=e.auth?e.auth+\"@\":\"\",e.hostname&&-1!==e.hostname.indexOf(\":\")?t+=\"[\"+e.hostname+\"]\":t+=e.hostname||\"\",t+=e.port?\":\"+e.port:\"\",t+=e.pathname||\"\",t+=e.search||\"\",t+=e.hash||\"\"}},function(e,t,r){\"use strict\";function n(){this.protocol=null,this.slashes=null,this.auth=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.pathname=null}var i=/^([a-z0-9.+-]+:)/i,s=/:[0-9]*$/,o=/^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,a=[\"{\",\"}\",\"|\",\"\\\\\",\"^\",\"`\"].concat([\"<\",\">\",'\"',\"`\",\" \",\"\\r\",\"\\n\",\"\\t\"]),c=[\"'\"].concat(a),l=[\"%\",\"/\",\"?\",\";\",\"#\"].concat(c),u=[\"/\",\"?\",\"#\"],p=/^[+a-z0-9A-Z_-]{0,63}$/,h=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,f={javascript:!0,\"javascript:\":!0},d={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,\"http:\":!0,\"https:\":!0,\"ftp:\":!0,\"gopher:\":!0,\"file:\":!0};n.prototype.parse=function(e,t){var r,n,s,a,c,g=e;if(g=g.trim(),!t&&1===e.split(\"#\").length){var m=o.exec(g);if(m)return this.pathname=m[1],m[2]&&(this.search=m[2]),this}var _=i.exec(g);if(_&&(s=(_=_[0]).toLowerCase(),this.protocol=_,g=g.substr(_.length)),(t||_||g.match(/^\\/\\/[^@\\/]+@[^@\\/]+/))&&(!(c=\"//\"===g.substr(0,2))||_&&f[_]||(g=g.substr(2),this.slashes=!0)),!f[_]&&(c||_&&!d[_])){var b,k,v=-1;for(r=0;r<u.length;r++)-1!==(a=g.indexOf(u[r]))&&(-1===v||a<v)&&(v=a);for(-1!==(k=-1===v?g.lastIndexOf(\"@\"):g.lastIndexOf(\"@\",v))&&(b=g.slice(0,k),g=g.slice(k+1),this.auth=b),v=-1,r=0;r<l.length;r++)-1!==(a=g.indexOf(l[r]))&&(-1===v||a<v)&&(v=a);-1===v&&(v=g.length),\":\"===g[v-1]&&v--;var y=g.slice(0,v);g=g.slice(v),this.parseHost(y),this.hostname=this.hostname||\"\";var x=\"[\"===this.hostname[0]&&\"]\"===this.hostname[this.hostname.length-1];if(!x){var C=this.hostname.split(/\\./);for(r=0,n=C.length;r<n;r++){var A=C[r];if(A&&!A.match(p)){for(var D=\"\",w=0,E=A.length;w<E;w++)A.charCodeAt(w)>127?D+=\"x\":D+=A[w];if(!D.match(p)){var q=C.slice(0,r),S=C.slice(r+1),F=A.match(h);F&&(q.push(F[1]),S.unshift(F[2])),S.length&&(g=S.join(\".\")+g),this.hostname=q.join(\".\");break}}}}this.hostname.length>255&&(this.hostname=\"\"),x&&(this.hostname=this.hostname.substr(1,this.hostname.length-2))}var T=g.indexOf(\"#\");-1!==T&&(this.hash=g.substr(T),g=g.slice(0,T));var L=g.indexOf(\"?\");return-1!==L&&(this.search=g.substr(L),g=g.slice(0,L)),g&&(this.pathname=g),d[s]&&this.hostname&&!this.pathname&&(this.pathname=\"\"),this},n.prototype.parseHost=function(e){var t=s.exec(e);t&&(\":\"!==(t=t[0])&&(this.port=t.substr(1)),e=e.substr(0,e.length-t.length)),e&&(this.hostname=e)},e.exports=function(e,t){if(e&&e instanceof n)return e;var r=new n;return r.parse(e,t),r}},function(e,t,r){\"use strict\";t.Any=r(9),t.Cc=r(10),t.Cf=r(27),t.P=r(3),t.Z=r(11)},function(e,t){e.exports=/[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/},function(e,t,r){\"use strict\";t.parseLinkLabel=r(29),t.parseLinkDestination=r(30),t.parseLinkTitle=r(31)},function(e,t,r){\"use strict\";e.exports=function(e,t,r){var n,i,s,o,a=-1,c=e.posMax,l=e.pos;for(e.pos=t+1,n=1;e.pos<c;){if(93===(s=e.src.charCodeAt(e.pos))&&0===--n){i=!0;break}if(o=e.pos,e.md.inline.skipToken(e),91===s)if(o===e.pos-1)n++;else if(r)return e.pos=l,-1}return i&&(a=e.pos),e.pos=l,a}},function(e,t,r){\"use strict\";var n=r(0).unescapeAll;e.exports=function(e,t,r){var i,s,o=t,a={ok:!1,pos:0,lines:0,str:\"\"};if(60===e.charCodeAt(t)){for(t++;t<r;){if(10===(i=e.charCodeAt(t)))return a;if(60===i)return a;if(62===i)return a.pos=t+1,a.str=n(e.slice(o+1,t)),a.ok=!0,a;92===i&&t+1<r?t+=2:t++}return a}for(s=0;t<r&&32!==(i=e.charCodeAt(t))&&!(i<32||127===i);)if(92===i&&t+1<r){if(32===e.charCodeAt(t+1))break;t+=2}else{if(40===i&&++s>32)return a;if(41===i){if(0===s)break;s--}t++}return o===t||0!==s||(a.str=n(e.slice(o,t)),a.lines=0,a.pos=t,a.ok=!0),a}},function(e,t,r){\"use strict\";var n=r(0).unescapeAll;e.exports=function(e,t,r){var i,s,o=0,a=t,c={ok:!1,pos:0,lines:0,str:\"\"};if(t>=r)return c;if(34!==(s=e.charCodeAt(t))&&39!==s&&40!==s)return c;for(t++,40===s&&(s=41);t<r;){if((i=e.charCodeAt(t))===s)return c.pos=t+1,c.lines=o,c.str=n(e.slice(a+1,t)),c.ok=!0,c;if(40===i&&41===s)return c;10===i?o++:92===i&&t+1<r&&(t++,10===e.charCodeAt(t)&&o++),t++}return c}},function(e,t,r){\"use strict\";var n=r(0).assign,i=r(0).unescapeAll,s=r(0).escapeHtml,o={};function a(){this.rules=n({},o)}o.code_inline=function(e,t,r,n,i){var o=e[t];return\"<code\"+i.renderAttrs(o)+\">\"+s(e[t].content)+\"</code>\"},o.code_block=function(e,t,r,n,i){var o=e[t];return\"<pre\"+i.renderAttrs(o)+\"><code>\"+s(e[t].content)+\"</code></pre>\\n\"},o.fence=function(e,t,r,n,o){var a,c,l,u,p,h=e[t],f=h.info?i(h.info).trim():\"\",d=\"\",g=\"\";return f&&(d=(l=f.split(/(\\s+)/g))[0],g=l.slice(2).join(\"\")),0===(a=r.highlight&&r.highlight(h.content,d,g)||s(h.content)).indexOf(\"<pre\")?a+\"\\n\":f?(c=h.attrIndex(\"class\"),u=h.attrs?h.attrs.slice():[],c<0?u.push([\"class\",r.langPrefix+d]):(u[c]=u[c].slice(),u[c][1]+=\" \"+r.langPrefix+d),p={attrs:u},\"<pre><code\"+o.renderAttrs(p)+\">\"+a+\"</code></pre>\\n\"):\"<pre><code\"+o.renderAttrs(h)+\">\"+a+\"</code></pre>\\n\"},o.image=function(e,t,r,n,i){var s=e[t];return s.attrs[s.attrIndex(\"alt\")][1]=i.renderInlineAsText(s.children,r,n),i.renderToken(e,t,r)},o.hardbreak=function(e,t,r){return r.xhtmlOut?\"<br />\\n\":\"<br>\\n\"},o.softbreak=function(e,t,r){return r.breaks?r.xhtmlOut?\"<br />\\n\":\"<br>\\n\":\"\\n\"},o.text=function(e,t){return s(e[t].content)},o.html_block=function(e,t){return e[t].content},o.html_inline=function(e,t){return e[t].content},a.prototype.renderAttrs=function(e){var t,r,n;if(!e.attrs)return\"\";for(n=\"\",t=0,r=e.attrs.length;t<r;t++)n+=\" \"+s(e.attrs[t][0])+'=\"'+s(e.attrs[t][1])+'\"';return n},a.prototype.renderToken=function(e,t,r){var n,i=\"\",s=!1,o=e[t];return o.hidden?\"\":(o.block&&-1!==o.nesting&&t&&e[t-1].hidden&&(i+=\"\\n\"),i+=(-1===o.nesting?\"</\":\"<\")+o.tag,i+=this.renderAttrs(o),0===o.nesting&&r.xhtmlOut&&(i+=\" /\"),o.block&&(s=!0,1===o.nesting&&t+1<e.length&&(\"inline\"===(n=e[t+1]).type||n.hidden||-1===n.nesting&&n.tag===o.tag)&&(s=!1)),i+=s?\">\\n\":\">\")},a.prototype.renderInline=function(e,t,r){for(var n,i=\"\",s=this.rules,o=0,a=e.length;o<a;o++)void 0!==s[n=e[o].type]?i+=s[n](e,o,t,r,this):i+=this.renderToken(e,o,t);return i},a.prototype.renderInlineAsText=function(e,t,r){for(var n=\"\",i=0,s=e.length;i<s;i++)\"text\"===e[i].type?n+=e[i].content:\"image\"===e[i].type?n+=this.renderInlineAsText(e[i].children,t,r):\"softbreak\"===e[i].type&&(n+=\"\\n\");return n},a.prototype.render=function(e,t,r){var n,i,s,o=\"\",a=this.rules;for(n=0,i=e.length;n<i;n++)\"inline\"===(s=e[n].type)?o+=this.renderInline(e[n].children,t,r):void 0!==a[s]?o+=a[e[n].type](e,n,t,r,this):o+=this.renderToken(e,n,t,r);return o},e.exports=a},function(e,t,r){\"use strict\";var n=r(4),i=[[\"normalize\",r(34)],[\"block\",r(35)],[\"inline\",r(36)],[\"linkify\",r(37)],[\"replacements\",r(38)],[\"smartquotes\",r(39)]];function s(){this.ruler=new n;for(var e=0;e<i.length;e++)this.ruler.push(i[e][0],i[e][1])}s.prototype.process=function(e){var t,r,n;for(t=0,r=(n=this.ruler.getRules(\"\")).length;t<r;t++)n[t](e)},s.prototype.State=r(40),e.exports=s},function(e,t,r){\"use strict\";var n=/\\r\\n?|\\n/g,i=/\\0/g;e.exports=function(e){var t;t=(t=e.src.replace(n,\"\\n\")).replace(i,\"�\"),e.src=t}},function(e,t,r){\"use strict\";e.exports=function(e){var t;e.inlineMode?((t=new e.Token(\"inline\",\"\",0)).content=e.src,t.map=[0,1],t.children=[],e.tokens.push(t)):e.md.block.parse(e.src,e.md,e.env,e.tokens)}},function(e,t,r){\"use strict\";e.exports=function(e){var t,r,n,i=e.tokens;for(r=0,n=i.length;r<n;r++)\"inline\"===(t=i[r]).type&&e.md.inline.parse(t.content,e.md,e.env,t.children)}},function(e,t,r){\"use strict\";var n=r(0).arrayReplaceAt;function i(e){return/^<\\/a\\s*>/i.test(e)}e.exports=function(e){var t,r,s,o,a,c,l,u,p,h,f,d,g,m,_,b,k,v,y=e.tokens;if(e.md.options.linkify)for(r=0,s=y.length;r<s;r++)if(\"inline\"===y[r].type&&e.md.linkify.pretest(y[r].content))for(g=0,t=(o=y[r].children).length-1;t>=0;t--)if(\"link_close\"!==(c=o[t]).type){if(\"html_inline\"===c.type&&(v=c.content,/^<a[>\\s]/i.test(v)&&g>0&&g--,i(c.content)&&g++),!(g>0)&&\"text\"===c.type&&e.md.linkify.test(c.content)){for(p=c.content,k=e.md.linkify.match(p),l=[],d=c.level,f=0,u=0;u<k.length;u++)m=k[u].url,_=e.md.normalizeLink(m),e.md.validateLink(_)&&(b=k[u].text,b=k[u].schema?\"mailto:\"!==k[u].schema||/^mailto:/i.test(b)?e.md.normalizeLinkText(b):e.md.normalizeLinkText(\"mailto:\"+b).replace(/^mailto:/,\"\"):e.md.normalizeLinkText(\"http://\"+b).replace(/^http:\\/\\//,\"\"),(h=k[u].index)>f&&((a=new e.Token(\"text\",\"\",0)).content=p.slice(f,h),a.level=d,l.push(a)),(a=new e.Token(\"link_open\",\"a\",1)).attrs=[[\"href\",_]],a.level=d++,a.markup=\"linkify\",a.info=\"auto\",l.push(a),(a=new e.Token(\"text\",\"\",0)).content=b,a.level=d,l.push(a),(a=new e.Token(\"link_close\",\"a\",-1)).level=--d,a.markup=\"linkify\",a.info=\"auto\",l.push(a),f=k[u].lastIndex);f<p.length&&((a=new e.Token(\"text\",\"\",0)).content=p.slice(f),a.level=d,l.push(a)),y[r].children=o=n(o,t,l)}}else for(t--;o[t].level!==c.level&&\"link_open\"!==o[t].type;)t--}},function(e,t,r){\"use strict\";var n=/\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/,i=/\\((c|tm|r|p)\\)/i,s=/\\((c|tm|r|p)\\)/gi,o={c:\"©\",r:\"®\",p:\"§\",tm:\"™\"};function a(e,t){return o[t.toLowerCase()]}function c(e){var t,r,n=0;for(t=e.length-1;t>=0;t--)\"text\"!==(r=e[t]).type||n||(r.content=r.content.replace(s,a)),\"link_open\"===r.type&&\"auto\"===r.info&&n--,\"link_close\"===r.type&&\"auto\"===r.info&&n++}function l(e){var t,r,i=0;for(t=e.length-1;t>=0;t--)\"text\"!==(r=e[t]).type||i||n.test(r.content)&&(r.content=r.content.replace(/\\+-/g,\"±\").replace(/\\.{2,}/g,\"…\").replace(/([?!])…/g,\"$1..\").replace(/([?!]){4,}/g,\"$1$1$1\").replace(/,{2,}/g,\",\").replace(/(^|[^-])---(?=[^-]|$)/gm,\"$1—\").replace(/(^|\\s)--(?=\\s|$)/gm,\"$1–\").replace(/(^|[^-\\s])--(?=[^-\\s]|$)/gm,\"$1–\")),\"link_open\"===r.type&&\"auto\"===r.info&&i--,\"link_close\"===r.type&&\"auto\"===r.info&&i++}e.exports=function(e){var t;if(e.md.options.typographer)for(t=e.tokens.length-1;t>=0;t--)\"inline\"===e.tokens[t].type&&(i.test(e.tokens[t].content)&&c(e.tokens[t].children),n.test(e.tokens[t].content)&&l(e.tokens[t].children))}},function(e,t,r){\"use strict\";var n=r(0).isWhiteSpace,i=r(0).isPunctChar,s=r(0).isMdAsciiPunct,o=/['\"]/,a=/['\"]/g;function c(e,t,r){return e.substr(0,t)+r+e.substr(t+1)}function l(e,t){var r,o,l,u,p,h,f,d,g,m,_,b,k,v,y,x,C,A,D,w,E;for(D=[],r=0;r<e.length;r++){for(o=e[r],f=e[r].level,C=D.length-1;C>=0&&!(D[C].level<=f);C--);if(D.length=C+1,\"text\"===o.type){p=0,h=(l=o.content).length;e:for(;p<h&&(a.lastIndex=p,u=a.exec(l));){if(y=x=!0,p=u.index+1,A=\"'\"===u[0],g=32,u.index-1>=0)g=l.charCodeAt(u.index-1);else for(C=r-1;C>=0&&(\"softbreak\"!==e[C].type&&\"hardbreak\"!==e[C].type);C--)if(e[C].content){g=e[C].content.charCodeAt(e[C].content.length-1);break}if(m=32,p<h)m=l.charCodeAt(p);else for(C=r+1;C<e.length&&(\"softbreak\"!==e[C].type&&\"hardbreak\"!==e[C].type);C++)if(e[C].content){m=e[C].content.charCodeAt(0);break}if(_=s(g)||i(String.fromCharCode(g)),b=s(m)||i(String.fromCharCode(m)),k=n(g),(v=n(m))?y=!1:b&&(k||_||(y=!1)),k?x=!1:_&&(v||b||(x=!1)),34===m&&'\"'===u[0]&&g>=48&&g<=57&&(x=y=!1),y&&x&&(y=_,x=b),y||x){if(x)for(C=D.length-1;C>=0&&(d=D[C],!(D[C].level<f));C--)if(d.single===A&&D[C].level===f){d=D[C],A?(w=t.md.options.quotes[2],E=t.md.options.quotes[3]):(w=t.md.options.quotes[0],E=t.md.options.quotes[1]),o.content=c(o.content,u.index,E),e[d.token].content=c(e[d.token].content,d.pos,w),p+=E.length-1,d.token===r&&(p+=w.length-1),h=(l=o.content).length,D.length=C;continue e}y?D.push({token:r,pos:u.index,single:A,level:f}):x&&A&&(o.content=c(o.content,u.index,\"’\"))}else A&&(o.content=c(o.content,u.index,\"’\"))}}}}e.exports=function(e){var t;if(e.md.options.typographer)for(t=e.tokens.length-1;t>=0;t--)\"inline\"===e.tokens[t].type&&o.test(e.tokens[t].content)&&l(e.tokens[t].children,e)}},function(e,t,r){\"use strict\";var n=r(5);function i(e,t,r){this.src=e,this.env=r,this.tokens=[],this.inlineMode=!1,this.md=t}i.prototype.Token=n,e.exports=i},function(e,t,r){\"use strict\";var n=r(4),i=[[\"table\",r(42),[\"paragraph\",\"reference\"]],[\"code\",r(43)],[\"fence\",r(44),[\"paragraph\",\"reference\",\"blockquote\",\"list\"]],[\"blockquote\",r(45),[\"paragraph\",\"reference\",\"blockquote\",\"list\"]],[\"hr\",r(46),[\"paragraph\",\"reference\",\"blockquote\",\"list\"]],[\"list\",r(47),[\"paragraph\",\"reference\",\"blockquote\"]],[\"reference\",r(48)],[\"html_block\",r(49),[\"paragraph\",\"reference\",\"blockquote\"]],[\"heading\",r(51),[\"paragraph\",\"reference\",\"blockquote\"]],[\"lheading\",r(52)],[\"paragraph\",r(53)]];function s(){this.ruler=new n;for(var e=0;e<i.length;e++)this.ruler.push(i[e][0],i[e][1],{alt:(i[e][2]||[]).slice()})}s.prototype.tokenize=function(e,t,r){for(var n,i=this.ruler.getRules(\"\"),s=i.length,o=t,a=!1,c=e.md.options.maxNesting;o<r&&(e.line=o=e.skipEmptyLines(o),!(o>=r))&&!(e.sCount[o]<e.blkIndent);){if(e.level>=c){e.line=r;break}for(n=0;n<s&&!i[n](e,o,r,!1);n++);e.tight=!a,e.isEmpty(e.line-1)&&(a=!0),(o=e.line)<r&&e.isEmpty(o)&&(a=!0,o++,e.line=o)}},s.prototype.parse=function(e,t,r,n){var i;e&&(i=new this.State(e,t,r,n),this.tokenize(i,i.line,i.lineMax))},s.prototype.State=r(54),e.exports=s},function(e,t,r){\"use strict\";var n=r(0).isSpace;function i(e,t){var r=e.bMarks[t]+e.tShift[t],n=e.eMarks[t];return e.src.substr(r,n-r)}function s(e){var t,r=[],n=0,i=e.length,s=!1,o=0,a=\"\";for(t=e.charCodeAt(n);n<i;)124===t&&(s?(a+=e.substring(o,n-1),o=n):(r.push(a+e.substring(o,n)),a=\"\",o=n+1)),s=92===t,n++,t=e.charCodeAt(n);return r.push(a+e.substring(o)),r}e.exports=function(e,t,r,o){var a,c,l,u,p,h,f,d,g,m,_,b,k,v,y,x,C,A;if(t+2>r)return!1;if(h=t+1,e.sCount[h]<e.blkIndent)return!1;if(e.sCount[h]-e.blkIndent>=4)return!1;if((l=e.bMarks[h]+e.tShift[h])>=e.eMarks[h])return!1;if(124!==(C=e.src.charCodeAt(l++))&&45!==C&&58!==C)return!1;if(l>=e.eMarks[h])return!1;if(124!==(A=e.src.charCodeAt(l++))&&45!==A&&58!==A&&!n(A))return!1;if(45===C&&n(A))return!1;for(;l<e.eMarks[h];){if(124!==(a=e.src.charCodeAt(l))&&45!==a&&58!==a&&!n(a))return!1;l++}for(f=(c=i(e,t+1)).split(\"|\"),m=[],u=0;u<f.length;u++){if(!(_=f[u].trim())){if(0===u||u===f.length-1)continue;return!1}if(!/^:?-+:?$/.test(_))return!1;58===_.charCodeAt(_.length-1)?m.push(58===_.charCodeAt(0)?\"center\":\"right\"):58===_.charCodeAt(0)?m.push(\"left\"):m.push(\"\")}if(-1===(c=i(e,t).trim()).indexOf(\"|\"))return!1;if(e.sCount[t]-e.blkIndent>=4)return!1;if((f=s(c)).length&&\"\"===f[0]&&f.shift(),f.length&&\"\"===f[f.length-1]&&f.pop(),0===(d=f.length)||d!==m.length)return!1;if(o)return!0;for(v=e.parentType,e.parentType=\"table\",x=e.md.block.ruler.getRules(\"blockquote\"),(g=e.push(\"table_open\",\"table\",1)).map=b=[t,0],(g=e.push(\"thead_open\",\"thead\",1)).map=[t,t+1],(g=e.push(\"tr_open\",\"tr\",1)).map=[t,t+1],u=0;u<f.length;u++)g=e.push(\"th_open\",\"th\",1),m[u]&&(g.attrs=[[\"style\",\"text-align:\"+m[u]]]),(g=e.push(\"inline\",\"\",0)).content=f[u].trim(),g.children=[],g=e.push(\"th_close\",\"th\",-1);for(g=e.push(\"tr_close\",\"tr\",-1),g=e.push(\"thead_close\",\"thead\",-1),h=t+2;h<r&&!(e.sCount[h]<e.blkIndent);h++){for(y=!1,u=0,p=x.length;u<p;u++)if(x[u](e,h,r,!0)){y=!0;break}if(y)break;if(!(c=i(e,h).trim()))break;if(e.sCount[h]-e.blkIndent>=4)break;for((f=s(c)).length&&\"\"===f[0]&&f.shift(),f.length&&\"\"===f[f.length-1]&&f.pop(),h===t+2&&((g=e.push(\"tbody_open\",\"tbody\",1)).map=k=[t+2,0]),(g=e.push(\"tr_open\",\"tr\",1)).map=[h,h+1],u=0;u<d;u++)g=e.push(\"td_open\",\"td\",1),m[u]&&(g.attrs=[[\"style\",\"text-align:\"+m[u]]]),(g=e.push(\"inline\",\"\",0)).content=f[u]?f[u].trim():\"\",g.children=[],g=e.push(\"td_close\",\"td\",-1);g=e.push(\"tr_close\",\"tr\",-1)}return k&&(g=e.push(\"tbody_close\",\"tbody\",-1),k[1]=h),g=e.push(\"table_close\",\"table\",-1),b[1]=h,e.parentType=v,e.line=h,!0}},function(e,t,r){\"use strict\";e.exports=function(e,t,r){var n,i,s;if(e.sCount[t]-e.blkIndent<4)return!1;for(i=n=t+1;n<r;)if(e.isEmpty(n))n++;else{if(!(e.sCount[n]-e.blkIndent>=4))break;i=++n}return e.line=i,(s=e.push(\"code_block\",\"code\",0)).content=e.getLines(t,i,4+e.blkIndent,!1)+\"\\n\",s.map=[t,e.line],!0}},function(e,t,r){\"use strict\";e.exports=function(e,t,r,n){var i,s,o,a,c,l,u,p=!1,h=e.bMarks[t]+e.tShift[t],f=e.eMarks[t];if(e.sCount[t]-e.blkIndent>=4)return!1;if(h+3>f)return!1;if(126!==(i=e.src.charCodeAt(h))&&96!==i)return!1;if(c=h,(s=(h=e.skipChars(h,i))-c)<3)return!1;if(u=e.src.slice(c,h),o=e.src.slice(h,f),96===i&&o.indexOf(String.fromCharCode(i))>=0)return!1;if(n)return!0;for(a=t;!(++a>=r)&&!((h=c=e.bMarks[a]+e.tShift[a])<(f=e.eMarks[a])&&e.sCount[a]<e.blkIndent);)if(e.src.charCodeAt(h)===i&&!(e.sCount[a]-e.blkIndent>=4||(h=e.skipChars(h,i))-c<s||(h=e.skipSpaces(h))<f)){p=!0;break}return s=e.sCount[t],e.line=a+(p?1:0),(l=e.push(\"fence\",\"code\",0)).info=o,l.content=e.getLines(t+1,a,s,!0),l.markup=u,l.map=[t,e.line],!0}},function(e,t,r){\"use strict\";var n=r(0).isSpace;e.exports=function(e,t,r,i){var s,o,a,c,l,u,p,h,f,d,g,m,_,b,k,v,y,x,C,A,D=e.lineMax,w=e.bMarks[t]+e.tShift[t],E=e.eMarks[t];if(e.sCount[t]-e.blkIndent>=4)return!1;if(62!==e.src.charCodeAt(w++))return!1;if(i)return!0;for(c=f=e.sCount[t]+1,32===e.src.charCodeAt(w)?(w++,c++,f++,s=!1,v=!0):9===e.src.charCodeAt(w)?(v=!0,(e.bsCount[t]+f)%4==3?(w++,c++,f++,s=!1):s=!0):v=!1,d=[e.bMarks[t]],e.bMarks[t]=w;w<E&&(o=e.src.charCodeAt(w),n(o));)9===o?f+=4-(f+e.bsCount[t]+(s?1:0))%4:f++,w++;for(g=[e.bsCount[t]],e.bsCount[t]=e.sCount[t]+1+(v?1:0),u=w>=E,b=[e.sCount[t]],e.sCount[t]=f-c,k=[e.tShift[t]],e.tShift[t]=w-e.bMarks[t],x=e.md.block.ruler.getRules(\"blockquote\"),_=e.parentType,e.parentType=\"blockquote\",h=t+1;h<r&&(A=e.sCount[h]<e.blkIndent,!((w=e.bMarks[h]+e.tShift[h])>=(E=e.eMarks[h])));h++)if(62!==e.src.charCodeAt(w++)||A){if(u)break;for(y=!1,a=0,l=x.length;a<l;a++)if(x[a](e,h,r,!0)){y=!0;break}if(y){e.lineMax=h,0!==e.blkIndent&&(d.push(e.bMarks[h]),g.push(e.bsCount[h]),k.push(e.tShift[h]),b.push(e.sCount[h]),e.sCount[h]-=e.blkIndent);break}d.push(e.bMarks[h]),g.push(e.bsCount[h]),k.push(e.tShift[h]),b.push(e.sCount[h]),e.sCount[h]=-1}else{for(c=f=e.sCount[h]+1,32===e.src.charCodeAt(w)?(w++,c++,f++,s=!1,v=!0):9===e.src.charCodeAt(w)?(v=!0,(e.bsCount[h]+f)%4==3?(w++,c++,f++,s=!1):s=!0):v=!1,d.push(e.bMarks[h]),e.bMarks[h]=w;w<E&&(o=e.src.charCodeAt(w),n(o));)9===o?f+=4-(f+e.bsCount[h]+(s?1:0))%4:f++,w++;u=w>=E,g.push(e.bsCount[h]),e.bsCount[h]=e.sCount[h]+1+(v?1:0),b.push(e.sCount[h]),e.sCount[h]=f-c,k.push(e.tShift[h]),e.tShift[h]=w-e.bMarks[h]}for(m=e.blkIndent,e.blkIndent=0,(C=e.push(\"blockquote_open\",\"blockquote\",1)).markup=\">\",C.map=p=[t,0],e.md.block.tokenize(e,t,h),(C=e.push(\"blockquote_close\",\"blockquote\",-1)).markup=\">\",e.lineMax=D,e.parentType=_,p[1]=e.line,a=0;a<k.length;a++)e.bMarks[a+t]=d[a],e.tShift[a+t]=k[a],e.sCount[a+t]=b[a],e.bsCount[a+t]=g[a];return e.blkIndent=m,!0}},function(e,t,r){\"use strict\";var n=r(0).isSpace;e.exports=function(e,t,r,i){var s,o,a,c,l=e.bMarks[t]+e.tShift[t],u=e.eMarks[t];if(e.sCount[t]-e.blkIndent>=4)return!1;if(42!==(s=e.src.charCodeAt(l++))&&45!==s&&95!==s)return!1;for(o=1;l<u;){if((a=e.src.charCodeAt(l++))!==s&&!n(a))return!1;a===s&&o++}return!(o<3)&&(i||(e.line=t+1,(c=e.push(\"hr\",\"hr\",0)).map=[t,e.line],c.markup=Array(o+1).join(String.fromCharCode(s))),!0)}},function(e,t,r){\"use strict\";var n=r(0).isSpace;function i(e,t){var r,i,s,o;return i=e.bMarks[t]+e.tShift[t],s=e.eMarks[t],42!==(r=e.src.charCodeAt(i++))&&45!==r&&43!==r||i<s&&(o=e.src.charCodeAt(i),!n(o))?-1:i}function s(e,t){var r,i=e.bMarks[t]+e.tShift[t],s=i,o=e.eMarks[t];if(s+1>=o)return-1;if((r=e.src.charCodeAt(s++))<48||r>57)return-1;for(;;){if(s>=o)return-1;if(!((r=e.src.charCodeAt(s++))>=48&&r<=57)){if(41===r||46===r)break;return-1}if(s-i>=10)return-1}return s<o&&(r=e.src.charCodeAt(s),!n(r))?-1:s}e.exports=function(e,t,r,n){var o,a,c,l,u,p,h,f,d,g,m,_,b,k,v,y,x,C,A,D,w,E,q,S,F,T,L,z,M=!1,I=!0;if(e.sCount[t]-e.blkIndent>=4)return!1;if(e.listIndent>=0&&e.sCount[t]-e.listIndent>=4&&e.sCount[t]<e.blkIndent)return!1;if(n&&\"paragraph\"===e.parentType&&e.sCount[t]>=e.blkIndent&&(M=!0),(q=s(e,t))>=0){if(h=!0,F=e.bMarks[t]+e.tShift[t],b=Number(e.src.slice(F,q-1)),M&&1!==b)return!1}else{if(!((q=i(e,t))>=0))return!1;h=!1}if(M&&e.skipSpaces(q)>=e.eMarks[t])return!1;if(_=e.src.charCodeAt(q-1),n)return!0;for(m=e.tokens.length,h?(z=e.push(\"ordered_list_open\",\"ol\",1),1!==b&&(z.attrs=[[\"start\",b]])):z=e.push(\"bullet_list_open\",\"ul\",1),z.map=g=[t,0],z.markup=String.fromCharCode(_),v=t,S=!1,L=e.md.block.ruler.getRules(\"list\"),C=e.parentType,e.parentType=\"list\";v<r;){for(E=q,k=e.eMarks[v],p=y=e.sCount[v]+q-(e.bMarks[t]+e.tShift[t]);E<k;){if(9===(o=e.src.charCodeAt(E)))y+=4-(y+e.bsCount[v])%4;else{if(32!==o)break;y++}E++}if((u=(a=E)>=k?1:y-p)>4&&(u=1),l=p+u,(z=e.push(\"list_item_open\",\"li\",1)).markup=String.fromCharCode(_),z.map=f=[t,0],h&&(z.info=e.src.slice(F,q-1)),w=e.tight,D=e.tShift[t],A=e.sCount[t],x=e.listIndent,e.listIndent=e.blkIndent,e.blkIndent=l,e.tight=!0,e.tShift[t]=a-e.bMarks[t],e.sCount[t]=y,a>=k&&e.isEmpty(t+1)?e.line=Math.min(e.line+2,r):e.md.block.tokenize(e,t,r,!0),e.tight&&!S||(I=!1),S=e.line-t>1&&e.isEmpty(e.line-1),e.blkIndent=e.listIndent,e.listIndent=x,e.tShift[t]=D,e.sCount[t]=A,e.tight=w,(z=e.push(\"list_item_close\",\"li\",-1)).markup=String.fromCharCode(_),v=t=e.line,f[1]=v,a=e.bMarks[t],v>=r)break;if(e.sCount[v]<e.blkIndent)break;if(e.sCount[t]-e.blkIndent>=4)break;for(T=!1,c=0,d=L.length;c<d;c++)if(L[c](e,v,r,!0)){T=!0;break}if(T)break;if(h){if((q=s(e,v))<0)break;F=e.bMarks[v]+e.tShift[v]}else if((q=i(e,v))<0)break;if(_!==e.src.charCodeAt(q-1))break}return(z=h?e.push(\"ordered_list_close\",\"ol\",-1):e.push(\"bullet_list_close\",\"ul\",-1)).markup=String.fromCharCode(_),g[1]=v,e.line=v,e.parentType=C,I&&function(e,t){var r,n,i=e.level+2;for(r=t+2,n=e.tokens.length-2;r<n;r++)e.tokens[r].level===i&&\"paragraph_open\"===e.tokens[r].type&&(e.tokens[r+2].hidden=!0,e.tokens[r].hidden=!0,r+=2)}(e,m),!0}},function(e,t,r){\"use strict\";var n=r(0).normalizeReference,i=r(0).isSpace;e.exports=function(e,t,r,s){var o,a,c,l,u,p,h,f,d,g,m,_,b,k,v,y,x=0,C=e.bMarks[t]+e.tShift[t],A=e.eMarks[t],D=t+1;if(e.sCount[t]-e.blkIndent>=4)return!1;if(91!==e.src.charCodeAt(C))return!1;for(;++C<A;)if(93===e.src.charCodeAt(C)&&92!==e.src.charCodeAt(C-1)){if(C+1===A)return!1;if(58!==e.src.charCodeAt(C+1))return!1;break}for(l=e.lineMax,v=e.md.block.ruler.getRules(\"reference\"),g=e.parentType,e.parentType=\"reference\";D<l&&!e.isEmpty(D);D++)if(!(e.sCount[D]-e.blkIndent>3||e.sCount[D]<0)){for(k=!1,p=0,h=v.length;p<h;p++)if(v[p](e,D,l,!0)){k=!0;break}if(k)break}for(A=(b=e.getLines(t,D,e.blkIndent,!1).trim()).length,C=1;C<A;C++){if(91===(o=b.charCodeAt(C)))return!1;if(93===o){d=C;break}(10===o||92===o&&++C<A&&10===b.charCodeAt(C))&&x++}if(d<0||58!==b.charCodeAt(d+1))return!1;for(C=d+2;C<A;C++)if(10===(o=b.charCodeAt(C)))x++;else if(!i(o))break;if(!(m=e.md.helpers.parseLinkDestination(b,C,A)).ok)return!1;if(u=e.md.normalizeLink(m.str),!e.md.validateLink(u))return!1;for(a=C=m.pos,c=x+=m.lines,_=C;C<A;C++)if(10===(o=b.charCodeAt(C)))x++;else if(!i(o))break;for(m=e.md.helpers.parseLinkTitle(b,C,A),C<A&&_!==C&&m.ok?(y=m.str,C=m.pos,x+=m.lines):(y=\"\",C=a,x=c);C<A&&(o=b.charCodeAt(C),i(o));)C++;if(C<A&&10!==b.charCodeAt(C)&&y)for(y=\"\",C=a,x=c;C<A&&(o=b.charCodeAt(C),i(o));)C++;return!(C<A&&10!==b.charCodeAt(C))&&(!!(f=n(b.slice(1,d)))&&(s||(void 0===e.env.references&&(e.env.references={}),void 0===e.env.references[f]&&(e.env.references[f]={title:y,href:u}),e.parentType=g,e.line=t+x+1),!0))}},function(e,t,r){\"use strict\";var n=r(50),i=r(12).HTML_OPEN_CLOSE_TAG_RE,s=[[/^<(script|pre|style|textarea)(?=(\\s|>|$))/i,/<\\/(script|pre|style|textarea)>/i,!0],[/^<!--/,/-->/,!0],[/^<\\?/,/\\?>/,!0],[/^<![A-Z]/,/>/,!0],[/^<!\\[CDATA\\[/,/\\]\\]>/,!0],[new RegExp(\"^</?(\"+n.join(\"|\")+\")(?=(\\\\s|/?>|$))\",\"i\"),/^$/,!0],[new RegExp(i.source+\"\\\\s*$\"),/^$/,!1]];e.exports=function(e,t,r,n){var i,o,a,c,l=e.bMarks[t]+e.tShift[t],u=e.eMarks[t];if(e.sCount[t]-e.blkIndent>=4)return!1;if(!e.md.options.html)return!1;if(60!==e.src.charCodeAt(l))return!1;for(c=e.src.slice(l,u),i=0;i<s.length&&!s[i][0].test(c);i++);if(i===s.length)return!1;if(n)return s[i][2];if(o=t+1,!s[i][1].test(c))for(;o<r&&!(e.sCount[o]<e.blkIndent);o++)if(l=e.bMarks[o]+e.tShift[o],u=e.eMarks[o],c=e.src.slice(l,u),s[i][1].test(c)){0!==c.length&&o++;break}return e.line=o,(a=e.push(\"html_block\",\"\",0)).map=[t,o],a.content=e.getLines(t,o,e.blkIndent,!0),!0}},function(e,t,r){\"use strict\";e.exports=[\"address\",\"article\",\"aside\",\"base\",\"basefont\",\"blockquote\",\"body\",\"caption\",\"center\",\"col\",\"colgroup\",\"dd\",\"details\",\"dialog\",\"dir\",\"div\",\"dl\",\"dt\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"frame\",\"frameset\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hr\",\"html\",\"iframe\",\"legend\",\"li\",\"link\",\"main\",\"menu\",\"menuitem\",\"nav\",\"noframes\",\"ol\",\"optgroup\",\"option\",\"p\",\"param\",\"section\",\"source\",\"summary\",\"table\",\"tbody\",\"td\",\"tfoot\",\"th\",\"thead\",\"title\",\"tr\",\"track\",\"ul\"]},function(e,t,r){\"use strict\";var n=r(0).isSpace;e.exports=function(e,t,r,i){var s,o,a,c,l=e.bMarks[t]+e.tShift[t],u=e.eMarks[t];if(e.sCount[t]-e.blkIndent>=4)return!1;if(35!==(s=e.src.charCodeAt(l))||l>=u)return!1;for(o=1,s=e.src.charCodeAt(++l);35===s&&l<u&&o<=6;)o++,s=e.src.charCodeAt(++l);return!(o>6||l<u&&!n(s))&&(i||(u=e.skipSpacesBack(u,l),(a=e.skipCharsBack(u,35,l))>l&&n(e.src.charCodeAt(a-1))&&(u=a),e.line=t+1,(c=e.push(\"heading_open\",\"h\"+String(o),1)).markup=\"########\".slice(0,o),c.map=[t,e.line],(c=e.push(\"inline\",\"\",0)).content=e.src.slice(l,u).trim(),c.map=[t,e.line],c.children=[],(c=e.push(\"heading_close\",\"h\"+String(o),-1)).markup=\"########\".slice(0,o)),!0)}},function(e,t,r){\"use strict\";e.exports=function(e,t,r){var n,i,s,o,a,c,l,u,p,h,f=t+1,d=e.md.block.ruler.getRules(\"paragraph\");if(e.sCount[t]-e.blkIndent>=4)return!1;for(h=e.parentType,e.parentType=\"paragraph\";f<r&&!e.isEmpty(f);f++)if(!(e.sCount[f]-e.blkIndent>3)){if(e.sCount[f]>=e.blkIndent&&(c=e.bMarks[f]+e.tShift[f])<(l=e.eMarks[f])&&(45===(p=e.src.charCodeAt(c))||61===p)&&(c=e.skipChars(c,p),(c=e.skipSpaces(c))>=l)){u=61===p?1:2;break}if(!(e.sCount[f]<0)){for(i=!1,s=0,o=d.length;s<o;s++)if(d[s](e,f,r,!0)){i=!0;break}if(i)break}}return!!u&&(n=e.getLines(t,f,e.blkIndent,!1).trim(),e.line=f+1,(a=e.push(\"heading_open\",\"h\"+String(u),1)).markup=String.fromCharCode(p),a.map=[t,e.line],(a=e.push(\"inline\",\"\",0)).content=n,a.map=[t,e.line-1],a.children=[],(a=e.push(\"heading_close\",\"h\"+String(u),-1)).markup=String.fromCharCode(p),e.parentType=h,!0)}},function(e,t,r){\"use strict\";e.exports=function(e,t){var r,n,i,s,o,a,c=t+1,l=e.md.block.ruler.getRules(\"paragraph\"),u=e.lineMax;for(a=e.parentType,e.parentType=\"paragraph\";c<u&&!e.isEmpty(c);c++)if(!(e.sCount[c]-e.blkIndent>3||e.sCount[c]<0)){for(n=!1,i=0,s=l.length;i<s;i++)if(l[i](e,c,u,!0)){n=!0;break}if(n)break}return r=e.getLines(t,c,e.blkIndent,!1).trim(),e.line=c,(o=e.push(\"paragraph_open\",\"p\",1)).map=[t,e.line],(o=e.push(\"inline\",\"\",0)).content=r,o.map=[t,e.line],o.children=[],o=e.push(\"paragraph_close\",\"p\",-1),e.parentType=a,!0}},function(e,t,r){\"use strict\";var n=r(5),i=r(0).isSpace;function s(e,t,r,n){var s,o,a,c,l,u,p,h;for(this.src=e,this.md=t,this.env=r,this.tokens=n,this.bMarks=[],this.eMarks=[],this.tShift=[],this.sCount=[],this.bsCount=[],this.blkIndent=0,this.line=0,this.lineMax=0,this.tight=!1,this.ddIndent=-1,this.listIndent=-1,this.parentType=\"root\",this.level=0,this.result=\"\",h=!1,a=c=u=p=0,l=(o=this.src).length;c<l;c++){if(s=o.charCodeAt(c),!h){if(i(s)){u++,9===s?p+=4-p%4:p++;continue}h=!0}10!==s&&c!==l-1||(10!==s&&c++,this.bMarks.push(a),this.eMarks.push(c),this.tShift.push(u),this.sCount.push(p),this.bsCount.push(0),h=!1,u=0,p=0,a=c+1)}this.bMarks.push(o.length),this.eMarks.push(o.length),this.tShift.push(0),this.sCount.push(0),this.bsCount.push(0),this.lineMax=this.bMarks.length-1}s.prototype.push=function(e,t,r){var i=new n(e,t,r);return i.block=!0,r<0&&this.level--,i.level=this.level,r>0&&this.level++,this.tokens.push(i),i},s.prototype.isEmpty=function(e){return this.bMarks[e]+this.tShift[e]>=this.eMarks[e]},s.prototype.skipEmptyLines=function(e){for(var t=this.lineMax;e<t&&!(this.bMarks[e]+this.tShift[e]<this.eMarks[e]);e++);return e},s.prototype.skipSpaces=function(e){for(var t,r=this.src.length;e<r&&(t=this.src.charCodeAt(e),i(t));e++);return e},s.prototype.skipSpacesBack=function(e,t){if(e<=t)return e;for(;e>t;)if(!i(this.src.charCodeAt(--e)))return e+1;return e},s.prototype.skipChars=function(e,t){for(var r=this.src.length;e<r&&this.src.charCodeAt(e)===t;e++);return e},s.prototype.skipCharsBack=function(e,t,r){if(e<=r)return e;for(;e>r;)if(t!==this.src.charCodeAt(--e))return e+1;return e},s.prototype.getLines=function(e,t,r,n){var s,o,a,c,l,u,p,h=e;if(e>=t)return\"\";for(u=new Array(t-e),s=0;h<t;h++,s++){for(o=0,p=c=this.bMarks[h],l=h+1<t||n?this.eMarks[h]+1:this.eMarks[h];c<l&&o<r;){if(a=this.src.charCodeAt(c),i(a))9===a?o+=4-(o+this.bsCount[h])%4:o++;else{if(!(c-p<this.tShift[h]))break;o++}c++}u[s]=o>r?new Array(o-r+1).join(\" \")+this.src.slice(c,l):this.src.slice(c,l)}return u.join(\"\")},s.prototype.Token=n,e.exports=s},function(e,t,r){\"use strict\";var n=r(4),i=[[\"text\",r(56)],[\"newline\",r(57)],[\"escape\",r(58)],[\"backticks\",r(59)],[\"strikethrough\",r(13).tokenize],[\"emphasis\",r(14).tokenize],[\"link\",r(60)],[\"image\",r(61)],[\"autolink\",r(62)],[\"html_inline\",r(63)],[\"entity\",r(64)]],s=[[\"balance_pairs\",r(65)],[\"strikethrough\",r(13).postProcess],[\"emphasis\",r(14).postProcess],[\"text_collapse\",r(66)]];function o(){var e;for(this.ruler=new n,e=0;e<i.length;e++)this.ruler.push(i[e][0],i[e][1]);for(this.ruler2=new n,e=0;e<s.length;e++)this.ruler2.push(s[e][0],s[e][1])}o.prototype.skipToken=function(e){var t,r,n=e.pos,i=this.ruler.getRules(\"\"),s=i.length,o=e.md.options.maxNesting,a=e.cache;if(void 0===a[n]){if(e.level<o)for(r=0;r<s&&(e.level++,t=i[r](e,!0),e.level--,!t);r++);else e.pos=e.posMax;t||e.pos++,a[n]=e.pos}else e.pos=a[n]},o.prototype.tokenize=function(e){for(var t,r,n=this.ruler.getRules(\"\"),i=n.length,s=e.posMax,o=e.md.options.maxNesting;e.pos<s;){if(e.level<o)for(r=0;r<i&&!(t=n[r](e,!1));r++);if(t){if(e.pos>=s)break}else e.pending+=e.src[e.pos++]}e.pending&&e.pushPending()},o.prototype.parse=function(e,t,r,n){var i,s,o,a=new this.State(e,t,r,n);for(this.tokenize(a),o=(s=this.ruler2.getRules(\"\")).length,i=0;i<o;i++)s[i](a)},o.prototype.State=r(67),e.exports=o},function(e,t,r){\"use strict\";function n(e){switch(e){case 10:case 33:case 35:case 36:case 37:case 38:case 42:case 43:case 45:case 58:case 60:case 61:case 62:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 125:case 126:return!0;default:return!1}}e.exports=function(e,t){for(var r=e.pos;r<e.posMax&&!n(e.src.charCodeAt(r));)r++;return r!==e.pos&&(t||(e.pending+=e.src.slice(e.pos,r)),e.pos=r,!0)}},function(e,t,r){\"use strict\";var n=r(0).isSpace;e.exports=function(e,t){var r,i,s,o=e.pos;if(10!==e.src.charCodeAt(o))return!1;if(r=e.pending.length-1,i=e.posMax,!t)if(r>=0&&32===e.pending.charCodeAt(r))if(r>=1&&32===e.pending.charCodeAt(r-1)){for(s=r-1;s>=1&&32===e.pending.charCodeAt(s-1);)s--;e.pending=e.pending.slice(0,s),e.push(\"hardbreak\",\"br\",0)}else e.pending=e.pending.slice(0,-1),e.push(\"softbreak\",\"br\",0);else e.push(\"softbreak\",\"br\",0);for(o++;o<i&&n(e.src.charCodeAt(o));)o++;return e.pos=o,!0}},function(e,t,r){\"use strict\";for(var n=r(0).isSpace,i=[],s=0;s<256;s++)i.push(0);\"\\\\!\\\"#$%&'()*+,./:;<=>?@[]^_`{|}~-\".split(\"\").forEach((function(e){i[e.charCodeAt(0)]=1})),e.exports=function(e,t){var r,s=e.pos,o=e.posMax;if(92!==e.src.charCodeAt(s))return!1;if(++s<o){if((r=e.src.charCodeAt(s))<256&&0!==i[r])return t||(e.pending+=e.src[s]),e.pos+=2,!0;if(10===r){for(t||e.push(\"hardbreak\",\"br\",0),s++;s<o&&(r=e.src.charCodeAt(s),n(r));)s++;return e.pos=s,!0}}return t||(e.pending+=\"\\\\\"),e.pos++,!0}},function(e,t,r){\"use strict\";e.exports=function(e,t){var r,n,i,s,o,a,c,l,u=e.pos;if(96!==e.src.charCodeAt(u))return!1;for(r=u,u++,n=e.posMax;u<n&&96===e.src.charCodeAt(u);)u++;if(c=(i=e.src.slice(r,u)).length,e.backticksScanned&&(e.backticks[c]||0)<=r)return t||(e.pending+=i),e.pos+=c,!0;for(o=a=u;-1!==(o=e.src.indexOf(\"`\",a));){for(a=o+1;a<n&&96===e.src.charCodeAt(a);)a++;if((l=a-o)===c)return t||((s=e.push(\"code_inline\",\"code\",0)).markup=i,s.content=e.src.slice(u,o).replace(/\\n/g,\" \").replace(/^ (.+) $/,\"$1\")),e.pos=a,!0;e.backticks[l]=o}return e.backticksScanned=!0,t||(e.pending+=i),e.pos+=c,!0}},function(e,t,r){\"use strict\";var n=r(0).normalizeReference,i=r(0).isSpace;e.exports=function(e,t){var r,s,o,a,c,l,u,p,h=\"\",f=\"\",d=e.pos,g=e.posMax,m=e.pos,_=!0;if(91!==e.src.charCodeAt(e.pos))return!1;if(c=e.pos+1,(a=e.md.helpers.parseLinkLabel(e,e.pos,!0))<0)return!1;if((l=a+1)<g&&40===e.src.charCodeAt(l)){for(_=!1,l++;l<g&&(s=e.src.charCodeAt(l),i(s)||10===s);l++);if(l>=g)return!1;if(m=l,(u=e.md.helpers.parseLinkDestination(e.src,l,e.posMax)).ok){for(h=e.md.normalizeLink(u.str),e.md.validateLink(h)?l=u.pos:h=\"\",m=l;l<g&&(s=e.src.charCodeAt(l),i(s)||10===s);l++);if(u=e.md.helpers.parseLinkTitle(e.src,l,e.posMax),l<g&&m!==l&&u.ok)for(f=u.str,l=u.pos;l<g&&(s=e.src.charCodeAt(l),i(s)||10===s);l++);}(l>=g||41!==e.src.charCodeAt(l))&&(_=!0),l++}if(_){if(void 0===e.env.references)return!1;if(l<g&&91===e.src.charCodeAt(l)?(m=l+1,(l=e.md.helpers.parseLinkLabel(e,l))>=0?o=e.src.slice(m,l++):l=a+1):l=a+1,o||(o=e.src.slice(c,a)),!(p=e.env.references[n(o)]))return e.pos=d,!1;h=p.href,f=p.title}return t||(e.pos=c,e.posMax=a,e.push(\"link_open\",\"a\",1).attrs=r=[[\"href\",h]],f&&r.push([\"title\",f]),e.md.inline.tokenize(e),e.push(\"link_close\",\"a\",-1)),e.pos=l,e.posMax=g,!0}},function(e,t,r){\"use strict\";var n=r(0).normalizeReference,i=r(0).isSpace;e.exports=function(e,t){var r,s,o,a,c,l,u,p,h,f,d,g,m,_=\"\",b=e.pos,k=e.posMax;if(33!==e.src.charCodeAt(e.pos))return!1;if(91!==e.src.charCodeAt(e.pos+1))return!1;if(l=e.pos+2,(c=e.md.helpers.parseLinkLabel(e,e.pos+1,!1))<0)return!1;if((u=c+1)<k&&40===e.src.charCodeAt(u)){for(u++;u<k&&(s=e.src.charCodeAt(u),i(s)||10===s);u++);if(u>=k)return!1;for(m=u,(h=e.md.helpers.parseLinkDestination(e.src,u,e.posMax)).ok&&(_=e.md.normalizeLink(h.str),e.md.validateLink(_)?u=h.pos:_=\"\"),m=u;u<k&&(s=e.src.charCodeAt(u),i(s)||10===s);u++);if(h=e.md.helpers.parseLinkTitle(e.src,u,e.posMax),u<k&&m!==u&&h.ok)for(f=h.str,u=h.pos;u<k&&(s=e.src.charCodeAt(u),i(s)||10===s);u++);else f=\"\";if(u>=k||41!==e.src.charCodeAt(u))return e.pos=b,!1;u++}else{if(void 0===e.env.references)return!1;if(u<k&&91===e.src.charCodeAt(u)?(m=u+1,(u=e.md.helpers.parseLinkLabel(e,u))>=0?a=e.src.slice(m,u++):u=c+1):u=c+1,a||(a=e.src.slice(l,c)),!(p=e.env.references[n(a)]))return e.pos=b,!1;_=p.href,f=p.title}return t||(o=e.src.slice(l,c),e.md.inline.parse(o,e.md,e.env,g=[]),(d=e.push(\"image\",\"img\",0)).attrs=r=[[\"src\",_],[\"alt\",\"\"]],d.children=g,d.content=o,f&&r.push([\"title\",f])),e.pos=u,e.posMax=k,!0}},function(e,t,r){\"use strict\";var n=/^([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/,i=/^([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)$/;e.exports=function(e,t){var r,s,o,a,c,l,u=e.pos;if(60!==e.src.charCodeAt(u))return!1;for(c=e.pos,l=e.posMax;;){if(++u>=l)return!1;if(60===(a=e.src.charCodeAt(u)))return!1;if(62===a)break}return r=e.src.slice(c+1,u),i.test(r)?(s=e.md.normalizeLink(r),!!e.md.validateLink(s)&&(t||((o=e.push(\"link_open\",\"a\",1)).attrs=[[\"href\",s]],o.markup=\"autolink\",o.info=\"auto\",(o=e.push(\"text\",\"\",0)).content=e.md.normalizeLinkText(r),(o=e.push(\"link_close\",\"a\",-1)).markup=\"autolink\",o.info=\"auto\"),e.pos+=r.length+2,!0)):!!n.test(r)&&(s=e.md.normalizeLink(\"mailto:\"+r),!!e.md.validateLink(s)&&(t||((o=e.push(\"link_open\",\"a\",1)).attrs=[[\"href\",s]],o.markup=\"autolink\",o.info=\"auto\",(o=e.push(\"text\",\"\",0)).content=e.md.normalizeLinkText(r),(o=e.push(\"link_close\",\"a\",-1)).markup=\"autolink\",o.info=\"auto\"),e.pos+=r.length+2,!0))}},function(e,t,r){\"use strict\";var n=r(12).HTML_TAG_RE;e.exports=function(e,t){var r,i,s,o=e.pos;return!!e.md.options.html&&(s=e.posMax,!(60!==e.src.charCodeAt(o)||o+2>=s)&&(!(33!==(r=e.src.charCodeAt(o+1))&&63!==r&&47!==r&&!function(e){var t=32|e;return t>=97&&t<=122}(r))&&(!!(i=e.src.slice(o).match(n))&&(t||(e.push(\"html_inline\",\"\",0).content=e.src.slice(o,o+i[0].length)),e.pos+=i[0].length,!0))))}},function(e,t,r){\"use strict\";var n=r(7),i=r(0).has,s=r(0).isValidEntityCode,o=r(0).fromCodePoint,a=/^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i,c=/^&([a-z][a-z0-9]{1,31});/i;e.exports=function(e,t){var r,l,u=e.pos,p=e.posMax;if(38!==e.src.charCodeAt(u))return!1;if(u+1<p)if(35===e.src.charCodeAt(u+1)){if(l=e.src.slice(u).match(a))return t||(r=\"x\"===l[1][0].toLowerCase()?parseInt(l[1].slice(1),16):parseInt(l[1],10),e.pending+=s(r)?o(r):o(65533)),e.pos+=l[0].length,!0}else if((l=e.src.slice(u).match(c))&&i(n,l[1]))return t||(e.pending+=n[l[1]]),e.pos+=l[0].length,!0;return t||(e.pending+=\"&\"),e.pos++,!0}},function(e,t,r){\"use strict\";function n(e,t){var r,n,i,s,o,a,c,l,u={},p=t.length;if(p){var h=0,f=-2,d=[];for(r=0;r<p;r++)if(i=t[r],d.push(0),t[h].marker===i.marker&&f===i.token-1||(h=r),f=i.token,i.length=i.length||0,i.close){for(u.hasOwnProperty(i.marker)||(u[i.marker]=[-1,-1,-1,-1,-1,-1]),o=u[i.marker][(i.open?3:0)+i.length%3],a=n=h-d[h]-1;n>o;n-=d[n]+1)if((s=t[n]).marker===i.marker&&s.open&&s.end<0&&(c=!1,(s.close||i.open)&&(s.length+i.length)%3==0&&(s.length%3==0&&i.length%3==0||(c=!0)),!c)){l=n>0&&!t[n-1].open?d[n-1]+1:0,d[r]=r-n+l,d[n]=l,i.open=!1,s.end=r,s.close=!1,a=-1,f=-2;break}-1!==a&&(u[i.marker][(i.open?3:0)+(i.length||0)%3]=a)}}}e.exports=function(e){var t,r=e.tokens_meta,i=e.tokens_meta.length;for(n(0,e.delimiters),t=0;t<i;t++)r[t]&&r[t].delimiters&&n(0,r[t].delimiters)}},function(e,t,r){\"use strict\";e.exports=function(e){var t,r,n=0,i=e.tokens,s=e.tokens.length;for(t=r=0;t<s;t++)i[t].nesting<0&&n--,i[t].level=n,i[t].nesting>0&&n++,\"text\"===i[t].type&&t+1<s&&\"text\"===i[t+1].type?i[t+1].content=i[t].content+i[t+1].content:(t!==r&&(i[r]=i[t]),r++);t!==r&&(i.length=r)}},function(e,t,r){\"use strict\";var n=r(5),i=r(0).isWhiteSpace,s=r(0).isPunctChar,o=r(0).isMdAsciiPunct;function a(e,t,r,n){this.src=e,this.env=r,this.md=t,this.tokens=n,this.tokens_meta=Array(n.length),this.pos=0,this.posMax=this.src.length,this.level=0,this.pending=\"\",this.pendingLevel=0,this.cache={},this.delimiters=[],this._prev_delimiters=[],this.backticks={},this.backticksScanned=!1}a.prototype.pushPending=function(){var e=new n(\"text\",\"\",0);return e.content=this.pending,e.level=this.pendingLevel,this.tokens.push(e),this.pending=\"\",e},a.prototype.push=function(e,t,r){this.pending&&this.pushPending();var i=new n(e,t,r),s=null;return r<0&&(this.level--,this.delimiters=this._prev_delimiters.pop()),i.level=this.level,r>0&&(this.level++,this._prev_delimiters.push(this.delimiters),this.delimiters=[],s={delimiters:this.delimiters}),this.pendingLevel=this.level,this.tokens.push(i),this.tokens_meta.push(s),i},a.prototype.scanDelims=function(e,t){var r,n,a,c,l,u,p,h,f,d=e,g=!0,m=!0,_=this.posMax,b=this.src.charCodeAt(e);for(r=e>0?this.src.charCodeAt(e-1):32;d<_&&this.src.charCodeAt(d)===b;)d++;return a=d-e,n=d<_?this.src.charCodeAt(d):32,p=o(r)||s(String.fromCharCode(r)),f=o(n)||s(String.fromCharCode(n)),u=i(r),(h=i(n))?g=!1:f&&(u||p||(g=!1)),u?m=!1:p&&(h||f||(m=!1)),t?(c=g,l=m):(c=g&&(!m||p),l=m&&(!g||f)),{can_open:c,can_close:l,length:a}},a.prototype.Token=n,e.exports=a},function(e,t,r){\"use strict\";function n(e){var t=Array.prototype.slice.call(arguments,1);return t.forEach((function(t){t&&Object.keys(t).forEach((function(r){e[r]=t[r]}))})),e}function i(e){return Object.prototype.toString.call(e)}function s(e){return\"[object Function]\"===i(e)}function o(e){return e.replace(/[.?*+^$[\\]\\\\(){}|-]/g,\"\\\\$&\")}var a={fuzzyLink:!0,fuzzyEmail:!0,fuzzyIP:!1};var c={\"http:\":{validate:function(e,t,r){var n=e.slice(t);return r.re.http||(r.re.http=new RegExp(\"^\\\\/\\\\/\"+r.re.src_auth+r.re.src_host_port_strict+r.re.src_path,\"i\")),r.re.http.test(n)?n.match(r.re.http)[0].length:0}},\"https:\":\"http:\",\"ftp:\":\"http:\",\"//\":{validate:function(e,t,r){var n=e.slice(t);return r.re.no_http||(r.re.no_http=new RegExp(\"^\"+r.re.src_auth+\"(?:localhost|(?:(?:\"+r.re.src_domain+\")\\\\.)+\"+r.re.src_domain_root+\")\"+r.re.src_port+r.re.src_host_terminator+r.re.src_path,\"i\")),r.re.no_http.test(n)?t>=3&&\":\"===e[t-3]||t>=3&&\"/\"===e[t-3]?0:n.match(r.re.no_http)[0].length:0}},\"mailto:\":{validate:function(e,t,r){var n=e.slice(t);return r.re.mailto||(r.re.mailto=new RegExp(\"^\"+r.re.src_email_name+\"@\"+r.re.src_host_strict,\"i\")),r.re.mailto.test(n)?n.match(r.re.mailto)[0].length:0}}},l=\"biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф\".split(\"|\");function u(e){var t=e.re=r(69)(e.__opts__),n=e.__tlds__.slice();function a(e){return e.replace(\"%TLDS%\",t.src_tlds)}e.onCompile(),e.__tlds_replaced__||n.push(\"a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]\"),n.push(t.src_xn),t.src_tlds=n.join(\"|\"),t.email_fuzzy=RegExp(a(t.tpl_email_fuzzy),\"i\"),t.link_fuzzy=RegExp(a(t.tpl_link_fuzzy),\"i\"),t.link_no_ip_fuzzy=RegExp(a(t.tpl_link_no_ip_fuzzy),\"i\"),t.host_fuzzy_test=RegExp(a(t.tpl_host_fuzzy_test),\"i\");var c=[];function l(e,t){throw new Error('(LinkifyIt) Invalid schema \"'+e+'\": '+t)}e.__compiled__={},Object.keys(e.__schemas__).forEach((function(t){var r=e.__schemas__[t];if(null!==r){var n={validate:null,link:null};if(e.__compiled__[t]=n,\"[object Object]\"===i(r))return!function(e){return\"[object RegExp]\"===i(e)}(r.validate)?s(r.validate)?n.validate=r.validate:l(t,r):n.validate=function(e){return function(t,r){var n=t.slice(r);return e.test(n)?n.match(e)[0].length:0}}(r.validate),void(s(r.normalize)?n.normalize=r.normalize:r.normalize?l(t,r):n.normalize=function(e,t){t.normalize(e)});!function(e){return\"[object String]\"===i(e)}(r)?l(t,r):c.push(t)}})),c.forEach((function(t){e.__compiled__[e.__schemas__[t]]&&(e.__compiled__[t].validate=e.__compiled__[e.__schemas__[t]].validate,e.__compiled__[t].normalize=e.__compiled__[e.__schemas__[t]].normalize)})),e.__compiled__[\"\"]={validate:null,normalize:function(e,t){t.normalize(e)}};var u=Object.keys(e.__compiled__).filter((function(t){return t.length>0&&e.__compiled__[t]})).map(o).join(\"|\");e.re.schema_test=RegExp(\"(^|(?!_)(?:[><｜]|\"+t.src_ZPCc+\"))(\"+u+\")\",\"i\"),e.re.schema_search=RegExp(\"(^|(?!_)(?:[><｜]|\"+t.src_ZPCc+\"))(\"+u+\")\",\"ig\"),e.re.pretest=RegExp(\"(\"+e.re.schema_test.source+\")|(\"+e.re.host_fuzzy_test.source+\")|@\",\"i\"),function(e){e.__index__=-1,e.__text_cache__=\"\"}(e)}function p(e,t){var r=e.__index__,n=e.__last_index__,i=e.__text_cache__.slice(r,n);this.schema=e.__schema__.toLowerCase(),this.index=r+t,this.lastIndex=n+t,this.raw=i,this.text=i,this.url=i}function h(e,t){var r=new p(e,t);return e.__compiled__[r.schema].normalize(r,e),r}function f(e,t){if(!(this instanceof f))return new f(e,t);var r;t||(r=e,Object.keys(r||{}).reduce((function(e,t){return e||a.hasOwnProperty(t)}),!1)&&(t=e,e={})),this.__opts__=n({},a,t),this.__index__=-1,this.__last_index__=-1,this.__schema__=\"\",this.__text_cache__=\"\",this.__schemas__=n({},c,e),this.__compiled__={},this.__tlds__=l,this.__tlds_replaced__=!1,this.re={},u(this)}f.prototype.add=function(e,t){return this.__schemas__[e]=t,u(this),this},f.prototype.set=function(e){return this.__opts__=n(this.__opts__,e),this},f.prototype.test=function(e){if(this.__text_cache__=e,this.__index__=-1,!e.length)return!1;var t,r,n,i,s,o,a,c;if(this.re.schema_test.test(e))for((a=this.re.schema_search).lastIndex=0;null!==(t=a.exec(e));)if(i=this.testSchemaAt(e,t[2],a.lastIndex)){this.__schema__=t[2],this.__index__=t.index+t[1].length,this.__last_index__=t.index+t[0].length+i;break}return this.__opts__.fuzzyLink&&this.__compiled__[\"http:\"]&&(c=e.search(this.re.host_fuzzy_test))>=0&&(this.__index__<0||c<this.__index__)&&null!==(r=e.match(this.__opts__.fuzzyIP?this.re.link_fuzzy:this.re.link_no_ip_fuzzy))&&(s=r.index+r[1].length,(this.__index__<0||s<this.__index__)&&(this.__schema__=\"\",this.__index__=s,this.__last_index__=r.index+r[0].length)),this.__opts__.fuzzyEmail&&this.__compiled__[\"mailto:\"]&&e.indexOf(\"@\")>=0&&null!==(n=e.match(this.re.email_fuzzy))&&(s=n.index+n[1].length,o=n.index+n[0].length,(this.__index__<0||s<this.__index__||s===this.__index__&&o>this.__last_index__)&&(this.__schema__=\"mailto:\",this.__index__=s,this.__last_index__=o)),this.__index__>=0},f.prototype.pretest=function(e){return this.re.pretest.test(e)},f.prototype.testSchemaAt=function(e,t,r){return this.__compiled__[t.toLowerCase()]?this.__compiled__[t.toLowerCase()].validate(e,r,this):0},f.prototype.match=function(e){var t=0,r=[];this.__index__>=0&&this.__text_cache__===e&&(r.push(h(this,t)),t=this.__last_index__);for(var n=t?e.slice(t):e;this.test(n);)r.push(h(this,t)),n=n.slice(this.__last_index__),t+=this.__last_index__;return r.length?r:null},f.prototype.tlds=function(e,t){return e=Array.isArray(e)?e:[e],t?(this.__tlds__=this.__tlds__.concat(e).sort().filter((function(e,t,r){return e!==r[t-1]})).reverse(),u(this),this):(this.__tlds__=e.slice(),this.__tlds_replaced__=!0,u(this),this)},f.prototype.normalize=function(e){e.schema||(e.url=\"http://\"+e.url),\"mailto:\"!==e.schema||/^mailto:/i.test(e.url)||(e.url=\"mailto:\"+e.url)},f.prototype.onCompile=function(){},e.exports=f},function(e,t,r){\"use strict\";e.exports=function(e){var t={};t.src_Any=r(9).source,t.src_Cc=r(10).source,t.src_Z=r(11).source,t.src_P=r(3).source,t.src_ZPCc=[t.src_Z,t.src_P,t.src_Cc].join(\"|\"),t.src_ZCc=[t.src_Z,t.src_Cc].join(\"|\");return t.src_pseudo_letter=\"(?:(?![><｜]|\"+t.src_ZPCc+\")\"+t.src_Any+\")\",t.src_ip4=\"(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\",t.src_auth=\"(?:(?:(?!\"+t.src_ZCc+\"|[@/\\\\[\\\\]()]).)+@)?\",t.src_port=\"(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?\",t.src_host_terminator=\"(?=$|[><｜]|\"+t.src_ZPCc+\")(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|\"+t.src_ZPCc+\"))\",t.src_path=\"(?:[/?#](?:(?!\"+t.src_ZCc+\"|[><｜]|[()[\\\\]{}.,\\\"'?!\\\\-]).|\\\\[(?:(?!\"+t.src_ZCc+\"|\\\\]).)*\\\\]|\\\\((?:(?!\"+t.src_ZCc+\"|[)]).)*\\\\)|\\\\{(?:(?!\"+t.src_ZCc+'|[}]).)*\\\\}|\\\\\"(?:(?!'+t.src_ZCc+'|[\"]).)+\\\\\"|\\\\\\'(?:(?!'+t.src_ZCc+\"|[']).)+\\\\'|\\\\'(?=\"+t.src_pseudo_letter+\"|[-]).|\\\\.{2,}[a-zA-Z0-9%/&]|\\\\.(?!\"+t.src_ZCc+\"|[.]).|\"+(e&&e[\"---\"]?\"\\\\-(?!--(?:[^-]|$))(?:-*)|\":\"\\\\-+|\")+\"\\\\,(?!\"+t.src_ZCc+\").|\\\\!+(?!\"+t.src_ZCc+\"|[!]).|\\\\?(?!\"+t.src_ZCc+\"|[?]).)+|\\\\/)?\",t.src_email_name='[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*',t.src_xn=\"xn--[a-z0-9\\\\-]{1,59}\",t.src_domain_root=\"(?:\"+t.src_xn+\"|\"+t.src_pseudo_letter+\"{1,63})\",t.src_domain=\"(?:\"+t.src_xn+\"|(?:\"+t.src_pseudo_letter+\")|(?:\"+t.src_pseudo_letter+\"(?:-|\"+t.src_pseudo_letter+\"){0,61}\"+t.src_pseudo_letter+\"))\",t.src_host=\"(?:(?:(?:(?:\"+t.src_domain+\")\\\\.)*\"+t.src_domain+\"))\",t.tpl_host_fuzzy=\"(?:\"+t.src_ip4+\"|(?:(?:(?:\"+t.src_domain+\")\\\\.)+(?:%TLDS%)))\",t.tpl_host_no_ip_fuzzy=\"(?:(?:(?:\"+t.src_domain+\")\\\\.)+(?:%TLDS%))\",t.src_host_strict=t.src_host+t.src_host_terminator,t.tpl_host_fuzzy_strict=t.tpl_host_fuzzy+t.src_host_terminator,t.src_host_port_strict=t.src_host+t.src_port+t.src_host_terminator,t.tpl_host_port_fuzzy_strict=t.tpl_host_fuzzy+t.src_port+t.src_host_terminator,t.tpl_host_port_no_ip_fuzzy_strict=t.tpl_host_no_ip_fuzzy+t.src_port+t.src_host_terminator,t.tpl_host_fuzzy_test=\"localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:\"+t.src_ZPCc+\"|>|$))\",t.tpl_email_fuzzy='(^|[><｜]|\"|\\\\(|'+t.src_ZCc+\")(\"+t.src_email_name+\"@\"+t.tpl_host_fuzzy_strict+\")\",t.tpl_link_fuzzy=\"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|｜]|\"+t.src_ZPCc+\"))((?![$+<=>^`|｜])\"+t.tpl_host_port_fuzzy_strict+t.src_path+\")\",t.tpl_link_no_ip_fuzzy=\"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|｜]|\"+t.src_ZPCc+\"))((?![$+<=>^`|｜])\"+t.tpl_host_port_no_ip_fuzzy_strict+t.src_path+\")\",t}},function(e,t,r){(function(e,n){var i;/*! https://mths.be/punycode v1.4.1 by @mathias */!function(s){t&&t.nodeType,e&&e.nodeType;var o=\"object\"==typeof n&&n;o.global!==o&&o.window!==o&&o.self;var a,c=2147483647,l=/^xn--/,u=/[^\\x20-\\x7E]/,p=/[\\x2E\\u3002\\uFF0E\\uFF61]/g,h={overflow:\"Overflow: input needs wider integers to process\",\"not-basic\":\"Illegal input >= 0x80 (not a basic code point)\",\"invalid-input\":\"Invalid input\"},f=Math.floor,d=String.fromCharCode;function g(e){throw new RangeError(h[e])}function m(e,t){for(var r=e.length,n=[];r--;)n[r]=t(e[r]);return n}function _(e,t){var r=e.split(\"@\"),n=\"\";return r.length>1&&(n=r[0]+\"@\",e=r[1]),n+m((e=e.replace(p,\".\")).split(\".\"),t).join(\".\")}function b(e){for(var t,r,n=[],i=0,s=e.length;i<s;)(t=e.charCodeAt(i++))>=55296&&t<=56319&&i<s?56320==(64512&(r=e.charCodeAt(i++)))?n.push(((1023&t)<<10)+(1023&r)+65536):(n.push(t),i--):n.push(t);return n}function k(e){return m(e,(function(e){var t=\"\";return e>65535&&(t+=d((e-=65536)>>>10&1023|55296),e=56320|1023&e),t+=d(e)})).join(\"\")}function v(e,t){return e+22+75*(e<26)-((0!=t)<<5)}function y(e,t,r){var n=0;for(e=r?f(e/700):e>>1,e+=f(e/t);e>455;n+=36)e=f(e/35);return f(n+36*e/(e+38))}function x(e){var t,r,n,i,s,o,a,l,u,p,h,d=[],m=e.length,_=0,b=128,v=72;for((r=e.lastIndexOf(\"-\"))<0&&(r=0),n=0;n<r;++n)e.charCodeAt(n)>=128&&g(\"not-basic\"),d.push(e.charCodeAt(n));for(i=r>0?r+1:0;i<m;){for(s=_,o=1,a=36;i>=m&&g(\"invalid-input\"),((l=(h=e.charCodeAt(i++))-48<10?h-22:h-65<26?h-65:h-97<26?h-97:36)>=36||l>f((c-_)/o))&&g(\"overflow\"),_+=l*o,!(l<(u=a<=v?1:a>=v+26?26:a-v));a+=36)o>f(c/(p=36-u))&&g(\"overflow\"),o*=p;v=y(_-s,t=d.length+1,0==s),f(_/t)>c-b&&g(\"overflow\"),b+=f(_/t),_%=t,d.splice(_++,0,b)}return k(d)}function C(e){var t,r,n,i,s,o,a,l,u,p,h,m,_,k,x,C=[];for(m=(e=b(e)).length,t=128,r=0,s=72,o=0;o<m;++o)(h=e[o])<128&&C.push(d(h));for(n=i=C.length,i&&C.push(\"-\");n<m;){for(a=c,o=0;o<m;++o)(h=e[o])>=t&&h<a&&(a=h);for(a-t>f((c-r)/(_=n+1))&&g(\"overflow\"),r+=(a-t)*_,t=a,o=0;o<m;++o)if((h=e[o])<t&&++r>c&&g(\"overflow\"),h==t){for(l=r,u=36;!(l<(p=u<=s?1:u>=s+26?26:u-s));u+=36)x=l-p,k=36-p,C.push(d(v(p+x%k,0))),l=f(x/k);C.push(d(v(l,0))),s=y(r,_,n==i),r=0,++n}++r,++t}return C.join(\"\")}a={version:\"1.4.1\",ucs2:{decode:b,encode:k},decode:x,encode:C,toASCII:function(e){return _(e,(function(e){return u.test(e)?\"xn--\"+C(e):e}))},toUnicode:function(e){return _(e,(function(e){return l.test(e)?x(e.slice(4).toLowerCase()):e}))}},void 0===(i=function(){return a}.call(t,r,t,e))||(e.exports=i)}()}).call(this,r(71)(e),r(72))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,\"loaded\",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,\"id\",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t){var r;r=function(){return this}();try{r=r||new Function(\"return this\")()}catch(e){\"object\"==typeof window&&(r=window)}e.exports=r},function(e,t,r){\"use strict\";e.exports={options:{html:!1,xhtmlOut:!1,breaks:!1,langPrefix:\"language-\",linkify:!1,typographer:!1,quotes:\"“”‘’\",highlight:null,maxNesting:100},components:{core:{},block:{},inline:{}}}},function(e,t,r){\"use strict\";e.exports={options:{html:!1,xhtmlOut:!1,breaks:!1,langPrefix:\"language-\",linkify:!1,typographer:!1,quotes:\"“”‘’\",highlight:null,maxNesting:20},components:{core:{rules:[\"normalize\",\"block\",\"inline\"]},block:{rules:[\"paragraph\"]},inline:{rules:[\"text\"],rules2:[\"balance_pairs\",\"text_collapse\"]}}}},function(e,t,r){\"use strict\";e.exports={options:{html:!0,xhtmlOut:!0,breaks:!1,langPrefix:\"language-\",linkify:!1,typographer:!1,quotes:\"“”‘’\",highlight:null,maxNesting:20},components:{core:{rules:[\"normalize\",\"block\",\"inline\"]},block:{rules:[\"blockquote\",\"code\",\"fence\",\"heading\",\"hr\",\"html_block\",\"lheading\",\"list\",\"reference\",\"paragraph\"]},inline:{rules:[\"autolink\",\"backticks\",\"emphasis\",\"entity\",\"escape\",\"html_inline\",\"image\",\"link\",\"newline\",\"text\"],rules2:[\"balance_pairs\",\"emphasis\",\"text_collapse\"]}}}},,function(e,t,r){\"use strict\";r.r(t),r.d(t,\"default\",(function(){return s}));var n=r(17),i=r(2);function s(e){var t=void 0===e?{}:e,r=t.Prism,s=t.baseConfig,o=t.codeBlockClass,a=t.codeHighlightExtensionMap,c=void 0===a?{}:a,l=Object(n.default)(s);return l.extend((function(e){e.set({highlight:Object(i.a)({codeHighlightExtensionMap:c,hasLang:function(e){return r.languages[e]},codeBlockClass:o,highlight:function(e,t){return r.highlight(e,r.languages[t],t)}})})})),{previewClass:\"markdown-body\",extend:function(e){l.extend((function(){for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];e.apply(void 0,n.concat([r]))}))},markdownParser:l.markdownParser}}},,function(e,t,r){\"use strict\";r.r(t);var n=r(1),i=r(77);t.default=function(e,t){void 0===t&&(t={});var r=t,s=r.extend,o=r.config,a=r.codeHighlightExtensionMap,c=function(e){var t=Object(i.default)({Prism:e.Prism,codeHighlightExtensionMap:e.codeHighlightExtensionMap||{},codeBlockClass:e.codeBlockClass||function(e){return\"v-md-prism-\"+e},baseConfig:Object(n.a)({link:{openLinkIcon:!0}},e.baseConfig)});return{previewClass:\"vuepress-markdown-body\",extend:function(e){t.extend(e)},markdownParser:t.markdownParser}}({Prism:r.Prism,baseConfig:o,codeHighlightExtensionMap:a});s&&c.extend(s),e.theme(c)}},function(e,t,r){},function(e,t,r){\"use strict\";e.exports=function(e,t,r){var n=(r=r||{}).marker||\":\",i=n.charCodeAt(0),s=n.length,o=r.validate||function(e){return e.trim().split(\" \",2)[0]===t},a=r.render||function(e,r,n,i,s){return 1===e[r].nesting&&e[r].attrJoin(\"class\",t),s.renderToken(e,r,n,i,s)};e.block.ruler.before(\"fence\",\"container_\"+t,(function(e,r,a,c){var l,u,p,h,f,d,g,m,_=!1,b=e.bMarks[r]+e.tShift[r],k=e.eMarks[r];if(i!==e.src.charCodeAt(b))return!1;for(l=b+1;l<=k&&n[(l-b)%s]===e.src[l];l++);if((p=Math.floor((l-b)/s))<3)return!1;if(l-=(l-b)%s,h=e.src.slice(b,l),f=e.src.slice(l,k),!o(f,h))return!1;if(c)return!0;for(u=r;!(++u>=a)&&!((b=e.bMarks[u]+e.tShift[u])<(k=e.eMarks[u])&&e.sCount[u]<e.blkIndent);)if(i===e.src.charCodeAt(b)&&!(e.sCount[u]-e.blkIndent>=4)){for(l=b+1;l<=k&&n[(l-b)%s]===e.src[l];l++);if(!(Math.floor((l-b)/s)<p||(l-=(l-b)%s,(l=e.skipSpaces(l))<k))){_=!0;break}}return g=e.parentType,m=e.lineMax,e.parentType=\"container\",e.lineMax=u,(d=e.push(\"container_\"+t+\"_open\",\"div\",1)).markup=h,d.block=!0,d.info=f,d.map=[r,u],e.md.block.tokenize(e,r+1,u),(d=e.push(\"container_\"+t+\"_close\",\"div\",-1)).markup=e.src.slice(b,l),d.block=!0,e.parentType=g,e.lineMax=m,e.line=u+(_?1:0),!0}),{alt:[\"paragraph\",\"reference\",\"blockquote\",\"list\"]}),e.renderer.rules[\"container_\"+t+\"_open\"]=a,e.renderer.rules[\"container_\"+t+\"_close\"]=a}},,,function(e,t,r){},function(e,t,r){},function(e,t,r){\"use strict\";r.r(t);var n=r(79),i=r(81),s=r.n(i);function o(e){return\"string\"==typeof e?function(){return e}:e}var a=function(e,t){var r=t.validate,n=t.marker,i=t.render,a=t.type,c=t.before,l=t.after,u=t.defaultTitle,p=void 0===u?a.toUpperCase():u,h=t.blockClass,f=void 0===h?\"custom-block\":h;if(a){var d,g;if(!i)void 0!==c&&void 0!==l?(d=o(c),g=o(l)):(d=function(e){return'<div class=\"'+f+\" \"+a+'\">'+(e?'<p class=\"'+f+'-title\">'+e+\"</p>\":\"\")+\"\\n\"},g=function(){return\"</div>\\n\"}),i=function(e,t){var r=e[t],n=r.info.trim().slice(a.length).trim();return!n&&p&&(n=\"function\"==typeof p?p():p),1===r.nesting?d(n):g(n)};e.use(s.a,a,{render:i,validate:r,marker:n})}},c=function(e){e.extendMarkdown((function(t){var r=function(){var t=e.lang.config;return t.langConfig[t.lang]};a(t,{type:\"tip\",defaultTitle:function(){return r().tip.tip.defaultTitle},blockClass:\"v-md-plugin-tip\"}),a(t,{type:\"warning\",defaultTitle:function(){return r().tip.warning.defaultTitle},blockClass:\"v-md-plugin-tip\"}),a(t,{type:\"danger\",defaultTitle:function(){return r().tip.danger.defaultTitle},blockClass:\"v-md-plugin-tip\"}),a(t,{type:\"details\",defaultTitle:function(){return r().tip.details.defaultTitle},before:function(e){return'<details class=\"v-md-plugin-tip details\">'+(e?\"<summary>\"+e+\"</summary>\":\"\")+\"\\n\"},after:function(){return\"</details>\\n\"}})})),e.lang.add({\"zh-CN\":{tip:{tip:{defaultTitle:\"提示\"},warning:{defaultTitle:\"注意\"},danger:{defaultTitle:\"警告\"},details:{defaultTitle:\"详细信息\"}}},\"en-US\":{tip:{tip:{defaultTitle:\"TIP\"},warning:{defaultTitle:\"WARNING\"},danger:{defaultTitle:\"DANGER\"},details:{defaultTitle:\"DETAILS\"}}}})};r(80),r(84),r(85),t.default={install:function(e,t){var r,i,s,o,a,l,u,p,h,f=(s=(i=void 0===r?{}:r).name,o=void 0===s?\"tip\":s,a=i.icon,l=void 0===a?\"v-md-icon-tip\":a,u=i.text,p=function(e,t){void 0===t&&(t=\"tip\"),e.insert((function(r){var n=r||e.langConfig.tip[t].placeholder;return{text:\"::: \"+t+\"\\n  \"+n+\"\\n:::\",selected:n}}))},h={title:function(e){return e.langConfig.tip.toolbar},icon:l,text:u,menus:[{name:\"tip\",text:function(e){return e.langConfig.tip.tip.toolbar},action:function(e){e.execCommand(o)}},{name:\"warning\",text:function(e){return e.langConfig.tip.warning.toolbar},action:function(e){e.execCommand(o,\"warning\")}},{name:\"danger\",text:function(e){return e.langConfig.tip.danger.toolbar},action:function(e){e.execCommand(o,\"danger\")}},{name:\"details\",text:function(e){return e.langConfig.tip.details.toolbar},action:function(e){e.execCommand(o,\"details\")}}]},{install:function(e){\"v-md-editor\"===e.name&&(e.command(o,p),e.toolbar(o,h),e.lang.add({\"zh-CN\":{tip:{toolbar:\"插入提示\",tip:{toolbar:\"提示\",placeholder:\"在此输入内容\"},warning:{toolbar:\"注意\",placeholder:\"在此输入内容\"},danger:{toolbar:\"警告\",placeholder:\"在此输入内容\"},details:{toolbar:\"详细信息\",placeholder:\"内容\"}}},\"en-US\":{tip:{toolbar:\"Insert tip\",tip:{toolbar:\"Tip\",placeholder:\"Insert content\"},warning:{toolbar:\"Warning\",placeholder:\"Insert content\"},danger:{toolbar:\"Danger\",placeholder:\"Insert content\"},details:{toolbar:\"Details\",placeholder:\"Content\"}}}})),e.vMdParser.use(c)}});e.vMdParser.use(n.default,t),e.use(f)}}}]).default}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGthbmdjL3YtbWQtZWRpdG9yL2xpYi90aGVtZS92dWVwcmVzcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQWlELG9CQUFvQixDQUEwSCxDQUFDLGdEQUFnRCxtQkFBbUIsU0FBUyxjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsdUNBQXVDLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLHNCQUFzQixtQkFBbUIsaURBQWlELGtCQUFrQixrQkFBa0IsYUFBYSxzQ0FBc0MsZ0JBQWdCLG1CQUFtQixjQUFjLDRLQUE0SyxjQUFjLFlBQVksOENBQThDLGdDQUFnQyw4QkFBOEIsOEJBQThCLGNBQWMsRUFBRSxrREFBa0QsS0FBSyxFQUFFLG9DQUFvQyxJQUFJLE9BQU8sSUFBSSxZQUFZLDhCQUE4QixVQUFVLFdBQVcsV0FBVyxhQUFhLEdBQUcsY0FBYyxZQUFZLHVCQUF1QixNQUFNLFdBQVcsUUFBUSwyREFBMkQsOENBQThDLDhCQUE4QixNQUFNLDhEQUE4RCxvQ0FBb0MsVUFBVSxJQUFJLEtBQUssd0JBQXdCLHNDQUFzQyx5Q0FBeUMsSUFBSSxrQ0FBa0MsNkNBQTZDLDJCQUEyQiwwRUFBMEUsd0JBQXdCLFFBQVEseUlBQXlJLE1BQU0sR0FBRyxrRUFBa0Usa0NBQWtDLGtDQUFrQyw2Q0FBNkMsdUJBQXVCLFVBQVUsd0JBQXdCLFNBQVMsNEJBQTRCLDZCQUE2QixVQUFVLDBHQUEwRyxTQUFTLDhCQUE4QixVQUFVLDZRQUE2USxrQkFBa0IsMkJBQTJCLGlCQUFpQix3QkFBd0IsMkJBQTJCLGtDQUFrQyxzSEFBc0gsaUJBQWlCLGFBQWEsYUFBYSxvQ0FBb0MsWUFBWSxtQkFBbUIsS0FBSyxtQkFBbUIs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LGFBQWEsNkJBQTZCLEdBQUcsZUFBZSw4QkFBOEIsaUJBQWlCLG9CQUFvQiw2QkFBNkIsS0FBSyxtQ0FBbUMsZ0NBQWdDLDhCQUE4QixPQUFPLHVDQUF1QyxvQ0FBb0MsOEJBQThCLE9BQU8sc0NBQXNDLG1DQUFtQyw4QkFBOEIsT0FBTyx1Q0FBdUMsb0NBQW9DLG9CQUFvQix5RkFBeUYsa0JBQWtCLHNCQUFzQixFQUFFLGVBQWUsU0FBUyxLQUFLLEtBQUssa0JBQWtCLFVBQVUsa0JBQWtCLFNBQVMsa0JBQWtCLFVBQVUsc0JBQXNCLFVBQVUsS0FBSyxLQUFLLG1CQUFtQixVQUFVLHVCQUF1QixTQUFTLHNCQUFzQixVQUFVLDBCQUEwQixHQUFHLDZCQUE2QixzQkFBc0IsMkNBQTJDLCtGQUErRiw0Q0FBNEMseUNBQXlDLE9BQU8sMkNBQTJDLEdBQUcsSUFBSSxrQkFBa0IsZ0NBQWdDLHVCQUF1Qiw0QkFBNEIsb0NBQW9DLG9CQUFvQixrQkFBa0IsRUFBRSxnQ0FBZ0Msd0NBQXdDLG9CQUFvQiw0QkFBNEIsRUFBRSwrQkFBK0IsdUNBQXVDLG9CQUFvQiwyQkFBMkIsRUFBRSxnQ0FBZ0Msd0NBQXdDLG9CQUFvQiw0QkFBNEIsRUFBRSxFQUFFLG9CQUFvQixtRUFBbUUsU0FBUyxLQUFLLG9CQUFvQixrQ0FBa0MsVUFBVSxrQ0FBa0MsU0FBUyxrQ0FBa0MsVUFBVSxrQ0FBa0MsVUFBVSxLQUFLLDBCQUEwQiwyQ0FBMkMsVUFBVSwrQ0FBK0MsU0FBUyw4Q0FBOEMsVUFBVSwyQ0FBMkMsdUJBQXVCLEVBQUUsd0NBQXdDLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGthbmdjL3YtbWQtZWRpdG9yL2xpYi90aGVtZS92dWVwcmVzcy5qcz8wOWM4Il0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFwiVk1kVGhlbWVcIixbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlZNZFRoZW1lPXQoKTplLlZNZFRoZW1lPXQoKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiByKG4pe2lmKHRbbl0pcmV0dXJuIHRbbl0uZXhwb3J0czt2YXIgaT10W25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxyKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiByLm09ZSxyLmM9dCxyLmQ9ZnVuY3Rpb24oZSx0LG4pe3IubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPXIoZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihyLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBpIGluIGUpci5kKG4saSxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLGkpKTtyZXR1cm4gbn0sci5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiByLmQodCxcImFcIix0KSx0fSxyLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHIucD1cIlwiLHIoci5zPTg2KX0oW2Z1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uIGkoZSx0KXtyZXR1cm4gbi5jYWxsKGUsdCl9ZnVuY3Rpb24gcyhlKXtyZXR1cm4hKGU+PTU1Mjk2JiZlPD01NzM0MykmJighKGU+PTY0OTc2JiZlPD02NTAwNykmJig2NTUzNSE9KDY1NTM1JmUpJiY2NTUzNCE9KDY1NTM1JmUpJiYoIShlPj0wJiZlPD04KSYmKDExIT09ZSYmKCEoZT49MTQmJmU8PTMxKSYmKCEoZT49MTI3JiZlPD0xNTkpJiYhKGU+MTExNDExMSkpKSkpKSl9ZnVuY3Rpb24gbyhlKXtpZihlPjY1NTM1KXt2YXIgdD01NTI5NisoKGUtPTY1NTM2KT4+MTApLHI9NTYzMjArKDEwMjMmZSk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodCxyKX1yZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlKX12YXIgYT0vXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZyxjPW5ldyBSZWdFeHAoYS5zb3VyY2UrXCJ8XCIrLyYoW2EteiNdW2EtejAtOV17MSwzMX0pOy9naS5zb3VyY2UsXCJnaVwiKSxsPS9eIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSkvaSx1PXIoNyk7dmFyIHA9L1smPD5cIl0vLGg9L1smPD5cIl0vZyxmPXtcIiZcIjpcIiZhbXA7XCIsXCI8XCI6XCImbHQ7XCIsXCI+XCI6XCImZ3Q7XCIsJ1wiJzpcIiZxdW90O1wifTtmdW5jdGlvbiBkKGUpe3JldHVybiBmW2VdfXZhciBnPS9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7dmFyIG09cigzKTt0LmxpYj17fSx0LmxpYi5tZHVybD1yKDgpLHQubGliLnVjbWljcm89cigyNiksdC5hc3NpZ249ZnVuY3Rpb24oZSl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKHQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IodCtcIm11c3QgYmUgb2JqZWN0XCIpO09iamVjdC5rZXlzKHQpLmZvckVhY2goKGZ1bmN0aW9uKHIpe2Vbcl09dFtyXX0pKX19KSksZX0sdC5pc1N0cmluZz1mdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgU3RyaW5nXVwiPT09ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKX0oZSl9LHQuaGFzPWksdC51bmVzY2FwZU1kPWZ1bmN0aW9uKGUpe3JldHVybiBlLmluZGV4T2YoXCJcXFxcXCIpPDA/ZTplLnJlcGxhY2UoYSxcIiQxXCIpfSx0LnVuZXNjYXBlQWxsPWZ1bmN0aW9uKGUpe3JldHVybiBlLmluZGV4T2YoXCJcXFxcXCIpPDAmJmUuaW5kZXhPZihcIiZcIik8MD9lOmUucmVwbGFjZShjLChmdW5jdGlvbihlLHQscil7cmV0dXJuIHR8fGZ1bmN0aW9uKGUsdCl7dmFyIHI9MDtyZXR1cm4gaSh1LHQpP3VbdF06MzU9PT10LmNoYXJDb2RlQXQoMCkmJmwudGVzdCh0KSYmcyhyPVwieFwiPT09dFsxXS50b0xvd2VyQ2FzZSgpP3BhcnNlSW50KHQuc2xpY2UoMiksMTYpOnBhcnNlSW50KHQuc2xpY2UoMSksMTApKT9vKHIpOmV9KGUscil9KSl9LHQuaXNWYWxpZEVudGl0eUNvZGU9cyx0LmZyb21Db2RlUG9pbnQ9byx0LmVzY2FwZUh0bWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHAudGVzdChlKT9lLnJlcGxhY2UoaCxkKTplfSx0LmFycmF5UmVwbGFjZUF0PWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm5bXS5jb25jYXQoZS5zbGljZSgwLHQpLHIsZS5zbGljZSh0KzEpKX0sdC5pc1NwYWNlPWZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlIDk6Y2FzZSAzMjpyZXR1cm4hMH1yZXR1cm4hMX0sdC5pc1doaXRlU3BhY2U9ZnVuY3Rpb24oZSl7aWYoZT49ODE5MiYmZTw9ODIwMilyZXR1cm4hMDtzd2l0Y2goZSl7Y2FzZSA5OmNhc2UgMTA6Y2FzZSAxMTpjYXNlIDEyOmNhc2UgMTM6Y2FzZSAzMjpjYXNlIDE2MDpjYXNlIDU3NjA6Y2FzZSA4MjM5OmNhc2UgODI4NzpjYXNlIDEyMjg4OnJldHVybiEwfXJldHVybiExfSx0LmlzTWRBc2NpaVB1bmN0PWZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlIDMzOmNhc2UgMzQ6Y2FzZSAzNTpjYXNlIDM2OmNhc2UgMzc6Y2FzZSAzODpjYXNlIDM5OmNhc2UgNDA6Y2FzZSA0MTpjYXNlIDQyOmNhc2UgNDM6Y2FzZSA0NDpjYXNlIDQ1OmNhc2UgNDY6Y2FzZSA0NzpjYXNlIDU4OmNhc2UgNTk6Y2FzZSA2MDpjYXNlIDYxOmNhc2UgNjI6Y2FzZSA2MzpjYXNlIDY0OmNhc2UgOTE6Y2FzZSA5MjpjYXNlIDkzOmNhc2UgOTQ6Y2FzZSA5NTpjYXNlIDk2OmNhc2UgMTIzOmNhc2UgMTI0OmNhc2UgMTI1OmNhc2UgMTI2OnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fSx0LmlzUHVuY3RDaGFyPWZ1bmN0aW9uKGUpe3JldHVybiBtLnRlc3QoZSl9LHQuZXNjYXBlUkU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZShnLFwiXFxcXCQmXCIpfSx0Lm5vcm1hbGl6ZVJlZmVyZW5jZT1mdW5jdGlvbihlKXtyZXR1cm4gZT1lLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpLFwi4bm+XCI9PT1cIuG6nlwiLnRvTG93ZXJDYXNlKCkmJihlPWUucmVwbGFjZSgv4bqeL2csXCLDn1wiKSksZS50b0xvd2VyQ2FzZSgpLnRvVXBwZXJDYXNlKCl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbigpe3JldHVybihuPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciByPWFyZ3VtZW50c1t0XTtmb3IodmFyIG4gaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixuKSYmKGVbbl09cltuXSl9cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ci5kKHQsXCJhXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG59KSl9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtyLmQodCxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gb30pKTt2YXIgbj1yKDE2KSxpPXIubihuKSxzPXIoMCk7ZnVuY3Rpb24gbyhlKXt2YXIgdD1lLmNvZGVIaWdobGlnaHRFeHRlbnNpb25NYXAscj12b2lkIDA9PT10P3t9OnQsbj1lLmhhc0xhbmcsaT12b2lkIDA9PT1uP2Z1bmN0aW9uKCl7cmV0dXJuITB9Om4sbz1lLmhpZ2hsaWdodCxhPXZvaWQgMD09PW8/ZnVuY3Rpb24oZSl7cmV0dXJuIGV9Om8sYz1lLmNvZGVCbG9ja0NsYXNzO3JldHVybiBmdW5jdGlvbihlLHQpe3ZhciBuPU9iamVjdChzLmVzY2FwZUh0bWwpKGUpO3JldHVybih0PXJbdF18fHQpJiZpKHQpJiYobj1hKGUsdCkpLCc8cHJlIGNsYXNzPVwiJytmdW5jdGlvbihlKXtyZXR1cm4gYz9jKGUpOlwibGFuZ3VhZ2UtXCIrZX0odCkrJ1wiPjxjb2RlPicrbitcIjwvY29kZT48L3ByZT5cIn19dC5iPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IGkuYTtyZXR1cm4gZS5zZXQoe2h0bWw6ITAsYnJlYWtzOiEwLGxpbmtpZnk6ITEsdHlwb2dyYXBoZXI6ITB9KSxlfX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9L1shLSMlLVxcKiwtXFwvOjtcXD9AXFxbLVxcXV9cXHtcXH1cXHhBMVxceEE3XFx4QUJcXHhCNlxceEI3XFx4QkJcXHhCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwOUZEXFx1MEE3NlxcdTBBRjBcXHUwQzg0XFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTRFXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV18XFx1RDgwMFtcXHVERDAwLVxcdUREMDJcXHVERjlGXFx1REZEMF18XFx1RDgwMVxcdURENkZ8XFx1RDgwMltcXHVEQzU3XFx1REQxRlxcdUREM0ZcXHVERTUwLVxcdURFNThcXHVERTdGXFx1REVGMC1cXHVERUY2XFx1REYzOS1cXHVERjNGXFx1REY5OS1cXHVERjlDXXxcXHVEODAzW1xcdURGNTUtXFx1REY1OV18XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM4XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODA1W1xcdURDNEItXFx1REM0RlxcdURDNUJcXHVEQzVEXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURFNjAtXFx1REU2Q1xcdURGM0MtXFx1REYzRV18XFx1RDgwNltcXHVEQzNCXFx1REUzRi1cXHVERTQ2XFx1REU5QS1cXHVERTlDXFx1REU5RS1cXHVERUEyXXxcXHVEODA3W1xcdURDNDEtXFx1REM0NVxcdURDNzBcXHVEQzcxXFx1REVGN1xcdURFRjhdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdfFxcdUQ4MUJbXFx1REU5Ny1cXHVERTlBXXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql18XFx1RDgzQVtcXHVERDVFXFx1REQ1Rl0vfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbigpe3RoaXMuX19ydWxlc19fPVtdLHRoaXMuX19jYWNoZV9fPW51bGx9bi5wcm90b3R5cGUuX19maW5kX189ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dDx0aGlzLl9fcnVsZXNfXy5sZW5ndGg7dCsrKWlmKHRoaXMuX19ydWxlc19fW3RdLm5hbWU9PT1lKXJldHVybiB0O3JldHVybi0xfSxuLnByb3RvdHlwZS5fX2NvbXBpbGVfXz1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1bXCJcIl07ZS5fX3J1bGVzX18uZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5lbmFibGVkJiZlLmFsdC5mb3JFYWNoKChmdW5jdGlvbihlKXt0LmluZGV4T2YoZSk8MCYmdC5wdXNoKGUpfSkpfSkpLGUuX19jYWNoZV9fPXt9LHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5fX2NhY2hlX19bdF09W10sZS5fX3J1bGVzX18uZm9yRWFjaCgoZnVuY3Rpb24ocil7ci5lbmFibGVkJiYodCYmci5hbHQuaW5kZXhPZih0KTwwfHxlLl9fY2FjaGVfX1t0XS5wdXNoKHIuZm4pKX0pKX0pKX0sbi5wcm90b3R5cGUuYXQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXMuX19maW5kX18oZSksaT1yfHx7fTtpZigtMT09PW4pdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiBcIitlKTt0aGlzLl9fcnVsZXNfX1tuXS5mbj10LHRoaXMuX19ydWxlc19fW25dLmFsdD1pLmFsdHx8W10sdGhpcy5fX2NhY2hlX189bnVsbH0sbi5wcm90b3R5cGUuYmVmb3JlPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPXRoaXMuX19maW5kX18oZSkscz1ufHx7fTtpZigtMT09PWkpdGhyb3cgbmV3IEVycm9yKFwiUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiBcIitlKTt0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaSwwLHtuYW1lOnQsZW5hYmxlZDohMCxmbjpyLGFsdDpzLmFsdHx8W119KSx0aGlzLl9fY2FjaGVfXz1udWxsfSxuLnByb3RvdHlwZS5hZnRlcj1mdW5jdGlvbihlLHQscixuKXt2YXIgaT10aGlzLl9fZmluZF9fKGUpLHM9bnx8e307aWYoLTE9PT1pKXRocm93IG5ldyBFcnJvcihcIlBhcnNlciBydWxlIG5vdCBmb3VuZDogXCIrZSk7dGhpcy5fX3J1bGVzX18uc3BsaWNlKGkrMSwwLHtuYW1lOnQsZW5hYmxlZDohMCxmbjpyLGFsdDpzLmFsdHx8W119KSx0aGlzLl9fY2FjaGVfXz1udWxsfSxuLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yfHx7fTt0aGlzLl9fcnVsZXNfXy5wdXNoKHtuYW1lOmUsZW5hYmxlZDohMCxmbjp0LGFsdDpuLmFsdHx8W119KSx0aGlzLl9fY2FjaGVfXz1udWxsfSxuLnByb3RvdHlwZS5lbmFibGU9ZnVuY3Rpb24oZSx0KXtBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pO3ZhciByPVtdO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMuX19maW5kX18oZSk7aWYobjwwKXtpZih0KXJldHVybjt0aHJvdyBuZXcgRXJyb3IoXCJSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSBcIitlKX10aGlzLl9fcnVsZXNfX1tuXS5lbmFibGVkPSEwLHIucHVzaChlKX0pLHRoaXMpLHRoaXMuX19jYWNoZV9fPW51bGwscn0sbi5wcm90b3R5cGUuZW5hYmxlT25seT1mdW5jdGlvbihlLHQpe0FycmF5LmlzQXJyYXkoZSl8fChlPVtlXSksdGhpcy5fX3J1bGVzX18uZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5lbmFibGVkPSExfSkpLHRoaXMuZW5hYmxlKGUsdCl9LG4ucHJvdG90eXBlLmRpc2FibGU9ZnVuY3Rpb24oZSx0KXtBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pO3ZhciByPVtdO3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMuX19maW5kX18oZSk7aWYobjwwKXtpZih0KXJldHVybjt0aHJvdyBuZXcgRXJyb3IoXCJSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSBcIitlKX10aGlzLl9fcnVsZXNfX1tuXS5lbmFibGVkPSExLHIucHVzaChlKX0pLHRoaXMpLHRoaXMuX19jYWNoZV9fPW51bGwscn0sbi5wcm90b3R5cGUuZ2V0UnVsZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PT10aGlzLl9fY2FjaGVfXyYmdGhpcy5fX2NvbXBpbGVfXygpLHRoaXMuX19jYWNoZV9fW2VdfHxbXX0sZS5leHBvcnRzPW59LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUsdCxyKXt0aGlzLnR5cGU9ZSx0aGlzLnRhZz10LHRoaXMuYXR0cnM9bnVsbCx0aGlzLm1hcD1udWxsLHRoaXMubmVzdGluZz1yLHRoaXMubGV2ZWw9MCx0aGlzLmNoaWxkcmVuPW51bGwsdGhpcy5jb250ZW50PVwiXCIsdGhpcy5tYXJrdXA9XCJcIix0aGlzLmluZm89XCJcIix0aGlzLm1ldGE9bnVsbCx0aGlzLmJsb2NrPSExLHRoaXMuaGlkZGVuPSExfW4ucHJvdG90eXBlLmF0dHJJbmRleD1mdW5jdGlvbihlKXt2YXIgdCxyLG47aWYoIXRoaXMuYXR0cnMpcmV0dXJuLTE7Zm9yKHI9MCxuPSh0PXRoaXMuYXR0cnMpLmxlbmd0aDtyPG47cisrKWlmKHRbcl1bMF09PT1lKXJldHVybiByO3JldHVybi0xfSxuLnByb3RvdHlwZS5hdHRyUHVzaD1mdW5jdGlvbihlKXt0aGlzLmF0dHJzP3RoaXMuYXR0cnMucHVzaChlKTp0aGlzLmF0dHJzPVtlXX0sbi5wcm90b3R5cGUuYXR0clNldD1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuYXR0ckluZGV4KGUpLG49W2UsdF07cjwwP3RoaXMuYXR0clB1c2gobik6dGhpcy5hdHRyc1tyXT1ufSxuLnByb3RvdHlwZS5hdHRyR2V0PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuYXR0ckluZGV4KGUpLHI9bnVsbDtyZXR1cm4gdD49MCYmKHI9dGhpcy5hdHRyc1t0XVsxXSkscn0sbi5wcm90b3R5cGUuYXR0ckpvaW49ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmF0dHJJbmRleChlKTtyPDA/dGhpcy5hdHRyUHVzaChbZSx0XSk6dGhpcy5hdHRyc1tyXVsxXT10aGlzLmF0dHJzW3JdWzFdK1wiIFwiK3R9LGUuZXhwb3J0cz1ufSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7Y29uc3Qgbj0vW1xcdTAwMDAtXFx1MDAxZl0vZyxpPS9bXFxzfmAhQCMkJV4mKigpXFwtXys9W1xcXXt9fFxcXFw7OlwiJ+KAnOKAneKAmOKAmeKAk+KAlDw+LC4/L10rL2cscz0vW1xcdTAzMDAtXFx1MDM2Rl0vZztlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9ybWFsaXplKFwiTkZLRFwiKS5yZXBsYWNlKHMsXCJcIikucmVwbGFjZShuLFwiXCIpLnJlcGxhY2UoaSxcIi1cIikucmVwbGFjZSgvXFwtezIsfS9nLFwiLVwiKS5yZXBsYWNlKC9eXFwtK3xcXC0rJC9nLFwiXCIpLnJlcGxhY2UoL14oXFxkKS8sXCJfJDFcIikudG9Mb3dlckNhc2UoKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9cigyMSl9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHMuZW5jb2RlPXIoMjIpLGUuZXhwb3J0cy5kZWNvZGU9cigyMyksZS5leHBvcnRzLmZvcm1hdD1yKDI0KSxlLmV4cG9ydHMucGFyc2U9cigyNSl9LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPS9bXFwwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vfSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz0vW1xcMC1cXHgxRlxceDdGLVxceDlGXS99LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPS9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwXS99LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1cIjxbQS1aYS16XVtBLVphLXowLTlcXFxcLV0qKD86XFxcXHMrW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSooPzpcXFxccyo9XFxcXHMqKD86W15cXFwiJz08PmBcXFxceDAwLVxcXFx4MjBdK3wnW14nXSonfFxcXCJbXlxcXCJdKlxcXCIpKT8pKlxcXFxzKlxcXFwvPz5cIixpPVwiPFxcXFwvW0EtWmEtel1bQS1aYS16MC05XFxcXC1dKlxcXFxzKj5cIixzPW5ldyBSZWdFeHAoXCJeKD86XCIrbitcInxcIitpK1wifFxceDNjIS0tLS1cXHgzZXxcXHgzYyEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLVxceDNlfDxbP11bXFxcXHNcXFxcU10qP1s/XT58PCFbQS1aXStcXFxccytbXj5dKj58PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+KVwiKSxvPW5ldyBSZWdFeHAoXCJeKD86XCIrbitcInxcIitpK1wiKVwiKTtlLmV4cG9ydHMuSFRNTF9UQUdfUkU9cyxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRT1vfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlLHQpe3ZhciByLG4saSxzLG8sYT1bXSxjPXQubGVuZ3RoO2ZvcihyPTA7cjxjO3IrKykxMjY9PT0oaT10W3JdKS5tYXJrZXImJi0xIT09aS5lbmQmJihzPXRbaS5lbmRdLChvPWUudG9rZW5zW2kudG9rZW5dKS50eXBlPVwic19vcGVuXCIsby50YWc9XCJzXCIsby5uZXN0aW5nPTEsby5tYXJrdXA9XCJ+flwiLG8uY29udGVudD1cIlwiLChvPWUudG9rZW5zW3MudG9rZW5dKS50eXBlPVwic19jbG9zZVwiLG8udGFnPVwic1wiLG8ubmVzdGluZz0tMSxvLm1hcmt1cD1cIn5+XCIsby5jb250ZW50PVwiXCIsXCJ0ZXh0XCI9PT1lLnRva2Vuc1tzLnRva2VuLTFdLnR5cGUmJlwiflwiPT09ZS50b2tlbnNbcy50b2tlbi0xXS5jb250ZW50JiZhLnB1c2gocy50b2tlbi0xKSk7Zm9yKDthLmxlbmd0aDspe2ZvcihuPShyPWEucG9wKCkpKzE7bjxlLnRva2Vucy5sZW5ndGgmJlwic19jbG9zZVwiPT09ZS50b2tlbnNbbl0udHlwZTspbisrO3IhPT0tLW4mJihvPWUudG9rZW5zW25dLGUudG9rZW5zW25dPWUudG9rZW5zW3JdLGUudG9rZW5zW3JdPW8pfX1lLmV4cG9ydHMudG9rZW5pemU9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGkscyxvPWUucG9zLGE9ZS5zcmMuY2hhckNvZGVBdChvKTtpZih0KXJldHVybiExO2lmKDEyNiE9PWEpcmV0dXJuITE7aWYoaT0obj1lLnNjYW5EZWxpbXMoZS5wb3MsITApKS5sZW5ndGgscz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpLGk8MilyZXR1cm4hMTtmb3IoaSUyJiYoZS5wdXNoKFwidGV4dFwiLFwiXCIsMCkuY29udGVudD1zLGktLSkscj0wO3I8aTtyKz0yKWUucHVzaChcInRleHRcIixcIlwiLDApLmNvbnRlbnQ9cytzLGUuZGVsaW1pdGVycy5wdXNoKHttYXJrZXI6YSxsZW5ndGg6MCx0b2tlbjplLnRva2Vucy5sZW5ndGgtMSxlbmQ6LTEsb3BlbjpuLmNhbl9vcGVuLGNsb3NlOm4uY2FuX2Nsb3NlfSk7cmV0dXJuIGUucG9zKz1uLmxlbmd0aCwhMH0sZS5leHBvcnRzLnBvc3RQcm9jZXNzPWZ1bmN0aW9uKGUpe3ZhciB0LHI9ZS50b2tlbnNfbWV0YSxpPWUudG9rZW5zX21ldGEubGVuZ3RoO2ZvcihuKGUsZS5kZWxpbWl0ZXJzKSx0PTA7dDxpO3QrKylyW3RdJiZyW3RdLmRlbGltaXRlcnMmJm4oZSxyW3RdLmRlbGltaXRlcnMpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSx0KXt2YXIgcixuLGkscyxvLGE7Zm9yKHI9dC5sZW5ndGgtMTtyPj0wO3ItLSk5NSE9PShuPXRbcl0pLm1hcmtlciYmNDIhPT1uLm1hcmtlcnx8LTEhPT1uLmVuZCYmKGk9dFtuLmVuZF0sYT1yPjAmJnRbci0xXS5lbmQ9PT1uLmVuZCsxJiZ0W3ItMV0ubWFya2VyPT09bi5tYXJrZXImJnRbci0xXS50b2tlbj09PW4udG9rZW4tMSYmdFtuLmVuZCsxXS50b2tlbj09PWkudG9rZW4rMSxvPVN0cmluZy5mcm9tQ2hhckNvZGUobi5tYXJrZXIpLChzPWUudG9rZW5zW24udG9rZW5dKS50eXBlPWE/XCJzdHJvbmdfb3BlblwiOlwiZW1fb3BlblwiLHMudGFnPWE/XCJzdHJvbmdcIjpcImVtXCIscy5uZXN0aW5nPTEscy5tYXJrdXA9YT9vK286byxzLmNvbnRlbnQ9XCJcIiwocz1lLnRva2Vuc1tpLnRva2VuXSkudHlwZT1hP1wic3Ryb25nX2Nsb3NlXCI6XCJlbV9jbG9zZVwiLHMudGFnPWE/XCJzdHJvbmdcIjpcImVtXCIscy5uZXN0aW5nPS0xLHMubWFya3VwPWE/bytvOm8scy5jb250ZW50PVwiXCIsYSYmKGUudG9rZW5zW3Rbci0xXS50b2tlbl0uY29udGVudD1cIlwiLGUudG9rZW5zW3Rbbi5lbmQrMV0udG9rZW5dLmNvbnRlbnQ9XCJcIixyLS0pKX1lLmV4cG9ydHMudG9rZW5pemU9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk9ZS5wb3Mscz1lLnNyYy5jaGFyQ29kZUF0KGkpO2lmKHQpcmV0dXJuITE7aWYoOTUhPT1zJiY0MiE9PXMpcmV0dXJuITE7Zm9yKG49ZS5zY2FuRGVsaW1zKGUucG9zLDQyPT09cykscj0wO3I8bi5sZW5ndGg7cisrKWUucHVzaChcInRleHRcIixcIlwiLDApLmNvbnRlbnQ9U3RyaW5nLmZyb21DaGFyQ29kZShzKSxlLmRlbGltaXRlcnMucHVzaCh7bWFya2VyOnMsbGVuZ3RoOm4ubGVuZ3RoLHRva2VuOmUudG9rZW5zLmxlbmd0aC0xLGVuZDotMSxvcGVuOm4uY2FuX29wZW4sY2xvc2U6bi5jYW5fY2xvc2V9KTtyZXR1cm4gZS5wb3MrPW4ubGVuZ3RoLCEwfSxlLmV4cG9ydHMucG9zdFByb2Nlc3M9ZnVuY3Rpb24oZSl7dmFyIHQscj1lLnRva2Vuc19tZXRhLGk9ZS50b2tlbnNfbWV0YS5sZW5ndGg7Zm9yKG4oZSxlLmRlbGltaXRlcnMpLHQ9MDt0PGk7dCsrKXJbdF0mJnJbdF0uZGVsaW1pdGVycyYmbihlLHJbdF0uZGVsaW1pdGVycyl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7Y29uc3Qgbj1yKDE4KSxpPXtsZWZ0RGVsaW1pdGVyOlwie1wiLHJpZ2h0RGVsaW1pdGVyOlwifVwiLGFsbG93ZWRBdHRyaWJ1dGVzOltdfTtmdW5jdGlvbiBzKGUsdCxyKXtsZXQgbj17bWF0Y2g6ITEsajpudWxsfSxpPXZvaWQgMCE9PXIuc2hpZnQ/dCtyLnNoaWZ0OnIucG9zaXRpb24sbD0odT1lLChwPWkpPj0wP3VbcF06dVt1Lmxlbmd0aCtwXSk7dmFyIHUscDtpZih2b2lkIDA9PT1sKXJldHVybiBuO2ZvcihsZXQgZSBpbiByKWlmKFwic2hpZnRcIiE9PWUmJlwicG9zaXRpb25cIiE9PWUpe2lmKHZvaWQgMD09PWxbZV0pcmV0dXJuIG47aWYoXCJjaGlsZHJlblwiPT09ZSYmbyhyLmNoaWxkcmVuKSl7aWYoMD09PWwuY2hpbGRyZW4ubGVuZ3RoKXJldHVybiBuO2xldCBlLHQ9ci5jaGlsZHJlbixpPWwuY2hpbGRyZW47aWYodC5ldmVyeShlPT52b2lkIDAhPT1lLnBvc2l0aW9uKSl7aWYoZT10LmV2ZXJ5KGU9PnMoaSxlLnBvc2l0aW9uLGUpLm1hdGNoKSxlKXtsZXQgZT1jKHQpLnBvc2l0aW9uO24uaj1lPj0wP2U6aS5sZW5ndGgrZX19ZWxzZSBmb3IobGV0IHI9MDtyPGkubGVuZ3RoO3IrKylpZihlPXQuZXZlcnkoZT0+cyhpLHIsZSkubWF0Y2gpLGUpe24uaj1yO2JyZWFrfWlmKCExPT09ZSlyZXR1cm4gbn1lbHNlIHN3aXRjaCh0eXBlb2YgcltlXSl7Y2FzZVwiYm9vbGVhblwiOmNhc2VcIm51bWJlclwiOmNhc2VcInN0cmluZ1wiOmlmKGxbZV0hPT1yW2VdKXJldHVybiBuO2JyZWFrO2Nhc2VcImZ1bmN0aW9uXCI6aWYoIXJbZV0obFtlXSkpcmV0dXJuIG47YnJlYWs7Y2FzZVwib2JqZWN0XCI6aWYoYShyW2VdKSl7aWYoITE9PT1yW2VdLmV2ZXJ5KHQ9PnQobFtlXSkpKXJldHVybiBuO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgb2YgcGF0dGVybiB0ZXN0IChrZXk6ICR7ZX0pLiBUZXN0IHNob3VsZCBiZSBvZiB0eXBlIGJvb2xlYW4sIG51bWJlciwgc3RyaW5nLCBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMuYCl9fXJldHVybiBuLm1hdGNoPSEwLG59ZnVuY3Rpb24gbyhlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGgmJmUuZXZlcnkoZT0+XCJvYmplY3RcIj09dHlwZW9mIGUpfWZ1bmN0aW9uIGEoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJmUubGVuZ3RoJiZlLmV2ZXJ5KGU9PlwiZnVuY3Rpb25cIj09dHlwZW9mIGUpfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGUuc2xpY2UoLTEpWzBdfHx7fX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtsZXQgcj1PYmplY3QuYXNzaWduKHt9LGkpO3I9T2JqZWN0LmFzc2lnbihyLHQpO2NvbnN0IG89bihyKTtlLmNvcmUucnVsZXIuYmVmb3JlKFwibGlua2lmeVwiLFwiY3VybHlfYXR0cmlidXRlc1wiLChmdW5jdGlvbihlKXtsZXQgdD1lLnRva2Vucztmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylmb3IobGV0IHI9MDtyPG8ubGVuZ3RoO3IrKyl7bGV0IG49b1tyXSxpPW51bGw7bi50ZXN0cy5ldmVyeShyPT57bGV0IG49cyh0LGUscik7cmV0dXJuIG51bGwhPT1uLmomJihpPW4uaiksbi5tYXRjaH0pJiYobi50cmFuc2Zvcm0odCxlLGkpLFwiaW5saW5lIGF0dHJpYnV0ZXNcIiE9PW4ubmFtZSYmXCJpbmxpbmUgbmVzdGluZyAwXCIhPT1uLm5hbWV8fHItLSl9fSkpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yKDIwKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3Iucih0KSxyLmQodCxcImRlZmF1bHRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZ30pKTt2YXIgbj1yKDEpLGk9cigxNSkscz1yLm4oaSksbz1mdW5jdGlvbihlLHQpe3ZhciByPSh2b2lkIDA9PT10P3t9OnQpLmxpbmVNYXJrdXAsbj12b2lkIDA9PT1yP1wiZGF0YS1saW5lXCI6cixpPWZ1bmN0aW9uKGUsdCxyLG4saSl7cmV0dXJuIGkucmVuZGVyVG9rZW4oZSx0LHIpfTtmdW5jdGlvbiBzKGUpe3JldHVybiBmdW5jdGlvbih0LHIsaSxzLG8pe3ZhciBhPXRbcl07cmV0dXJuIGEuYXR0clB1c2goW24sYS5tYXBbMF0rMV0pLGUodCxyLGkscyxvKX19ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZnVuY3Rpb24odCxyLGkscyxvKXt2YXIgYT1lKHQscixpLHMsbyksYz10W3JdLm1hcFswXSsxO3JldHVyblwiPGRpdiBcIituKyc9XCInK2MrJ1wiPicrYStcIjwvZGl2PlwifX12YXIgYT17dGFibGVfb3BlbjpzLGJsb2NrcXVvdGVfb3BlbjpzLGJ1bGxldF9saXN0X29wZW46cyxvcmRlcmVkX2xpc3Rfb3BlbjpzLHJlZmVyZW5jZV9vcGVuOnMsaGVhZGluZ19vcGVuOnMsbGhlYWRpbmdfb3BlbjpzLHBhcmFncmFwaF9vcGVuOnMsaHI6cyxodG1sX2Jsb2NrOm8sY29kZV9ibG9jazpvLGZlbmNlOm99O09iamVjdC5rZXlzKGEpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPWUucmVuZGVyZXIucnVsZXNbdF18fGk7ZS5yZW5kZXJlci5ydWxlc1t0XT1hW3RdKHIpfSkpfSxhPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9e30pO3ZhciByPXQuZ2V0TWFya3M7ciYmZS5jb3JlLnJ1bGVyLnB1c2goXCJhbmNob3JcIiwoZnVuY3Rpb24oZSl7dmFyIHQ9e30sbj1lLnRva2VucztuLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuXCJoZWFkaW5nX29wZW5cIj09PWUudHlwZX0pKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgaT1uW24uaW5kZXhPZihlKSsxXS5jb250ZW50LHM9TnVtYmVyKGUudGFnLnN1YnN0cigxKSk7dFtpXT1pIGluIHQ/TnVtYmVyKHRbaV0pKzE6XCJcIjt2YXIgbz1yKGkscyx0W2ldKTtvJiZvLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPXQuYXR0cixuPXQudmFsdWU7ZS5hdHRyUHVzaChbcixuXSl9KSl9KSl9KSl9LGM9e2luY2x1ZGVMZXZlbDpbMiwzXSxjb250YWluZXJDbGFzczpcInRhYmxlLW9mLWNvbnRlbnRzXCIsbGlzdENsYXNzOlwidGFibGUtb2YtY29udGVudC1saXN0XCIsbGlzdEl0ZW1DbGFzczpcInRhYmxlLW9mLWNvbnRlbnQtbGlzdC1pdGVtXCIsbWFya2VyUGF0dGVybjovXlxcW1xcW3RvY1xcXVxcXS9pbSxsaXN0VHlwZTpcInVsXCIsZ2V0QW5jaG9yQXR0cnM6ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZm9ybWF0OnZvaWQgMCxmb3JjZUZ1bGxUb2M6ITEsY29udGFpbmVySGVhZGVySHRtbDp2b2lkIDAsY29udGFpbmVyRm9vdGVySHRtbDp2b2lkIDAsdHJhbnNmb3JtTGluazp2b2lkIDB9LGw9ZnVuY3Rpb24oZSx0KXt2YXIgcixpPU9iamVjdChuLmEpKHt9LGMsdCkscz1pLm1hcmtlclBhdHRlcm47ZnVuY3Rpb24gbyhlLHQscil7Zm9yKHZhciBuLHMsYT1bXSxjPVwiXCIsbD10Lmxlbmd0aCx1PWU7dTxsOyl7dmFyIHA9dFt1XSxoPXRbdS0xXSxmPXAudGFnJiZwYXJzZUludChwLnRhZy5zdWJzdHIoMSwxKSk7aWYoXCJoZWFkaW5nX2Nsb3NlXCI9PT1wLnR5cGUmJi0xIT1pLmluY2x1ZGVMZXZlbC5pbmRleE9mKGYpJiZcImlubGluZVwiPT09aC50eXBlKXtpZihuKXtpZihmPm4pe2MrPShzPW8odSx0LHIpKVsxXSx1PXNbMF07Y29udGludWV9aWYoZjxuKXJldHVybiBjKz1cIjwvbGk+XCIsYS5wdXNoKGMpLFt1LFwiPFwiK2kubGlzdFR5cGUrJyBjbGFzcz1cIicraS5saXN0Q2xhc3MrJ1wiPicrYS5qb2luKFwiXCIpK1wiPC9cIitpLmxpc3RUeXBlK1wiPlwiXTtmPT1uJiYoYys9XCI8L2xpPlwiLGEucHVzaChjKSl9ZWxzZSBuPWY7dmFyIGQ9aC5jaGlsZHJlbi5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdC5jb250ZW50fSksXCJcIiksZz1oLmNvbnRlbnQsbT1yW2ddPWcgaW4gcj9OdW1iZXIocltnXSkrMTpcIlwiLF89aS5nZXRBbmNob3JBdHRycyhnLGYsbSk7Yz0nPGxpIGNsYXNzPVwiJytpLmxpc3RJdGVtQ2xhc3MrJ1wiPlxcbiAgICAgIDxhICcrXy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmF0dHIrJz1cIicrZS52YWx1ZSsnXCInfSkpLmpvaW4oXCIgXCIpK1wiPlwiLGMrPWQsYys9XCI8L2E+XCIsdSsrfWVsc2UgdSsrfXJldHVybiBjKz1cIlwiPT09Yz9cIlwiOlwiPC9saT5cIixhLnB1c2goYyksW3UsXCI8XCIraS5saXN0VHlwZSsnIGNsYXNzPVwiJytpLmxpc3RDbGFzcysnXCI+JythLmpvaW4oXCJcIikrXCI8L1wiK2kubGlzdFR5cGUrXCI+XCJdfWUucmVuZGVyZXIucnVsZXMudG9jX29wZW49ZnVuY3Rpb24oZSx0KXt2YXIgcj0nPGRpdiBjbGFzcz1cIicraS5jb250YWluZXJDbGFzcysnXCI+JztyZXR1cm4gaS5jb250YWluZXJIZWFkZXJIdG1sJiYocis9aS5jb250YWluZXJIZWFkZXJIdG1sKSxyfSxlLnJlbmRlcmVyLnJ1bGVzLnRvY19jbG9zZT1mdW5jdGlvbihlLHQpe3ZhciByPVwiXCI7cmV0dXJuIGkuY29udGFpbmVyRm9vdGVySHRtbCYmKHI9aS5jb250YWluZXJGb290ZXJIdG1sKSxyK1wiPC9kaXY+XCJ9LGUucmVuZGVyZXIucnVsZXMudG9jX2JvZHk9ZnVuY3Rpb24oZSx0KXt2YXIgbj17fTtpZihpLmZvcmNlRnVsbFRvYyl7Zm9yKHZhciBzPVwiXCIsYT0wLGM9ciYmci50b2tlbnMmJnIudG9rZW5zLmxlbmd0aDthPGM7KXt2YXIgbD1vKGEsci50b2tlbnMsbik7YT1sWzBdLHMrPWxbMV19cmV0dXJuIHN9cmV0dXJuIG8oMCxyLnRva2VucyxuKVsxXX0sZS5jb3JlLnJ1bGVyLnB1c2goXCJncmFiX3N0YXRlXCIsKGZ1bmN0aW9uKGUpe3I9ZX0pKSxlLmlubGluZS5ydWxlci5hZnRlcihcImVtcGhhc2lzXCIsXCJ0b2NcIiwoZnVuY3Rpb24oZSx0KXt2YXIgcjtpZig5MSE9PWUuc3JjLmNoYXJDb2RlQXQoZS5wb3MpKXJldHVybiExO2lmKHQpcmV0dXJuITE7aWYoKHI9KHI9cy5leGVjKGUuc3JjLnN1YnN0cihlLnBvcykpKT9yLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGV9KSk6W10pLmxlbmd0aDwxKXJldHVybiExO2UucHVzaChcInRvY19vcGVuXCIsXCJ0b2NcIiwxKS5tYXJrdXA9XCJbW3RvY11dXCIsZS5wdXNoKFwidG9jX2JvZHlcIixcIlwiLDApLGUucHVzaChcInRvY19jbG9zZVwiLFwidG9jXCIsLTEpO3ZhciBuPWUuc3JjLmluZGV4T2YoXCJcXG5cIixlLnBvcyk7cmV0dXJuIGUucG9zPS0xIT09bj9uOmUucG9zK2UucG9zTWF4KzEsITB9KSl9LHU9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD17fSk7dmFyIHI9dC5nZXRXcmFwcGVyQ2xhc3Msbj12b2lkIDA9PT1yP2Z1bmN0aW9uKGUpe3JldHVyblwibGFuZ3VhZ2UtXCIrZX06cixpPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSsrKXJbaV09YXJndW1lbnRzW2ldO3ZhciBzPXJbMF0sbz1yWzFdLGE9c1tvXSxjPWUuYXBwbHkodm9pZCAwLHIpO3JldHVybidcXHgzYyEtLWJlZm9yZWJlZ2luLS1cXHgzZTxkaXYgY2xhc3M9XCInK24oYS5pbmZvLnRyaW0oKSkrJyBleHRyYS1jbGFzc1wiIGV4dHJhLWF0dHI+XFx4M2MhLS1hZnRlcmJlZ2luLS1cXHgzZScrYytcIlxceDNjIS0tYmVmb3JlZW5kLS1cXHgzZTwvZGl2PlxceDNjIS0tYWZ0ZXJlbmQtLVxceDNlXCJ9fSxzPWUucmVuZGVyZXIucnVsZXMsbz1zLmZlbmNlLGE9cy5jb2RlX2Jsb2NrO2UucmVuZGVyZXIucnVsZXMuZmVuY2U9aShvKSxlLnJlbmRlcmVyLnJ1bGVzLmNvZGVfYmxvY2s9aShhKX0scD1mdW5jdGlvbihlLHQpe3ZhciByPXQuZXh0ZXJuYWxBdHRycyxuPXQub3BlbkxpbmtJY29uLGk9dC5vcGVuTGlua0ljb25DbGFzcyxzPSExO2UucmVuZGVyZXIucnVsZXMubGlua19vcGVuPWZ1bmN0aW9uKGUsdCxuLGksbyl7dmFyIGE9ZVt0XSxjPWEuYXR0ckluZGV4KFwiaHJlZlwiKTtpZihjPj0wKXt2YXIgbD1hLmF0dHJzW2NdWzFdOy9eaHR0cHM/Oi8udGVzdChsKSYmKE9iamVjdC5rZXlzKHIpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2EuYXR0clNldChlLHJbZV0pfSkpLC9fYmxhbmsvaS50ZXN0KHIudGFyZ2V0KSYmKHM9ITApKX1yZXR1cm4gby5yZW5kZXJUb2tlbihlLHQsbil9LGUucmVuZGVyZXIucnVsZXMubGlua19jbG9zZT1mdW5jdGlvbihlLHQscixvLGEpe3JldHVybiBzJiYocz0hMSxuKT9pPyc8aSBjbGFzcz1cIicraSsnXCI+PC9pPicrYS5yZW5kZXJUb2tlbihlLHQscik6JzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIiB3aWR0aD1cIjE1XCIgaGVpZ2h0PVwiMTVcIiBjbGFzcz1cInYtbWQtc3ZnLW91dGJvdW5kXCI+PHBhdGggZmlsbD1cImN1cnJlbnRDb2xvclwiIGQ9XCJNMTguOCw4NS4xaDU2bDAsMGMyLjIsMCw0LTEuOCw0LTR2LTMyaC04djI4aC00OHYtNDhoMjh2LThoLTMybDAsMGMtMi4yLDAtNCwxLjgtNCw0djU2QzE0LjgsODMuMywxNi42LDg1LjEsMTguOCw4NS4xelwiPjwvcGF0aD4gPHBvbHlnb24gZmlsbD1cImN1cnJlbnRDb2xvclwiIHBvaW50cz1cIjQ1LjcsNDguNyA1MS4zLDU0LjMgNzcuMiwyOC41IDc3LjIsMzcuMiA4NS4yLDM3LjIgODUuMiwxNC45IDYyLjgsMTQuOSA2Mi44LDIyLjkgNzEuNSwyMi45XCI+PC9wb2x5Z29uPjwvc3ZnPicrYS5yZW5kZXJUb2tlbihlLHQscik6YS5yZW5kZXJUb2tlbihlLHQscil9fSxoPXIoNiksZj1yLm4oaCksZD1yKDIpO2Z1bmN0aW9uIGcoZSl7dmFyIHQ9dm9pZCAwPT09ZT97fTplLHI9dC50b2MsaT10LmxpbmssYz10LmF0dHJzLGg9T2JqZWN0KGQuYikoKTtyZXR1cm4gaC51c2UocCxPYmplY3Qobi5hKSh7ZXh0ZXJuYWxBdHRyczp7dGFyZ2V0OlwiX2JsYW5rXCJ9fSxpKSkudXNlKHUse2dldFdyYXBwZXJDbGFzczpmdW5jdGlvbihlKXtyZXR1cm5cInYtbWQtcHJlLXdyYXBwZXIgdi1tZC1wcmUtd3JhcHBlci1cIitlfX0pLnVzZShzLmEsT2JqZWN0KG4uYSkoe2xlZnREZWxpbWl0ZXI6XCJ7e3tcIixyaWdodERlbGltaXRlcjpcIn19fVwifSxjLHthbGxvd2VkQXR0cmlidXRlczpbXCJ3aWR0aFwiLFwiaGVpZ2h0XCJdLmNvbmNhdChudWxsPT1jP3ZvaWQgMDpjLmFsbG93ZWRBdHRyaWJ1dGVzKX0pKS51c2UoYSx7Z2V0TWFya3M6ZnVuY3Rpb24oZSx0LHIpe3JldHVyblt7YXR0cjpcImRhdGEtdi1tZC1oZWFkaW5nXCIsdmFsdWU6ZigpKGUpKyhyP1wiLVwiK3I6XCJcIil9XX19KS51c2UobCxPYmplY3Qobi5hKSh7bGlzdENsYXNzOlwidi1tZC10b2NcIixsaXN0SXRlbUNsYXNzOlwidi1tZC10b2MtaXRlbVwiLGdldEFuY2hvckF0dHJzOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm5be2F0dHI6XCJkYXRhLXYtbWQtYW5jaG9yXCIsdmFsdWU6ZigpKGUpKyhyP1wiLVwiK3I6XCJcIil9XX19LHIpKS51c2Uobyx7bGluZU1hcmt1cDpcImRhdGEtdi1tZC1saW5lXCJ9KSx7cHJldmlld0NsYXNzOlwibWFya2Rvd24tYm9keVwiLGV4dGVuZDpmdW5jdGlvbihlKXtlKGgpfSxtYXJrZG93blBhcnNlcjpofX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtjb25zdCBuPXIoMTkpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUuc2xpY2UoLTEpWzBdfWUuZXhwb3J0cz1lPT57Y29uc3QgdD1uZXcgUmVnRXhwKFwiXiB7MCwzfVstKl9dezMsfSA/XCIrbi5lc2NhcGVSZWdFeHAoZS5sZWZ0RGVsaW1pdGVyKStcIlteXCIrbi5lc2NhcGVSZWdFeHAoZS5yaWdodERlbGltaXRlcikrXCJdXCIpO3JldHVyblt7bmFtZTpcImZlbmNlZCBjb2RlIGJsb2Nrc1wiLHRlc3RzOlt7c2hpZnQ6MCxibG9jazohMCxpbmZvOm4uaGFzRGVsaW1pdGVycyhcImVuZFwiLGUpfV0sdHJhbnNmb3JtOih0LHIpPT57bGV0IGk9dFtyXSxzPWkuaW5mby5sYXN0SW5kZXhPZihlLmxlZnREZWxpbWl0ZXIpLG89bi5nZXRBdHRycyhpLmluZm8scyxlKTtuLmFkZEF0dHJzKG8saSksaS5pbmZvPW4ucmVtb3ZlRGVsaW1pdGVyKGkuaW5mbyxlKX19LHtuYW1lOlwiaW5saW5lIG5lc3RpbmcgMFwiLHRlc3RzOlt7c2hpZnQ6MCx0eXBlOlwiaW5saW5lXCIsY2hpbGRyZW46W3tzaGlmdDotMSx0eXBlOmU9PlwiaW1hZ2VcIj09PWV8fFwiY29kZV9pbmxpbmVcIj09PWV9LHtzaGlmdDowLHR5cGU6XCJ0ZXh0XCIsY29udGVudDpuLmhhc0RlbGltaXRlcnMoXCJzdGFydFwiLGUpfV19XSx0cmFuc2Zvcm06KHQscixpKT0+e2xldCBzPXRbcl0uY2hpbGRyZW5baV0sbz1zLmNvbnRlbnQuaW5kZXhPZihlLnJpZ2h0RGVsaW1pdGVyKSxhPXRbcl0uY2hpbGRyZW5baS0xXSxjPW4uZ2V0QXR0cnMocy5jb250ZW50LDAsZSk7bi5hZGRBdHRycyhjLGEpLHMuY29udGVudC5sZW5ndGg9PT1vK2UucmlnaHREZWxpbWl0ZXIubGVuZ3RoP3Rbcl0uY2hpbGRyZW4uc3BsaWNlKGksMSk6cy5jb250ZW50PXMuY29udGVudC5zbGljZShvK2UucmlnaHREZWxpbWl0ZXIubGVuZ3RoKX19LHtuYW1lOlwidGFibGVzXCIsdGVzdHM6W3tzaGlmdDowLHR5cGU6XCJ0YWJsZV9jbG9zZVwifSx7c2hpZnQ6MSx0eXBlOlwicGFyYWdyYXBoX29wZW5cIn0se3NoaWZ0OjIsdHlwZTpcImlubGluZVwiLGNvbnRlbnQ6bi5oYXNEZWxpbWl0ZXJzKFwib25seVwiLGUpfV0sdHJhbnNmb3JtOih0LHIpPT57bGV0IGk9dFtyKzJdLHM9bi5nZXRNYXRjaGluZ09wZW5pbmdUb2tlbih0LHIpLG89bi5nZXRBdHRycyhpLmNvbnRlbnQsMCxlKTtuLmFkZEF0dHJzKG8scyksdC5zcGxpY2UocisxLDMpfX0se25hbWU6XCJpbmxpbmUgYXR0cmlidXRlc1wiLHRlc3RzOlt7c2hpZnQ6MCx0eXBlOlwiaW5saW5lXCIsY2hpbGRyZW46W3tzaGlmdDotMSxuZXN0aW5nOi0xfSx7c2hpZnQ6MCx0eXBlOlwidGV4dFwiLGNvbnRlbnQ6bi5oYXNEZWxpbWl0ZXJzKFwic3RhcnRcIixlKX1dfV0sdHJhbnNmb3JtOih0LHIsaSk9PntsZXQgcz10W3JdLmNoaWxkcmVuW2ldLG89cy5jb250ZW50LGE9bi5nZXRBdHRycyhvLDAsZSksYz1uLmdldE1hdGNoaW5nT3BlbmluZ1Rva2VuKHRbcl0uY2hpbGRyZW4saS0xKTtuLmFkZEF0dHJzKGEsYykscy5jb250ZW50PW8uc2xpY2Uoby5pbmRleE9mKGUucmlnaHREZWxpbWl0ZXIpK2UucmlnaHREZWxpbWl0ZXIubGVuZ3RoKX19LHtuYW1lOlwibGlzdCBzb2Z0YnJlYWtcIix0ZXN0czpbe3NoaWZ0Oi0yLHR5cGU6XCJsaXN0X2l0ZW1fb3BlblwifSx7c2hpZnQ6MCx0eXBlOlwiaW5saW5lXCIsY2hpbGRyZW46W3twb3NpdGlvbjotMix0eXBlOlwic29mdGJyZWFrXCJ9LHtwb3NpdGlvbjotMSx0eXBlOlwidGV4dFwiLGNvbnRlbnQ6bi5oYXNEZWxpbWl0ZXJzKFwib25seVwiLGUpfV19XSx0cmFuc2Zvcm06KHQscixpKT0+e2xldCBzPXRbcl0uY2hpbGRyZW5baV0uY29udGVudCxvPW4uZ2V0QXR0cnMocywwLGUpLGE9ci0yO2Zvcig7dFthLTFdJiZcIm9yZGVyZWRfbGlzdF9vcGVuXCIhPT10W2EtMV0udHlwZSYmXCJidWxsZXRfbGlzdF9vcGVuXCIhPT10W2EtMV0udHlwZTspYS0tO24uYWRkQXR0cnMobyx0W2EtMV0pLHRbcl0uY2hpbGRyZW49dFtyXS5jaGlsZHJlbi5zbGljZSgwLC0yKX19LHtuYW1lOlwibGlzdCBkb3VibGUgc29mdGJyZWFrXCIsdGVzdHM6W3tzaGlmdDowLHR5cGU6ZT0+XCJidWxsZXRfbGlzdF9jbG9zZVwiPT09ZXx8XCJvcmRlcmVkX2xpc3RfY2xvc2VcIj09PWV9LHtzaGlmdDoxLHR5cGU6XCJwYXJhZ3JhcGhfb3BlblwifSx7c2hpZnQ6Mix0eXBlOlwiaW5saW5lXCIsY29udGVudDpuLmhhc0RlbGltaXRlcnMoXCJvbmx5XCIsZSksY2hpbGRyZW46ZT0+MT09PWUubGVuZ3RofSx7c2hpZnQ6Myx0eXBlOlwicGFyYWdyYXBoX2Nsb3NlXCJ9XSx0cmFuc2Zvcm06KHQscik9PntsZXQgaT10W3IrMl0uY29udGVudCxzPW4uZ2V0QXR0cnMoaSwwLGUpLG89bi5nZXRNYXRjaGluZ09wZW5pbmdUb2tlbih0LHIpO24uYWRkQXR0cnMocyxvKSx0LnNwbGljZShyKzEsMyl9fSx7bmFtZTpcImxpc3QgaXRlbSBlbmRcIix0ZXN0czpbe3NoaWZ0Oi0yLHR5cGU6XCJsaXN0X2l0ZW1fb3BlblwifSx7c2hpZnQ6MCx0eXBlOlwiaW5saW5lXCIsY2hpbGRyZW46W3twb3NpdGlvbjotMSx0eXBlOlwidGV4dFwiLGNvbnRlbnQ6bi5oYXNEZWxpbWl0ZXJzKFwiZW5kXCIsZSl9XX1dLHRyYW5zZm9ybToodCxyLHMpPT57bGV0IG89dFtyXS5jaGlsZHJlbltzXSxhPW8uY29udGVudCxjPW4uZ2V0QXR0cnMoYSxhLmxhc3RJbmRleE9mKGUubGVmdERlbGltaXRlciksZSk7bi5hZGRBdHRycyhjLHRbci0yXSk7bGV0IGw9YS5zbGljZSgwLGEubGFzdEluZGV4T2YoZS5sZWZ0RGVsaW1pdGVyKSk7by5jb250ZW50PVwiIFwiIT09aShsKT9sOmwuc2xpY2UoMCwtMSl9fSx7bmFtZTpcIlxcbnsuYX0gc29mdGJyZWFrIHRoZW4gY3VybHkgaW4gc3RhcnRcIix0ZXN0czpbe3NoaWZ0OjAsdHlwZTpcImlubGluZVwiLGNoaWxkcmVuOlt7cG9zaXRpb246LTIsdHlwZTpcInNvZnRicmVha1wifSx7cG9zaXRpb246LTEsdHlwZTpcInRleHRcIixjb250ZW50Om4uaGFzRGVsaW1pdGVycyhcIm9ubHlcIixlKX1dfV0sdHJhbnNmb3JtOih0LHIsaSk9PntsZXQgcz10W3JdLmNoaWxkcmVuW2ldLG89bi5nZXRBdHRycyhzLmNvbnRlbnQsMCxlKSxhPXIrMTtmb3IoO3RbYSsxXSYmLTE9PT10W2ErMV0ubmVzdGluZzspYSsrO2xldCBjPW4uZ2V0TWF0Y2hpbmdPcGVuaW5nVG9rZW4odCxhKTtuLmFkZEF0dHJzKG8sYyksdFtyXS5jaGlsZHJlbj10W3JdLmNoaWxkcmVuLnNsaWNlKDAsLTIpfX0se25hbWU6XCJob3Jpem9udGFsIHJ1bGVcIix0ZXN0czpbe3NoaWZ0OjAsdHlwZTpcInBhcmFncmFwaF9vcGVuXCJ9LHtzaGlmdDoxLHR5cGU6XCJpbmxpbmVcIixjaGlsZHJlbjplPT4xPT09ZS5sZW5ndGgsY29udGVudDplPT5udWxsIT09ZS5tYXRjaCh0KX0se3NoaWZ0OjIsdHlwZTpcInBhcmFncmFwaF9jbG9zZVwifV0sdHJhbnNmb3JtOih0LHIpPT57bGV0IGk9dFtyXTtpLnR5cGU9XCJoclwiLGkudGFnPVwiaHJcIixpLm5lc3Rpbmc9MDtsZXQgcz10W3IrMV0uY29udGVudCxvPXMubGFzdEluZGV4T2YoZS5sZWZ0RGVsaW1pdGVyKTtpLmF0dHJzPW4uZ2V0QXR0cnMocyxvLGUpLGkubWFya3VwPXMsdC5zcGxpY2UocisxLDIpfX0se25hbWU6XCJlbmQgb2YgYmxvY2tcIix0ZXN0czpbe3NoaWZ0OjAsdHlwZTpcImlubGluZVwiLGNoaWxkcmVuOlt7cG9zaXRpb246LTEsY29udGVudDpuLmhhc0RlbGltaXRlcnMoXCJlbmRcIixlKSx0eXBlOmU9PlwiY29kZV9pbmxpbmVcIiE9PWV9XX1dLHRyYW5zZm9ybToodCxyLHMpPT57bGV0IG89dFtyXS5jaGlsZHJlbltzXSxhPW8uY29udGVudCxjPW4uZ2V0QXR0cnMoYSxhLmxhc3RJbmRleE9mKGUubGVmdERlbGltaXRlciksZSksbD1yKzE7Zm9yKDt0W2wrMV0mJi0xPT09dFtsKzFdLm5lc3Rpbmc7KWwrKztsZXQgdT1uLmdldE1hdGNoaW5nT3BlbmluZ1Rva2VuKHQsbCk7bi5hZGRBdHRycyhjLHUpO2xldCBwPWEuc2xpY2UoMCxhLmxhc3RJbmRleE9mKGUubGVmdERlbGltaXRlcikpO28uY29udGVudD1cIiBcIiE9PWkocCk/cDpwLnNsaWNlKDAsLTEpfX1dfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGUucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZyxcIlxcXFwkJlwiKX10LmdldEF0dHJzPWZ1bmN0aW9uKGUsdCxyKXtjb25zdCBuPS9bXlxcdFxcblxcZiAvPlwiJz1dLyxpPVtdO2xldCBzPVwiXCIsbz1cIlwiLGE9ITAsYz0hMTtmb3IobGV0IGw9dCtyLmxlZnREZWxpbWl0ZXIubGVuZ3RoO2w8ZS5sZW5ndGg7bCsrKXtpZihlLnNsaWNlKGwsbCtyLnJpZ2h0RGVsaW1pdGVyLmxlbmd0aCk9PT1yLnJpZ2h0RGVsaW1pdGVyKXtcIlwiIT09cyYmaS5wdXNoKFtzLG9dKTticmVha31sZXQgdD1lLmNoYXJBdChsKTtpZihcIj1cIj09PXQmJmEpYT0hMTtlbHNlIGlmKFwiLlwiIT09dHx8XCJcIiE9PXMpaWYoXCIjXCIhPT10fHxcIlwiIT09cylpZignXCInIT09dHx8XCJcIiE9PW8paWYoJ1wiJz09PXQmJmMpYz0hMTtlbHNlIGlmKFwiIFwiIT09dHx8YylhJiYtMT09PXQuc2VhcmNoKG4pfHwoYT9zKz10Om8rPXQpO2Vsc2V7aWYoXCJcIj09PXMpY29udGludWU7aS5wdXNoKFtzLG9dKSxzPVwiXCIsbz1cIlwiLGE9ITB9ZWxzZSBjPSEwO2Vsc2Ugcz1cImlkXCIsYT0hMTtlbHNlXCIuXCI9PT1lLmNoYXJBdChsKzEpPyhzPVwiY3NzLW1vZHVsZVwiLGwrPTEpOnM9XCJjbGFzc1wiLGE9ITF9aWYoci5hbGxvd2VkQXR0cmlidXRlcyYmci5hbGxvd2VkQXR0cmlidXRlcy5sZW5ndGgpe2xldCBlPXIuYWxsb3dlZEF0dHJpYnV0ZXM7cmV0dXJuIGkuZmlsdGVyKChmdW5jdGlvbih0KXtsZXQgcj10WzBdO3JldHVybiBlLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiByPT09ZXx8ZSBpbnN0YW5jZW9mIFJlZ0V4cCYmZS50ZXN0KHIpfSkpfSkpfXJldHVybiBpfSx0LmFkZEF0dHJzPWZ1bmN0aW9uKGUsdCl7Zm9yKGxldCByPTAsbj1lLmxlbmd0aDtyPG47KytyKXtsZXQgbj1lW3JdWzBdO1wiY2xhc3NcIj09PW4/dC5hdHRySm9pbihcImNsYXNzXCIsZVtyXVsxXSk6XCJjc3MtbW9kdWxlXCI9PT1uP3QuYXR0ckpvaW4oXCJjc3MtbW9kdWxlXCIsZVtyXVsxXSk6dC5hdHRyUHVzaChlW3JdKX1yZXR1cm4gdH0sdC5oYXNEZWxpbWl0ZXJzPWZ1bmN0aW9uKGUsdCl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKCdQYXJhbWV0ZXIgYHdoZXJlYCBub3QgcGFzc2VkLiBTaG91bGQgYmUgXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiIG9yIFwib25seVwiLicpO3JldHVybiBmdW5jdGlvbihyKXtsZXQgbixpLHMsbyxhPXQubGVmdERlbGltaXRlci5sZW5ndGgrMSt0LnJpZ2h0RGVsaW1pdGVyLmxlbmd0aDtpZighcnx8XCJzdHJpbmdcIiE9dHlwZW9mIHJ8fHIubGVuZ3RoPGEpcmV0dXJuITE7bGV0IGM9YS10LnJpZ2h0RGVsaW1pdGVyLmxlbmd0aDtzd2l0Y2goZSl7Y2FzZVwic3RhcnRcIjpzPXIuc2xpY2UoMCx0LmxlZnREZWxpbWl0ZXIubGVuZ3RoKSxuPXM9PT10LmxlZnREZWxpbWl0ZXI/MDotMSxpPS0xPT09bj8tMTpyLmluZGV4T2YodC5yaWdodERlbGltaXRlcixjKSxvPXIuY2hhckF0KGkrdC5yaWdodERlbGltaXRlci5sZW5ndGgpLG8mJi0xIT09dC5yaWdodERlbGltaXRlci5pbmRleE9mKG8pJiYoaT0tMSk7YnJlYWs7Y2FzZVwiZW5kXCI6bj1yLmxhc3RJbmRleE9mKHQubGVmdERlbGltaXRlciksaT0tMT09PW4/LTE6ci5pbmRleE9mKHQucmlnaHREZWxpbWl0ZXIsbitjKSxpPWk9PT1yLmxlbmd0aC10LnJpZ2h0RGVsaW1pdGVyLmxlbmd0aD9pOi0xO2JyZWFrO2Nhc2VcIm9ubHlcIjpzPXIuc2xpY2UoMCx0LmxlZnREZWxpbWl0ZXIubGVuZ3RoKSxuPXM9PT10LmxlZnREZWxpbWl0ZXI/MDotMSxzPXIuc2xpY2Uoci5sZW5ndGgtdC5yaWdodERlbGltaXRlci5sZW5ndGgpLGk9cz09PXQucmlnaHREZWxpbWl0ZXI/ci5sZW5ndGgtdC5yaWdodERlbGltaXRlci5sZW5ndGg6LTF9cmV0dXJuLTEhPT1uJiYtMSE9PWkmJmZ1bmN0aW9uKGUpe2xldCByPVwiLlwiPT09ZS5jaGFyQXQodC5sZWZ0RGVsaW1pdGVyLmxlbmd0aCksbj1cIiNcIj09PWUuY2hhckF0KHQubGVmdERlbGltaXRlci5sZW5ndGgpO3JldHVybiByfHxuP2UubGVuZ3RoPj1hKzE6ZS5sZW5ndGg+PWF9KHIuc3Vic3RyaW5nKG4saSt0LnJpZ2h0RGVsaW1pdGVyLmxlbmd0aCkpfX0sdC5yZW1vdmVEZWxpbWl0ZXI9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4odC5sZWZ0RGVsaW1pdGVyKSxpPW4odC5yaWdodERlbGltaXRlcik7bGV0IHM9bmV3IFJlZ0V4cChcIlsgXFxcXG5dP1wiK3IrXCJbXlwiK3IraStcIl0rXCIraStcIiRcIiksbz1lLnNlYXJjaChzKTtyZXR1cm4tMSE9PW8/ZS5zbGljZSgwLG8pOmV9LHQuZXNjYXBlUmVnRXhwPW4sdC5nZXRNYXRjaGluZ09wZW5pbmdUb2tlbj1mdW5jdGlvbihlLHQpe2lmKFwic29mdGJyZWFrXCI9PT1lW3RdLnR5cGUpcmV0dXJuITE7aWYoMD09PWVbdF0ubmVzdGluZylyZXR1cm4gZVt0XTtsZXQgcj1lW3RdLmxldmVsLG49ZVt0XS50eXBlLnJlcGxhY2UoXCJfY2xvc2VcIixcIl9vcGVuXCIpO2Zvcig7dD49MDstLXQpaWYoZVt0XS50eXBlPT09biYmZVt0XS5sZXZlbD09PXIpcmV0dXJuIGVbdF19O2xldCBpPS9bJjw+XCJdLyxzPS9bJjw+XCJdL2csbz17XCImXCI6XCImYW1wO1wiLFwiPFwiOlwiJmx0O1wiLFwiPlwiOlwiJmd0O1wiLCdcIic6XCImcXVvdDtcIn07ZnVuY3Rpb24gYShlKXtyZXR1cm4gb1tlXX10LmVzY2FwZUh0bWw9ZnVuY3Rpb24oZSl7cmV0dXJuIGkudGVzdChlKT9lLnJlcGxhY2UocyxhKTplfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMCksaT1yKDI4KSxzPXIoMzIpLG89cigzMyksYT1yKDQxKSxjPXIoNTUpLGw9cig2OCksdT1yKDgpLHA9cig3MCksaD17ZGVmYXVsdDpyKDczKSx6ZXJvOnIoNzQpLGNvbW1vbm1hcms6cig3NSl9LGY9L14odmJzY3JpcHR8amF2YXNjcmlwdHxmaWxlfGRhdGEpOi8sZD0vXmRhdGE6aW1hZ2VcXC8oZ2lmfHBuZ3xqcGVnfHdlYnApOy87ZnVuY3Rpb24gZyhlKXt2YXIgdD1lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO3JldHVybiFmLnRlc3QodCl8fCEhZC50ZXN0KHQpfXZhciBtPVtcImh0dHA6XCIsXCJodHRwczpcIixcIm1haWx0bzpcIl07ZnVuY3Rpb24gXyhlKXt2YXIgdD11LnBhcnNlKGUsITApO2lmKHQuaG9zdG5hbWUmJighdC5wcm90b2NvbHx8bS5pbmRleE9mKHQucHJvdG9jb2wpPj0wKSl0cnl7dC5ob3N0bmFtZT1wLnRvQVNDSUkodC5ob3N0bmFtZSl9Y2F0Y2goZSl7fXJldHVybiB1LmVuY29kZSh1LmZvcm1hdCh0KSl9ZnVuY3Rpb24gYihlKXt2YXIgdD11LnBhcnNlKGUsITApO2lmKHQuaG9zdG5hbWUmJighdC5wcm90b2NvbHx8bS5pbmRleE9mKHQucHJvdG9jb2wpPj0wKSl0cnl7dC5ob3N0bmFtZT1wLnRvVW5pY29kZSh0Lmhvc3RuYW1lKX1jYXRjaChlKXt9cmV0dXJuIHUuZGVjb2RlKHUuZm9ybWF0KHQpLHUuZGVjb2RlLmRlZmF1bHRDaGFycytcIiVcIil9ZnVuY3Rpb24gayhlLHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGspKXJldHVybiBuZXcgayhlLHQpO3R8fG4uaXNTdHJpbmcoZSl8fCh0PWV8fHt9LGU9XCJkZWZhdWx0XCIpLHRoaXMuaW5saW5lPW5ldyBjLHRoaXMuYmxvY2s9bmV3IGEsdGhpcy5jb3JlPW5ldyBvLHRoaXMucmVuZGVyZXI9bmV3IHMsdGhpcy5saW5raWZ5PW5ldyBsLHRoaXMudmFsaWRhdGVMaW5rPWcsdGhpcy5ub3JtYWxpemVMaW5rPV8sdGhpcy5ub3JtYWxpemVMaW5rVGV4dD1iLHRoaXMudXRpbHM9bix0aGlzLmhlbHBlcnM9bi5hc3NpZ24oe30saSksdGhpcy5vcHRpb25zPXt9LHRoaXMuY29uZmlndXJlKGUpLHQmJnRoaXMuc2V0KHQpfWsucHJvdG90eXBlLnNldD1mdW5jdGlvbihlKXtyZXR1cm4gbi5hc3NpZ24odGhpcy5vcHRpb25zLGUpLHRoaXN9LGsucHJvdG90eXBlLmNvbmZpZ3VyZT1mdW5jdGlvbihlKXt2YXIgdCxyPXRoaXM7aWYobi5pc1N0cmluZyhlKSYmIShlPWhbdD1lXSkpdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicrdCsnXCIsIGNoZWNrIG5hbWUnKTtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCwgY2FuJ3QgYmUgZW1wdHlcIik7cmV0dXJuIGUub3B0aW9ucyYmci5zZXQoZS5vcHRpb25zKSxlLmNvbXBvbmVudHMmJk9iamVjdC5rZXlzKGUuY29tcG9uZW50cykuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5jb21wb25lbnRzW3RdLnJ1bGVzJiZyW3RdLnJ1bGVyLmVuYWJsZU9ubHkoZS5jb21wb25lbnRzW3RdLnJ1bGVzKSxlLmNvbXBvbmVudHNbdF0ucnVsZXMyJiZyW3RdLnJ1bGVyMi5lbmFibGVPbmx5KGUuY29tcG9uZW50c1t0XS5ydWxlczIpfSkpLHRoaXN9LGsucHJvdG90eXBlLmVuYWJsZT1mdW5jdGlvbihlLHQpe3ZhciByPVtdO0FycmF5LmlzQXJyYXkoZSl8fChlPVtlXSksW1wiY29yZVwiLFwiYmxvY2tcIixcImlubGluZVwiXS5mb3JFYWNoKChmdW5jdGlvbih0KXtyPXIuY29uY2F0KHRoaXNbdF0ucnVsZXIuZW5hYmxlKGUsITApKX0pLHRoaXMpLHI9ci5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmVuYWJsZShlLCEwKSk7dmFyIG49ZS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiByLmluZGV4T2YoZSk8MH0pKTtpZihuLmxlbmd0aCYmIXQpdGhyb3cgbmV3IEVycm9yKFwiTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6IFwiK24pO3JldHVybiB0aGlzfSxrLnByb3RvdHlwZS5kaXNhYmxlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9W107QXJyYXkuaXNBcnJheShlKXx8KGU9W2VdKSxbXCJjb3JlXCIsXCJibG9ja1wiLFwiaW5saW5lXCJdLmZvckVhY2goKGZ1bmN0aW9uKHQpe3I9ci5jb25jYXQodGhpc1t0XS5ydWxlci5kaXNhYmxlKGUsITApKX0pLHRoaXMpLHI9ci5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUoZSwhMCkpO3ZhciBuPWUuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gci5pbmRleE9mKGUpPDB9KSk7aWYobi5sZW5ndGgmJiF0KXRocm93IG5ldyBFcnJvcihcIk1hcmtkb3duSXQuIEZhaWxlZCB0byBkaXNhYmxlIHVua25vd24gcnVsZShzKTogXCIrbik7cmV0dXJuIHRoaXN9LGsucHJvdG90eXBlLnVzZT1mdW5jdGlvbihlKXt2YXIgdD1bdGhpc10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSk7cmV0dXJuIGUuYXBwbHkoZSx0KSx0aGlzfSxrLnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbihlLHQpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nXCIpO3ZhciByPW5ldyB0aGlzLmNvcmUuU3RhdGUoZSx0aGlzLHQpO3JldHVybiB0aGlzLmNvcmUucHJvY2VzcyhyKSxyLnRva2Vuc30say5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9dHx8e30sdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShlLHQpLHRoaXMub3B0aW9ucyx0KX0say5wcm90b3R5cGUucGFyc2VJbmxpbmU9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgdGhpcy5jb3JlLlN0YXRlKGUsdGhpcyx0KTtyZXR1cm4gci5pbmxpbmVNb2RlPSEwLHRoaXMuY29yZS5wcm9jZXNzKHIpLHIudG9rZW5zfSxrLnByb3RvdHlwZS5yZW5kZXJJbmxpbmU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD10fHx7fSx0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKGUsdCksdGhpcy5vcHRpb25zLHQpfSxlLmV4cG9ydHM9a30sZnVuY3Rpb24oZSl7ZS5leHBvcnRzPUpTT04ucGFyc2UoJ3tcIkFhY3V0ZVwiOlwiw4FcIixcImFhY3V0ZVwiOlwiw6FcIixcIkFicmV2ZVwiOlwixIJcIixcImFicmV2ZVwiOlwixINcIixcImFjXCI6XCLiiL5cIixcImFjZFwiOlwi4oi/XCIsXCJhY0VcIjpcIuKIvsyzXCIsXCJBY2lyY1wiOlwiw4JcIixcImFjaXJjXCI6XCLDolwiLFwiYWN1dGVcIjpcIsK0XCIsXCJBY3lcIjpcItCQXCIsXCJhY3lcIjpcItCwXCIsXCJBRWxpZ1wiOlwiw4ZcIixcImFlbGlnXCI6XCLDplwiLFwiYWZcIjpcIuKBoVwiLFwiQWZyXCI6XCLwnZSEXCIsXCJhZnJcIjpcIvCdlJ5cIixcIkFncmF2ZVwiOlwiw4BcIixcImFncmF2ZVwiOlwiw6BcIixcImFsZWZzeW1cIjpcIuKEtVwiLFwiYWxlcGhcIjpcIuKEtVwiLFwiQWxwaGFcIjpcIs6RXCIsXCJhbHBoYVwiOlwizrFcIixcIkFtYWNyXCI6XCLEgFwiLFwiYW1hY3JcIjpcIsSBXCIsXCJhbWFsZ1wiOlwi4qi/XCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiYW5kYW5kXCI6XCLiqZVcIixcIkFuZFwiOlwi4qmTXCIsXCJhbmRcIjpcIuKIp1wiLFwiYW5kZFwiOlwi4qmcXCIsXCJhbmRzbG9wZVwiOlwi4qmYXCIsXCJhbmR2XCI6XCLiqZpcIixcImFuZ1wiOlwi4oigXCIsXCJhbmdlXCI6XCLipqRcIixcImFuZ2xlXCI6XCLiiKBcIixcImFuZ21zZGFhXCI6XCLipqhcIixcImFuZ21zZGFiXCI6XCLipqlcIixcImFuZ21zZGFjXCI6XCLipqpcIixcImFuZ21zZGFkXCI6XCLipqtcIixcImFuZ21zZGFlXCI6XCLipqxcIixcImFuZ21zZGFmXCI6XCLipq1cIixcImFuZ21zZGFnXCI6XCLipq5cIixcImFuZ21zZGFoXCI6XCLipq9cIixcImFuZ21zZFwiOlwi4oihXCIsXCJhbmdydFwiOlwi4oifXCIsXCJhbmdydHZiXCI6XCLiir5cIixcImFuZ3J0dmJkXCI6XCLipp1cIixcImFuZ3NwaFwiOlwi4oiiXCIsXCJhbmdzdFwiOlwiw4VcIixcImFuZ3phcnJcIjpcIuKNvFwiLFwiQW9nb25cIjpcIsSEXCIsXCJhb2dvblwiOlwixIVcIixcIkFvcGZcIjpcIvCdlLhcIixcImFvcGZcIjpcIvCdlZJcIixcImFwYWNpclwiOlwi4qmvXCIsXCJhcFwiOlwi4omIXCIsXCJhcEVcIjpcIuKpsFwiLFwiYXBlXCI6XCLiiYpcIixcImFwaWRcIjpcIuKJi1wiLFwiYXBvc1wiOlwiXFwnXCIsXCJBcHBseUZ1bmN0aW9uXCI6XCLigaFcIixcImFwcHJveFwiOlwi4omIXCIsXCJhcHByb3hlcVwiOlwi4omKXCIsXCJBcmluZ1wiOlwiw4VcIixcImFyaW5nXCI6XCLDpVwiLFwiQXNjclwiOlwi8J2SnFwiLFwiYXNjclwiOlwi8J2StlwiLFwiQXNzaWduXCI6XCLiiZRcIixcImFzdFwiOlwiKlwiLFwiYXN5bXBcIjpcIuKJiFwiLFwiYXN5bXBlcVwiOlwi4omNXCIsXCJBdGlsZGVcIjpcIsODXCIsXCJhdGlsZGVcIjpcIsOjXCIsXCJBdW1sXCI6XCLDhFwiLFwiYXVtbFwiOlwiw6RcIixcImF3Y29uaW50XCI6XCLiiLNcIixcImF3aW50XCI6XCLiqJFcIixcImJhY2tjb25nXCI6XCLiiYxcIixcImJhY2tlcHNpbG9uXCI6XCLPtlwiLFwiYmFja3ByaW1lXCI6XCLigLVcIixcImJhY2tzaW1cIjpcIuKIvVwiLFwiYmFja3NpbWVxXCI6XCLii41cIixcIkJhY2tzbGFzaFwiOlwi4oiWXCIsXCJCYXJ2XCI6XCLiq6dcIixcImJhcnZlZVwiOlwi4oq9XCIsXCJiYXJ3ZWRcIjpcIuKMhVwiLFwiQmFyd2VkXCI6XCLijIZcIixcImJhcndlZGdlXCI6XCLijIVcIixcImJicmtcIjpcIuKOtVwiLFwiYmJya3RicmtcIjpcIuKOtlwiLFwiYmNvbmdcIjpcIuKJjFwiLFwiQmN5XCI6XCLQkVwiLFwiYmN5XCI6XCLQsVwiLFwiYmRxdW9cIjpcIuKAnlwiLFwiYmVjYXVzXCI6XCLiiLVcIixcImJlY2F1c2VcIjpcIuKItVwiLFwiQmVjYXVzZVwiOlwi4oi1XCIsXCJiZW1wdHl2XCI6XCLiprBcIixcImJlcHNpXCI6XCLPtlwiLFwiYmVybm91XCI6XCLihKxcIixcIkJlcm5vdWxsaXNcIjpcIuKErFwiLFwiQmV0YVwiOlwizpJcIixcImJldGFcIjpcIs6yXCIsXCJiZXRoXCI6XCLihLZcIixcImJldHdlZW5cIjpcIuKJrFwiLFwiQmZyXCI6XCLwnZSFXCIsXCJiZnJcIjpcIvCdlJ9cIixcImJpZ2NhcFwiOlwi4ouCXCIsXCJiaWdjaXJjXCI6XCLil69cIixcImJpZ2N1cFwiOlwi4ouDXCIsXCJiaWdvZG90XCI6XCLiqIBcIixcImJpZ29wbHVzXCI6XCLiqIFcIixcImJpZ290aW1lc1wiOlwi4qiCXCIsXCJiaWdzcWN1cFwiOlwi4qiGXCIsXCJiaWdzdGFyXCI6XCLimIVcIixcImJpZ3RyaWFuZ2xlZG93blwiOlwi4pa9XCIsXCJiaWd0cmlhbmdsZXVwXCI6XCLilrNcIixcImJpZ3VwbHVzXCI6XCLiqIRcIixcImJpZ3ZlZVwiOlwi4ouBXCIsXCJiaWd3ZWRnZVwiOlwi4ouAXCIsXCJia2Fyb3dcIjpcIuKkjVwiLFwiYmxhY2tsb3plbmdlXCI6XCLip6tcIixcImJsYWNrc3F1YXJlXCI6XCLilqpcIixcImJsYWNrdHJpYW5nbGVcIjpcIuKWtFwiLFwiYmxhY2t0cmlhbmdsZWRvd25cIjpcIuKWvlwiLFwiYmxhY2t0cmlhbmdsZWxlZnRcIjpcIuKXglwiLFwiYmxhY2t0cmlhbmdsZXJpZ2h0XCI6XCLilrhcIixcImJsYW5rXCI6XCLikKNcIixcImJsazEyXCI6XCLilpJcIixcImJsazE0XCI6XCLilpFcIixcImJsazM0XCI6XCLilpNcIixcImJsb2NrXCI6XCLilohcIixcImJuZVwiOlwiPeKDpVwiLFwiYm5lcXVpdlwiOlwi4omh4oOlXCIsXCJiTm90XCI6XCLiq61cIixcImJub3RcIjpcIuKMkFwiLFwiQm9wZlwiOlwi8J2UuVwiLFwiYm9wZlwiOlwi8J2Vk1wiLFwiYm90XCI6XCLiiqVcIixcImJvdHRvbVwiOlwi4oqlXCIsXCJib3d0aWVcIjpcIuKLiFwiLFwiYm94Ym94XCI6XCLip4lcIixcImJveGRsXCI6XCLilJBcIixcImJveGRMXCI6XCLilZVcIixcImJveERsXCI6XCLilZZcIixcImJveERMXCI6XCLilZdcIixcImJveGRyXCI6XCLilIxcIixcImJveGRSXCI6XCLilZJcIixcImJveERyXCI6XCLilZNcIixcImJveERSXCI6XCLilZRcIixcImJveGhcIjpcIuKUgFwiLFwiYm94SFwiOlwi4pWQXCIsXCJib3hoZFwiOlwi4pSsXCIsXCJib3hIZFwiOlwi4pWkXCIsXCJib3hoRFwiOlwi4pWlXCIsXCJib3hIRFwiOlwi4pWmXCIsXCJib3hodVwiOlwi4pS0XCIsXCJib3hIdVwiOlwi4pWnXCIsXCJib3hoVVwiOlwi4pWoXCIsXCJib3hIVVwiOlwi4pWpXCIsXCJib3htaW51c1wiOlwi4oqfXCIsXCJib3hwbHVzXCI6XCLiip5cIixcImJveHRpbWVzXCI6XCLiiqBcIixcImJveHVsXCI6XCLilJhcIixcImJveHVMXCI6XCLilZtcIixcImJveFVsXCI6XCLilZxcIixcImJveFVMXCI6XCLilZ1cIixcImJveHVyXCI6XCLilJRcIixcImJveHVSXCI6XCLilZhcIixcImJveFVyXCI6XCLilZlcIixcImJveFVSXCI6XCLilZpcIixcImJveHZcIjpcIuKUglwiLFwiYm94VlwiOlwi4pWRXCIsXCJib3h2aFwiOlwi4pS8XCIsXCJib3h2SFwiOlwi4pWqXCIsXCJib3hWaFwiOlwi4pWrXCIsXCJib3hWSFwiOlwi4pWsXCIsXCJib3h2bFwiOlwi4pSkXCIsXCJib3h2TFwiOlwi4pWhXCIsXCJib3hWbFwiOlwi4pWiXCIsXCJib3hWTFwiOlwi4pWjXCIsXCJib3h2clwiOlwi4pScXCIsXCJib3h2UlwiOlwi4pWeXCIsXCJib3hWclwiOlwi4pWfXCIsXCJib3hWUlwiOlwi4pWgXCIsXCJicHJpbWVcIjpcIuKAtVwiLFwiYnJldmVcIjpcIsuYXCIsXCJCcmV2ZVwiOlwiy5hcIixcImJydmJhclwiOlwiwqZcIixcImJzY3JcIjpcIvCdkrdcIixcIkJzY3JcIjpcIuKErFwiLFwiYnNlbWlcIjpcIuKBj1wiLFwiYnNpbVwiOlwi4oi9XCIsXCJic2ltZVwiOlwi4ouNXCIsXCJic29sYlwiOlwi4qeFXCIsXCJic29sXCI6XCJcXFxcXFxcXFwiLFwiYnNvbGhzdWJcIjpcIuKfiFwiLFwiYnVsbFwiOlwi4oCiXCIsXCJidWxsZXRcIjpcIuKAolwiLFwiYnVtcFwiOlwi4omOXCIsXCJidW1wRVwiOlwi4qquXCIsXCJidW1wZVwiOlwi4omPXCIsXCJCdW1wZXFcIjpcIuKJjlwiLFwiYnVtcGVxXCI6XCLiiY9cIixcIkNhY3V0ZVwiOlwixIZcIixcImNhY3V0ZVwiOlwixIdcIixcImNhcGFuZFwiOlwi4qmEXCIsXCJjYXBicmN1cFwiOlwi4qmJXCIsXCJjYXBjYXBcIjpcIuKpi1wiLFwiY2FwXCI6XCLiiKlcIixcIkNhcFwiOlwi4ouSXCIsXCJjYXBjdXBcIjpcIuKph1wiLFwiY2FwZG90XCI6XCLiqYBcIixcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6XCLihYVcIixcImNhcHNcIjpcIuKIqe+4gFwiLFwiY2FyZXRcIjpcIuKBgVwiLFwiY2Fyb25cIjpcIsuHXCIsXCJDYXlsZXlzXCI6XCLihK1cIixcImNjYXBzXCI6XCLiqY1cIixcIkNjYXJvblwiOlwixIxcIixcImNjYXJvblwiOlwixI1cIixcIkNjZWRpbFwiOlwiw4dcIixcImNjZWRpbFwiOlwiw6dcIixcIkNjaXJjXCI6XCLEiFwiLFwiY2NpcmNcIjpcIsSJXCIsXCJDY29uaW50XCI6XCLiiLBcIixcImNjdXBzXCI6XCLiqYxcIixcImNjdXBzc21cIjpcIuKpkFwiLFwiQ2RvdFwiOlwixIpcIixcImNkb3RcIjpcIsSLXCIsXCJjZWRpbFwiOlwiwrhcIixcIkNlZGlsbGFcIjpcIsK4XCIsXCJjZW1wdHl2XCI6XCLiprJcIixcImNlbnRcIjpcIsKiXCIsXCJjZW50ZXJkb3RcIjpcIsK3XCIsXCJDZW50ZXJEb3RcIjpcIsK3XCIsXCJjZnJcIjpcIvCdlKBcIixcIkNmclwiOlwi4oStXCIsXCJDSGN5XCI6XCLQp1wiLFwiY2hjeVwiOlwi0YdcIixcImNoZWNrXCI6XCLinJNcIixcImNoZWNrbWFya1wiOlwi4pyTXCIsXCJDaGlcIjpcIs6nXCIsXCJjaGlcIjpcIs+HXCIsXCJjaXJjXCI6XCLLhlwiLFwiY2lyY2VxXCI6XCLiiZdcIixcImNpcmNsZWFycm93bGVmdFwiOlwi4oa6XCIsXCJjaXJjbGVhcnJvd3JpZ2h0XCI6XCLihrtcIixcImNpcmNsZWRhc3RcIjpcIuKKm1wiLFwiY2lyY2xlZGNpcmNcIjpcIuKKmlwiLFwiY2lyY2xlZGRhc2hcIjpcIuKKnVwiLFwiQ2lyY2xlRG90XCI6XCLiiplcIixcImNpcmNsZWRSXCI6XCLCrlwiLFwiY2lyY2xlZFNcIjpcIuKTiFwiLFwiQ2lyY2xlTWludXNcIjpcIuKKllwiLFwiQ2lyY2xlUGx1c1wiOlwi4oqVXCIsXCJDaXJjbGVUaW1lc1wiOlwi4oqXXCIsXCJjaXJcIjpcIuKXi1wiLFwiY2lyRVwiOlwi4qeDXCIsXCJjaXJlXCI6XCLiiZdcIixcImNpcmZuaW50XCI6XCLiqJBcIixcImNpcm1pZFwiOlwi4quvXCIsXCJjaXJzY2lyXCI6XCLip4JcIixcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiyXCIsXCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnVwiLFwiQ2xvc2VDdXJseVF1b3RlXCI6XCLigJlcIixcImNsdWJzXCI6XCLimaNcIixcImNsdWJzdWl0XCI6XCLimaNcIixcImNvbG9uXCI6XCI6XCIsXCJDb2xvblwiOlwi4oi3XCIsXCJDb2xvbmVcIjpcIuKptFwiLFwiY29sb25lXCI6XCLiiZRcIixcImNvbG9uZXFcIjpcIuKJlFwiLFwiY29tbWFcIjpcIixcIixcImNvbW1hdFwiOlwiQFwiLFwiY29tcFwiOlwi4oiBXCIsXCJjb21wZm5cIjpcIuKImFwiLFwiY29tcGxlbWVudFwiOlwi4oiBXCIsXCJjb21wbGV4ZXNcIjpcIuKEglwiLFwiY29uZ1wiOlwi4omFXCIsXCJjb25nZG90XCI6XCLiqa1cIixcIkNvbmdydWVudFwiOlwi4omhXCIsXCJjb25pbnRcIjpcIuKIrlwiLFwiQ29uaW50XCI6XCLiiK9cIixcIkNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiuXCIsXCJjb3BmXCI6XCLwnZWUXCIsXCJDb3BmXCI6XCLihIJcIixcImNvcHJvZFwiOlwi4oiQXCIsXCJDb3Byb2R1Y3RcIjpcIuKIkFwiLFwiY29weVwiOlwiwqlcIixcIkNPUFlcIjpcIsKpXCIsXCJjb3B5c3JcIjpcIuKEl1wiLFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oizXCIsXCJjcmFyclwiOlwi4oa1XCIsXCJjcm9zc1wiOlwi4pyXXCIsXCJDcm9zc1wiOlwi4qivXCIsXCJDc2NyXCI6XCLwnZKeXCIsXCJjc2NyXCI6XCLwnZK4XCIsXCJjc3ViXCI6XCLiq49cIixcImNzdWJlXCI6XCLiq5FcIixcImNzdXBcIjpcIuKrkFwiLFwiY3N1cGVcIjpcIuKrklwiLFwiY3Rkb3RcIjpcIuKLr1wiLFwiY3VkYXJybFwiOlwi4qS4XCIsXCJjdWRhcnJyXCI6XCLipLVcIixcImN1ZXByXCI6XCLii55cIixcImN1ZXNjXCI6XCLii59cIixcImN1bGFyclwiOlwi4oa2XCIsXCJjdWxhcnJwXCI6XCLipL1cIixcImN1cGJyY2FwXCI6XCLiqYhcIixcImN1cGNhcFwiOlwi4qmGXCIsXCJDdXBDYXBcIjpcIuKJjVwiLFwiY3VwXCI6XCLiiKpcIixcIkN1cFwiOlwi4ouTXCIsXCJjdXBjdXBcIjpcIuKpilwiLFwiY3VwZG90XCI6XCLiio1cIixcImN1cG9yXCI6XCLiqYVcIixcImN1cHNcIjpcIuKIqu+4gFwiLFwiY3VyYXJyXCI6XCLihrdcIixcImN1cmFycm1cIjpcIuKkvFwiLFwiY3VybHllcXByZWNcIjpcIuKLnlwiLFwiY3VybHllcXN1Y2NcIjpcIuKLn1wiLFwiY3VybHl2ZWVcIjpcIuKLjlwiLFwiY3VybHl3ZWRnZVwiOlwi4ouPXCIsXCJjdXJyZW5cIjpcIsKkXCIsXCJjdXJ2ZWFycm93bGVmdFwiOlwi4oa2XCIsXCJjdXJ2ZWFycm93cmlnaHRcIjpcIuKGt1wiLFwiY3V2ZWVcIjpcIuKLjlwiLFwiY3V3ZWRcIjpcIuKLj1wiLFwiY3djb25pbnRcIjpcIuKIslwiLFwiY3dpbnRcIjpcIuKIsVwiLFwiY3lsY3R5XCI6XCLijK1cIixcImRhZ2dlclwiOlwi4oCgXCIsXCJEYWdnZXJcIjpcIuKAoVwiLFwiZGFsZXRoXCI6XCLihLhcIixcImRhcnJcIjpcIuKGk1wiLFwiRGFyclwiOlwi4oahXCIsXCJkQXJyXCI6XCLih5NcIixcImRhc2hcIjpcIuKAkFwiLFwiRGFzaHZcIjpcIuKrpFwiLFwiZGFzaHZcIjpcIuKKo1wiLFwiZGJrYXJvd1wiOlwi4qSPXCIsXCJkYmxhY1wiOlwiy51cIixcIkRjYXJvblwiOlwixI5cIixcImRjYXJvblwiOlwixI9cIixcIkRjeVwiOlwi0JRcIixcImRjeVwiOlwi0LRcIixcImRkYWdnZXJcIjpcIuKAoVwiLFwiZGRhcnJcIjpcIuKHilwiLFwiRERcIjpcIuKFhVwiLFwiZGRcIjpcIuKFhlwiLFwiRERvdHJhaGRcIjpcIuKkkVwiLFwiZGRvdHNlcVwiOlwi4qm3XCIsXCJkZWdcIjpcIsKwXCIsXCJEZWxcIjpcIuKIh1wiLFwiRGVsdGFcIjpcIs6UXCIsXCJkZWx0YVwiOlwizrRcIixcImRlbXB0eXZcIjpcIuKmsVwiLFwiZGZpc2h0XCI6XCLipb9cIixcIkRmclwiOlwi8J2Uh1wiLFwiZGZyXCI6XCLwnZShXCIsXCJkSGFyXCI6XCLipaVcIixcImRoYXJsXCI6XCLih4NcIixcImRoYXJyXCI6XCLih4JcIixcIkRpYWNyaXRpY2FsQWN1dGVcIjpcIsK0XCIsXCJEaWFjcml0aWNhbERvdFwiOlwiy5lcIixcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjpcIsudXCIsXCJEaWFjcml0aWNhbEdyYXZlXCI6XCJgXCIsXCJEaWFjcml0aWNhbFRpbGRlXCI6XCLLnFwiLFwiZGlhbVwiOlwi4ouEXCIsXCJkaWFtb25kXCI6XCLii4RcIixcIkRpYW1vbmRcIjpcIuKLhFwiLFwiZGlhbW9uZHN1aXRcIjpcIuKZplwiLFwiZGlhbXNcIjpcIuKZplwiLFwiZGllXCI6XCLCqFwiLFwiRGlmZmVyZW50aWFsRFwiOlwi4oWGXCIsXCJkaWdhbW1hXCI6XCLPnVwiLFwiZGlzaW5cIjpcIuKLslwiLFwiZGl2XCI6XCLDt1wiLFwiZGl2aWRlXCI6XCLDt1wiLFwiZGl2aWRlb250aW1lc1wiOlwi4ouHXCIsXCJkaXZvbnhcIjpcIuKLh1wiLFwiREpjeVwiOlwi0IJcIixcImRqY3lcIjpcItGSXCIsXCJkbGNvcm5cIjpcIuKMnlwiLFwiZGxjcm9wXCI6XCLijI1cIixcImRvbGxhclwiOlwiJFwiLFwiRG9wZlwiOlwi8J2Uu1wiLFwiZG9wZlwiOlwi8J2VlVwiLFwiRG90XCI6XCLCqFwiLFwiZG90XCI6XCLLmVwiLFwiRG90RG90XCI6XCLig5xcIixcImRvdGVxXCI6XCLiiZBcIixcImRvdGVxZG90XCI6XCLiiZFcIixcIkRvdEVxdWFsXCI6XCLiiZBcIixcImRvdG1pbnVzXCI6XCLiiLhcIixcImRvdHBsdXNcIjpcIuKIlFwiLFwiZG90c3F1YXJlXCI6XCLiiqFcIixcImRvdWJsZWJhcndlZGdlXCI6XCLijIZcIixcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oivXCIsXCJEb3VibGVEb3RcIjpcIsKoXCIsXCJEb3VibGVEb3duQXJyb3dcIjpcIuKHk1wiLFwiRG91YmxlTGVmdEFycm93XCI6XCLih5BcIixcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6XCLih5RcIixcIkRvdWJsZUxlZnRUZWVcIjpcIuKrpFwiLFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOlwi4p+4XCIsXCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKfulwiLFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjpcIuKfuVwiLFwiRG91YmxlUmlnaHRBcnJvd1wiOlwi4oeSXCIsXCJEb3VibGVSaWdodFRlZVwiOlwi4oqoXCIsXCJEb3VibGVVcEFycm93XCI6XCLih5FcIixcIkRvdWJsZVVwRG93bkFycm93XCI6XCLih5VcIixcIkRvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKVcIixcIkRvd25BcnJvd0JhclwiOlwi4qSTXCIsXCJkb3duYXJyb3dcIjpcIuKGk1wiLFwiRG93bkFycm93XCI6XCLihpNcIixcIkRvd25hcnJvd1wiOlwi4oeTXCIsXCJEb3duQXJyb3dVcEFycm93XCI6XCLih7VcIixcIkRvd25CcmV2ZVwiOlwizJFcIixcImRvd25kb3duYXJyb3dzXCI6XCLih4pcIixcImRvd25oYXJwb29ubGVmdFwiOlwi4oeDXCIsXCJkb3duaGFycG9vbnJpZ2h0XCI6XCLih4JcIixcIkRvd25MZWZ0UmlnaHRWZWN0b3JcIjpcIuKlkFwiLFwiRG93bkxlZnRUZWVWZWN0b3JcIjpcIuKlnlwiLFwiRG93bkxlZnRWZWN0b3JCYXJcIjpcIuKlllwiLFwiRG93bkxlZnRWZWN0b3JcIjpcIuKGvVwiLFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6XCLipZ9cIixcIkRvd25SaWdodFZlY3RvckJhclwiOlwi4qWXXCIsXCJEb3duUmlnaHRWZWN0b3JcIjpcIuKHgVwiLFwiRG93blRlZUFycm93XCI6XCLihqdcIixcIkRvd25UZWVcIjpcIuKKpFwiLFwiZHJia2Fyb3dcIjpcIuKkkFwiLFwiZHJjb3JuXCI6XCLijJ9cIixcImRyY3JvcFwiOlwi4oyMXCIsXCJEc2NyXCI6XCLwnZKfXCIsXCJkc2NyXCI6XCLwnZK5XCIsXCJEU2N5XCI6XCLQhVwiLFwiZHNjeVwiOlwi0ZVcIixcImRzb2xcIjpcIuKntlwiLFwiRHN0cm9rXCI6XCLEkFwiLFwiZHN0cm9rXCI6XCLEkVwiLFwiZHRkb3RcIjpcIuKLsVwiLFwiZHRyaVwiOlwi4pa/XCIsXCJkdHJpZlwiOlwi4pa+XCIsXCJkdWFyclwiOlwi4oe1XCIsXCJkdWhhclwiOlwi4qWvXCIsXCJkd2FuZ2xlXCI6XCLipqZcIixcIkRaY3lcIjpcItCPXCIsXCJkemN5XCI6XCLRn1wiLFwiZHppZ3JhcnJcIjpcIuKfv1wiLFwiRWFjdXRlXCI6XCLDiVwiLFwiZWFjdXRlXCI6XCLDqVwiLFwiZWFzdGVyXCI6XCLiqa5cIixcIkVjYXJvblwiOlwixJpcIixcImVjYXJvblwiOlwixJtcIixcIkVjaXJjXCI6XCLDilwiLFwiZWNpcmNcIjpcIsOqXCIsXCJlY2lyXCI6XCLiiZZcIixcImVjb2xvblwiOlwi4omVXCIsXCJFY3lcIjpcItCtXCIsXCJlY3lcIjpcItGNXCIsXCJlRERvdFwiOlwi4qm3XCIsXCJFZG90XCI6XCLEllwiLFwiZWRvdFwiOlwixJdcIixcImVEb3RcIjpcIuKJkVwiLFwiZWVcIjpcIuKFh1wiLFwiZWZEb3RcIjpcIuKJklwiLFwiRWZyXCI6XCLwnZSIXCIsXCJlZnJcIjpcIvCdlKJcIixcImVnXCI6XCLiqppcIixcIkVncmF2ZVwiOlwiw4hcIixcImVncmF2ZVwiOlwiw6hcIixcImVnc1wiOlwi4qqWXCIsXCJlZ3Nkb3RcIjpcIuKqmFwiLFwiZWxcIjpcIuKqmVwiLFwiRWxlbWVudFwiOlwi4oiIXCIsXCJlbGludGVyc1wiOlwi4o+nXCIsXCJlbGxcIjpcIuKEk1wiLFwiZWxzXCI6XCLiqpVcIixcImVsc2RvdFwiOlwi4qqXXCIsXCJFbWFjclwiOlwixJJcIixcImVtYWNyXCI6XCLEk1wiLFwiZW1wdHlcIjpcIuKIhVwiLFwiZW1wdHlzZXRcIjpcIuKIhVwiLFwiRW1wdHlTbWFsbFNxdWFyZVwiOlwi4pe7XCIsXCJlbXB0eXZcIjpcIuKIhVwiLFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjpcIuKWq1wiLFwiZW1zcDEzXCI6XCLigIRcIixcImVtc3AxNFwiOlwi4oCFXCIsXCJlbXNwXCI6XCLigINcIixcIkVOR1wiOlwixYpcIixcImVuZ1wiOlwixYtcIixcImVuc3BcIjpcIuKAglwiLFwiRW9nb25cIjpcIsSYXCIsXCJlb2dvblwiOlwixJlcIixcIkVvcGZcIjpcIvCdlLxcIixcImVvcGZcIjpcIvCdlZZcIixcImVwYXJcIjpcIuKLlVwiLFwiZXBhcnNsXCI6XCLip6NcIixcImVwbHVzXCI6XCLiqbFcIixcImVwc2lcIjpcIs61XCIsXCJFcHNpbG9uXCI6XCLOlVwiLFwiZXBzaWxvblwiOlwizrVcIixcImVwc2l2XCI6XCLPtVwiLFwiZXFjaXJjXCI6XCLiiZZcIixcImVxY29sb25cIjpcIuKJlVwiLFwiZXFzaW1cIjpcIuKJglwiLFwiZXFzbGFudGd0clwiOlwi4qqWXCIsXCJlcXNsYW50bGVzc1wiOlwi4qqVXCIsXCJFcXVhbFwiOlwi4qm1XCIsXCJlcXVhbHNcIjpcIj1cIixcIkVxdWFsVGlsZGVcIjpcIuKJglwiLFwiZXF1ZXN0XCI6XCLiiZ9cIixcIkVxdWlsaWJyaXVtXCI6XCLih4xcIixcImVxdWl2XCI6XCLiiaFcIixcImVxdWl2RERcIjpcIuKpuFwiLFwiZXF2cGFyc2xcIjpcIuKnpVwiLFwiZXJhcnJcIjpcIuKlsVwiLFwiZXJEb3RcIjpcIuKJk1wiLFwiZXNjclwiOlwi4oSvXCIsXCJFc2NyXCI6XCLihLBcIixcImVzZG90XCI6XCLiiZBcIixcIkVzaW1cIjpcIuKps1wiLFwiZXNpbVwiOlwi4omCXCIsXCJFdGFcIjpcIs6XXCIsXCJldGFcIjpcIs63XCIsXCJFVEhcIjpcIsOQXCIsXCJldGhcIjpcIsOwXCIsXCJFdW1sXCI6XCLDi1wiLFwiZXVtbFwiOlwiw6tcIixcImV1cm9cIjpcIuKCrFwiLFwiZXhjbFwiOlwiIVwiLFwiZXhpc3RcIjpcIuKIg1wiLFwiRXhpc3RzXCI6XCLiiINcIixcImV4cGVjdGF0aW9uXCI6XCLihLBcIixcImV4cG9uZW50aWFsZVwiOlwi4oWHXCIsXCJFeHBvbmVudGlhbEVcIjpcIuKFh1wiLFwiZmFsbGluZ2RvdHNlcVwiOlwi4omSXCIsXCJGY3lcIjpcItCkXCIsXCJmY3lcIjpcItGEXCIsXCJmZW1hbGVcIjpcIuKZgFwiLFwiZmZpbGlnXCI6XCLvrINcIixcImZmbGlnXCI6XCLvrIBcIixcImZmbGxpZ1wiOlwi76yEXCIsXCJGZnJcIjpcIvCdlIlcIixcImZmclwiOlwi8J2Uo1wiLFwiZmlsaWdcIjpcIu+sgVwiLFwiRmlsbGVkU21hbGxTcXVhcmVcIjpcIuKXvFwiLFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6XCLilqpcIixcImZqbGlnXCI6XCJmalwiLFwiZmxhdFwiOlwi4pmtXCIsXCJmbGxpZ1wiOlwi76yCXCIsXCJmbHRuc1wiOlwi4paxXCIsXCJmbm9mXCI6XCLGklwiLFwiRm9wZlwiOlwi8J2UvVwiLFwiZm9wZlwiOlwi8J2Vl1wiLFwiZm9yYWxsXCI6XCLiiIBcIixcIkZvckFsbFwiOlwi4oiAXCIsXCJmb3JrXCI6XCLii5RcIixcImZvcmt2XCI6XCLiq5lcIixcIkZvdXJpZXJ0cmZcIjpcIuKEsVwiLFwiZnBhcnRpbnRcIjpcIuKojVwiLFwiZnJhYzEyXCI6XCLCvVwiLFwiZnJhYzEzXCI6XCLihZNcIixcImZyYWMxNFwiOlwiwrxcIixcImZyYWMxNVwiOlwi4oWVXCIsXCJmcmFjMTZcIjpcIuKFmVwiLFwiZnJhYzE4XCI6XCLihZtcIixcImZyYWMyM1wiOlwi4oWUXCIsXCJmcmFjMjVcIjpcIuKFllwiLFwiZnJhYzM0XCI6XCLCvlwiLFwiZnJhYzM1XCI6XCLihZdcIixcImZyYWMzOFwiOlwi4oWcXCIsXCJmcmFjNDVcIjpcIuKFmFwiLFwiZnJhYzU2XCI6XCLihZpcIixcImZyYWM1OFwiOlwi4oWdXCIsXCJmcmFjNzhcIjpcIuKFnlwiLFwiZnJhc2xcIjpcIuKBhFwiLFwiZnJvd25cIjpcIuKMolwiLFwiZnNjclwiOlwi8J2Su1wiLFwiRnNjclwiOlwi4oSxXCIsXCJnYWN1dGVcIjpcIse1XCIsXCJHYW1tYVwiOlwizpNcIixcImdhbW1hXCI6XCLOs1wiLFwiR2FtbWFkXCI6XCLPnFwiLFwiZ2FtbWFkXCI6XCLPnVwiLFwiZ2FwXCI6XCLiqoZcIixcIkdicmV2ZVwiOlwixJ5cIixcImdicmV2ZVwiOlwixJ9cIixcIkdjZWRpbFwiOlwixKJcIixcIkdjaXJjXCI6XCLEnFwiLFwiZ2NpcmNcIjpcIsSdXCIsXCJHY3lcIjpcItCTXCIsXCJnY3lcIjpcItCzXCIsXCJHZG90XCI6XCLEoFwiLFwiZ2RvdFwiOlwixKFcIixcImdlXCI6XCLiiaVcIixcImdFXCI6XCLiiadcIixcImdFbFwiOlwi4qqMXCIsXCJnZWxcIjpcIuKLm1wiLFwiZ2VxXCI6XCLiiaVcIixcImdlcXFcIjpcIuKJp1wiLFwiZ2Vxc2xhbnRcIjpcIuKpvlwiLFwiZ2VzY2NcIjpcIuKqqVwiLFwiZ2VzXCI6XCLiqb5cIixcImdlc2RvdFwiOlwi4qqAXCIsXCJnZXNkb3RvXCI6XCLiqoJcIixcImdlc2RvdG9sXCI6XCLiqoRcIixcImdlc2xcIjpcIuKLm++4gFwiLFwiZ2VzbGVzXCI6XCLiqpRcIixcIkdmclwiOlwi8J2UilwiLFwiZ2ZyXCI6XCLwnZSkXCIsXCJnZ1wiOlwi4omrXCIsXCJHZ1wiOlwi4ouZXCIsXCJnZ2dcIjpcIuKLmVwiLFwiZ2ltZWxcIjpcIuKEt1wiLFwiR0pjeVwiOlwi0INcIixcImdqY3lcIjpcItGTXCIsXCJnbGFcIjpcIuKqpVwiLFwiZ2xcIjpcIuKJt1wiLFwiZ2xFXCI6XCLiqpJcIixcImdsalwiOlwi4qqkXCIsXCJnbmFwXCI6XCLiqopcIixcImduYXBwcm94XCI6XCLiqopcIixcImduZVwiOlwi4qqIXCIsXCJnbkVcIjpcIuKJqVwiLFwiZ25lcVwiOlwi4qqIXCIsXCJnbmVxcVwiOlwi4ompXCIsXCJnbnNpbVwiOlwi4ounXCIsXCJHb3BmXCI6XCLwnZS+XCIsXCJnb3BmXCI6XCLwnZWYXCIsXCJncmF2ZVwiOlwiYFwiLFwiR3JlYXRlckVxdWFsXCI6XCLiiaVcIixcIkdyZWF0ZXJFcXVhbExlc3NcIjpcIuKLm1wiLFwiR3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnXCIsXCJHcmVhdGVyR3JlYXRlclwiOlwi4qqiXCIsXCJHcmVhdGVyTGVzc1wiOlwi4om3XCIsXCJHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+XCIsXCJHcmVhdGVyVGlsZGVcIjpcIuKJs1wiLFwiR3NjclwiOlwi8J2SolwiLFwiZ3NjclwiOlwi4oSKXCIsXCJnc2ltXCI6XCLiibNcIixcImdzaW1lXCI6XCLiqo5cIixcImdzaW1sXCI6XCLiqpBcIixcImd0Y2NcIjpcIuKqp1wiLFwiZ3RjaXJcIjpcIuKpulwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJHdFwiOlwi4omrXCIsXCJndGRvdFwiOlwi4ouXXCIsXCJndGxQYXJcIjpcIuKmlVwiLFwiZ3RxdWVzdFwiOlwi4qm8XCIsXCJndHJhcHByb3hcIjpcIuKqhlwiLFwiZ3RyYXJyXCI6XCLipbhcIixcImd0cmRvdFwiOlwi4ouXXCIsXCJndHJlcWxlc3NcIjpcIuKLm1wiLFwiZ3RyZXFxbGVzc1wiOlwi4qqMXCIsXCJndHJsZXNzXCI6XCLiibdcIixcImd0cnNpbVwiOlwi4omzXCIsXCJndmVydG5lcXFcIjpcIuKJqe+4gFwiLFwiZ3ZuRVwiOlwi4omp77iAXCIsXCJIYWNla1wiOlwiy4dcIixcImhhaXJzcFwiOlwi4oCKXCIsXCJoYWxmXCI6XCLCvVwiLFwiaGFtaWx0XCI6XCLihItcIixcIkhBUkRjeVwiOlwi0KpcIixcImhhcmRjeVwiOlwi0YpcIixcImhhcnJjaXJcIjpcIuKliFwiLFwiaGFyclwiOlwi4oaUXCIsXCJoQXJyXCI6XCLih5RcIixcImhhcnJ3XCI6XCLihq1cIixcIkhhdFwiOlwiXlwiLFwiaGJhclwiOlwi4oSPXCIsXCJIY2lyY1wiOlwixKRcIixcImhjaXJjXCI6XCLEpVwiLFwiaGVhcnRzXCI6XCLimaVcIixcImhlYXJ0c3VpdFwiOlwi4pmlXCIsXCJoZWxsaXBcIjpcIuKAplwiLFwiaGVyY29uXCI6XCLiirlcIixcImhmclwiOlwi8J2UpVwiLFwiSGZyXCI6XCLihIxcIixcIkhpbGJlcnRTcGFjZVwiOlwi4oSLXCIsXCJoa3NlYXJvd1wiOlwi4qSlXCIsXCJoa3N3YXJvd1wiOlwi4qSmXCIsXCJob2FyclwiOlwi4oe/XCIsXCJob210aHRcIjpcIuKIu1wiLFwiaG9va2xlZnRhcnJvd1wiOlwi4oapXCIsXCJob29rcmlnaHRhcnJvd1wiOlwi4oaqXCIsXCJob3BmXCI6XCLwnZWZXCIsXCJIb3BmXCI6XCLihI1cIixcImhvcmJhclwiOlwi4oCVXCIsXCJIb3Jpem9udGFsTGluZVwiOlwi4pSAXCIsXCJoc2NyXCI6XCLwnZK9XCIsXCJIc2NyXCI6XCLihItcIixcImhzbGFzaFwiOlwi4oSPXCIsXCJIc3Ryb2tcIjpcIsSmXCIsXCJoc3Ryb2tcIjpcIsSnXCIsXCJIdW1wRG93bkh1bXBcIjpcIuKJjlwiLFwiSHVtcEVxdWFsXCI6XCLiiY9cIixcImh5YnVsbFwiOlwi4oGDXCIsXCJoeXBoZW5cIjpcIuKAkFwiLFwiSWFjdXRlXCI6XCLDjVwiLFwiaWFjdXRlXCI6XCLDrVwiLFwiaWNcIjpcIuKBo1wiLFwiSWNpcmNcIjpcIsOOXCIsXCJpY2lyY1wiOlwiw65cIixcIkljeVwiOlwi0JhcIixcImljeVwiOlwi0LhcIixcIklkb3RcIjpcIsSwXCIsXCJJRWN5XCI6XCLQlVwiLFwiaWVjeVwiOlwi0LVcIixcImlleGNsXCI6XCLCoVwiLFwiaWZmXCI6XCLih5RcIixcImlmclwiOlwi8J2UplwiLFwiSWZyXCI6XCLihJFcIixcIklncmF2ZVwiOlwiw4xcIixcImlncmF2ZVwiOlwiw6xcIixcImlpXCI6XCLihYhcIixcImlpaWludFwiOlwi4qiMXCIsXCJpaWludFwiOlwi4oitXCIsXCJpaW5maW5cIjpcIuKnnFwiLFwiaWlvdGFcIjpcIuKEqVwiLFwiSUpsaWdcIjpcIsSyXCIsXCJpamxpZ1wiOlwixLNcIixcIkltYWNyXCI6XCLEqlwiLFwiaW1hY3JcIjpcIsSrXCIsXCJpbWFnZVwiOlwi4oSRXCIsXCJJbWFnaW5hcnlJXCI6XCLihYhcIixcImltYWdsaW5lXCI6XCLihJBcIixcImltYWdwYXJ0XCI6XCLihJFcIixcImltYXRoXCI6XCLEsVwiLFwiSW1cIjpcIuKEkVwiLFwiaW1vZlwiOlwi4oq3XCIsXCJpbXBlZFwiOlwixrVcIixcIkltcGxpZXNcIjpcIuKHklwiLFwiaW5jYXJlXCI6XCLihIVcIixcImluXCI6XCLiiIhcIixcImluZmluXCI6XCLiiJ5cIixcImluZmludGllXCI6XCLip51cIixcImlub2RvdFwiOlwixLFcIixcImludGNhbFwiOlwi4oq6XCIsXCJpbnRcIjpcIuKIq1wiLFwiSW50XCI6XCLiiKxcIixcImludGVnZXJzXCI6XCLihKRcIixcIkludGVncmFsXCI6XCLiiKtcIixcImludGVyY2FsXCI6XCLiirpcIixcIkludGVyc2VjdGlvblwiOlwi4ouCXCIsXCJpbnRsYXJoa1wiOlwi4qiXXCIsXCJpbnRwcm9kXCI6XCLiqLxcIixcIkludmlzaWJsZUNvbW1hXCI6XCLigaNcIixcIkludmlzaWJsZVRpbWVzXCI6XCLigaJcIixcIklPY3lcIjpcItCBXCIsXCJpb2N5XCI6XCLRkVwiLFwiSW9nb25cIjpcIsSuXCIsXCJpb2dvblwiOlwixK9cIixcIklvcGZcIjpcIvCdlYBcIixcImlvcGZcIjpcIvCdlZpcIixcIklvdGFcIjpcIs6ZXCIsXCJpb3RhXCI6XCLOuVwiLFwiaXByb2RcIjpcIuKovFwiLFwiaXF1ZXN0XCI6XCLCv1wiLFwiaXNjclwiOlwi8J2SvlwiLFwiSXNjclwiOlwi4oSQXCIsXCJpc2luXCI6XCLiiIhcIixcImlzaW5kb3RcIjpcIuKLtVwiLFwiaXNpbkVcIjpcIuKLuVwiLFwiaXNpbnNcIjpcIuKLtFwiLFwiaXNpbnN2XCI6XCLii7NcIixcImlzaW52XCI6XCLiiIhcIixcIml0XCI6XCLigaJcIixcIkl0aWxkZVwiOlwixKhcIixcIml0aWxkZVwiOlwixKlcIixcIkl1a2N5XCI6XCLQhlwiLFwiaXVrY3lcIjpcItGWXCIsXCJJdW1sXCI6XCLDj1wiLFwiaXVtbFwiOlwiw69cIixcIkpjaXJjXCI6XCLEtFwiLFwiamNpcmNcIjpcIsS1XCIsXCJKY3lcIjpcItCZXCIsXCJqY3lcIjpcItC5XCIsXCJKZnJcIjpcIvCdlI1cIixcImpmclwiOlwi8J2Up1wiLFwiam1hdGhcIjpcIsi3XCIsXCJKb3BmXCI6XCLwnZWBXCIsXCJqb3BmXCI6XCLwnZWbXCIsXCJKc2NyXCI6XCLwnZKlXCIsXCJqc2NyXCI6XCLwnZK/XCIsXCJKc2VyY3lcIjpcItCIXCIsXCJqc2VyY3lcIjpcItGYXCIsXCJKdWtjeVwiOlwi0IRcIixcImp1a2N5XCI6XCLRlFwiLFwiS2FwcGFcIjpcIs6aXCIsXCJrYXBwYVwiOlwizrpcIixcImthcHBhdlwiOlwiz7BcIixcIktjZWRpbFwiOlwixLZcIixcImtjZWRpbFwiOlwixLdcIixcIktjeVwiOlwi0JpcIixcImtjeVwiOlwi0LpcIixcIktmclwiOlwi8J2UjlwiLFwia2ZyXCI6XCLwnZSoXCIsXCJrZ3JlZW5cIjpcIsS4XCIsXCJLSGN5XCI6XCLQpVwiLFwia2hjeVwiOlwi0YVcIixcIktKY3lcIjpcItCMXCIsXCJramN5XCI6XCLRnFwiLFwiS29wZlwiOlwi8J2VglwiLFwia29wZlwiOlwi8J2VnFwiLFwiS3NjclwiOlwi8J2SplwiLFwia3NjclwiOlwi8J2TgFwiLFwibEFhcnJcIjpcIuKHmlwiLFwiTGFjdXRlXCI6XCLEuVwiLFwibGFjdXRlXCI6XCLEulwiLFwibGFlbXB0eXZcIjpcIuKmtFwiLFwibGFncmFuXCI6XCLihJJcIixcIkxhbWJkYVwiOlwizptcIixcImxhbWJkYVwiOlwizrtcIixcImxhbmdcIjpcIuKfqFwiLFwiTGFuZ1wiOlwi4p+qXCIsXCJsYW5nZFwiOlwi4qaRXCIsXCJsYW5nbGVcIjpcIuKfqFwiLFwibGFwXCI6XCLiqoVcIixcIkxhcGxhY2V0cmZcIjpcIuKEklwiLFwibGFxdW9cIjpcIsKrXCIsXCJsYXJyYlwiOlwi4oekXCIsXCJsYXJyYmZzXCI6XCLipJ9cIixcImxhcnJcIjpcIuKGkFwiLFwiTGFyclwiOlwi4oaeXCIsXCJsQXJyXCI6XCLih5BcIixcImxhcnJmc1wiOlwi4qSdXCIsXCJsYXJyaGtcIjpcIuKGqVwiLFwibGFycmxwXCI6XCLihqtcIixcImxhcnJwbFwiOlwi4qS5XCIsXCJsYXJyc2ltXCI6XCLipbNcIixcImxhcnJ0bFwiOlwi4oaiXCIsXCJsYXRhaWxcIjpcIuKkmVwiLFwibEF0YWlsXCI6XCLipJtcIixcImxhdFwiOlwi4qqrXCIsXCJsYXRlXCI6XCLiqq1cIixcImxhdGVzXCI6XCLiqq3vuIBcIixcImxiYXJyXCI6XCLipIxcIixcImxCYXJyXCI6XCLipI5cIixcImxiYnJrXCI6XCLinbJcIixcImxicmFjZVwiOlwie1wiLFwibGJyYWNrXCI6XCJbXCIsXCJsYnJrZVwiOlwi4qaLXCIsXCJsYnJrc2xkXCI6XCLipo9cIixcImxicmtzbHVcIjpcIuKmjVwiLFwiTGNhcm9uXCI6XCLEvVwiLFwibGNhcm9uXCI6XCLEvlwiLFwiTGNlZGlsXCI6XCLEu1wiLFwibGNlZGlsXCI6XCLEvFwiLFwibGNlaWxcIjpcIuKMiFwiLFwibGN1YlwiOlwie1wiLFwiTGN5XCI6XCLQm1wiLFwibGN5XCI6XCLQu1wiLFwibGRjYVwiOlwi4qS2XCIsXCJsZHF1b1wiOlwi4oCcXCIsXCJsZHF1b3JcIjpcIuKAnlwiLFwibGRyZGhhclwiOlwi4qWnXCIsXCJsZHJ1c2hhclwiOlwi4qWLXCIsXCJsZHNoXCI6XCLihrJcIixcImxlXCI6XCLiiaRcIixcImxFXCI6XCLiiaZcIixcIkxlZnRBbmdsZUJyYWNrZXRcIjpcIuKfqFwiLFwiTGVmdEFycm93QmFyXCI6XCLih6RcIixcImxlZnRhcnJvd1wiOlwi4oaQXCIsXCJMZWZ0QXJyb3dcIjpcIuKGkFwiLFwiTGVmdGFycm93XCI6XCLih5BcIixcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjpcIuKHhlwiLFwibGVmdGFycm93dGFpbFwiOlwi4oaiXCIsXCJMZWZ0Q2VpbGluZ1wiOlwi4oyIXCIsXCJMZWZ0RG91YmxlQnJhY2tldFwiOlwi4p+mXCIsXCJMZWZ0RG93blRlZVZlY3RvclwiOlwi4qWhXCIsXCJMZWZ0RG93blZlY3RvckJhclwiOlwi4qWZXCIsXCJMZWZ0RG93blZlY3RvclwiOlwi4oeDXCIsXCJMZWZ0Rmxvb3JcIjpcIuKMilwiLFwibGVmdGhhcnBvb25kb3duXCI6XCLihr1cIixcImxlZnRoYXJwb29udXBcIjpcIuKGvFwiLFwibGVmdGxlZnRhcnJvd3NcIjpcIuKHh1wiLFwibGVmdHJpZ2h0YXJyb3dcIjpcIuKGlFwiLFwiTGVmdFJpZ2h0QXJyb3dcIjpcIuKGlFwiLFwiTGVmdHJpZ2h0YXJyb3dcIjpcIuKHlFwiLFwibGVmdHJpZ2h0YXJyb3dzXCI6XCLih4ZcIixcImxlZnRyaWdodGhhcnBvb25zXCI6XCLih4tcIixcImxlZnRyaWdodHNxdWlnYXJyb3dcIjpcIuKGrVwiLFwiTGVmdFJpZ2h0VmVjdG9yXCI6XCLipY5cIixcIkxlZnRUZWVBcnJvd1wiOlwi4oakXCIsXCJMZWZ0VGVlXCI6XCLiiqNcIixcIkxlZnRUZWVWZWN0b3JcIjpcIuKlmlwiLFwibGVmdHRocmVldGltZXNcIjpcIuKLi1wiLFwiTGVmdFRyaWFuZ2xlQmFyXCI6XCLip49cIixcIkxlZnRUcmlhbmdsZVwiOlwi4oqyXCIsXCJMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4oq0XCIsXCJMZWZ0VXBEb3duVmVjdG9yXCI6XCLipZFcIixcIkxlZnRVcFRlZVZlY3RvclwiOlwi4qWgXCIsXCJMZWZ0VXBWZWN0b3JCYXJcIjpcIuKlmFwiLFwiTGVmdFVwVmVjdG9yXCI6XCLihr9cIixcIkxlZnRWZWN0b3JCYXJcIjpcIuKlklwiLFwiTGVmdFZlY3RvclwiOlwi4oa8XCIsXCJsRWdcIjpcIuKqi1wiLFwibGVnXCI6XCLii5pcIixcImxlcVwiOlwi4omkXCIsXCJsZXFxXCI6XCLiiaZcIixcImxlcXNsYW50XCI6XCLiqb1cIixcImxlc2NjXCI6XCLiqqhcIixcImxlc1wiOlwi4qm9XCIsXCJsZXNkb3RcIjpcIuKpv1wiLFwibGVzZG90b1wiOlwi4qqBXCIsXCJsZXNkb3RvclwiOlwi4qqDXCIsXCJsZXNnXCI6XCLii5rvuIBcIixcImxlc2dlc1wiOlwi4qqTXCIsXCJsZXNzYXBwcm94XCI6XCLiqoVcIixcImxlc3Nkb3RcIjpcIuKLllwiLFwibGVzc2VxZ3RyXCI6XCLii5pcIixcImxlc3NlcXFndHJcIjpcIuKqi1wiLFwiTGVzc0VxdWFsR3JlYXRlclwiOlwi4ouaXCIsXCJMZXNzRnVsbEVxdWFsXCI6XCLiiaZcIixcIkxlc3NHcmVhdGVyXCI6XCLiibZcIixcImxlc3NndHJcIjpcIuKJtlwiLFwiTGVzc0xlc3NcIjpcIuKqoVwiLFwibGVzc3NpbVwiOlwi4omyXCIsXCJMZXNzU2xhbnRFcXVhbFwiOlwi4qm9XCIsXCJMZXNzVGlsZGVcIjpcIuKJslwiLFwibGZpc2h0XCI6XCLipbxcIixcImxmbG9vclwiOlwi4oyKXCIsXCJMZnJcIjpcIvCdlI9cIixcImxmclwiOlwi8J2UqVwiLFwibGdcIjpcIuKJtlwiLFwibGdFXCI6XCLiqpFcIixcImxIYXJcIjpcIuKlolwiLFwibGhhcmRcIjpcIuKGvVwiLFwibGhhcnVcIjpcIuKGvFwiLFwibGhhcnVsXCI6XCLipapcIixcImxoYmxrXCI6XCLiloRcIixcIkxKY3lcIjpcItCJXCIsXCJsamN5XCI6XCLRmVwiLFwibGxhcnJcIjpcIuKHh1wiLFwibGxcIjpcIuKJqlwiLFwiTGxcIjpcIuKLmFwiLFwibGxjb3JuZXJcIjpcIuKMnlwiLFwiTGxlZnRhcnJvd1wiOlwi4oeaXCIsXCJsbGhhcmRcIjpcIuKlq1wiLFwibGx0cmlcIjpcIuKXulwiLFwiTG1pZG90XCI6XCLEv1wiLFwibG1pZG90XCI6XCLFgFwiLFwibG1vdXN0YWNoZVwiOlwi4o6wXCIsXCJsbW91c3RcIjpcIuKOsFwiLFwibG5hcFwiOlwi4qqJXCIsXCJsbmFwcHJveFwiOlwi4qqJXCIsXCJsbmVcIjpcIuKqh1wiLFwibG5FXCI6XCLiiahcIixcImxuZXFcIjpcIuKqh1wiLFwibG5lcXFcIjpcIuKJqFwiLFwibG5zaW1cIjpcIuKLplwiLFwibG9hbmdcIjpcIuKfrFwiLFwibG9hcnJcIjpcIuKHvVwiLFwibG9icmtcIjpcIuKfplwiLFwibG9uZ2xlZnRhcnJvd1wiOlwi4p+1XCIsXCJMb25nTGVmdEFycm93XCI6XCLin7VcIixcIkxvbmdsZWZ0YXJyb3dcIjpcIuKfuFwiLFwibG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7dcIixcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwi4p+3XCIsXCJMb25nbGVmdHJpZ2h0YXJyb3dcIjpcIuKfulwiLFwibG9uZ21hcHN0b1wiOlwi4p+8XCIsXCJsb25ncmlnaHRhcnJvd1wiOlwi4p+2XCIsXCJMb25nUmlnaHRBcnJvd1wiOlwi4p+2XCIsXCJMb25ncmlnaHRhcnJvd1wiOlwi4p+5XCIsXCJsb29wYXJyb3dsZWZ0XCI6XCLihqtcIixcImxvb3BhcnJvd3JpZ2h0XCI6XCLihqxcIixcImxvcGFyXCI6XCLipoVcIixcIkxvcGZcIjpcIvCdlYNcIixcImxvcGZcIjpcIvCdlZ1cIixcImxvcGx1c1wiOlwi4qitXCIsXCJsb3RpbWVzXCI6XCLiqLRcIixcImxvd2FzdFwiOlwi4oiXXCIsXCJsb3diYXJcIjpcIl9cIixcIkxvd2VyTGVmdEFycm93XCI6XCLihplcIixcIkxvd2VyUmlnaHRBcnJvd1wiOlwi4oaYXCIsXCJsb3pcIjpcIuKXilwiLFwibG96ZW5nZVwiOlwi4peKXCIsXCJsb3pmXCI6XCLip6tcIixcImxwYXJcIjpcIihcIixcImxwYXJsdFwiOlwi4qaTXCIsXCJscmFyclwiOlwi4oeGXCIsXCJscmNvcm5lclwiOlwi4oyfXCIsXCJscmhhclwiOlwi4oeLXCIsXCJscmhhcmRcIjpcIuKlrVwiLFwibHJtXCI6XCLigI5cIixcImxydHJpXCI6XCLiir9cIixcImxzYXF1b1wiOlwi4oC5XCIsXCJsc2NyXCI6XCLwnZOBXCIsXCJMc2NyXCI6XCLihJJcIixcImxzaFwiOlwi4oawXCIsXCJMc2hcIjpcIuKGsFwiLFwibHNpbVwiOlwi4omyXCIsXCJsc2ltZVwiOlwi4qqNXCIsXCJsc2ltZ1wiOlwi4qqPXCIsXCJsc3FiXCI6XCJbXCIsXCJsc3F1b1wiOlwi4oCYXCIsXCJsc3F1b3JcIjpcIuKAmlwiLFwiTHN0cm9rXCI6XCLFgVwiLFwibHN0cm9rXCI6XCLFglwiLFwibHRjY1wiOlwi4qqmXCIsXCJsdGNpclwiOlwi4qm5XCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIkx0XCI6XCLiiapcIixcImx0ZG90XCI6XCLii5ZcIixcImx0aHJlZVwiOlwi4ouLXCIsXCJsdGltZXNcIjpcIuKLiVwiLFwibHRsYXJyXCI6XCLipbZcIixcImx0cXVlc3RcIjpcIuKpu1wiLFwibHRyaVwiOlwi4peDXCIsXCJsdHJpZVwiOlwi4oq0XCIsXCJsdHJpZlwiOlwi4peCXCIsXCJsdHJQYXJcIjpcIuKmllwiLFwibHVyZHNoYXJcIjpcIuKlilwiLFwibHVydWhhclwiOlwi4qWmXCIsXCJsdmVydG5lcXFcIjpcIuKJqO+4gFwiLFwibHZuRVwiOlwi4omo77iAXCIsXCJtYWNyXCI6XCLCr1wiLFwibWFsZVwiOlwi4pmCXCIsXCJtYWx0XCI6XCLinKBcIixcIm1hbHRlc2VcIjpcIuKcoFwiLFwiTWFwXCI6XCLipIVcIixcIm1hcFwiOlwi4oamXCIsXCJtYXBzdG9cIjpcIuKGplwiLFwibWFwc3RvZG93blwiOlwi4oanXCIsXCJtYXBzdG9sZWZ0XCI6XCLihqRcIixcIm1hcHN0b3VwXCI6XCLihqVcIixcIm1hcmtlclwiOlwi4pauXCIsXCJtY29tbWFcIjpcIuKoqVwiLFwiTWN5XCI6XCLQnFwiLFwibWN5XCI6XCLQvFwiLFwibWRhc2hcIjpcIuKAlFwiLFwibUREb3RcIjpcIuKIulwiLFwibWVhc3VyZWRhbmdsZVwiOlwi4oihXCIsXCJNZWRpdW1TcGFjZVwiOlwi4oGfXCIsXCJNZWxsaW50cmZcIjpcIuKEs1wiLFwiTWZyXCI6XCLwnZSQXCIsXCJtZnJcIjpcIvCdlKpcIixcIm1ob1wiOlwi4oSnXCIsXCJtaWNyb1wiOlwiwrVcIixcIm1pZGFzdFwiOlwiKlwiLFwibWlkY2lyXCI6XCLiq7BcIixcIm1pZFwiOlwi4oijXCIsXCJtaWRkb3RcIjpcIsK3XCIsXCJtaW51c2JcIjpcIuKKn1wiLFwibWludXNcIjpcIuKIklwiLFwibWludXNkXCI6XCLiiLhcIixcIm1pbnVzZHVcIjpcIuKoqlwiLFwiTWludXNQbHVzXCI6XCLiiJNcIixcIm1sY3BcIjpcIuKrm1wiLFwibWxkclwiOlwi4oCmXCIsXCJtbnBsdXNcIjpcIuKIk1wiLFwibW9kZWxzXCI6XCLiiqdcIixcIk1vcGZcIjpcIvCdlYRcIixcIm1vcGZcIjpcIvCdlZ5cIixcIm1wXCI6XCLiiJNcIixcIm1zY3JcIjpcIvCdk4JcIixcIk1zY3JcIjpcIuKEs1wiLFwibXN0cG9zXCI6XCLiiL5cIixcIk11XCI6XCLOnFwiLFwibXVcIjpcIs68XCIsXCJtdWx0aW1hcFwiOlwi4oq4XCIsXCJtdW1hcFwiOlwi4oq4XCIsXCJuYWJsYVwiOlwi4oiHXCIsXCJOYWN1dGVcIjpcIsWDXCIsXCJuYWN1dGVcIjpcIsWEXCIsXCJuYW5nXCI6XCLiiKDig5JcIixcIm5hcFwiOlwi4omJXCIsXCJuYXBFXCI6XCLiqbDMuFwiLFwibmFwaWRcIjpcIuKJi8y4XCIsXCJuYXBvc1wiOlwixYlcIixcIm5hcHByb3hcIjpcIuKJiVwiLFwibmF0dXJhbFwiOlwi4pmuXCIsXCJuYXR1cmFsc1wiOlwi4oSVXCIsXCJuYXR1clwiOlwi4pmuXCIsXCJuYnNwXCI6XCLCoFwiLFwibmJ1bXBcIjpcIuKJjsy4XCIsXCJuYnVtcGVcIjpcIuKJj8y4XCIsXCJuY2FwXCI6XCLiqYNcIixcIk5jYXJvblwiOlwixYdcIixcIm5jYXJvblwiOlwixYhcIixcIk5jZWRpbFwiOlwixYVcIixcIm5jZWRpbFwiOlwixYZcIixcIm5jb25nXCI6XCLiiYdcIixcIm5jb25nZG90XCI6XCLiqa3MuFwiLFwibmN1cFwiOlwi4qmCXCIsXCJOY3lcIjpcItCdXCIsXCJuY3lcIjpcItC9XCIsXCJuZGFzaFwiOlwi4oCTXCIsXCJuZWFyaGtcIjpcIuKkpFwiLFwibmVhcnJcIjpcIuKGl1wiLFwibmVBcnJcIjpcIuKHl1wiLFwibmVhcnJvd1wiOlwi4oaXXCIsXCJuZVwiOlwi4omgXCIsXCJuZWRvdFwiOlwi4omQzLhcIixcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpblNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJuZXF1aXZcIjpcIuKJolwiLFwibmVzZWFyXCI6XCLipKhcIixcIm5lc2ltXCI6XCLiiYLMuFwiLFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKJq1wiLFwiTmVzdGVkTGVzc0xlc3NcIjpcIuKJqlwiLFwiTmV3TGluZVwiOlwiXFxcXG5cIixcIm5leGlzdFwiOlwi4oiEXCIsXCJuZXhpc3RzXCI6XCLiiIRcIixcIk5mclwiOlwi8J2UkVwiLFwibmZyXCI6XCLwnZSrXCIsXCJuZ0VcIjpcIuKJp8y4XCIsXCJuZ2VcIjpcIuKJsVwiLFwibmdlcVwiOlwi4omxXCIsXCJuZ2VxcVwiOlwi4omnzLhcIixcIm5nZXFzbGFudFwiOlwi4qm+zLhcIixcIm5nZXNcIjpcIuKpvsy4XCIsXCJuR2dcIjpcIuKLmcy4XCIsXCJuZ3NpbVwiOlwi4om1XCIsXCJuR3RcIjpcIuKJq+KDklwiLFwibmd0XCI6XCLiia9cIixcIm5ndHJcIjpcIuKJr1wiLFwibkd0dlwiOlwi4omrzLhcIixcIm5oYXJyXCI6XCLihq5cIixcIm5oQXJyXCI6XCLih45cIixcIm5ocGFyXCI6XCLiq7JcIixcIm5pXCI6XCLiiItcIixcIm5pc1wiOlwi4ou8XCIsXCJuaXNkXCI6XCLii7pcIixcIm5pdlwiOlwi4oiLXCIsXCJOSmN5XCI6XCLQilwiLFwibmpjeVwiOlwi0ZpcIixcIm5sYXJyXCI6XCLihppcIixcIm5sQXJyXCI6XCLih41cIixcIm5sZHJcIjpcIuKApVwiLFwibmxFXCI6XCLiiabMuFwiLFwibmxlXCI6XCLiibBcIixcIm5sZWZ0YXJyb3dcIjpcIuKGmlwiLFwibkxlZnRhcnJvd1wiOlwi4oeNXCIsXCJubGVmdHJpZ2h0YXJyb3dcIjpcIuKGrlwiLFwibkxlZnRyaWdodGFycm93XCI6XCLih45cIixcIm5sZXFcIjpcIuKJsFwiLFwibmxlcXFcIjpcIuKJpsy4XCIsXCJubGVxc2xhbnRcIjpcIuKpvcy4XCIsXCJubGVzXCI6XCLiqb3MuFwiLFwibmxlc3NcIjpcIuKJrlwiLFwibkxsXCI6XCLii5jMuFwiLFwibmxzaW1cIjpcIuKJtFwiLFwibkx0XCI6XCLiiarig5JcIixcIm5sdFwiOlwi4omuXCIsXCJubHRyaVwiOlwi4ouqXCIsXCJubHRyaWVcIjpcIuKLrFwiLFwibkx0dlwiOlwi4omqzLhcIixcIm5taWRcIjpcIuKIpFwiLFwiTm9CcmVha1wiOlwi4oGgXCIsXCJOb25CcmVha2luZ1NwYWNlXCI6XCLCoFwiLFwibm9wZlwiOlwi8J2Vn1wiLFwiTm9wZlwiOlwi4oSVXCIsXCJOb3RcIjpcIuKrrFwiLFwibm90XCI6XCLCrFwiLFwiTm90Q29uZ3J1ZW50XCI6XCLiiaJcIixcIk5vdEN1cENhcFwiOlwi4omtXCIsXCJOb3REb3VibGVWZXJ0aWNhbEJhclwiOlwi4oimXCIsXCJOb3RFbGVtZW50XCI6XCLiiIlcIixcIk5vdEVxdWFsXCI6XCLiiaBcIixcIk5vdEVxdWFsVGlsZGVcIjpcIuKJgsy4XCIsXCJOb3RFeGlzdHNcIjpcIuKIhFwiLFwiTm90R3JlYXRlclwiOlwi4omvXCIsXCJOb3RHcmVhdGVyRXF1YWxcIjpcIuKJsVwiLFwiTm90R3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnzLhcIixcIk5vdEdyZWF0ZXJHcmVhdGVyXCI6XCLiiavMuFwiLFwiTm90R3JlYXRlckxlc3NcIjpcIuKJuVwiLFwiTm90R3JlYXRlclNsYW50RXF1YWxcIjpcIuKpvsy4XCIsXCJOb3RHcmVhdGVyVGlsZGVcIjpcIuKJtVwiLFwiTm90SHVtcERvd25IdW1wXCI6XCLiiY7MuFwiLFwiTm90SHVtcEVxdWFsXCI6XCLiiY/MuFwiLFwibm90aW5cIjpcIuKIiVwiLFwibm90aW5kb3RcIjpcIuKLtcy4XCIsXCJub3RpbkVcIjpcIuKLucy4XCIsXCJub3RpbnZhXCI6XCLiiIlcIixcIm5vdGludmJcIjpcIuKLt1wiLFwibm90aW52Y1wiOlwi4ou2XCIsXCJOb3RMZWZ0VHJpYW5nbGVCYXJcIjpcIuKnj8y4XCIsXCJOb3RMZWZ0VHJpYW5nbGVcIjpcIuKLqlwiLFwiTm90TGVmdFRyaWFuZ2xlRXF1YWxcIjpcIuKLrFwiLFwiTm90TGVzc1wiOlwi4omuXCIsXCJOb3RMZXNzRXF1YWxcIjpcIuKJsFwiLFwiTm90TGVzc0dyZWF0ZXJcIjpcIuKJuFwiLFwiTm90TGVzc0xlc3NcIjpcIuKJqsy4XCIsXCJOb3RMZXNzU2xhbnRFcXVhbFwiOlwi4qm9zLhcIixcIk5vdExlc3NUaWxkZVwiOlwi4om0XCIsXCJOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlclwiOlwi4qqizLhcIixcIk5vdE5lc3RlZExlc3NMZXNzXCI6XCLiqqHMuFwiLFwibm90bmlcIjpcIuKIjFwiLFwibm90bml2YVwiOlwi4oiMXCIsXCJub3RuaXZiXCI6XCLii75cIixcIm5vdG5pdmNcIjpcIuKLvVwiLFwiTm90UHJlY2VkZXNcIjpcIuKKgFwiLFwiTm90UHJlY2VkZXNFcXVhbFwiOlwi4qqvzLhcIixcIk5vdFByZWNlZGVzU2xhbnRFcXVhbFwiOlwi4ougXCIsXCJOb3RSZXZlcnNlRWxlbWVudFwiOlwi4oiMXCIsXCJOb3RSaWdodFRyaWFuZ2xlQmFyXCI6XCLip5DMuFwiLFwiTm90UmlnaHRUcmlhbmdsZVwiOlwi4ourXCIsXCJOb3RSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKLrVwiLFwiTm90U3F1YXJlU3Vic2V0XCI6XCLiio/MuFwiLFwiTm90U3F1YXJlU3Vic2V0RXF1YWxcIjpcIuKLolwiLFwiTm90U3F1YXJlU3VwZXJzZXRcIjpcIuKKkMy4XCIsXCJOb3RTcXVhcmVTdXBlcnNldEVxdWFsXCI6XCLii6NcIixcIk5vdFN1YnNldFwiOlwi4oqC4oOSXCIsXCJOb3RTdWJzZXRFcXVhbFwiOlwi4oqIXCIsXCJOb3RTdWNjZWVkc1wiOlwi4oqBXCIsXCJOb3RTdWNjZWVkc0VxdWFsXCI6XCLiqrDMuFwiLFwiTm90U3VjY2VlZHNTbGFudEVxdWFsXCI6XCLii6FcIixcIk5vdFN1Y2NlZWRzVGlsZGVcIjpcIuKJv8y4XCIsXCJOb3RTdXBlcnNldFwiOlwi4oqD4oOSXCIsXCJOb3RTdXBlcnNldEVxdWFsXCI6XCLiiolcIixcIk5vdFRpbGRlXCI6XCLiiYFcIixcIk5vdFRpbGRlRXF1YWxcIjpcIuKJhFwiLFwiTm90VGlsZGVGdWxsRXF1YWxcIjpcIuKJh1wiLFwiTm90VGlsZGVUaWxkZVwiOlwi4omJXCIsXCJOb3RWZXJ0aWNhbEJhclwiOlwi4oikXCIsXCJucGFyYWxsZWxcIjpcIuKIplwiLFwibnBhclwiOlwi4oimXCIsXCJucGFyc2xcIjpcIuKrveKDpVwiLFwibnBhcnRcIjpcIuKIgsy4XCIsXCJucG9saW50XCI6XCLiqJRcIixcIm5wclwiOlwi4oqAXCIsXCJucHJjdWVcIjpcIuKLoFwiLFwibnByZWNcIjpcIuKKgFwiLFwibnByZWNlcVwiOlwi4qqvzLhcIixcIm5wcmVcIjpcIuKqr8y4XCIsXCJucmFycmNcIjpcIuKks8y4XCIsXCJucmFyclwiOlwi4oabXCIsXCJuckFyclwiOlwi4oePXCIsXCJucmFycndcIjpcIuKGncy4XCIsXCJucmlnaHRhcnJvd1wiOlwi4oabXCIsXCJuUmlnaHRhcnJvd1wiOlwi4oePXCIsXCJucnRyaVwiOlwi4ourXCIsXCJucnRyaWVcIjpcIuKLrVwiLFwibnNjXCI6XCLiioFcIixcIm5zY2N1ZVwiOlwi4ouhXCIsXCJuc2NlXCI6XCLiqrDMuFwiLFwiTnNjclwiOlwi8J2SqVwiLFwibnNjclwiOlwi8J2Tg1wiLFwibnNob3J0bWlkXCI6XCLiiKRcIixcIm5zaG9ydHBhcmFsbGVsXCI6XCLiiKZcIixcIm5zaW1cIjpcIuKJgVwiLFwibnNpbWVcIjpcIuKJhFwiLFwibnNpbWVxXCI6XCLiiYRcIixcIm5zbWlkXCI6XCLiiKRcIixcIm5zcGFyXCI6XCLiiKZcIixcIm5zcXN1YmVcIjpcIuKLolwiLFwibnNxc3VwZVwiOlwi4oujXCIsXCJuc3ViXCI6XCLiioRcIixcIm5zdWJFXCI6XCLiq4XMuFwiLFwibnN1YmVcIjpcIuKKiFwiLFwibnN1YnNldFwiOlwi4oqC4oOSXCIsXCJuc3Vic2V0ZXFcIjpcIuKKiFwiLFwibnN1YnNldGVxcVwiOlwi4quFzLhcIixcIm5zdWNjXCI6XCLiioFcIixcIm5zdWNjZXFcIjpcIuKqsMy4XCIsXCJuc3VwXCI6XCLiioVcIixcIm5zdXBFXCI6XCLiq4bMuFwiLFwibnN1cGVcIjpcIuKKiVwiLFwibnN1cHNldFwiOlwi4oqD4oOSXCIsXCJuc3Vwc2V0ZXFcIjpcIuKKiVwiLFwibnN1cHNldGVxcVwiOlwi4quGzLhcIixcIm50Z2xcIjpcIuKJuVwiLFwiTnRpbGRlXCI6XCLDkVwiLFwibnRpbGRlXCI6XCLDsVwiLFwibnRsZ1wiOlwi4om4XCIsXCJudHJpYW5nbGVsZWZ0XCI6XCLii6pcIixcIm50cmlhbmdsZWxlZnRlcVwiOlwi4ousXCIsXCJudHJpYW5nbGVyaWdodFwiOlwi4ourXCIsXCJudHJpYW5nbGVyaWdodGVxXCI6XCLii61cIixcIk51XCI6XCLOnVwiLFwibnVcIjpcIs69XCIsXCJudW1cIjpcIiNcIixcIm51bWVyb1wiOlwi4oSWXCIsXCJudW1zcFwiOlwi4oCHXCIsXCJudmFwXCI6XCLiiY3ig5JcIixcIm52ZGFzaFwiOlwi4oqsXCIsXCJudkRhc2hcIjpcIuKKrVwiLFwiblZkYXNoXCI6XCLiiq5cIixcIm5WRGFzaFwiOlwi4oqvXCIsXCJudmdlXCI6XCLiiaXig5JcIixcIm52Z3RcIjpcIj7ig5JcIixcIm52SGFyclwiOlwi4qSEXCIsXCJudmluZmluXCI6XCLip55cIixcIm52bEFyclwiOlwi4qSCXCIsXCJudmxlXCI6XCLiiaTig5JcIixcIm52bHRcIjpcIjzig5JcIixcIm52bHRyaWVcIjpcIuKKtOKDklwiLFwibnZyQXJyXCI6XCLipINcIixcIm52cnRyaWVcIjpcIuKKteKDklwiLFwibnZzaW1cIjpcIuKIvOKDklwiLFwibndhcmhrXCI6XCLipKNcIixcIm53YXJyXCI6XCLihpZcIixcIm53QXJyXCI6XCLih5ZcIixcIm53YXJyb3dcIjpcIuKGllwiLFwibnduZWFyXCI6XCLipKdcIixcIk9hY3V0ZVwiOlwiw5NcIixcIm9hY3V0ZVwiOlwiw7NcIixcIm9hc3RcIjpcIuKKm1wiLFwiT2NpcmNcIjpcIsOUXCIsXCJvY2lyY1wiOlwiw7RcIixcIm9jaXJcIjpcIuKKmlwiLFwiT2N5XCI6XCLQnlwiLFwib2N5XCI6XCLQvlwiLFwib2Rhc2hcIjpcIuKKnVwiLFwiT2RibGFjXCI6XCLFkFwiLFwib2RibGFjXCI6XCLFkVwiLFwib2RpdlwiOlwi4qi4XCIsXCJvZG90XCI6XCLiiplcIixcIm9kc29sZFwiOlwi4qa8XCIsXCJPRWxpZ1wiOlwixZJcIixcIm9lbGlnXCI6XCLFk1wiLFwib2ZjaXJcIjpcIuKmv1wiLFwiT2ZyXCI6XCLwnZSSXCIsXCJvZnJcIjpcIvCdlKxcIixcIm9nb25cIjpcIsubXCIsXCJPZ3JhdmVcIjpcIsOSXCIsXCJvZ3JhdmVcIjpcIsOyXCIsXCJvZ3RcIjpcIuKngVwiLFwib2hiYXJcIjpcIuKmtVwiLFwib2htXCI6XCLOqVwiLFwib2ludFwiOlwi4oiuXCIsXCJvbGFyclwiOlwi4oa6XCIsXCJvbGNpclwiOlwi4qa+XCIsXCJvbGNyb3NzXCI6XCLiprtcIixcIm9saW5lXCI6XCLigL5cIixcIm9sdFwiOlwi4qeAXCIsXCJPbWFjclwiOlwixYxcIixcIm9tYWNyXCI6XCLFjVwiLFwiT21lZ2FcIjpcIs6pXCIsXCJvbWVnYVwiOlwiz4lcIixcIk9taWNyb25cIjpcIs6fXCIsXCJvbWljcm9uXCI6XCLOv1wiLFwib21pZFwiOlwi4qa2XCIsXCJvbWludXNcIjpcIuKKllwiLFwiT29wZlwiOlwi8J2VhlwiLFwib29wZlwiOlwi8J2VoFwiLFwib3BhclwiOlwi4qa3XCIsXCJPcGVuQ3VybHlEb3VibGVRdW90ZVwiOlwi4oCcXCIsXCJPcGVuQ3VybHlRdW90ZVwiOlwi4oCYXCIsXCJvcGVycFwiOlwi4qa5XCIsXCJvcGx1c1wiOlwi4oqVXCIsXCJvcmFyclwiOlwi4oa7XCIsXCJPclwiOlwi4qmUXCIsXCJvclwiOlwi4oioXCIsXCJvcmRcIjpcIuKpnVwiLFwib3JkZXJcIjpcIuKEtFwiLFwib3JkZXJvZlwiOlwi4oS0XCIsXCJvcmRmXCI6XCLCqlwiLFwib3JkbVwiOlwiwrpcIixcIm9yaWdvZlwiOlwi4oq2XCIsXCJvcm9yXCI6XCLiqZZcIixcIm9yc2xvcGVcIjpcIuKpl1wiLFwib3J2XCI6XCLiqZtcIixcIm9TXCI6XCLik4hcIixcIk9zY3JcIjpcIvCdkqpcIixcIm9zY3JcIjpcIuKEtFwiLFwiT3NsYXNoXCI6XCLDmFwiLFwib3NsYXNoXCI6XCLDuFwiLFwib3NvbFwiOlwi4oqYXCIsXCJPdGlsZGVcIjpcIsOVXCIsXCJvdGlsZGVcIjpcIsO1XCIsXCJvdGltZXNhc1wiOlwi4qi2XCIsXCJPdGltZXNcIjpcIuKot1wiLFwib3RpbWVzXCI6XCLiipdcIixcIk91bWxcIjpcIsOWXCIsXCJvdW1sXCI6XCLDtlwiLFwib3ZiYXJcIjpcIuKMvVwiLFwiT3ZlckJhclwiOlwi4oC+XCIsXCJPdmVyQnJhY2VcIjpcIuKPnlwiLFwiT3ZlckJyYWNrZXRcIjpcIuKOtFwiLFwiT3ZlclBhcmVudGhlc2lzXCI6XCLij5xcIixcInBhcmFcIjpcIsK2XCIsXCJwYXJhbGxlbFwiOlwi4oilXCIsXCJwYXJcIjpcIuKIpVwiLFwicGFyc2ltXCI6XCLiq7NcIixcInBhcnNsXCI6XCLiq71cIixcInBhcnRcIjpcIuKIglwiLFwiUGFydGlhbERcIjpcIuKIglwiLFwiUGN5XCI6XCLQn1wiLFwicGN5XCI6XCLQv1wiLFwicGVyY250XCI6XCIlXCIsXCJwZXJpb2RcIjpcIi5cIixcInBlcm1pbFwiOlwi4oCwXCIsXCJwZXJwXCI6XCLiiqVcIixcInBlcnRlbmtcIjpcIuKAsVwiLFwiUGZyXCI6XCLwnZSTXCIsXCJwZnJcIjpcIvCdlK1cIixcIlBoaVwiOlwizqZcIixcInBoaVwiOlwiz4ZcIixcInBoaXZcIjpcIs+VXCIsXCJwaG1tYXRcIjpcIuKEs1wiLFwicGhvbmVcIjpcIuKYjlwiLFwiUGlcIjpcIs6gXCIsXCJwaVwiOlwiz4BcIixcInBpdGNoZm9ya1wiOlwi4ouUXCIsXCJwaXZcIjpcIs+WXCIsXCJwbGFuY2tcIjpcIuKEj1wiLFwicGxhbmNraFwiOlwi4oSOXCIsXCJwbGFua3ZcIjpcIuKEj1wiLFwicGx1c2FjaXJcIjpcIuKoo1wiLFwicGx1c2JcIjpcIuKKnlwiLFwicGx1c2NpclwiOlwi4qiiXCIsXCJwbHVzXCI6XCIrXCIsXCJwbHVzZG9cIjpcIuKIlFwiLFwicGx1c2R1XCI6XCLiqKVcIixcInBsdXNlXCI6XCLiqbJcIixcIlBsdXNNaW51c1wiOlwiwrFcIixcInBsdXNtblwiOlwiwrFcIixcInBsdXNzaW1cIjpcIuKoplwiLFwicGx1c3R3b1wiOlwi4qinXCIsXCJwbVwiOlwiwrFcIixcIlBvaW5jYXJlcGxhbmVcIjpcIuKEjFwiLFwicG9pbnRpbnRcIjpcIuKolVwiLFwicG9wZlwiOlwi8J2VoVwiLFwiUG9wZlwiOlwi4oSZXCIsXCJwb3VuZFwiOlwiwqNcIixcInByYXBcIjpcIuKqt1wiLFwiUHJcIjpcIuKqu1wiLFwicHJcIjpcIuKJulwiLFwicHJjdWVcIjpcIuKJvFwiLFwicHJlY2FwcHJveFwiOlwi4qq3XCIsXCJwcmVjXCI6XCLiibpcIixcInByZWNjdXJseWVxXCI6XCLiibxcIixcIlByZWNlZGVzXCI6XCLiibpcIixcIlByZWNlZGVzRXF1YWxcIjpcIuKqr1wiLFwiUHJlY2VkZXNTbGFudEVxdWFsXCI6XCLiibxcIixcIlByZWNlZGVzVGlsZGVcIjpcIuKJvlwiLFwicHJlY2VxXCI6XCLiqq9cIixcInByZWNuYXBwcm94XCI6XCLiqrlcIixcInByZWNuZXFxXCI6XCLiqrVcIixcInByZWNuc2ltXCI6XCLii6hcIixcInByZVwiOlwi4qqvXCIsXCJwckVcIjpcIuKqs1wiLFwicHJlY3NpbVwiOlwi4om+XCIsXCJwcmltZVwiOlwi4oCyXCIsXCJQcmltZVwiOlwi4oCzXCIsXCJwcmltZXNcIjpcIuKEmVwiLFwicHJuYXBcIjpcIuKquVwiLFwicHJuRVwiOlwi4qq1XCIsXCJwcm5zaW1cIjpcIuKLqFwiLFwicHJvZFwiOlwi4oiPXCIsXCJQcm9kdWN0XCI6XCLiiI9cIixcInByb2ZhbGFyXCI6XCLijK5cIixcInByb2ZsaW5lXCI6XCLijJJcIixcInByb2ZzdXJmXCI6XCLijJNcIixcInByb3BcIjpcIuKInVwiLFwiUHJvcG9ydGlvbmFsXCI6XCLiiJ1cIixcIlByb3BvcnRpb25cIjpcIuKIt1wiLFwicHJvcHRvXCI6XCLiiJ1cIixcInByc2ltXCI6XCLiib5cIixcInBydXJlbFwiOlwi4oqwXCIsXCJQc2NyXCI6XCLwnZKrXCIsXCJwc2NyXCI6XCLwnZOFXCIsXCJQc2lcIjpcIs6oXCIsXCJwc2lcIjpcIs+IXCIsXCJwdW5jc3BcIjpcIuKAiFwiLFwiUWZyXCI6XCLwnZSUXCIsXCJxZnJcIjpcIvCdlK5cIixcInFpbnRcIjpcIuKojFwiLFwicW9wZlwiOlwi8J2VolwiLFwiUW9wZlwiOlwi4oSaXCIsXCJxcHJpbWVcIjpcIuKBl1wiLFwiUXNjclwiOlwi8J2SrFwiLFwicXNjclwiOlwi8J2ThlwiLFwicXVhdGVybmlvbnNcIjpcIuKEjVwiLFwicXVhdGludFwiOlwi4qiWXCIsXCJxdWVzdFwiOlwiP1wiLFwicXVlc3RlcVwiOlwi4omfXCIsXCJxdW90XCI6XCJcXFxcXCJcIixcIlFVT1RcIjpcIlxcXFxcIlwiLFwickFhcnJcIjpcIuKHm1wiLFwicmFjZVwiOlwi4oi9zLFcIixcIlJhY3V0ZVwiOlwixZRcIixcInJhY3V0ZVwiOlwixZVcIixcInJhZGljXCI6XCLiiJpcIixcInJhZW1wdHl2XCI6XCLiprNcIixcInJhbmdcIjpcIuKfqVwiLFwiUmFuZ1wiOlwi4p+rXCIsXCJyYW5nZFwiOlwi4qaSXCIsXCJyYW5nZVwiOlwi4qalXCIsXCJyYW5nbGVcIjpcIuKfqVwiLFwicmFxdW9cIjpcIsK7XCIsXCJyYXJyYXBcIjpcIuKltVwiLFwicmFycmJcIjpcIuKHpVwiLFwicmFycmJmc1wiOlwi4qSgXCIsXCJyYXJyY1wiOlwi4qSzXCIsXCJyYXJyXCI6XCLihpJcIixcIlJhcnJcIjpcIuKGoFwiLFwickFyclwiOlwi4oeSXCIsXCJyYXJyZnNcIjpcIuKknlwiLFwicmFycmhrXCI6XCLihqpcIixcInJhcnJscFwiOlwi4oasXCIsXCJyYXJycGxcIjpcIuKlhVwiLFwicmFycnNpbVwiOlwi4qW0XCIsXCJSYXJydGxcIjpcIuKkllwiLFwicmFycnRsXCI6XCLihqNcIixcInJhcnJ3XCI6XCLihp1cIixcInJhdGFpbFwiOlwi4qSaXCIsXCJyQXRhaWxcIjpcIuKknFwiLFwicmF0aW9cIjpcIuKItlwiLFwicmF0aW9uYWxzXCI6XCLihJpcIixcInJiYXJyXCI6XCLipI1cIixcInJCYXJyXCI6XCLipI9cIixcIlJCYXJyXCI6XCLipJBcIixcInJiYnJrXCI6XCLinbNcIixcInJicmFjZVwiOlwifVwiLFwicmJyYWNrXCI6XCJdXCIsXCJyYnJrZVwiOlwi4qaMXCIsXCJyYnJrc2xkXCI6XCLipo5cIixcInJicmtzbHVcIjpcIuKmkFwiLFwiUmNhcm9uXCI6XCLFmFwiLFwicmNhcm9uXCI6XCLFmVwiLFwiUmNlZGlsXCI6XCLFllwiLFwicmNlZGlsXCI6XCLFl1wiLFwicmNlaWxcIjpcIuKMiVwiLFwicmN1YlwiOlwifVwiLFwiUmN5XCI6XCLQoFwiLFwicmN5XCI6XCLRgFwiLFwicmRjYVwiOlwi4qS3XCIsXCJyZGxkaGFyXCI6XCLipalcIixcInJkcXVvXCI6XCLigJ1cIixcInJkcXVvclwiOlwi4oCdXCIsXCJyZHNoXCI6XCLihrNcIixcInJlYWxcIjpcIuKEnFwiLFwicmVhbGluZVwiOlwi4oSbXCIsXCJyZWFscGFydFwiOlwi4oScXCIsXCJyZWFsc1wiOlwi4oSdXCIsXCJSZVwiOlwi4oScXCIsXCJyZWN0XCI6XCLilq1cIixcInJlZ1wiOlwiwq5cIixcIlJFR1wiOlwiwq5cIixcIlJldmVyc2VFbGVtZW50XCI6XCLiiItcIixcIlJldmVyc2VFcXVpbGlicml1bVwiOlwi4oeLXCIsXCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOlwi4qWvXCIsXCJyZmlzaHRcIjpcIuKlvVwiLFwicmZsb29yXCI6XCLijItcIixcInJmclwiOlwi8J2Ur1wiLFwiUmZyXCI6XCLihJxcIixcInJIYXJcIjpcIuKlpFwiLFwicmhhcmRcIjpcIuKHgVwiLFwicmhhcnVcIjpcIuKHgFwiLFwicmhhcnVsXCI6XCLipaxcIixcIlJob1wiOlwizqFcIixcInJob1wiOlwiz4FcIixcInJob3ZcIjpcIs+xXCIsXCJSaWdodEFuZ2xlQnJhY2tldFwiOlwi4p+pXCIsXCJSaWdodEFycm93QmFyXCI6XCLih6VcIixcInJpZ2h0YXJyb3dcIjpcIuKGklwiLFwiUmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJSaWdodGFycm93XCI6XCLih5JcIixcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjpcIuKHhFwiLFwicmlnaHRhcnJvd3RhaWxcIjpcIuKGo1wiLFwiUmlnaHRDZWlsaW5nXCI6XCLijIlcIixcIlJpZ2h0RG91YmxlQnJhY2tldFwiOlwi4p+nXCIsXCJSaWdodERvd25UZWVWZWN0b3JcIjpcIuKlnVwiLFwiUmlnaHREb3duVmVjdG9yQmFyXCI6XCLipZVcIixcIlJpZ2h0RG93blZlY3RvclwiOlwi4oeCXCIsXCJSaWdodEZsb29yXCI6XCLijItcIixcInJpZ2h0aGFycG9vbmRvd25cIjpcIuKHgVwiLFwicmlnaHRoYXJwb29udXBcIjpcIuKHgFwiLFwicmlnaHRsZWZ0YXJyb3dzXCI6XCLih4RcIixcInJpZ2h0bGVmdGhhcnBvb25zXCI6XCLih4xcIixcInJpZ2h0cmlnaHRhcnJvd3NcIjpcIuKHiVwiLFwicmlnaHRzcXVpZ2Fycm93XCI6XCLihp1cIixcIlJpZ2h0VGVlQXJyb3dcIjpcIuKGplwiLFwiUmlnaHRUZWVcIjpcIuKKolwiLFwiUmlnaHRUZWVWZWN0b3JcIjpcIuKlm1wiLFwicmlnaHR0aHJlZXRpbWVzXCI6XCLii4xcIixcIlJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkFwiLFwiUmlnaHRUcmlhbmdsZVwiOlwi4oqzXCIsXCJSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKKtVwiLFwiUmlnaHRVcERvd25WZWN0b3JcIjpcIuKlj1wiLFwiUmlnaHRVcFRlZVZlY3RvclwiOlwi4qWcXCIsXCJSaWdodFVwVmVjdG9yQmFyXCI6XCLipZRcIixcIlJpZ2h0VXBWZWN0b3JcIjpcIuKGvlwiLFwiUmlnaHRWZWN0b3JCYXJcIjpcIuKlk1wiLFwiUmlnaHRWZWN0b3JcIjpcIuKHgFwiLFwicmluZ1wiOlwiy5pcIixcInJpc2luZ2RvdHNlcVwiOlwi4omTXCIsXCJybGFyclwiOlwi4oeEXCIsXCJybGhhclwiOlwi4oeMXCIsXCJybG1cIjpcIuKAj1wiLFwicm1vdXN0YWNoZVwiOlwi4o6xXCIsXCJybW91c3RcIjpcIuKOsVwiLFwicm5taWRcIjpcIuKrrlwiLFwicm9hbmdcIjpcIuKfrVwiLFwicm9hcnJcIjpcIuKHvlwiLFwicm9icmtcIjpcIuKfp1wiLFwicm9wYXJcIjpcIuKmhlwiLFwicm9wZlwiOlwi8J2Vo1wiLFwiUm9wZlwiOlwi4oSdXCIsXCJyb3BsdXNcIjpcIuKorlwiLFwicm90aW1lc1wiOlwi4qi1XCIsXCJSb3VuZEltcGxpZXNcIjpcIuKlsFwiLFwicnBhclwiOlwiKVwiLFwicnBhcmd0XCI6XCLippRcIixcInJwcG9saW50XCI6XCLiqJJcIixcInJyYXJyXCI6XCLih4lcIixcIlJyaWdodGFycm93XCI6XCLih5tcIixcInJzYXF1b1wiOlwi4oC6XCIsXCJyc2NyXCI6XCLwnZOHXCIsXCJSc2NyXCI6XCLihJtcIixcInJzaFwiOlwi4oaxXCIsXCJSc2hcIjpcIuKGsVwiLFwicnNxYlwiOlwiXVwiLFwicnNxdW9cIjpcIuKAmVwiLFwicnNxdW9yXCI6XCLigJlcIixcInJ0aHJlZVwiOlwi4ouMXCIsXCJydGltZXNcIjpcIuKLilwiLFwicnRyaVwiOlwi4pa5XCIsXCJydHJpZVwiOlwi4oq1XCIsXCJydHJpZlwiOlwi4pa4XCIsXCJydHJpbHRyaVwiOlwi4qeOXCIsXCJSdWxlRGVsYXllZFwiOlwi4qe0XCIsXCJydWx1aGFyXCI6XCLipahcIixcInJ4XCI6XCLihJ5cIixcIlNhY3V0ZVwiOlwixZpcIixcInNhY3V0ZVwiOlwixZtcIixcInNicXVvXCI6XCLigJpcIixcInNjYXBcIjpcIuKquFwiLFwiU2Nhcm9uXCI6XCLFoFwiLFwic2Nhcm9uXCI6XCLFoVwiLFwiU2NcIjpcIuKqvFwiLFwic2NcIjpcIuKJu1wiLFwic2NjdWVcIjpcIuKJvVwiLFwic2NlXCI6XCLiqrBcIixcInNjRVwiOlwi4qq0XCIsXCJTY2VkaWxcIjpcIsWeXCIsXCJzY2VkaWxcIjpcIsWfXCIsXCJTY2lyY1wiOlwixZxcIixcInNjaXJjXCI6XCLFnVwiLFwic2NuYXBcIjpcIuKqulwiLFwic2NuRVwiOlwi4qq2XCIsXCJzY25zaW1cIjpcIuKLqVwiLFwic2Nwb2xpbnRcIjpcIuKok1wiLFwic2NzaW1cIjpcIuKJv1wiLFwiU2N5XCI6XCLQoVwiLFwic2N5XCI6XCLRgVwiLFwic2RvdGJcIjpcIuKKoVwiLFwic2RvdFwiOlwi4ouFXCIsXCJzZG90ZVwiOlwi4qmmXCIsXCJzZWFyaGtcIjpcIuKkpVwiLFwic2VhcnJcIjpcIuKGmFwiLFwic2VBcnJcIjpcIuKHmFwiLFwic2VhcnJvd1wiOlwi4oaYXCIsXCJzZWN0XCI6XCLCp1wiLFwic2VtaVwiOlwiO1wiLFwic2Vzd2FyXCI6XCLipKlcIixcInNldG1pbnVzXCI6XCLiiJZcIixcInNldG1uXCI6XCLiiJZcIixcInNleHRcIjpcIuKctlwiLFwiU2ZyXCI6XCLwnZSWXCIsXCJzZnJcIjpcIvCdlLBcIixcInNmcm93blwiOlwi4oyiXCIsXCJzaGFycFwiOlwi4pmvXCIsXCJTSENIY3lcIjpcItCpXCIsXCJzaGNoY3lcIjpcItGJXCIsXCJTSGN5XCI6XCLQqFwiLFwic2hjeVwiOlwi0YhcIixcIlNob3J0RG93bkFycm93XCI6XCLihpNcIixcIlNob3J0TGVmdEFycm93XCI6XCLihpBcIixcInNob3J0bWlkXCI6XCLiiKNcIixcInNob3J0cGFyYWxsZWxcIjpcIuKIpVwiLFwiU2hvcnRSaWdodEFycm93XCI6XCLihpJcIixcIlNob3J0VXBBcnJvd1wiOlwi4oaRXCIsXCJzaHlcIjpcIsKtXCIsXCJTaWdtYVwiOlwizqNcIixcInNpZ21hXCI6XCLPg1wiLFwic2lnbWFmXCI6XCLPglwiLFwic2lnbWF2XCI6XCLPglwiLFwic2ltXCI6XCLiiLxcIixcInNpbWRvdFwiOlwi4qmqXCIsXCJzaW1lXCI6XCLiiYNcIixcInNpbWVxXCI6XCLiiYNcIixcInNpbWdcIjpcIuKqnlwiLFwic2ltZ0VcIjpcIuKqoFwiLFwic2ltbFwiOlwi4qqdXCIsXCJzaW1sRVwiOlwi4qqfXCIsXCJzaW1uZVwiOlwi4omGXCIsXCJzaW1wbHVzXCI6XCLiqKRcIixcInNpbXJhcnJcIjpcIuKlslwiLFwic2xhcnJcIjpcIuKGkFwiLFwiU21hbGxDaXJjbGVcIjpcIuKImFwiLFwic21hbGxzZXRtaW51c1wiOlwi4oiWXCIsXCJzbWFzaHBcIjpcIuKos1wiLFwic21lcGFyc2xcIjpcIuKnpFwiLFwic21pZFwiOlwi4oijXCIsXCJzbWlsZVwiOlwi4oyjXCIsXCJzbXRcIjpcIuKqqlwiLFwic210ZVwiOlwi4qqsXCIsXCJzbXRlc1wiOlwi4qqs77iAXCIsXCJTT0ZUY3lcIjpcItCsXCIsXCJzb2Z0Y3lcIjpcItGMXCIsXCJzb2xiYXJcIjpcIuKMv1wiLFwic29sYlwiOlwi4qeEXCIsXCJzb2xcIjpcIi9cIixcIlNvcGZcIjpcIvCdlYpcIixcInNvcGZcIjpcIvCdlaRcIixcInNwYWRlc1wiOlwi4pmgXCIsXCJzcGFkZXN1aXRcIjpcIuKZoFwiLFwic3BhclwiOlwi4oilXCIsXCJzcWNhcFwiOlwi4oqTXCIsXCJzcWNhcHNcIjpcIuKKk++4gFwiLFwic3FjdXBcIjpcIuKKlFwiLFwic3FjdXBzXCI6XCLiipTvuIBcIixcIlNxcnRcIjpcIuKImlwiLFwic3FzdWJcIjpcIuKKj1wiLFwic3FzdWJlXCI6XCLiipFcIixcInNxc3Vic2V0XCI6XCLiio9cIixcInNxc3Vic2V0ZXFcIjpcIuKKkVwiLFwic3FzdXBcIjpcIuKKkFwiLFwic3FzdXBlXCI6XCLiipJcIixcInNxc3Vwc2V0XCI6XCLiipBcIixcInNxc3Vwc2V0ZXFcIjpcIuKKklwiLFwic3F1YXJlXCI6XCLilqFcIixcIlNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVJbnRlcnNlY3Rpb25cIjpcIuKKk1wiLFwiU3F1YXJlU3Vic2V0XCI6XCLiio9cIixcIlNxdWFyZVN1YnNldEVxdWFsXCI6XCLiipFcIixcIlNxdWFyZVN1cGVyc2V0XCI6XCLiipBcIixcIlNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKKklwiLFwiU3F1YXJlVW5pb25cIjpcIuKKlFwiLFwic3F1YXJmXCI6XCLilqpcIixcInNxdVwiOlwi4pahXCIsXCJzcXVmXCI6XCLilqpcIixcInNyYXJyXCI6XCLihpJcIixcIlNzY3JcIjpcIvCdkq5cIixcInNzY3JcIjpcIvCdk4hcIixcInNzZXRtblwiOlwi4oiWXCIsXCJzc21pbGVcIjpcIuKMo1wiLFwic3N0YXJmXCI6XCLii4ZcIixcIlN0YXJcIjpcIuKLhlwiLFwic3RhclwiOlwi4piGXCIsXCJzdGFyZlwiOlwi4piFXCIsXCJzdHJhaWdodGVwc2lsb25cIjpcIs+1XCIsXCJzdHJhaWdodHBoaVwiOlwiz5VcIixcInN0cm5zXCI6XCLCr1wiLFwic3ViXCI6XCLiioJcIixcIlN1YlwiOlwi4ouQXCIsXCJzdWJkb3RcIjpcIuKqvVwiLFwic3ViRVwiOlwi4quFXCIsXCJzdWJlXCI6XCLiioZcIixcInN1YmVkb3RcIjpcIuKrg1wiLFwic3VibXVsdFwiOlwi4quBXCIsXCJzdWJuRVwiOlwi4quLXCIsXCJzdWJuZVwiOlwi4oqKXCIsXCJzdWJwbHVzXCI6XCLiqr9cIixcInN1YnJhcnJcIjpcIuKluVwiLFwic3Vic2V0XCI6XCLiioJcIixcIlN1YnNldFwiOlwi4ouQXCIsXCJzdWJzZXRlcVwiOlwi4oqGXCIsXCJzdWJzZXRlcXFcIjpcIuKrhVwiLFwiU3Vic2V0RXF1YWxcIjpcIuKKhlwiLFwic3Vic2V0bmVxXCI6XCLiiopcIixcInN1YnNldG5lcXFcIjpcIuKri1wiLFwic3Vic2ltXCI6XCLiq4dcIixcInN1YnN1YlwiOlwi4quVXCIsXCJzdWJzdXBcIjpcIuKrk1wiLFwic3VjY2FwcHJveFwiOlwi4qq4XCIsXCJzdWNjXCI6XCLiibtcIixcInN1Y2NjdXJseWVxXCI6XCLiib1cIixcIlN1Y2NlZWRzXCI6XCLiibtcIixcIlN1Y2NlZWRzRXF1YWxcIjpcIuKqsFwiLFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6XCLiib1cIixcIlN1Y2NlZWRzVGlsZGVcIjpcIuKJv1wiLFwic3VjY2VxXCI6XCLiqrBcIixcInN1Y2NuYXBwcm94XCI6XCLiqrpcIixcInN1Y2NuZXFxXCI6XCLiqrZcIixcInN1Y2Nuc2ltXCI6XCLii6lcIixcInN1Y2NzaW1cIjpcIuKJv1wiLFwiU3VjaFRoYXRcIjpcIuKIi1wiLFwic3VtXCI6XCLiiJFcIixcIlN1bVwiOlwi4oiRXCIsXCJzdW5nXCI6XCLimapcIixcInN1cDFcIjpcIsK5XCIsXCJzdXAyXCI6XCLCslwiLFwic3VwM1wiOlwiwrNcIixcInN1cFwiOlwi4oqDXCIsXCJTdXBcIjpcIuKLkVwiLFwic3VwZG90XCI6XCLiqr5cIixcInN1cGRzdWJcIjpcIuKrmFwiLFwic3VwRVwiOlwi4quGXCIsXCJzdXBlXCI6XCLiiodcIixcInN1cGVkb3RcIjpcIuKrhFwiLFwiU3VwZXJzZXRcIjpcIuKKg1wiLFwiU3VwZXJzZXRFcXVhbFwiOlwi4oqHXCIsXCJzdXBoc29sXCI6XCLin4lcIixcInN1cGhzdWJcIjpcIuKrl1wiLFwic3VwbGFyclwiOlwi4qW7XCIsXCJzdXBtdWx0XCI6XCLiq4JcIixcInN1cG5FXCI6XCLiq4xcIixcInN1cG5lXCI6XCLiiotcIixcInN1cHBsdXNcIjpcIuKrgFwiLFwic3Vwc2V0XCI6XCLiioNcIixcIlN1cHNldFwiOlwi4ouRXCIsXCJzdXBzZXRlcVwiOlwi4oqHXCIsXCJzdXBzZXRlcXFcIjpcIuKrhlwiLFwic3Vwc2V0bmVxXCI6XCLiiotcIixcInN1cHNldG5lcXFcIjpcIuKrjFwiLFwic3Vwc2ltXCI6XCLiq4hcIixcInN1cHN1YlwiOlwi4quUXCIsXCJzdXBzdXBcIjpcIuKrllwiLFwic3dhcmhrXCI6XCLipKZcIixcInN3YXJyXCI6XCLihplcIixcInN3QXJyXCI6XCLih5lcIixcInN3YXJyb3dcIjpcIuKGmVwiLFwic3dud2FyXCI6XCLipKpcIixcInN6bGlnXCI6XCLDn1wiLFwiVGFiXCI6XCJcXFxcdFwiLFwidGFyZ2V0XCI6XCLijJZcIixcIlRhdVwiOlwizqRcIixcInRhdVwiOlwiz4RcIixcInRicmtcIjpcIuKOtFwiLFwiVGNhcm9uXCI6XCLFpFwiLFwidGNhcm9uXCI6XCLFpVwiLFwiVGNlZGlsXCI6XCLFolwiLFwidGNlZGlsXCI6XCLFo1wiLFwiVGN5XCI6XCLQolwiLFwidGN5XCI6XCLRglwiLFwidGRvdFwiOlwi4oObXCIsXCJ0ZWxyZWNcIjpcIuKMlVwiLFwiVGZyXCI6XCLwnZSXXCIsXCJ0ZnJcIjpcIvCdlLFcIixcInRoZXJlNFwiOlwi4oi0XCIsXCJ0aGVyZWZvcmVcIjpcIuKItFwiLFwiVGhlcmVmb3JlXCI6XCLiiLRcIixcIlRoZXRhXCI6XCLOmFwiLFwidGhldGFcIjpcIs64XCIsXCJ0aGV0YXN5bVwiOlwiz5FcIixcInRoZXRhdlwiOlwiz5FcIixcInRoaWNrYXBwcm94XCI6XCLiiYhcIixcInRoaWNrc2ltXCI6XCLiiLxcIixcIlRoaWNrU3BhY2VcIjpcIuKBn+KAilwiLFwiVGhpblNwYWNlXCI6XCLigIlcIixcInRoaW5zcFwiOlwi4oCJXCIsXCJ0aGthcFwiOlwi4omIXCIsXCJ0aGtzaW1cIjpcIuKIvFwiLFwiVEhPUk5cIjpcIsOeXCIsXCJ0aG9yblwiOlwiw75cIixcInRpbGRlXCI6XCLLnFwiLFwiVGlsZGVcIjpcIuKIvFwiLFwiVGlsZGVFcXVhbFwiOlwi4omDXCIsXCJUaWxkZUZ1bGxFcXVhbFwiOlwi4omFXCIsXCJUaWxkZVRpbGRlXCI6XCLiiYhcIixcInRpbWVzYmFyXCI6XCLiqLFcIixcInRpbWVzYlwiOlwi4oqgXCIsXCJ0aW1lc1wiOlwiw5dcIixcInRpbWVzZFwiOlwi4qiwXCIsXCJ0aW50XCI6XCLiiK1cIixcInRvZWFcIjpcIuKkqFwiLFwidG9wYm90XCI6XCLijLZcIixcInRvcGNpclwiOlwi4quxXCIsXCJ0b3BcIjpcIuKKpFwiLFwiVG9wZlwiOlwi8J2Vi1wiLFwidG9wZlwiOlwi8J2VpVwiLFwidG9wZm9ya1wiOlwi4quaXCIsXCJ0b3NhXCI6XCLipKlcIixcInRwcmltZVwiOlwi4oC0XCIsXCJ0cmFkZVwiOlwi4oSiXCIsXCJUUkFERVwiOlwi4oSiXCIsXCJ0cmlhbmdsZVwiOlwi4pa1XCIsXCJ0cmlhbmdsZWRvd25cIjpcIuKWv1wiLFwidHJpYW5nbGVsZWZ0XCI6XCLil4NcIixcInRyaWFuZ2xlbGVmdGVxXCI6XCLiirRcIixcInRyaWFuZ2xlcVwiOlwi4omcXCIsXCJ0cmlhbmdsZXJpZ2h0XCI6XCLilrlcIixcInRyaWFuZ2xlcmlnaHRlcVwiOlwi4oq1XCIsXCJ0cmlkb3RcIjpcIuKXrFwiLFwidHJpZVwiOlwi4omcXCIsXCJ0cmltaW51c1wiOlwi4qi6XCIsXCJUcmlwbGVEb3RcIjpcIuKDm1wiLFwidHJpcGx1c1wiOlwi4qi5XCIsXCJ0cmlzYlwiOlwi4qeNXCIsXCJ0cml0aW1lXCI6XCLiqLtcIixcInRycGV6aXVtXCI6XCLij6JcIixcIlRzY3JcIjpcIvCdkq9cIixcInRzY3JcIjpcIvCdk4lcIixcIlRTY3lcIjpcItCmXCIsXCJ0c2N5XCI6XCLRhlwiLFwiVFNIY3lcIjpcItCLXCIsXCJ0c2hjeVwiOlwi0ZtcIixcIlRzdHJva1wiOlwixaZcIixcInRzdHJva1wiOlwixadcIixcInR3aXh0XCI6XCLiiaxcIixcInR3b2hlYWRsZWZ0YXJyb3dcIjpcIuKGnlwiLFwidHdvaGVhZHJpZ2h0YXJyb3dcIjpcIuKGoFwiLFwiVWFjdXRlXCI6XCLDmlwiLFwidWFjdXRlXCI6XCLDulwiLFwidWFyclwiOlwi4oaRXCIsXCJVYXJyXCI6XCLihp9cIixcInVBcnJcIjpcIuKHkVwiLFwiVWFycm9jaXJcIjpcIuKliVwiLFwiVWJyY3lcIjpcItCOXCIsXCJ1YnJjeVwiOlwi0Z5cIixcIlVicmV2ZVwiOlwixaxcIixcInVicmV2ZVwiOlwixa1cIixcIlVjaXJjXCI6XCLDm1wiLFwidWNpcmNcIjpcIsO7XCIsXCJVY3lcIjpcItCjXCIsXCJ1Y3lcIjpcItGDXCIsXCJ1ZGFyclwiOlwi4oeFXCIsXCJVZGJsYWNcIjpcIsWwXCIsXCJ1ZGJsYWNcIjpcIsWxXCIsXCJ1ZGhhclwiOlwi4qWuXCIsXCJ1ZmlzaHRcIjpcIuKlvlwiLFwiVWZyXCI6XCLwnZSYXCIsXCJ1ZnJcIjpcIvCdlLJcIixcIlVncmF2ZVwiOlwiw5lcIixcInVncmF2ZVwiOlwiw7lcIixcInVIYXJcIjpcIuKlo1wiLFwidWhhcmxcIjpcIuKGv1wiLFwidWhhcnJcIjpcIuKGvlwiLFwidWhibGtcIjpcIuKWgFwiLFwidWxjb3JuXCI6XCLijJxcIixcInVsY29ybmVyXCI6XCLijJxcIixcInVsY3JvcFwiOlwi4oyPXCIsXCJ1bHRyaVwiOlwi4pe4XCIsXCJVbWFjclwiOlwixapcIixcInVtYWNyXCI6XCLFq1wiLFwidW1sXCI6XCLCqFwiLFwiVW5kZXJCYXJcIjpcIl9cIixcIlVuZGVyQnJhY2VcIjpcIuKPn1wiLFwiVW5kZXJCcmFja2V0XCI6XCLijrVcIixcIlVuZGVyUGFyZW50aGVzaXNcIjpcIuKPnVwiLFwiVW5pb25cIjpcIuKLg1wiLFwiVW5pb25QbHVzXCI6XCLiio5cIixcIlVvZ29uXCI6XCLFslwiLFwidW9nb25cIjpcIsWzXCIsXCJVb3BmXCI6XCLwnZWMXCIsXCJ1b3BmXCI6XCLwnZWmXCIsXCJVcEFycm93QmFyXCI6XCLipJJcIixcInVwYXJyb3dcIjpcIuKGkVwiLFwiVXBBcnJvd1wiOlwi4oaRXCIsXCJVcGFycm93XCI6XCLih5FcIixcIlVwQXJyb3dEb3duQXJyb3dcIjpcIuKHhVwiLFwidXBkb3duYXJyb3dcIjpcIuKGlVwiLFwiVXBEb3duQXJyb3dcIjpcIuKGlVwiLFwiVXBkb3duYXJyb3dcIjpcIuKHlVwiLFwiVXBFcXVpbGlicml1bVwiOlwi4qWuXCIsXCJ1cGhhcnBvb25sZWZ0XCI6XCLihr9cIixcInVwaGFycG9vbnJpZ2h0XCI6XCLihr5cIixcInVwbHVzXCI6XCLiio5cIixcIlVwcGVyTGVmdEFycm93XCI6XCLihpZcIixcIlVwcGVyUmlnaHRBcnJvd1wiOlwi4oaXXCIsXCJ1cHNpXCI6XCLPhVwiLFwiVXBzaVwiOlwiz5JcIixcInVwc2loXCI6XCLPklwiLFwiVXBzaWxvblwiOlwizqVcIixcInVwc2lsb25cIjpcIs+FXCIsXCJVcFRlZUFycm93XCI6XCLihqVcIixcIlVwVGVlXCI6XCLiiqVcIixcInVwdXBhcnJvd3NcIjpcIuKHiFwiLFwidXJjb3JuXCI6XCLijJ1cIixcInVyY29ybmVyXCI6XCLijJ1cIixcInVyY3JvcFwiOlwi4oyOXCIsXCJVcmluZ1wiOlwixa5cIixcInVyaW5nXCI6XCLFr1wiLFwidXJ0cmlcIjpcIuKXuVwiLFwiVXNjclwiOlwi8J2SsFwiLFwidXNjclwiOlwi8J2TilwiLFwidXRkb3RcIjpcIuKLsFwiLFwiVXRpbGRlXCI6XCLFqFwiLFwidXRpbGRlXCI6XCLFqVwiLFwidXRyaVwiOlwi4pa1XCIsXCJ1dHJpZlwiOlwi4pa0XCIsXCJ1dWFyclwiOlwi4oeIXCIsXCJVdW1sXCI6XCLDnFwiLFwidXVtbFwiOlwiw7xcIixcInV3YW5nbGVcIjpcIuKmp1wiLFwidmFuZ3J0XCI6XCLippxcIixcInZhcmVwc2lsb25cIjpcIs+1XCIsXCJ2YXJrYXBwYVwiOlwiz7BcIixcInZhcm5vdGhpbmdcIjpcIuKIhVwiLFwidmFycGhpXCI6XCLPlVwiLFwidmFycGlcIjpcIs+WXCIsXCJ2YXJwcm9wdG9cIjpcIuKInVwiLFwidmFyclwiOlwi4oaVXCIsXCJ2QXJyXCI6XCLih5VcIixcInZhcnJob1wiOlwiz7FcIixcInZhcnNpZ21hXCI6XCLPglwiLFwidmFyc3Vic2V0bmVxXCI6XCLiiorvuIBcIixcInZhcnN1YnNldG5lcXFcIjpcIuKri++4gFwiLFwidmFyc3Vwc2V0bmVxXCI6XCLiiovvuIBcIixcInZhcnN1cHNldG5lcXFcIjpcIuKrjO+4gFwiLFwidmFydGhldGFcIjpcIs+RXCIsXCJ2YXJ0cmlhbmdsZWxlZnRcIjpcIuKKslwiLFwidmFydHJpYW5nbGVyaWdodFwiOlwi4oqzXCIsXCJ2QmFyXCI6XCLiq6hcIixcIlZiYXJcIjpcIuKrq1wiLFwidkJhcnZcIjpcIuKrqVwiLFwiVmN5XCI6XCLQklwiLFwidmN5XCI6XCLQslwiLFwidmRhc2hcIjpcIuKKolwiLFwidkRhc2hcIjpcIuKKqFwiLFwiVmRhc2hcIjpcIuKKqVwiLFwiVkRhc2hcIjpcIuKKq1wiLFwiVmRhc2hsXCI6XCLiq6ZcIixcInZlZWJhclwiOlwi4oq7XCIsXCJ2ZWVcIjpcIuKIqFwiLFwiVmVlXCI6XCLii4FcIixcInZlZWVxXCI6XCLiiZpcIixcInZlbGxpcFwiOlwi4ouuXCIsXCJ2ZXJiYXJcIjpcInxcIixcIlZlcmJhclwiOlwi4oCWXCIsXCJ2ZXJ0XCI6XCJ8XCIsXCJWZXJ0XCI6XCLigJZcIixcIlZlcnRpY2FsQmFyXCI6XCLiiKNcIixcIlZlcnRpY2FsTGluZVwiOlwifFwiLFwiVmVydGljYWxTZXBhcmF0b3JcIjpcIuKdmFwiLFwiVmVydGljYWxUaWxkZVwiOlwi4omAXCIsXCJWZXJ5VGhpblNwYWNlXCI6XCLigIpcIixcIlZmclwiOlwi8J2UmVwiLFwidmZyXCI6XCLwnZSzXCIsXCJ2bHRyaVwiOlwi4oqyXCIsXCJ2bnN1YlwiOlwi4oqC4oOSXCIsXCJ2bnN1cFwiOlwi4oqD4oOSXCIsXCJWb3BmXCI6XCLwnZWNXCIsXCJ2b3BmXCI6XCLwnZWnXCIsXCJ2cHJvcFwiOlwi4oidXCIsXCJ2cnRyaVwiOlwi4oqzXCIsXCJWc2NyXCI6XCLwnZKxXCIsXCJ2c2NyXCI6XCLwnZOLXCIsXCJ2c3VibkVcIjpcIuKri++4gFwiLFwidnN1Ym5lXCI6XCLiiorvuIBcIixcInZzdXBuRVwiOlwi4quM77iAXCIsXCJ2c3VwbmVcIjpcIuKKi++4gFwiLFwiVnZkYXNoXCI6XCLiiqpcIixcInZ6aWd6YWdcIjpcIuKmmlwiLFwiV2NpcmNcIjpcIsW0XCIsXCJ3Y2lyY1wiOlwixbVcIixcIndlZGJhclwiOlwi4qmfXCIsXCJ3ZWRnZVwiOlwi4oinXCIsXCJXZWRnZVwiOlwi4ouAXCIsXCJ3ZWRnZXFcIjpcIuKJmVwiLFwid2VpZXJwXCI6XCLihJhcIixcIldmclwiOlwi8J2UmlwiLFwid2ZyXCI6XCLwnZS0XCIsXCJXb3BmXCI6XCLwnZWOXCIsXCJ3b3BmXCI6XCLwnZWoXCIsXCJ3cFwiOlwi4oSYXCIsXCJ3clwiOlwi4omAXCIsXCJ3cmVhdGhcIjpcIuKJgFwiLFwiV3NjclwiOlwi8J2SslwiLFwid3NjclwiOlwi8J2TjFwiLFwieGNhcFwiOlwi4ouCXCIsXCJ4Y2lyY1wiOlwi4pevXCIsXCJ4Y3VwXCI6XCLii4NcIixcInhkdHJpXCI6XCLilr1cIixcIlhmclwiOlwi8J2Um1wiLFwieGZyXCI6XCLwnZS1XCIsXCJ4aGFyclwiOlwi4p+3XCIsXCJ4aEFyclwiOlwi4p+6XCIsXCJYaVwiOlwizp5cIixcInhpXCI6XCLOvlwiLFwieGxhcnJcIjpcIuKftVwiLFwieGxBcnJcIjpcIuKfuFwiLFwieG1hcFwiOlwi4p+8XCIsXCJ4bmlzXCI6XCLii7tcIixcInhvZG90XCI6XCLiqIBcIixcIlhvcGZcIjpcIvCdlY9cIixcInhvcGZcIjpcIvCdlalcIixcInhvcGx1c1wiOlwi4qiBXCIsXCJ4b3RpbWVcIjpcIuKoglwiLFwieHJhcnJcIjpcIuKftlwiLFwieHJBcnJcIjpcIuKfuVwiLFwiWHNjclwiOlwi8J2Ss1wiLFwieHNjclwiOlwi8J2TjVwiLFwieHNxY3VwXCI6XCLiqIZcIixcInh1cGx1c1wiOlwi4qiEXCIsXCJ4dXRyaVwiOlwi4pazXCIsXCJ4dmVlXCI6XCLii4FcIixcInh3ZWRnZVwiOlwi4ouAXCIsXCJZYWN1dGVcIjpcIsOdXCIsXCJ5YWN1dGVcIjpcIsO9XCIsXCJZQWN5XCI6XCLQr1wiLFwieWFjeVwiOlwi0Y9cIixcIlljaXJjXCI6XCLFtlwiLFwieWNpcmNcIjpcIsW3XCIsXCJZY3lcIjpcItCrXCIsXCJ5Y3lcIjpcItGLXCIsXCJ5ZW5cIjpcIsKlXCIsXCJZZnJcIjpcIvCdlJxcIixcInlmclwiOlwi8J2UtlwiLFwiWUljeVwiOlwi0IdcIixcInlpY3lcIjpcItGXXCIsXCJZb3BmXCI6XCLwnZWQXCIsXCJ5b3BmXCI6XCLwnZWqXCIsXCJZc2NyXCI6XCLwnZK0XCIsXCJ5c2NyXCI6XCLwnZOOXCIsXCJZVWN5XCI6XCLQrlwiLFwieXVjeVwiOlwi0Y5cIixcInl1bWxcIjpcIsO/XCIsXCJZdW1sXCI6XCLFuFwiLFwiWmFjdXRlXCI6XCLFuVwiLFwiemFjdXRlXCI6XCLFulwiLFwiWmNhcm9uXCI6XCLFvVwiLFwiemNhcm9uXCI6XCLFvlwiLFwiWmN5XCI6XCLQl1wiLFwiemN5XCI6XCLQt1wiLFwiWmRvdFwiOlwixbtcIixcInpkb3RcIjpcIsW8XCIsXCJ6ZWV0cmZcIjpcIuKEqFwiLFwiWmVyb1dpZHRoU3BhY2VcIjpcIuKAi1wiLFwiWmV0YVwiOlwizpZcIixcInpldGFcIjpcIs62XCIsXCJ6ZnJcIjpcIvCdlLdcIixcIlpmclwiOlwi4oSoXCIsXCJaSGN5XCI6XCLQllwiLFwiemhjeVwiOlwi0LZcIixcInppZ3JhcnJcIjpcIuKHnVwiLFwiem9wZlwiOlwi8J2Vq1wiLFwiWm9wZlwiOlwi4oSkXCIsXCJac2NyXCI6XCLwnZK1XCIsXCJ6c2NyXCI6XCLwnZOPXCIsXCJ6d2pcIjpcIuKAjVwiLFwiendualwiOlwi4oCMXCJ9Jyl9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj17fTtmdW5jdGlvbiBpKGUsdCxyKXt2YXIgcyxvLGEsYyxsLHU9XCJcIjtmb3IoXCJzdHJpbmdcIiE9dHlwZW9mIHQmJihyPXQsdD1pLmRlZmF1bHRDaGFycyksdm9pZCAwPT09ciYmKHI9ITApLGw9ZnVuY3Rpb24oZSl7dmFyIHQscixpPW5bZV07aWYoaSlyZXR1cm4gaTtmb3IoaT1uW2VdPVtdLHQ9MDt0PDEyODt0Kyspcj1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpLC9eWzAtOWEtel0kL2kudGVzdChyKT9pLnB1c2gocik6aS5wdXNoKFwiJVwiKyhcIjBcIit0LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMikpO2Zvcih0PTA7dDxlLmxlbmd0aDt0KyspaVtlLmNoYXJDb2RlQXQodCldPWVbdF07cmV0dXJuIGl9KHQpLHM9MCxvPWUubGVuZ3RoO3M8bztzKyspaWYoYT1lLmNoYXJDb2RlQXQocyksciYmMzc9PT1hJiZzKzI8byYmL15bMC05YS1mXXsyfSQvaS50ZXN0KGUuc2xpY2UocysxLHMrMykpKXUrPWUuc2xpY2UocyxzKzMpLHMrPTI7ZWxzZSBpZihhPDEyOCl1Kz1sW2FdO2Vsc2UgaWYoYT49NTUyOTYmJmE8PTU3MzQzKXtpZihhPj01NTI5NiYmYTw9NTYzMTkmJnMrMTxvJiYoYz1lLmNoYXJDb2RlQXQocysxKSk+PTU2MzIwJiZjPD01NzM0Myl7dSs9ZW5jb2RlVVJJQ29tcG9uZW50KGVbc10rZVtzKzFdKSxzKys7Y29udGludWV9dSs9XCIlRUYlQkYlQkRcIn1lbHNlIHUrPWVuY29kZVVSSUNvbXBvbmVudChlW3NdKTtyZXR1cm4gdX1pLmRlZmF1bHRDaGFycz1cIjsvPzpAJj0rJCwtXy4hfionKCkjXCIsaS5jb21wb25lbnRDaGFycz1cIi1fLiF+KicoKVwiLGUuZXhwb3J0cz1pfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49e307ZnVuY3Rpb24gaShlLHQpe3ZhciByO3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiB0JiYodD1pLmRlZmF1bHRDaGFycykscj1mdW5jdGlvbihlKXt2YXIgdCxyLGk9bltlXTtpZihpKXJldHVybiBpO2ZvcihpPW5bZV09W10sdD0wO3Q8MTI4O3QrKylyPVN0cmluZy5mcm9tQ2hhckNvZGUodCksaS5wdXNoKHIpO2Zvcih0PTA7dDxlLmxlbmd0aDt0KyspaVtyPWUuY2hhckNvZGVBdCh0KV09XCIlXCIrKFwiMFwiK3IudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtyZXR1cm4gaX0odCksZS5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksKGZ1bmN0aW9uKGUpe3ZhciB0LG4saSxzLG8sYSxjLGw9XCJcIjtmb3IodD0wLG49ZS5sZW5ndGg7dDxuO3QrPTMpKGk9cGFyc2VJbnQoZS5zbGljZSh0KzEsdCszKSwxNikpPDEyOD9sKz1yW2ldOjE5Mj09KDIyNCZpKSYmdCszPG4mJjEyOD09KDE5MiYocz1wYXJzZUludChlLnNsaWNlKHQrNCx0KzYpLDE2KSkpPyhsKz0oYz1pPDw2JjE5ODR8NjMmcyk8MTI4P1wi77+977+9XCI6U3RyaW5nLmZyb21DaGFyQ29kZShjKSx0Kz0zKToyMjQ9PSgyNDAmaSkmJnQrNjxuJiYocz1wYXJzZUludChlLnNsaWNlKHQrNCx0KzYpLDE2KSxvPXBhcnNlSW50KGUuc2xpY2UodCs3LHQrOSksMTYpLDEyOD09KDE5MiZzKSYmMTI4PT0oMTkyJm8pKT8obCs9KGM9aTw8MTImNjE0NDB8czw8NiY0MDMyfDYzJm8pPDIwNDh8fGM+PTU1Mjk2JiZjPD01NzM0Mz9cIu+/ve+/ve+/vVwiOlN0cmluZy5mcm9tQ2hhckNvZGUoYyksdCs9Nik6MjQwPT0oMjQ4JmkpJiZ0Kzk8biYmKHM9cGFyc2VJbnQoZS5zbGljZSh0KzQsdCs2KSwxNiksbz1wYXJzZUludChlLnNsaWNlKHQrNyx0KzkpLDE2KSxhPXBhcnNlSW50KGUuc2xpY2UodCsxMCx0KzEyKSwxNiksMTI4PT0oMTkyJnMpJiYxMjg9PSgxOTImbykmJjEyOD09KDE5MiZhKSk/KChjPWk8PDE4JjE4MzUwMDh8czw8MTImMjU4MDQ4fG88PDYmNDAzMnw2MyZhKTw2NTUzNnx8Yz4xMTE0MTExP2wrPVwi77+977+977+977+9XCI6KGMtPTY1NTM2LGwrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGM+PjEwKSw1NjMyMCsoMTAyMyZjKSkpLHQrPTkpOmwrPVwi77+9XCI7cmV0dXJuIGx9KSl9aS5kZWZhdWx0Q2hhcnM9XCI7Lz86QCY9KyQsI1wiLGkuY29tcG9uZW50Q2hhcnM9XCJcIixlLmV4cG9ydHM9aX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD1cIlwiO3JldHVybiB0Kz1lLnByb3RvY29sfHxcIlwiLHQrPWUuc2xhc2hlcz9cIi8vXCI6XCJcIix0Kz1lLmF1dGg/ZS5hdXRoK1wiQFwiOlwiXCIsZS5ob3N0bmFtZSYmLTEhPT1lLmhvc3RuYW1lLmluZGV4T2YoXCI6XCIpP3QrPVwiW1wiK2UuaG9zdG5hbWUrXCJdXCI6dCs9ZS5ob3N0bmFtZXx8XCJcIix0Kz1lLnBvcnQ/XCI6XCIrZS5wb3J0OlwiXCIsdCs9ZS5wYXRobmFtZXx8XCJcIix0Kz1lLnNlYXJjaHx8XCJcIix0Kz1lLmhhc2h8fFwiXCJ9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbigpe3RoaXMucHJvdG9jb2w9bnVsbCx0aGlzLnNsYXNoZXM9bnVsbCx0aGlzLmF1dGg9bnVsbCx0aGlzLnBvcnQ9bnVsbCx0aGlzLmhvc3RuYW1lPW51bGwsdGhpcy5oYXNoPW51bGwsdGhpcy5zZWFyY2g9bnVsbCx0aGlzLnBhdGhuYW1lPW51bGx9dmFyIGk9L14oW2EtejAtOS4rLV0rOikvaSxzPS86WzAtOV0qJC8sbz0vXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLGE9W1wie1wiLFwifVwiLFwifFwiLFwiXFxcXFwiLFwiXlwiLFwiYFwiXS5jb25jYXQoW1wiPFwiLFwiPlwiLCdcIicsXCJgXCIsXCIgXCIsXCJcXHJcIixcIlxcblwiLFwiXFx0XCJdKSxjPVtcIidcIl0uY29uY2F0KGEpLGw9W1wiJVwiLFwiL1wiLFwiP1wiLFwiO1wiLFwiI1wiXS5jb25jYXQoYyksdT1bXCIvXCIsXCI/XCIsXCIjXCJdLHA9L15bK2EtejAtOUEtWl8tXXswLDYzfSQvLGg9L14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLGY9e2phdmFzY3JpcHQ6ITAsXCJqYXZhc2NyaXB0OlwiOiEwfSxkPXtodHRwOiEwLGh0dHBzOiEwLGZ0cDohMCxnb3BoZXI6ITAsZmlsZTohMCxcImh0dHA6XCI6ITAsXCJodHRwczpcIjohMCxcImZ0cDpcIjohMCxcImdvcGhlcjpcIjohMCxcImZpbGU6XCI6ITB9O24ucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixzLGEsYyxnPWU7aWYoZz1nLnRyaW0oKSwhdCYmMT09PWUuc3BsaXQoXCIjXCIpLmxlbmd0aCl7dmFyIG09by5leGVjKGcpO2lmKG0pcmV0dXJuIHRoaXMucGF0aG5hbWU9bVsxXSxtWzJdJiYodGhpcy5zZWFyY2g9bVsyXSksdGhpc312YXIgXz1pLmV4ZWMoZyk7aWYoXyYmKHM9KF89X1swXSkudG9Mb3dlckNhc2UoKSx0aGlzLnByb3RvY29sPV8sZz1nLnN1YnN0cihfLmxlbmd0aCkpLCh0fHxffHxnLm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkmJighKGM9XCIvL1wiPT09Zy5zdWJzdHIoMCwyKSl8fF8mJmZbX118fChnPWcuc3Vic3RyKDIpLHRoaXMuc2xhc2hlcz0hMCkpLCFmW19dJiYoY3x8XyYmIWRbX10pKXt2YXIgYixrLHY9LTE7Zm9yKHI9MDtyPHUubGVuZ3RoO3IrKyktMSE9PShhPWcuaW5kZXhPZih1W3JdKSkmJigtMT09PXZ8fGE8dikmJih2PWEpO2ZvcigtMSE9PShrPS0xPT09dj9nLmxhc3RJbmRleE9mKFwiQFwiKTpnLmxhc3RJbmRleE9mKFwiQFwiLHYpKSYmKGI9Zy5zbGljZSgwLGspLGc9Zy5zbGljZShrKzEpLHRoaXMuYXV0aD1iKSx2PS0xLHI9MDtyPGwubGVuZ3RoO3IrKyktMSE9PShhPWcuaW5kZXhPZihsW3JdKSkmJigtMT09PXZ8fGE8dikmJih2PWEpOy0xPT09diYmKHY9Zy5sZW5ndGgpLFwiOlwiPT09Z1t2LTFdJiZ2LS07dmFyIHk9Zy5zbGljZSgwLHYpO2c9Zy5zbGljZSh2KSx0aGlzLnBhcnNlSG9zdCh5KSx0aGlzLmhvc3RuYW1lPXRoaXMuaG9zdG5hbWV8fFwiXCI7dmFyIHg9XCJbXCI9PT10aGlzLmhvc3RuYW1lWzBdJiZcIl1cIj09PXRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGgtMV07aWYoIXgpe3ZhciBDPXRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO2ZvcihyPTAsbj1DLmxlbmd0aDtyPG47cisrKXt2YXIgQT1DW3JdO2lmKEEmJiFBLm1hdGNoKHApKXtmb3IodmFyIEQ9XCJcIix3PTAsRT1BLmxlbmd0aDt3PEU7dysrKUEuY2hhckNvZGVBdCh3KT4xMjc/RCs9XCJ4XCI6RCs9QVt3XTtpZighRC5tYXRjaChwKSl7dmFyIHE9Qy5zbGljZSgwLHIpLFM9Qy5zbGljZShyKzEpLEY9QS5tYXRjaChoKTtGJiYocS5wdXNoKEZbMV0pLFMudW5zaGlmdChGWzJdKSksUy5sZW5ndGgmJihnPVMuam9pbihcIi5cIikrZyksdGhpcy5ob3N0bmFtZT1xLmpvaW4oXCIuXCIpO2JyZWFrfX19fXRoaXMuaG9zdG5hbWUubGVuZ3RoPjI1NSYmKHRoaXMuaG9zdG5hbWU9XCJcIikseCYmKHRoaXMuaG9zdG5hbWU9dGhpcy5ob3N0bmFtZS5zdWJzdHIoMSx0aGlzLmhvc3RuYW1lLmxlbmd0aC0yKSl9dmFyIFQ9Zy5pbmRleE9mKFwiI1wiKTstMSE9PVQmJih0aGlzLmhhc2g9Zy5zdWJzdHIoVCksZz1nLnNsaWNlKDAsVCkpO3ZhciBMPWcuaW5kZXhPZihcIj9cIik7cmV0dXJuLTEhPT1MJiYodGhpcy5zZWFyY2g9Zy5zdWJzdHIoTCksZz1nLnNsaWNlKDAsTCkpLGcmJih0aGlzLnBhdGhuYW1lPWcpLGRbc10mJnRoaXMuaG9zdG5hbWUmJiF0aGlzLnBhdGhuYW1lJiYodGhpcy5wYXRobmFtZT1cIlwiKSx0aGlzfSxuLnByb3RvdHlwZS5wYXJzZUhvc3Q9ZnVuY3Rpb24oZSl7dmFyIHQ9cy5leGVjKGUpO3QmJihcIjpcIiE9PSh0PXRbMF0pJiYodGhpcy5wb3J0PXQuc3Vic3RyKDEpKSxlPWUuc3Vic3RyKDAsZS5sZW5ndGgtdC5sZW5ndGgpKSxlJiYodGhpcy5ob3N0bmFtZT1lKX0sZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7aWYoZSYmZSBpbnN0YW5jZW9mIG4pcmV0dXJuIGU7dmFyIHI9bmV3IG47cmV0dXJuIHIucGFyc2UoZSx0KSxyfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuQW55PXIoOSksdC5DYz1yKDEwKSx0LkNmPXIoMjcpLHQuUD1yKDMpLHQuWj1yKDExKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9L1tcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTA4RTJcXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDY0XFx1MjA2Ni1cXHUyMDZGXFx1RkVGRlxcdUZGRjktXFx1RkZGQl18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRF18XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdL30sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QucGFyc2VMaW5rTGFiZWw9cigyOSksdC5wYXJzZUxpbmtEZXN0aW5hdGlvbj1yKDMwKSx0LnBhcnNlTGlua1RpdGxlPXIoMzEpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbixpLHMsbyxhPS0xLGM9ZS5wb3NNYXgsbD1lLnBvcztmb3IoZS5wb3M9dCsxLG49MTtlLnBvczxjOyl7aWYoOTM9PT0ocz1lLnNyYy5jaGFyQ29kZUF0KGUucG9zKSkmJjA9PT0tLW4pe2k9ITA7YnJlYWt9aWYobz1lLnBvcyxlLm1kLmlubGluZS5za2lwVG9rZW4oZSksOTE9PT1zKWlmKG89PT1lLnBvcy0xKW4rKztlbHNlIGlmKHIpcmV0dXJuIGUucG9zPWwsLTF9cmV0dXJuIGkmJihhPWUucG9zKSxlLnBvcz1sLGF9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigwKS51bmVzY2FwZUFsbDtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIpe3ZhciBpLHMsbz10LGE9e29rOiExLHBvczowLGxpbmVzOjAsc3RyOlwiXCJ9O2lmKDYwPT09ZS5jaGFyQ29kZUF0KHQpKXtmb3IodCsrO3Q8cjspe2lmKDEwPT09KGk9ZS5jaGFyQ29kZUF0KHQpKSlyZXR1cm4gYTtpZig2MD09PWkpcmV0dXJuIGE7aWYoNjI9PT1pKXJldHVybiBhLnBvcz10KzEsYS5zdHI9bihlLnNsaWNlKG8rMSx0KSksYS5vaz0hMCxhOzkyPT09aSYmdCsxPHI/dCs9Mjp0Kyt9cmV0dXJuIGF9Zm9yKHM9MDt0PHImJjMyIT09KGk9ZS5jaGFyQ29kZUF0KHQpKSYmIShpPDMyfHwxMjc9PT1pKTspaWYoOTI9PT1pJiZ0KzE8cil7aWYoMzI9PT1lLmNoYXJDb2RlQXQodCsxKSlicmVhazt0Kz0yfWVsc2V7aWYoNDA9PT1pJiYrK3M+MzIpcmV0dXJuIGE7aWYoNDE9PT1pKXtpZigwPT09cylicmVhaztzLS19dCsrfXJldHVybiBvPT09dHx8MCE9PXN8fChhLnN0cj1uKGUuc2xpY2Uobyx0KSksYS5saW5lcz0wLGEucG9zPXQsYS5vaz0hMCksYX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDApLnVuZXNjYXBlQWxsO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7dmFyIGkscyxvPTAsYT10LGM9e29rOiExLHBvczowLGxpbmVzOjAsc3RyOlwiXCJ9O2lmKHQ+PXIpcmV0dXJuIGM7aWYoMzQhPT0ocz1lLmNoYXJDb2RlQXQodCkpJiYzOSE9PXMmJjQwIT09cylyZXR1cm4gYztmb3IodCsrLDQwPT09cyYmKHM9NDEpO3Q8cjspe2lmKChpPWUuY2hhckNvZGVBdCh0KSk9PT1zKXJldHVybiBjLnBvcz10KzEsYy5saW5lcz1vLGMuc3RyPW4oZS5zbGljZShhKzEsdCkpLGMub2s9ITAsYztpZig0MD09PWkmJjQxPT09cylyZXR1cm4gYzsxMD09PWk/bysrOjkyPT09aSYmdCsxPHImJih0KyssMTA9PT1lLmNoYXJDb2RlQXQodCkmJm8rKyksdCsrfXJldHVybiBjfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMCkuYXNzaWduLGk9cigwKS51bmVzY2FwZUFsbCxzPXIoMCkuZXNjYXBlSHRtbCxvPXt9O2Z1bmN0aW9uIGEoKXt0aGlzLnJ1bGVzPW4oe30sbyl9by5jb2RlX2lubGluZT1mdW5jdGlvbihlLHQscixuLGkpe3ZhciBvPWVbdF07cmV0dXJuXCI8Y29kZVwiK2kucmVuZGVyQXR0cnMobykrXCI+XCIrcyhlW3RdLmNvbnRlbnQpK1wiPC9jb2RlPlwifSxvLmNvZGVfYmxvY2s9ZnVuY3Rpb24oZSx0LHIsbixpKXt2YXIgbz1lW3RdO3JldHVyblwiPHByZVwiK2kucmVuZGVyQXR0cnMobykrXCI+PGNvZGU+XCIrcyhlW3RdLmNvbnRlbnQpK1wiPC9jb2RlPjwvcHJlPlxcblwifSxvLmZlbmNlPWZ1bmN0aW9uKGUsdCxyLG4sbyl7dmFyIGEsYyxsLHUscCxoPWVbdF0sZj1oLmluZm8/aShoLmluZm8pLnRyaW0oKTpcIlwiLGQ9XCJcIixnPVwiXCI7cmV0dXJuIGYmJihkPShsPWYuc3BsaXQoLyhcXHMrKS9nKSlbMF0sZz1sLnNsaWNlKDIpLmpvaW4oXCJcIikpLDA9PT0oYT1yLmhpZ2hsaWdodCYmci5oaWdobGlnaHQoaC5jb250ZW50LGQsZyl8fHMoaC5jb250ZW50KSkuaW5kZXhPZihcIjxwcmVcIik/YStcIlxcblwiOmY/KGM9aC5hdHRySW5kZXgoXCJjbGFzc1wiKSx1PWguYXR0cnM/aC5hdHRycy5zbGljZSgpOltdLGM8MD91LnB1c2goW1wiY2xhc3NcIixyLmxhbmdQcmVmaXgrZF0pOih1W2NdPXVbY10uc2xpY2UoKSx1W2NdWzFdKz1cIiBcIityLmxhbmdQcmVmaXgrZCkscD17YXR0cnM6dX0sXCI8cHJlPjxjb2RlXCIrby5yZW5kZXJBdHRycyhwKStcIj5cIithK1wiPC9jb2RlPjwvcHJlPlxcblwiKTpcIjxwcmU+PGNvZGVcIitvLnJlbmRlckF0dHJzKGgpK1wiPlwiK2ErXCI8L2NvZGU+PC9wcmU+XFxuXCJ9LG8uaW1hZ2U9ZnVuY3Rpb24oZSx0LHIsbixpKXt2YXIgcz1lW3RdO3JldHVybiBzLmF0dHJzW3MuYXR0ckluZGV4KFwiYWx0XCIpXVsxXT1pLnJlbmRlcklubGluZUFzVGV4dChzLmNoaWxkcmVuLHIsbiksaS5yZW5kZXJUb2tlbihlLHQscil9LG8uaGFyZGJyZWFrPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gci54aHRtbE91dD9cIjxiciAvPlxcblwiOlwiPGJyPlxcblwifSxvLnNvZnRicmVhaz1mdW5jdGlvbihlLHQscil7cmV0dXJuIHIuYnJlYWtzP3IueGh0bWxPdXQ/XCI8YnIgLz5cXG5cIjpcIjxicj5cXG5cIjpcIlxcblwifSxvLnRleHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gcyhlW3RdLmNvbnRlbnQpfSxvLmh0bWxfYmxvY2s9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZVt0XS5jb250ZW50fSxvLmh0bWxfaW5saW5lPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdF0uY29udGVudH0sYS5wcm90b3R5cGUucmVuZGVyQXR0cnM9ZnVuY3Rpb24oZSl7dmFyIHQscixuO2lmKCFlLmF0dHJzKXJldHVyblwiXCI7Zm9yKG49XCJcIix0PTAscj1lLmF0dHJzLmxlbmd0aDt0PHI7dCsrKW4rPVwiIFwiK3MoZS5hdHRyc1t0XVswXSkrJz1cIicrcyhlLmF0dHJzW3RdWzFdKSsnXCInO3JldHVybiBufSxhLnByb3RvdHlwZS5yZW5kZXJUb2tlbj1mdW5jdGlvbihlLHQscil7dmFyIG4saT1cIlwiLHM9ITEsbz1lW3RdO3JldHVybiBvLmhpZGRlbj9cIlwiOihvLmJsb2NrJiYtMSE9PW8ubmVzdGluZyYmdCYmZVt0LTFdLmhpZGRlbiYmKGkrPVwiXFxuXCIpLGkrPSgtMT09PW8ubmVzdGluZz9cIjwvXCI6XCI8XCIpK28udGFnLGkrPXRoaXMucmVuZGVyQXR0cnMobyksMD09PW8ubmVzdGluZyYmci54aHRtbE91dCYmKGkrPVwiIC9cIiksby5ibG9jayYmKHM9ITAsMT09PW8ubmVzdGluZyYmdCsxPGUubGVuZ3RoJiYoXCJpbmxpbmVcIj09PShuPWVbdCsxXSkudHlwZXx8bi5oaWRkZW58fC0xPT09bi5uZXN0aW5nJiZuLnRhZz09PW8udGFnKSYmKHM9ITEpKSxpKz1zP1wiPlxcblwiOlwiPlwiKX0sYS5wcm90b3R5cGUucmVuZGVySW5saW5lPWZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIG4saT1cIlwiLHM9dGhpcy5ydWxlcyxvPTAsYT1lLmxlbmd0aDtvPGE7bysrKXZvaWQgMCE9PXNbbj1lW29dLnR5cGVdP2krPXNbbl0oZSxvLHQscix0aGlzKTppKz10aGlzLnJlbmRlclRva2VuKGUsbyx0KTtyZXR1cm4gaX0sYS5wcm90b3R5cGUucmVuZGVySW5saW5lQXNUZXh0PWZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIG49XCJcIixpPTAscz1lLmxlbmd0aDtpPHM7aSsrKVwidGV4dFwiPT09ZVtpXS50eXBlP24rPWVbaV0uY29udGVudDpcImltYWdlXCI9PT1lW2ldLnR5cGU/bis9dGhpcy5yZW5kZXJJbmxpbmVBc1RleHQoZVtpXS5jaGlsZHJlbix0LHIpOlwic29mdGJyZWFrXCI9PT1lW2ldLnR5cGUmJihuKz1cIlxcblwiKTtyZXR1cm4gbn0sYS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbixpLHMsbz1cIlwiLGE9dGhpcy5ydWxlcztmb3Iobj0wLGk9ZS5sZW5ndGg7bjxpO24rKylcImlubGluZVwiPT09KHM9ZVtuXS50eXBlKT9vKz10aGlzLnJlbmRlcklubGluZShlW25dLmNoaWxkcmVuLHQscik6dm9pZCAwIT09YVtzXT9vKz1hW2Vbbl0udHlwZV0oZSxuLHQscix0aGlzKTpvKz10aGlzLnJlbmRlclRva2VuKGUsbix0LHIpO3JldHVybiBvfSxlLmV4cG9ydHM9YX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNCksaT1bW1wibm9ybWFsaXplXCIscigzNCldLFtcImJsb2NrXCIscigzNSldLFtcImlubGluZVwiLHIoMzYpXSxbXCJsaW5raWZ5XCIscigzNyldLFtcInJlcGxhY2VtZW50c1wiLHIoMzgpXSxbXCJzbWFydHF1b3Rlc1wiLHIoMzkpXV07ZnVuY3Rpb24gcygpe3RoaXMucnVsZXI9bmV3IG47Zm9yKHZhciBlPTA7ZTxpLmxlbmd0aDtlKyspdGhpcy5ydWxlci5wdXNoKGlbZV1bMF0saVtlXVsxXSl9cy5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbihlKXt2YXIgdCxyLG47Zm9yKHQ9MCxyPShuPXRoaXMucnVsZXIuZ2V0UnVsZXMoXCJcIikpLmxlbmd0aDt0PHI7dCsrKW5bdF0oZSl9LHMucHJvdG90eXBlLlN0YXRlPXIoNDApLGUuZXhwb3J0cz1zfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49L1xcclxcbj98XFxuL2csaT0vXFwwL2c7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0O3Q9KHQ9ZS5zcmMucmVwbGFjZShuLFwiXFxuXCIpKS5yZXBsYWNlKGksXCLvv71cIiksZS5zcmM9dH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQ7ZS5pbmxpbmVNb2RlPygodD1uZXcgZS5Ub2tlbihcImlubGluZVwiLFwiXCIsMCkpLmNvbnRlbnQ9ZS5zcmMsdC5tYXA9WzAsMV0sdC5jaGlsZHJlbj1bXSxlLnRva2Vucy5wdXNoKHQpKTplLm1kLmJsb2NrLnBhcnNlKGUuc3JjLGUubWQsZS5lbnYsZS50b2tlbnMpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdCxyLG4saT1lLnRva2Vucztmb3Iocj0wLG49aS5sZW5ndGg7cjxuO3IrKylcImlubGluZVwiPT09KHQ9aVtyXSkudHlwZSYmZS5tZC5pbmxpbmUucGFyc2UodC5jb250ZW50LGUubWQsZS5lbnYsdC5jaGlsZHJlbil9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigwKS5hcnJheVJlcGxhY2VBdDtmdW5jdGlvbiBpKGUpe3JldHVybi9ePFxcL2FcXHMqPi9pLnRlc3QoZSl9ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0LHIscyxvLGEsYyxsLHUscCxoLGYsZCxnLG0sXyxiLGssdix5PWUudG9rZW5zO2lmKGUubWQub3B0aW9ucy5saW5raWZ5KWZvcihyPTAscz15Lmxlbmd0aDtyPHM7cisrKWlmKFwiaW5saW5lXCI9PT15W3JdLnR5cGUmJmUubWQubGlua2lmeS5wcmV0ZXN0KHlbcl0uY29udGVudCkpZm9yKGc9MCx0PShvPXlbcl0uY2hpbGRyZW4pLmxlbmd0aC0xO3Q+PTA7dC0tKWlmKFwibGlua19jbG9zZVwiIT09KGM9b1t0XSkudHlwZSl7aWYoXCJodG1sX2lubGluZVwiPT09Yy50eXBlJiYodj1jLmNvbnRlbnQsL148YVs+XFxzXS9pLnRlc3QodikmJmc+MCYmZy0tLGkoYy5jb250ZW50KSYmZysrKSwhKGc+MCkmJlwidGV4dFwiPT09Yy50eXBlJiZlLm1kLmxpbmtpZnkudGVzdChjLmNvbnRlbnQpKXtmb3IocD1jLmNvbnRlbnQsaz1lLm1kLmxpbmtpZnkubWF0Y2gocCksbD1bXSxkPWMubGV2ZWwsZj0wLHU9MDt1PGsubGVuZ3RoO3UrKyltPWtbdV0udXJsLF89ZS5tZC5ub3JtYWxpemVMaW5rKG0pLGUubWQudmFsaWRhdGVMaW5rKF8pJiYoYj1rW3VdLnRleHQsYj1rW3VdLnNjaGVtYT9cIm1haWx0bzpcIiE9PWtbdV0uc2NoZW1hfHwvXm1haWx0bzovaS50ZXN0KGIpP2UubWQubm9ybWFsaXplTGlua1RleHQoYik6ZS5tZC5ub3JtYWxpemVMaW5rVGV4dChcIm1haWx0bzpcIitiKS5yZXBsYWNlKC9ebWFpbHRvOi8sXCJcIik6ZS5tZC5ub3JtYWxpemVMaW5rVGV4dChcImh0dHA6Ly9cIitiKS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLFwiXCIpLChoPWtbdV0uaW5kZXgpPmYmJigoYT1uZXcgZS5Ub2tlbihcInRleHRcIixcIlwiLDApKS5jb250ZW50PXAuc2xpY2UoZixoKSxhLmxldmVsPWQsbC5wdXNoKGEpKSwoYT1uZXcgZS5Ub2tlbihcImxpbmtfb3BlblwiLFwiYVwiLDEpKS5hdHRycz1bW1wiaHJlZlwiLF9dXSxhLmxldmVsPWQrKyxhLm1hcmt1cD1cImxpbmtpZnlcIixhLmluZm89XCJhdXRvXCIsbC5wdXNoKGEpLChhPW5ldyBlLlRva2VuKFwidGV4dFwiLFwiXCIsMCkpLmNvbnRlbnQ9YixhLmxldmVsPWQsbC5wdXNoKGEpLChhPW5ldyBlLlRva2VuKFwibGlua19jbG9zZVwiLFwiYVwiLC0xKSkubGV2ZWw9LS1kLGEubWFya3VwPVwibGlua2lmeVwiLGEuaW5mbz1cImF1dG9cIixsLnB1c2goYSksZj1rW3VdLmxhc3RJbmRleCk7ZjxwLmxlbmd0aCYmKChhPW5ldyBlLlRva2VuKFwidGV4dFwiLFwiXCIsMCkpLmNvbnRlbnQ9cC5zbGljZShmKSxhLmxldmVsPWQsbC5wdXNoKGEpKSx5W3JdLmNoaWxkcmVuPW89bihvLHQsbCl9fWVsc2UgZm9yKHQtLTtvW3RdLmxldmVsIT09Yy5sZXZlbCYmXCJsaW5rX29wZW5cIiE9PW9bdF0udHlwZTspdC0tfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPS9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS8saT0vXFwoKGN8dG18cnxwKVxcKS9pLHM9L1xcKChjfHRtfHJ8cClcXCkvZ2ksbz17YzpcIsKpXCIscjpcIsKuXCIscDpcIsKnXCIsdG06XCLihKJcIn07ZnVuY3Rpb24gYShlLHQpe3JldHVybiBvW3QudG9Mb3dlckNhc2UoKV19ZnVuY3Rpb24gYyhlKXt2YXIgdCxyLG49MDtmb3IodD1lLmxlbmd0aC0xO3Q+PTA7dC0tKVwidGV4dFwiIT09KHI9ZVt0XSkudHlwZXx8bnx8KHIuY29udGVudD1yLmNvbnRlbnQucmVwbGFjZShzLGEpKSxcImxpbmtfb3BlblwiPT09ci50eXBlJiZcImF1dG9cIj09PXIuaW5mbyYmbi0tLFwibGlua19jbG9zZVwiPT09ci50eXBlJiZcImF1dG9cIj09PXIuaW5mbyYmbisrfWZ1bmN0aW9uIGwoZSl7dmFyIHQscixpPTA7Zm9yKHQ9ZS5sZW5ndGgtMTt0Pj0wO3QtLSlcInRleHRcIiE9PShyPWVbdF0pLnR5cGV8fGl8fG4udGVzdChyLmNvbnRlbnQpJiYoci5jb250ZW50PXIuY29udGVudC5yZXBsYWNlKC9cXCstL2csXCLCsVwiKS5yZXBsYWNlKC9cXC57Mix9L2csXCLigKZcIikucmVwbGFjZSgvKFs/IV0p4oCmL2csXCIkMS4uXCIpLnJlcGxhY2UoLyhbPyFdKXs0LH0vZyxcIiQxJDEkMVwiKS5yZXBsYWNlKC8sezIsfS9nLFwiLFwiKS5yZXBsYWNlKC8oXnxbXi1dKS0tLSg/PVteLV18JCkvZ20sXCIkMeKAlFwiKS5yZXBsYWNlKC8oXnxcXHMpLS0oPz1cXHN8JCkvZ20sXCIkMeKAk1wiKS5yZXBsYWNlKC8oXnxbXi1cXHNdKS0tKD89W14tXFxzXXwkKS9nbSxcIiQx4oCTXCIpKSxcImxpbmtfb3BlblwiPT09ci50eXBlJiZcImF1dG9cIj09PXIuaW5mbyYmaS0tLFwibGlua19jbG9zZVwiPT09ci50eXBlJiZcImF1dG9cIj09PXIuaW5mbyYmaSsrfWUuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdDtpZihlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpZm9yKHQ9ZS50b2tlbnMubGVuZ3RoLTE7dD49MDt0LS0pXCJpbmxpbmVcIj09PWUudG9rZW5zW3RdLnR5cGUmJihpLnRlc3QoZS50b2tlbnNbdF0uY29udGVudCkmJmMoZS50b2tlbnNbdF0uY2hpbGRyZW4pLG4udGVzdChlLnRva2Vuc1t0XS5jb250ZW50KSYmbChlLnRva2Vuc1t0XS5jaGlsZHJlbikpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMCkuaXNXaGl0ZVNwYWNlLGk9cigwKS5pc1B1bmN0Q2hhcixzPXIoMCkuaXNNZEFzY2lpUHVuY3Qsbz0vWydcIl0vLGE9L1snXCJdL2c7ZnVuY3Rpb24gYyhlLHQscil7cmV0dXJuIGUuc3Vic3RyKDAsdCkrcitlLnN1YnN0cih0KzEpfWZ1bmN0aW9uIGwoZSx0KXt2YXIgcixvLGwsdSxwLGgsZixkLGcsbSxfLGIsayx2LHkseCxDLEEsRCx3LEU7Zm9yKEQ9W10scj0wO3I8ZS5sZW5ndGg7cisrKXtmb3Iobz1lW3JdLGY9ZVtyXS5sZXZlbCxDPUQubGVuZ3RoLTE7Qz49MCYmIShEW0NdLmxldmVsPD1mKTtDLS0pO2lmKEQubGVuZ3RoPUMrMSxcInRleHRcIj09PW8udHlwZSl7cD0wLGg9KGw9by5jb250ZW50KS5sZW5ndGg7ZTpmb3IoO3A8aCYmKGEubGFzdEluZGV4PXAsdT1hLmV4ZWMobCkpOyl7aWYoeT14PSEwLHA9dS5pbmRleCsxLEE9XCInXCI9PT11WzBdLGc9MzIsdS5pbmRleC0xPj0wKWc9bC5jaGFyQ29kZUF0KHUuaW5kZXgtMSk7ZWxzZSBmb3IoQz1yLTE7Qz49MCYmKFwic29mdGJyZWFrXCIhPT1lW0NdLnR5cGUmJlwiaGFyZGJyZWFrXCIhPT1lW0NdLnR5cGUpO0MtLSlpZihlW0NdLmNvbnRlbnQpe2c9ZVtDXS5jb250ZW50LmNoYXJDb2RlQXQoZVtDXS5jb250ZW50Lmxlbmd0aC0xKTticmVha31pZihtPTMyLHA8aCltPWwuY2hhckNvZGVBdChwKTtlbHNlIGZvcihDPXIrMTtDPGUubGVuZ3RoJiYoXCJzb2Z0YnJlYWtcIiE9PWVbQ10udHlwZSYmXCJoYXJkYnJlYWtcIiE9PWVbQ10udHlwZSk7QysrKWlmKGVbQ10uY29udGVudCl7bT1lW0NdLmNvbnRlbnQuY2hhckNvZGVBdCgwKTticmVha31pZihfPXMoZyl8fGkoU3RyaW5nLmZyb21DaGFyQ29kZShnKSksYj1zKG0pfHxpKFN0cmluZy5mcm9tQ2hhckNvZGUobSkpLGs9bihnKSwodj1uKG0pKT95PSExOmImJihrfHxffHwoeT0hMSkpLGs/eD0hMTpfJiYodnx8Ynx8KHg9ITEpKSwzND09PW0mJidcIic9PT11WzBdJiZnPj00OCYmZzw9NTcmJih4PXk9ITEpLHkmJngmJih5PV8seD1iKSx5fHx4KXtpZih4KWZvcihDPUQubGVuZ3RoLTE7Qz49MCYmKGQ9RFtDXSwhKERbQ10ubGV2ZWw8ZikpO0MtLSlpZihkLnNpbmdsZT09PUEmJkRbQ10ubGV2ZWw9PT1mKXtkPURbQ10sQT8odz10Lm1kLm9wdGlvbnMucXVvdGVzWzJdLEU9dC5tZC5vcHRpb25zLnF1b3Rlc1szXSk6KHc9dC5tZC5vcHRpb25zLnF1b3Rlc1swXSxFPXQubWQub3B0aW9ucy5xdW90ZXNbMV0pLG8uY29udGVudD1jKG8uY29udGVudCx1LmluZGV4LEUpLGVbZC50b2tlbl0uY29udGVudD1jKGVbZC50b2tlbl0uY29udGVudCxkLnBvcyx3KSxwKz1FLmxlbmd0aC0xLGQudG9rZW49PT1yJiYocCs9dy5sZW5ndGgtMSksaD0obD1vLmNvbnRlbnQpLmxlbmd0aCxELmxlbmd0aD1DO2NvbnRpbnVlIGV9eT9ELnB1c2goe3Rva2VuOnIscG9zOnUuaW5kZXgsc2luZ2xlOkEsbGV2ZWw6Zn0pOngmJkEmJihvLmNvbnRlbnQ9YyhvLmNvbnRlbnQsdS5pbmRleCxcIuKAmVwiKSl9ZWxzZSBBJiYoby5jb250ZW50PWMoby5jb250ZW50LHUuaW5kZXgsXCLigJlcIikpfX19fWUuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdDtpZihlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpZm9yKHQ9ZS50b2tlbnMubGVuZ3RoLTE7dD49MDt0LS0pXCJpbmxpbmVcIj09PWUudG9rZW5zW3RdLnR5cGUmJm8udGVzdChlLnRva2Vuc1t0XS5jb250ZW50KSYmbChlLnRva2Vuc1t0XS5jaGlsZHJlbixlKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDUpO2Z1bmN0aW9uIGkoZSx0LHIpe3RoaXMuc3JjPWUsdGhpcy5lbnY9cix0aGlzLnRva2Vucz1bXSx0aGlzLmlubGluZU1vZGU9ITEsdGhpcy5tZD10fWkucHJvdG90eXBlLlRva2VuPW4sZS5leHBvcnRzPWl9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDQpLGk9W1tcInRhYmxlXCIscig0MiksW1wicGFyYWdyYXBoXCIsXCJyZWZlcmVuY2VcIl1dLFtcImNvZGVcIixyKDQzKV0sW1wiZmVuY2VcIixyKDQ0KSxbXCJwYXJhZ3JhcGhcIixcInJlZmVyZW5jZVwiLFwiYmxvY2txdW90ZVwiLFwibGlzdFwiXV0sW1wiYmxvY2txdW90ZVwiLHIoNDUpLFtcInBhcmFncmFwaFwiLFwicmVmZXJlbmNlXCIsXCJibG9ja3F1b3RlXCIsXCJsaXN0XCJdXSxbXCJoclwiLHIoNDYpLFtcInBhcmFncmFwaFwiLFwicmVmZXJlbmNlXCIsXCJibG9ja3F1b3RlXCIsXCJsaXN0XCJdXSxbXCJsaXN0XCIscig0NyksW1wicGFyYWdyYXBoXCIsXCJyZWZlcmVuY2VcIixcImJsb2NrcXVvdGVcIl1dLFtcInJlZmVyZW5jZVwiLHIoNDgpXSxbXCJodG1sX2Jsb2NrXCIscig0OSksW1wicGFyYWdyYXBoXCIsXCJyZWZlcmVuY2VcIixcImJsb2NrcXVvdGVcIl1dLFtcImhlYWRpbmdcIixyKDUxKSxbXCJwYXJhZ3JhcGhcIixcInJlZmVyZW5jZVwiLFwiYmxvY2txdW90ZVwiXV0sW1wibGhlYWRpbmdcIixyKDUyKV0sW1wicGFyYWdyYXBoXCIscig1MyldXTtmdW5jdGlvbiBzKCl7dGhpcy5ydWxlcj1uZXcgbjtmb3IodmFyIGU9MDtlPGkubGVuZ3RoO2UrKyl0aGlzLnJ1bGVyLnB1c2goaVtlXVswXSxpW2VdWzFdLHthbHQ6KGlbZV1bMl18fFtdKS5zbGljZSgpfSl9cy5wcm90b3R5cGUudG9rZW5pemU9ZnVuY3Rpb24oZSx0LHIpe2Zvcih2YXIgbixpPXRoaXMucnVsZXIuZ2V0UnVsZXMoXCJcIikscz1pLmxlbmd0aCxvPXQsYT0hMSxjPWUubWQub3B0aW9ucy5tYXhOZXN0aW5nO288ciYmKGUubGluZT1vPWUuc2tpcEVtcHR5TGluZXMobyksIShvPj1yKSkmJiEoZS5zQ291bnRbb108ZS5ibGtJbmRlbnQpOyl7aWYoZS5sZXZlbD49Yyl7ZS5saW5lPXI7YnJlYWt9Zm9yKG49MDtuPHMmJiFpW25dKGUsbyxyLCExKTtuKyspO2UudGlnaHQ9IWEsZS5pc0VtcHR5KGUubGluZS0xKSYmKGE9ITApLChvPWUubGluZSk8ciYmZS5pc0VtcHR5KG8pJiYoYT0hMCxvKyssZS5saW5lPW8pfX0scy5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk7ZSYmKGk9bmV3IHRoaXMuU3RhdGUoZSx0LHIsbiksdGhpcy50b2tlbml6ZShpLGkubGluZSxpLmxpbmVNYXgpKX0scy5wcm90b3R5cGUuU3RhdGU9cig1NCksZS5leHBvcnRzPXN9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDApLmlzU3BhY2U7ZnVuY3Rpb24gaShlLHQpe3ZhciByPWUuYk1hcmtzW3RdK2UudFNoaWZ0W3RdLG49ZS5lTWFya3NbdF07cmV0dXJuIGUuc3JjLnN1YnN0cihyLG4tcil9ZnVuY3Rpb24gcyhlKXt2YXIgdCxyPVtdLG49MCxpPWUubGVuZ3RoLHM9ITEsbz0wLGE9XCJcIjtmb3IodD1lLmNoYXJDb2RlQXQobik7bjxpOykxMjQ9PT10JiYocz8oYSs9ZS5zdWJzdHJpbmcobyxuLTEpLG89bik6KHIucHVzaChhK2Uuc3Vic3RyaW5nKG8sbikpLGE9XCJcIixvPW4rMSkpLHM9OTI9PT10LG4rKyx0PWUuY2hhckNvZGVBdChuKTtyZXR1cm4gci5wdXNoKGErZS5zdWJzdHJpbmcobykpLHJ9ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyLG8pe3ZhciBhLGMsbCx1LHAsaCxmLGQsZyxtLF8sYixrLHYseSx4LEMsQTtpZih0KzI+cilyZXR1cm4hMTtpZihoPXQrMSxlLnNDb3VudFtoXTxlLmJsa0luZGVudClyZXR1cm4hMTtpZihlLnNDb3VudFtoXS1lLmJsa0luZGVudD49NClyZXR1cm4hMTtpZigobD1lLmJNYXJrc1toXStlLnRTaGlmdFtoXSk+PWUuZU1hcmtzW2hdKXJldHVybiExO2lmKDEyNCE9PShDPWUuc3JjLmNoYXJDb2RlQXQobCsrKSkmJjQ1IT09QyYmNTghPT1DKXJldHVybiExO2lmKGw+PWUuZU1hcmtzW2hdKXJldHVybiExO2lmKDEyNCE9PShBPWUuc3JjLmNoYXJDb2RlQXQobCsrKSkmJjQ1IT09QSYmNTghPT1BJiYhbihBKSlyZXR1cm4hMTtpZig0NT09PUMmJm4oQSkpcmV0dXJuITE7Zm9yKDtsPGUuZU1hcmtzW2hdOyl7aWYoMTI0IT09KGE9ZS5zcmMuY2hhckNvZGVBdChsKSkmJjQ1IT09YSYmNTghPT1hJiYhbihhKSlyZXR1cm4hMTtsKyt9Zm9yKGY9KGM9aShlLHQrMSkpLnNwbGl0KFwifFwiKSxtPVtdLHU9MDt1PGYubGVuZ3RoO3UrKyl7aWYoIShfPWZbdV0udHJpbSgpKSl7aWYoMD09PXV8fHU9PT1mLmxlbmd0aC0xKWNvbnRpbnVlO3JldHVybiExfWlmKCEvXjo/LSs6PyQvLnRlc3QoXykpcmV0dXJuITE7NTg9PT1fLmNoYXJDb2RlQXQoXy5sZW5ndGgtMSk/bS5wdXNoKDU4PT09Xy5jaGFyQ29kZUF0KDApP1wiY2VudGVyXCI6XCJyaWdodFwiKTo1OD09PV8uY2hhckNvZGVBdCgwKT9tLnB1c2goXCJsZWZ0XCIpOm0ucHVzaChcIlwiKX1pZigtMT09PShjPWkoZSx0KS50cmltKCkpLmluZGV4T2YoXCJ8XCIpKXJldHVybiExO2lmKGUuc0NvdW50W3RdLWUuYmxrSW5kZW50Pj00KXJldHVybiExO2lmKChmPXMoYykpLmxlbmd0aCYmXCJcIj09PWZbMF0mJmYuc2hpZnQoKSxmLmxlbmd0aCYmXCJcIj09PWZbZi5sZW5ndGgtMV0mJmYucG9wKCksMD09PShkPWYubGVuZ3RoKXx8ZCE9PW0ubGVuZ3RoKXJldHVybiExO2lmKG8pcmV0dXJuITA7Zm9yKHY9ZS5wYXJlbnRUeXBlLGUucGFyZW50VHlwZT1cInRhYmxlXCIseD1lLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKFwiYmxvY2txdW90ZVwiKSwoZz1lLnB1c2goXCJ0YWJsZV9vcGVuXCIsXCJ0YWJsZVwiLDEpKS5tYXA9Yj1bdCwwXSwoZz1lLnB1c2goXCJ0aGVhZF9vcGVuXCIsXCJ0aGVhZFwiLDEpKS5tYXA9W3QsdCsxXSwoZz1lLnB1c2goXCJ0cl9vcGVuXCIsXCJ0clwiLDEpKS5tYXA9W3QsdCsxXSx1PTA7dTxmLmxlbmd0aDt1KyspZz1lLnB1c2goXCJ0aF9vcGVuXCIsXCJ0aFwiLDEpLG1bdV0mJihnLmF0dHJzPVtbXCJzdHlsZVwiLFwidGV4dC1hbGlnbjpcIittW3VdXV0pLChnPWUucHVzaChcImlubGluZVwiLFwiXCIsMCkpLmNvbnRlbnQ9Zlt1XS50cmltKCksZy5jaGlsZHJlbj1bXSxnPWUucHVzaChcInRoX2Nsb3NlXCIsXCJ0aFwiLC0xKTtmb3IoZz1lLnB1c2goXCJ0cl9jbG9zZVwiLFwidHJcIiwtMSksZz1lLnB1c2goXCJ0aGVhZF9jbG9zZVwiLFwidGhlYWRcIiwtMSksaD10KzI7aDxyJiYhKGUuc0NvdW50W2hdPGUuYmxrSW5kZW50KTtoKyspe2Zvcih5PSExLHU9MCxwPXgubGVuZ3RoO3U8cDt1KyspaWYoeFt1XShlLGgsciwhMCkpe3k9ITA7YnJlYWt9aWYoeSlicmVhaztpZighKGM9aShlLGgpLnRyaW0oKSkpYnJlYWs7aWYoZS5zQ291bnRbaF0tZS5ibGtJbmRlbnQ+PTQpYnJlYWs7Zm9yKChmPXMoYykpLmxlbmd0aCYmXCJcIj09PWZbMF0mJmYuc2hpZnQoKSxmLmxlbmd0aCYmXCJcIj09PWZbZi5sZW5ndGgtMV0mJmYucG9wKCksaD09PXQrMiYmKChnPWUucHVzaChcInRib2R5X29wZW5cIixcInRib2R5XCIsMSkpLm1hcD1rPVt0KzIsMF0pLChnPWUucHVzaChcInRyX29wZW5cIixcInRyXCIsMSkpLm1hcD1baCxoKzFdLHU9MDt1PGQ7dSsrKWc9ZS5wdXNoKFwidGRfb3BlblwiLFwidGRcIiwxKSxtW3VdJiYoZy5hdHRycz1bW1wic3R5bGVcIixcInRleHQtYWxpZ246XCIrbVt1XV1dKSwoZz1lLnB1c2goXCJpbmxpbmVcIixcIlwiLDApKS5jb250ZW50PWZbdV0/Zlt1XS50cmltKCk6XCJcIixnLmNoaWxkcmVuPVtdLGc9ZS5wdXNoKFwidGRfY2xvc2VcIixcInRkXCIsLTEpO2c9ZS5wdXNoKFwidHJfY2xvc2VcIixcInRyXCIsLTEpfXJldHVybiBrJiYoZz1lLnB1c2goXCJ0Ym9keV9jbG9zZVwiLFwidGJvZHlcIiwtMSksa1sxXT1oKSxnPWUucHVzaChcInRhYmxlX2Nsb3NlXCIsXCJ0YWJsZVwiLC0xKSxiWzFdPWgsZS5wYXJlbnRUeXBlPXYsZS5saW5lPWgsITB9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbixpLHM7aWYoZS5zQ291bnRbdF0tZS5ibGtJbmRlbnQ8NClyZXR1cm4hMTtmb3IoaT1uPXQrMTtuPHI7KWlmKGUuaXNFbXB0eShuKSluKys7ZWxzZXtpZighKGUuc0NvdW50W25dLWUuYmxrSW5kZW50Pj00KSlicmVhaztpPSsrbn1yZXR1cm4gZS5saW5lPWksKHM9ZS5wdXNoKFwiY29kZV9ibG9ja1wiLFwiY29kZVwiLDApKS5jb250ZW50PWUuZ2V0TGluZXModCxpLDQrZS5ibGtJbmRlbnQsITEpK1wiXFxuXCIscy5tYXA9W3QsZS5saW5lXSwhMH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGkscyxvLGEsYyxsLHUscD0hMSxoPWUuYk1hcmtzW3RdK2UudFNoaWZ0W3RdLGY9ZS5lTWFya3NbdF07aWYoZS5zQ291bnRbdF0tZS5ibGtJbmRlbnQ+PTQpcmV0dXJuITE7aWYoaCszPmYpcmV0dXJuITE7aWYoMTI2IT09KGk9ZS5zcmMuY2hhckNvZGVBdChoKSkmJjk2IT09aSlyZXR1cm4hMTtpZihjPWgsKHM9KGg9ZS5za2lwQ2hhcnMoaCxpKSktYyk8MylyZXR1cm4hMTtpZih1PWUuc3JjLnNsaWNlKGMsaCksbz1lLnNyYy5zbGljZShoLGYpLDk2PT09aSYmby5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpPj0wKXJldHVybiExO2lmKG4pcmV0dXJuITA7Zm9yKGE9dDshKCsrYT49cikmJiEoKGg9Yz1lLmJNYXJrc1thXStlLnRTaGlmdFthXSk8KGY9ZS5lTWFya3NbYV0pJiZlLnNDb3VudFthXTxlLmJsa0luZGVudCk7KWlmKGUuc3JjLmNoYXJDb2RlQXQoaCk9PT1pJiYhKGUuc0NvdW50W2FdLWUuYmxrSW5kZW50Pj00fHwoaD1lLnNraXBDaGFycyhoLGkpKS1jPHN8fChoPWUuc2tpcFNwYWNlcyhoKSk8Zikpe3A9ITA7YnJlYWt9cmV0dXJuIHM9ZS5zQ291bnRbdF0sZS5saW5lPWErKHA/MTowKSwobD1lLnB1c2goXCJmZW5jZVwiLFwiY29kZVwiLDApKS5pbmZvPW8sbC5jb250ZW50PWUuZ2V0TGluZXModCsxLGEscywhMCksbC5tYXJrdXA9dSxsLm1hcD1bdCxlLmxpbmVdLCEwfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMCkuaXNTcGFjZTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsaSl7dmFyIHMsbyxhLGMsbCx1LHAsaCxmLGQsZyxtLF8sYixrLHYseSx4LEMsQSxEPWUubGluZU1heCx3PWUuYk1hcmtzW3RdK2UudFNoaWZ0W3RdLEU9ZS5lTWFya3NbdF07aWYoZS5zQ291bnRbdF0tZS5ibGtJbmRlbnQ+PTQpcmV0dXJuITE7aWYoNjIhPT1lLnNyYy5jaGFyQ29kZUF0KHcrKykpcmV0dXJuITE7aWYoaSlyZXR1cm4hMDtmb3IoYz1mPWUuc0NvdW50W3RdKzEsMzI9PT1lLnNyYy5jaGFyQ29kZUF0KHcpPyh3KyssYysrLGYrKyxzPSExLHY9ITApOjk9PT1lLnNyYy5jaGFyQ29kZUF0KHcpPyh2PSEwLChlLmJzQ291bnRbdF0rZiklND09Mz8odysrLGMrKyxmKysscz0hMSk6cz0hMCk6dj0hMSxkPVtlLmJNYXJrc1t0XV0sZS5iTWFya3NbdF09dzt3PEUmJihvPWUuc3JjLmNoYXJDb2RlQXQodyksbihvKSk7KTk9PT1vP2YrPTQtKGYrZS5ic0NvdW50W3RdKyhzPzE6MCkpJTQ6ZisrLHcrKztmb3IoZz1bZS5ic0NvdW50W3RdXSxlLmJzQ291bnRbdF09ZS5zQ291bnRbdF0rMSsodj8xOjApLHU9dz49RSxiPVtlLnNDb3VudFt0XV0sZS5zQ291bnRbdF09Zi1jLGs9W2UudFNoaWZ0W3RdXSxlLnRTaGlmdFt0XT13LWUuYk1hcmtzW3RdLHg9ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcyhcImJsb2NrcXVvdGVcIiksXz1lLnBhcmVudFR5cGUsZS5wYXJlbnRUeXBlPVwiYmxvY2txdW90ZVwiLGg9dCsxO2g8ciYmKEE9ZS5zQ291bnRbaF08ZS5ibGtJbmRlbnQsISgodz1lLmJNYXJrc1toXStlLnRTaGlmdFtoXSk+PShFPWUuZU1hcmtzW2hdKSkpO2grKylpZig2MiE9PWUuc3JjLmNoYXJDb2RlQXQodysrKXx8QSl7aWYodSlicmVhaztmb3IoeT0hMSxhPTAsbD14Lmxlbmd0aDthPGw7YSsrKWlmKHhbYV0oZSxoLHIsITApKXt5PSEwO2JyZWFrfWlmKHkpe2UubGluZU1heD1oLDAhPT1lLmJsa0luZGVudCYmKGQucHVzaChlLmJNYXJrc1toXSksZy5wdXNoKGUuYnNDb3VudFtoXSksay5wdXNoKGUudFNoaWZ0W2hdKSxiLnB1c2goZS5zQ291bnRbaF0pLGUuc0NvdW50W2hdLT1lLmJsa0luZGVudCk7YnJlYWt9ZC5wdXNoKGUuYk1hcmtzW2hdKSxnLnB1c2goZS5ic0NvdW50W2hdKSxrLnB1c2goZS50U2hpZnRbaF0pLGIucHVzaChlLnNDb3VudFtoXSksZS5zQ291bnRbaF09LTF9ZWxzZXtmb3IoYz1mPWUuc0NvdW50W2hdKzEsMzI9PT1lLnNyYy5jaGFyQ29kZUF0KHcpPyh3KyssYysrLGYrKyxzPSExLHY9ITApOjk9PT1lLnNyYy5jaGFyQ29kZUF0KHcpPyh2PSEwLChlLmJzQ291bnRbaF0rZiklND09Mz8odysrLGMrKyxmKysscz0hMSk6cz0hMCk6dj0hMSxkLnB1c2goZS5iTWFya3NbaF0pLGUuYk1hcmtzW2hdPXc7dzxFJiYobz1lLnNyYy5jaGFyQ29kZUF0KHcpLG4obykpOyk5PT09bz9mKz00LShmK2UuYnNDb3VudFtoXSsocz8xOjApKSU0OmYrKyx3Kys7dT13Pj1FLGcucHVzaChlLmJzQ291bnRbaF0pLGUuYnNDb3VudFtoXT1lLnNDb3VudFtoXSsxKyh2PzE6MCksYi5wdXNoKGUuc0NvdW50W2hdKSxlLnNDb3VudFtoXT1mLWMsay5wdXNoKGUudFNoaWZ0W2hdKSxlLnRTaGlmdFtoXT13LWUuYk1hcmtzW2hdfWZvcihtPWUuYmxrSW5kZW50LGUuYmxrSW5kZW50PTAsKEM9ZS5wdXNoKFwiYmxvY2txdW90ZV9vcGVuXCIsXCJibG9ja3F1b3RlXCIsMSkpLm1hcmt1cD1cIj5cIixDLm1hcD1wPVt0LDBdLGUubWQuYmxvY2sudG9rZW5pemUoZSx0LGgpLChDPWUucHVzaChcImJsb2NrcXVvdGVfY2xvc2VcIixcImJsb2NrcXVvdGVcIiwtMSkpLm1hcmt1cD1cIj5cIixlLmxpbmVNYXg9RCxlLnBhcmVudFR5cGU9XyxwWzFdPWUubGluZSxhPTA7YTxrLmxlbmd0aDthKyspZS5iTWFya3NbYSt0XT1kW2FdLGUudFNoaWZ0W2ErdF09a1thXSxlLnNDb3VudFthK3RdPWJbYV0sZS5ic0NvdW50W2ErdF09Z1thXTtyZXR1cm4gZS5ibGtJbmRlbnQ9bSwhMH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDApLmlzU3BhY2U7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyLGkpe3ZhciBzLG8sYSxjLGw9ZS5iTWFya3NbdF0rZS50U2hpZnRbdF0sdT1lLmVNYXJrc1t0XTtpZihlLnNDb3VudFt0XS1lLmJsa0luZGVudD49NClyZXR1cm4hMTtpZig0MiE9PShzPWUuc3JjLmNoYXJDb2RlQXQobCsrKSkmJjQ1IT09cyYmOTUhPT1zKXJldHVybiExO2ZvcihvPTE7bDx1Oyl7aWYoKGE9ZS5zcmMuY2hhckNvZGVBdChsKyspKSE9PXMmJiFuKGEpKXJldHVybiExO2E9PT1zJiZvKyt9cmV0dXJuIShvPDMpJiYoaXx8KGUubGluZT10KzEsKGM9ZS5wdXNoKFwiaHJcIixcImhyXCIsMCkpLm1hcD1bdCxlLmxpbmVdLGMubWFya3VwPUFycmF5KG8rMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKHMpKSksITApfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMCkuaXNTcGFjZTtmdW5jdGlvbiBpKGUsdCl7dmFyIHIsaSxzLG87cmV0dXJuIGk9ZS5iTWFya3NbdF0rZS50U2hpZnRbdF0scz1lLmVNYXJrc1t0XSw0MiE9PShyPWUuc3JjLmNoYXJDb2RlQXQoaSsrKSkmJjQ1IT09ciYmNDMhPT1yfHxpPHMmJihvPWUuc3JjLmNoYXJDb2RlQXQoaSksIW4obykpPy0xOml9ZnVuY3Rpb24gcyhlLHQpe3ZhciByLGk9ZS5iTWFya3NbdF0rZS50U2hpZnRbdF0scz1pLG89ZS5lTWFya3NbdF07aWYocysxPj1vKXJldHVybi0xO2lmKChyPWUuc3JjLmNoYXJDb2RlQXQocysrKSk8NDh8fHI+NTcpcmV0dXJuLTE7Zm9yKDs7KXtpZihzPj1vKXJldHVybi0xO2lmKCEoKHI9ZS5zcmMuY2hhckNvZGVBdChzKyspKT49NDgmJnI8PTU3KSl7aWYoNDE9PT1yfHw0Nj09PXIpYnJlYWs7cmV0dXJuLTF9aWYocy1pPj0xMClyZXR1cm4tMX1yZXR1cm4gczxvJiYocj1lLnNyYy5jaGFyQ29kZUF0KHMpLCFuKHIpKT8tMTpzfWUuZXhwb3J0cz1mdW5jdGlvbihlLHQscixuKXt2YXIgbyxhLGMsbCx1LHAsaCxmLGQsZyxtLF8sYixrLHYseSx4LEMsQSxELHcsRSxxLFMsRixULEwseixNPSExLEk9ITA7aWYoZS5zQ291bnRbdF0tZS5ibGtJbmRlbnQ+PTQpcmV0dXJuITE7aWYoZS5saXN0SW5kZW50Pj0wJiZlLnNDb3VudFt0XS1lLmxpc3RJbmRlbnQ+PTQmJmUuc0NvdW50W3RdPGUuYmxrSW5kZW50KXJldHVybiExO2lmKG4mJlwicGFyYWdyYXBoXCI9PT1lLnBhcmVudFR5cGUmJmUuc0NvdW50W3RdPj1lLmJsa0luZGVudCYmKE09ITApLChxPXMoZSx0KSk+PTApe2lmKGg9ITAsRj1lLmJNYXJrc1t0XStlLnRTaGlmdFt0XSxiPU51bWJlcihlLnNyYy5zbGljZShGLHEtMSkpLE0mJjEhPT1iKXJldHVybiExfWVsc2V7aWYoISgocT1pKGUsdCkpPj0wKSlyZXR1cm4hMTtoPSExfWlmKE0mJmUuc2tpcFNwYWNlcyhxKT49ZS5lTWFya3NbdF0pcmV0dXJuITE7aWYoXz1lLnNyYy5jaGFyQ29kZUF0KHEtMSksbilyZXR1cm4hMDtmb3IobT1lLnRva2Vucy5sZW5ndGgsaD8oej1lLnB1c2goXCJvcmRlcmVkX2xpc3Rfb3BlblwiLFwib2xcIiwxKSwxIT09YiYmKHouYXR0cnM9W1tcInN0YXJ0XCIsYl1dKSk6ej1lLnB1c2goXCJidWxsZXRfbGlzdF9vcGVuXCIsXCJ1bFwiLDEpLHoubWFwPWc9W3QsMF0sei5tYXJrdXA9U3RyaW5nLmZyb21DaGFyQ29kZShfKSx2PXQsUz0hMSxMPWUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoXCJsaXN0XCIpLEM9ZS5wYXJlbnRUeXBlLGUucGFyZW50VHlwZT1cImxpc3RcIjt2PHI7KXtmb3IoRT1xLGs9ZS5lTWFya3Nbdl0scD15PWUuc0NvdW50W3ZdK3EtKGUuYk1hcmtzW3RdK2UudFNoaWZ0W3RdKTtFPGs7KXtpZig5PT09KG89ZS5zcmMuY2hhckNvZGVBdChFKSkpeSs9NC0oeStlLmJzQ291bnRbdl0pJTQ7ZWxzZXtpZigzMiE9PW8pYnJlYWs7eSsrfUUrK31pZigodT0oYT1FKT49az8xOnktcCk+NCYmKHU9MSksbD1wK3UsKHo9ZS5wdXNoKFwibGlzdF9pdGVtX29wZW5cIixcImxpXCIsMSkpLm1hcmt1cD1TdHJpbmcuZnJvbUNoYXJDb2RlKF8pLHoubWFwPWY9W3QsMF0saCYmKHouaW5mbz1lLnNyYy5zbGljZShGLHEtMSkpLHc9ZS50aWdodCxEPWUudFNoaWZ0W3RdLEE9ZS5zQ291bnRbdF0seD1lLmxpc3RJbmRlbnQsZS5saXN0SW5kZW50PWUuYmxrSW5kZW50LGUuYmxrSW5kZW50PWwsZS50aWdodD0hMCxlLnRTaGlmdFt0XT1hLWUuYk1hcmtzW3RdLGUuc0NvdW50W3RdPXksYT49ayYmZS5pc0VtcHR5KHQrMSk/ZS5saW5lPU1hdGgubWluKGUubGluZSsyLHIpOmUubWQuYmxvY2sudG9rZW5pemUoZSx0LHIsITApLGUudGlnaHQmJiFTfHwoST0hMSksUz1lLmxpbmUtdD4xJiZlLmlzRW1wdHkoZS5saW5lLTEpLGUuYmxrSW5kZW50PWUubGlzdEluZGVudCxlLmxpc3RJbmRlbnQ9eCxlLnRTaGlmdFt0XT1ELGUuc0NvdW50W3RdPUEsZS50aWdodD13LCh6PWUucHVzaChcImxpc3RfaXRlbV9jbG9zZVwiLFwibGlcIiwtMSkpLm1hcmt1cD1TdHJpbmcuZnJvbUNoYXJDb2RlKF8pLHY9dD1lLmxpbmUsZlsxXT12LGE9ZS5iTWFya3NbdF0sdj49cilicmVhaztpZihlLnNDb3VudFt2XTxlLmJsa0luZGVudClicmVhaztpZihlLnNDb3VudFt0XS1lLmJsa0luZGVudD49NClicmVhaztmb3IoVD0hMSxjPTAsZD1MLmxlbmd0aDtjPGQ7YysrKWlmKExbY10oZSx2LHIsITApKXtUPSEwO2JyZWFrfWlmKFQpYnJlYWs7aWYoaCl7aWYoKHE9cyhlLHYpKTwwKWJyZWFrO0Y9ZS5iTWFya3Nbdl0rZS50U2hpZnRbdl19ZWxzZSBpZigocT1pKGUsdikpPDApYnJlYWs7aWYoXyE9PWUuc3JjLmNoYXJDb2RlQXQocS0xKSlicmVha31yZXR1cm4oej1oP2UucHVzaChcIm9yZGVyZWRfbGlzdF9jbG9zZVwiLFwib2xcIiwtMSk6ZS5wdXNoKFwiYnVsbGV0X2xpc3RfY2xvc2VcIixcInVsXCIsLTEpKS5tYXJrdXA9U3RyaW5nLmZyb21DaGFyQ29kZShfKSxnWzFdPXYsZS5saW5lPXYsZS5wYXJlbnRUeXBlPUMsSSYmZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk9ZS5sZXZlbCsyO2ZvcihyPXQrMixuPWUudG9rZW5zLmxlbmd0aC0yO3I8bjtyKyspZS50b2tlbnNbcl0ubGV2ZWw9PT1pJiZcInBhcmFncmFwaF9vcGVuXCI9PT1lLnRva2Vuc1tyXS50eXBlJiYoZS50b2tlbnNbcisyXS5oaWRkZW49ITAsZS50b2tlbnNbcl0uaGlkZGVuPSEwLHIrPTIpfShlLG0pLCEwfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMCkubm9ybWFsaXplUmVmZXJlbmNlLGk9cigwKS5pc1NwYWNlO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscixzKXt2YXIgbyxhLGMsbCx1LHAsaCxmLGQsZyxtLF8sYixrLHYseSx4PTAsQz1lLmJNYXJrc1t0XStlLnRTaGlmdFt0XSxBPWUuZU1hcmtzW3RdLEQ9dCsxO2lmKGUuc0NvdW50W3RdLWUuYmxrSW5kZW50Pj00KXJldHVybiExO2lmKDkxIT09ZS5zcmMuY2hhckNvZGVBdChDKSlyZXR1cm4hMTtmb3IoOysrQzxBOylpZig5Mz09PWUuc3JjLmNoYXJDb2RlQXQoQykmJjkyIT09ZS5zcmMuY2hhckNvZGVBdChDLTEpKXtpZihDKzE9PT1BKXJldHVybiExO2lmKDU4IT09ZS5zcmMuY2hhckNvZGVBdChDKzEpKXJldHVybiExO2JyZWFrfWZvcihsPWUubGluZU1heCx2PWUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoXCJyZWZlcmVuY2VcIiksZz1lLnBhcmVudFR5cGUsZS5wYXJlbnRUeXBlPVwicmVmZXJlbmNlXCI7RDxsJiYhZS5pc0VtcHR5KEQpO0QrKylpZighKGUuc0NvdW50W0RdLWUuYmxrSW5kZW50PjN8fGUuc0NvdW50W0RdPDApKXtmb3Ioaz0hMSxwPTAsaD12Lmxlbmd0aDtwPGg7cCsrKWlmKHZbcF0oZSxELGwsITApKXtrPSEwO2JyZWFrfWlmKGspYnJlYWt9Zm9yKEE9KGI9ZS5nZXRMaW5lcyh0LEQsZS5ibGtJbmRlbnQsITEpLnRyaW0oKSkubGVuZ3RoLEM9MTtDPEE7QysrKXtpZig5MT09PShvPWIuY2hhckNvZGVBdChDKSkpcmV0dXJuITE7aWYoOTM9PT1vKXtkPUM7YnJlYWt9KDEwPT09b3x8OTI9PT1vJiYrK0M8QSYmMTA9PT1iLmNoYXJDb2RlQXQoQykpJiZ4Kyt9aWYoZDwwfHw1OCE9PWIuY2hhckNvZGVBdChkKzEpKXJldHVybiExO2ZvcihDPWQrMjtDPEE7QysrKWlmKDEwPT09KG89Yi5jaGFyQ29kZUF0KEMpKSl4Kys7ZWxzZSBpZighaShvKSlicmVhaztpZighKG09ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKGIsQyxBKSkub2spcmV0dXJuITE7aWYodT1lLm1kLm5vcm1hbGl6ZUxpbmsobS5zdHIpLCFlLm1kLnZhbGlkYXRlTGluayh1KSlyZXR1cm4hMTtmb3IoYT1DPW0ucG9zLGM9eCs9bS5saW5lcyxfPUM7QzxBO0MrKylpZigxMD09PShvPWIuY2hhckNvZGVBdChDKSkpeCsrO2Vsc2UgaWYoIWkobykpYnJlYWs7Zm9yKG09ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKGIsQyxBKSxDPEEmJl8hPT1DJiZtLm9rPyh5PW0uc3RyLEM9bS5wb3MseCs9bS5saW5lcyk6KHk9XCJcIixDPWEseD1jKTtDPEEmJihvPWIuY2hhckNvZGVBdChDKSxpKG8pKTspQysrO2lmKEM8QSYmMTAhPT1iLmNoYXJDb2RlQXQoQykmJnkpZm9yKHk9XCJcIixDPWEseD1jO0M8QSYmKG89Yi5jaGFyQ29kZUF0KEMpLGkobykpOylDKys7cmV0dXJuIShDPEEmJjEwIT09Yi5jaGFyQ29kZUF0KEMpKSYmKCEhKGY9bihiLnNsaWNlKDEsZCkpKSYmKHN8fCh2b2lkIDA9PT1lLmVudi5yZWZlcmVuY2VzJiYoZS5lbnYucmVmZXJlbmNlcz17fSksdm9pZCAwPT09ZS5lbnYucmVmZXJlbmNlc1tmXSYmKGUuZW52LnJlZmVyZW5jZXNbZl09e3RpdGxlOnksaHJlZjp1fSksZS5wYXJlbnRUeXBlPWcsZS5saW5lPXQreCsxKSwhMCkpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNTApLGk9cigxMikuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSxzPVtbL148KHNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpKD89KFxcc3w+fCQpKS9pLC88XFwvKHNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpPi9pLCEwXSxbL148IS0tLywvLS0+LywhMF0sWy9ePFxcPy8sL1xcPz4vLCEwXSxbL148IVtBLVpdLywvPi8sITBdLFsvXjwhXFxbQ0RBVEFcXFsvLC9cXF1cXF0+LywhMF0sW25ldyBSZWdFeHAoXCJePC8/KFwiK24uam9pbihcInxcIikrXCIpKD89KFxcXFxzfC8/PnwkKSlcIixcImlcIiksL14kLywhMF0sW25ldyBSZWdFeHAoaS5zb3VyY2UrXCJcXFxccyokXCIpLC9eJC8sITFdXTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGksbyxhLGMsbD1lLmJNYXJrc1t0XStlLnRTaGlmdFt0XSx1PWUuZU1hcmtzW3RdO2lmKGUuc0NvdW50W3RdLWUuYmxrSW5kZW50Pj00KXJldHVybiExO2lmKCFlLm1kLm9wdGlvbnMuaHRtbClyZXR1cm4hMTtpZig2MCE9PWUuc3JjLmNoYXJDb2RlQXQobCkpcmV0dXJuITE7Zm9yKGM9ZS5zcmMuc2xpY2UobCx1KSxpPTA7aTxzLmxlbmd0aCYmIXNbaV1bMF0udGVzdChjKTtpKyspO2lmKGk9PT1zLmxlbmd0aClyZXR1cm4hMTtpZihuKXJldHVybiBzW2ldWzJdO2lmKG89dCsxLCFzW2ldWzFdLnRlc3QoYykpZm9yKDtvPHImJiEoZS5zQ291bnRbb108ZS5ibGtJbmRlbnQpO28rKylpZihsPWUuYk1hcmtzW29dK2UudFNoaWZ0W29dLHU9ZS5lTWFya3Nbb10sYz1lLnNyYy5zbGljZShsLHUpLHNbaV1bMV0udGVzdChjKSl7MCE9PWMubGVuZ3RoJiZvKys7YnJlYWt9cmV0dXJuIGUubGluZT1vLChhPWUucHVzaChcImh0bWxfYmxvY2tcIixcIlwiLDApKS5tYXA9W3Qsb10sYS5jb250ZW50PWUuZ2V0TGluZXModCxvLGUuYmxrSW5kZW50LCEwKSwhMH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9W1wiYWRkcmVzc1wiLFwiYXJ0aWNsZVwiLFwiYXNpZGVcIixcImJhc2VcIixcImJhc2Vmb250XCIsXCJibG9ja3F1b3RlXCIsXCJib2R5XCIsXCJjYXB0aW9uXCIsXCJjZW50ZXJcIixcImNvbFwiLFwiY29sZ3JvdXBcIixcImRkXCIsXCJkZXRhaWxzXCIsXCJkaWFsb2dcIixcImRpclwiLFwiZGl2XCIsXCJkbFwiLFwiZHRcIixcImZpZWxkc2V0XCIsXCJmaWdjYXB0aW9uXCIsXCJmaWd1cmVcIixcImZvb3RlclwiLFwiZm9ybVwiLFwiZnJhbWVcIixcImZyYW1lc2V0XCIsXCJoMVwiLFwiaDJcIixcImgzXCIsXCJoNFwiLFwiaDVcIixcImg2XCIsXCJoZWFkXCIsXCJoZWFkZXJcIixcImhyXCIsXCJodG1sXCIsXCJpZnJhbWVcIixcImxlZ2VuZFwiLFwibGlcIixcImxpbmtcIixcIm1haW5cIixcIm1lbnVcIixcIm1lbnVpdGVtXCIsXCJuYXZcIixcIm5vZnJhbWVzXCIsXCJvbFwiLFwib3B0Z3JvdXBcIixcIm9wdGlvblwiLFwicFwiLFwicGFyYW1cIixcInNlY3Rpb25cIixcInNvdXJjZVwiLFwic3VtbWFyeVwiLFwidGFibGVcIixcInRib2R5XCIsXCJ0ZFwiLFwidGZvb3RcIixcInRoXCIsXCJ0aGVhZFwiLFwidGl0bGVcIixcInRyXCIsXCJ0cmFja1wiLFwidWxcIl19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDApLmlzU3BhY2U7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyLGkpe3ZhciBzLG8sYSxjLGw9ZS5iTWFya3NbdF0rZS50U2hpZnRbdF0sdT1lLmVNYXJrc1t0XTtpZihlLnNDb3VudFt0XS1lLmJsa0luZGVudD49NClyZXR1cm4hMTtpZigzNSE9PShzPWUuc3JjLmNoYXJDb2RlQXQobCkpfHxsPj11KXJldHVybiExO2ZvcihvPTEscz1lLnNyYy5jaGFyQ29kZUF0KCsrbCk7MzU9PT1zJiZsPHUmJm88PTY7KW8rKyxzPWUuc3JjLmNoYXJDb2RlQXQoKytsKTtyZXR1cm4hKG8+Nnx8bDx1JiYhbihzKSkmJihpfHwodT1lLnNraXBTcGFjZXNCYWNrKHUsbCksKGE9ZS5za2lwQ2hhcnNCYWNrKHUsMzUsbCkpPmwmJm4oZS5zcmMuY2hhckNvZGVBdChhLTEpKSYmKHU9YSksZS5saW5lPXQrMSwoYz1lLnB1c2goXCJoZWFkaW5nX29wZW5cIixcImhcIitTdHJpbmcobyksMSkpLm1hcmt1cD1cIiMjIyMjIyMjXCIuc2xpY2UoMCxvKSxjLm1hcD1bdCxlLmxpbmVdLChjPWUucHVzaChcImlubGluZVwiLFwiXCIsMCkpLmNvbnRlbnQ9ZS5zcmMuc2xpY2UobCx1KS50cmltKCksYy5tYXA9W3QsZS5saW5lXSxjLmNoaWxkcmVuPVtdLChjPWUucHVzaChcImhlYWRpbmdfY2xvc2VcIixcImhcIitTdHJpbmcobyksLTEpKS5tYXJrdXA9XCIjIyMjIyMjI1wiLnNsaWNlKDAsbykpLCEwKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuLGkscyxvLGEsYyxsLHUscCxoLGY9dCsxLGQ9ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcyhcInBhcmFncmFwaFwiKTtpZihlLnNDb3VudFt0XS1lLmJsa0luZGVudD49NClyZXR1cm4hMTtmb3IoaD1lLnBhcmVudFR5cGUsZS5wYXJlbnRUeXBlPVwicGFyYWdyYXBoXCI7ZjxyJiYhZS5pc0VtcHR5KGYpO2YrKylpZighKGUuc0NvdW50W2ZdLWUuYmxrSW5kZW50PjMpKXtpZihlLnNDb3VudFtmXT49ZS5ibGtJbmRlbnQmJihjPWUuYk1hcmtzW2ZdK2UudFNoaWZ0W2ZdKTwobD1lLmVNYXJrc1tmXSkmJig0NT09PShwPWUuc3JjLmNoYXJDb2RlQXQoYykpfHw2MT09PXApJiYoYz1lLnNraXBDaGFycyhjLHApLChjPWUuc2tpcFNwYWNlcyhjKSk+PWwpKXt1PTYxPT09cD8xOjI7YnJlYWt9aWYoIShlLnNDb3VudFtmXTwwKSl7Zm9yKGk9ITEscz0wLG89ZC5sZW5ndGg7czxvO3MrKylpZihkW3NdKGUsZixyLCEwKSl7aT0hMDticmVha31pZihpKWJyZWFrfX1yZXR1cm4hIXUmJihuPWUuZ2V0TGluZXModCxmLGUuYmxrSW5kZW50LCExKS50cmltKCksZS5saW5lPWYrMSwoYT1lLnB1c2goXCJoZWFkaW5nX29wZW5cIixcImhcIitTdHJpbmcodSksMSkpLm1hcmt1cD1TdHJpbmcuZnJvbUNoYXJDb2RlKHApLGEubWFwPVt0LGUubGluZV0sKGE9ZS5wdXNoKFwiaW5saW5lXCIsXCJcIiwwKSkuY29udGVudD1uLGEubWFwPVt0LGUubGluZS0xXSxhLmNoaWxkcmVuPVtdLChhPWUucHVzaChcImhlYWRpbmdfY2xvc2VcIixcImhcIitTdHJpbmcodSksLTEpKS5tYXJrdXA9U3RyaW5nLmZyb21DaGFyQ29kZShwKSxlLnBhcmVudFR5cGU9aCwhMCl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLHMsbyxhLGM9dCsxLGw9ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcyhcInBhcmFncmFwaFwiKSx1PWUubGluZU1heDtmb3IoYT1lLnBhcmVudFR5cGUsZS5wYXJlbnRUeXBlPVwicGFyYWdyYXBoXCI7Yzx1JiYhZS5pc0VtcHR5KGMpO2MrKylpZighKGUuc0NvdW50W2NdLWUuYmxrSW5kZW50PjN8fGUuc0NvdW50W2NdPDApKXtmb3Iobj0hMSxpPTAscz1sLmxlbmd0aDtpPHM7aSsrKWlmKGxbaV0oZSxjLHUsITApKXtuPSEwO2JyZWFrfWlmKG4pYnJlYWt9cmV0dXJuIHI9ZS5nZXRMaW5lcyh0LGMsZS5ibGtJbmRlbnQsITEpLnRyaW0oKSxlLmxpbmU9Yywobz1lLnB1c2goXCJwYXJhZ3JhcGhfb3BlblwiLFwicFwiLDEpKS5tYXA9W3QsZS5saW5lXSwobz1lLnB1c2goXCJpbmxpbmVcIixcIlwiLDApKS5jb250ZW50PXIsby5tYXA9W3QsZS5saW5lXSxvLmNoaWxkcmVuPVtdLG89ZS5wdXNoKFwicGFyYWdyYXBoX2Nsb3NlXCIsXCJwXCIsLTEpLGUucGFyZW50VHlwZT1hLCEwfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNSksaT1yKDApLmlzU3BhY2U7ZnVuY3Rpb24gcyhlLHQscixuKXt2YXIgcyxvLGEsYyxsLHUscCxoO2Zvcih0aGlzLnNyYz1lLHRoaXMubWQ9dCx0aGlzLmVudj1yLHRoaXMudG9rZW5zPW4sdGhpcy5iTWFya3M9W10sdGhpcy5lTWFya3M9W10sdGhpcy50U2hpZnQ9W10sdGhpcy5zQ291bnQ9W10sdGhpcy5ic0NvdW50PVtdLHRoaXMuYmxrSW5kZW50PTAsdGhpcy5saW5lPTAsdGhpcy5saW5lTWF4PTAsdGhpcy50aWdodD0hMSx0aGlzLmRkSW5kZW50PS0xLHRoaXMubGlzdEluZGVudD0tMSx0aGlzLnBhcmVudFR5cGU9XCJyb290XCIsdGhpcy5sZXZlbD0wLHRoaXMucmVzdWx0PVwiXCIsaD0hMSxhPWM9dT1wPTAsbD0obz10aGlzLnNyYykubGVuZ3RoO2M8bDtjKyspe2lmKHM9by5jaGFyQ29kZUF0KGMpLCFoKXtpZihpKHMpKXt1KyssOT09PXM/cCs9NC1wJTQ6cCsrO2NvbnRpbnVlfWg9ITB9MTAhPT1zJiZjIT09bC0xfHwoMTAhPT1zJiZjKyssdGhpcy5iTWFya3MucHVzaChhKSx0aGlzLmVNYXJrcy5wdXNoKGMpLHRoaXMudFNoaWZ0LnB1c2godSksdGhpcy5zQ291bnQucHVzaChwKSx0aGlzLmJzQ291bnQucHVzaCgwKSxoPSExLHU9MCxwPTAsYT1jKzEpfXRoaXMuYk1hcmtzLnB1c2goby5sZW5ndGgpLHRoaXMuZU1hcmtzLnB1c2goby5sZW5ndGgpLHRoaXMudFNoaWZ0LnB1c2goMCksdGhpcy5zQ291bnQucHVzaCgwKSx0aGlzLmJzQ291bnQucHVzaCgwKSx0aGlzLmxpbmVNYXg9dGhpcy5iTWFya3MubGVuZ3RoLTF9cy5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQscil7dmFyIGk9bmV3IG4oZSx0LHIpO3JldHVybiBpLmJsb2NrPSEwLHI8MCYmdGhpcy5sZXZlbC0tLGkubGV2ZWw9dGhpcy5sZXZlbCxyPjAmJnRoaXMubGV2ZWwrKyx0aGlzLnRva2Vucy5wdXNoKGkpLGl9LHMucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYk1hcmtzW2VdK3RoaXMudFNoaWZ0W2VdPj10aGlzLmVNYXJrc1tlXX0scy5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMubGluZU1heDtlPHQmJiEodGhpcy5iTWFya3NbZV0rdGhpcy50U2hpZnRbZV08dGhpcy5lTWFya3NbZV0pO2UrKyk7cmV0dXJuIGV9LHMucHJvdG90eXBlLnNraXBTcGFjZXM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LHI9dGhpcy5zcmMubGVuZ3RoO2U8ciYmKHQ9dGhpcy5zcmMuY2hhckNvZGVBdChlKSxpKHQpKTtlKyspO3JldHVybiBlfSxzLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjaz1mdW5jdGlvbihlLHQpe2lmKGU8PXQpcmV0dXJuIGU7Zm9yKDtlPnQ7KWlmKCFpKHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1lKSkpcmV0dXJuIGUrMTtyZXR1cm4gZX0scy5wcm90b3R5cGUuc2tpcENoYXJzPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPXRoaXMuc3JjLmxlbmd0aDtlPHImJnRoaXMuc3JjLmNoYXJDb2RlQXQoZSk9PT10O2UrKyk7cmV0dXJuIGV9LHMucHJvdG90eXBlLnNraXBDaGFyc0JhY2s9ZnVuY3Rpb24oZSx0LHIpe2lmKGU8PXIpcmV0dXJuIGU7Zm9yKDtlPnI7KWlmKHQhPT10aGlzLnNyYy5jaGFyQ29kZUF0KC0tZSkpcmV0dXJuIGUrMTtyZXR1cm4gZX0scy5wcm90b3R5cGUuZ2V0TGluZXM9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIHMsbyxhLGMsbCx1LHAsaD1lO2lmKGU+PXQpcmV0dXJuXCJcIjtmb3IodT1uZXcgQXJyYXkodC1lKSxzPTA7aDx0O2grKyxzKyspe2ZvcihvPTAscD1jPXRoaXMuYk1hcmtzW2hdLGw9aCsxPHR8fG4/dGhpcy5lTWFya3NbaF0rMTp0aGlzLmVNYXJrc1toXTtjPGwmJm88cjspe2lmKGE9dGhpcy5zcmMuY2hhckNvZGVBdChjKSxpKGEpKTk9PT1hP28rPTQtKG8rdGhpcy5ic0NvdW50W2hdKSU0Om8rKztlbHNle2lmKCEoYy1wPHRoaXMudFNoaWZ0W2hdKSlicmVhaztvKyt9YysrfXVbc109bz5yP25ldyBBcnJheShvLXIrMSkuam9pbihcIiBcIikrdGhpcy5zcmMuc2xpY2UoYyxsKTp0aGlzLnNyYy5zbGljZShjLGwpfXJldHVybiB1LmpvaW4oXCJcIil9LHMucHJvdG90eXBlLlRva2VuPW4sZS5leHBvcnRzPXN9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDQpLGk9W1tcInRleHRcIixyKDU2KV0sW1wibmV3bGluZVwiLHIoNTcpXSxbXCJlc2NhcGVcIixyKDU4KV0sW1wiYmFja3RpY2tzXCIscig1OSldLFtcInN0cmlrZXRocm91Z2hcIixyKDEzKS50b2tlbml6ZV0sW1wiZW1waGFzaXNcIixyKDE0KS50b2tlbml6ZV0sW1wibGlua1wiLHIoNjApXSxbXCJpbWFnZVwiLHIoNjEpXSxbXCJhdXRvbGlua1wiLHIoNjIpXSxbXCJodG1sX2lubGluZVwiLHIoNjMpXSxbXCJlbnRpdHlcIixyKDY0KV1dLHM9W1tcImJhbGFuY2VfcGFpcnNcIixyKDY1KV0sW1wic3RyaWtldGhyb3VnaFwiLHIoMTMpLnBvc3RQcm9jZXNzXSxbXCJlbXBoYXNpc1wiLHIoMTQpLnBvc3RQcm9jZXNzXSxbXCJ0ZXh0X2NvbGxhcHNlXCIscig2NildXTtmdW5jdGlvbiBvKCl7dmFyIGU7Zm9yKHRoaXMucnVsZXI9bmV3IG4sZT0wO2U8aS5sZW5ndGg7ZSsrKXRoaXMucnVsZXIucHVzaChpW2VdWzBdLGlbZV1bMV0pO2Zvcih0aGlzLnJ1bGVyMj1uZXcgbixlPTA7ZTxzLmxlbmd0aDtlKyspdGhpcy5ydWxlcjIucHVzaChzW2VdWzBdLHNbZV1bMV0pfW8ucHJvdG90eXBlLnNraXBUb2tlbj1mdW5jdGlvbihlKXt2YXIgdCxyLG49ZS5wb3MsaT10aGlzLnJ1bGVyLmdldFJ1bGVzKFwiXCIpLHM9aS5sZW5ndGgsbz1lLm1kLm9wdGlvbnMubWF4TmVzdGluZyxhPWUuY2FjaGU7aWYodm9pZCAwPT09YVtuXSl7aWYoZS5sZXZlbDxvKWZvcihyPTA7cjxzJiYoZS5sZXZlbCsrLHQ9aVtyXShlLCEwKSxlLmxldmVsLS0sIXQpO3IrKyk7ZWxzZSBlLnBvcz1lLnBvc01heDt0fHxlLnBvcysrLGFbbl09ZS5wb3N9ZWxzZSBlLnBvcz1hW25dfSxvLnByb3RvdHlwZS50b2tlbml6ZT1mdW5jdGlvbihlKXtmb3IodmFyIHQscixuPXRoaXMucnVsZXIuZ2V0UnVsZXMoXCJcIiksaT1uLmxlbmd0aCxzPWUucG9zTWF4LG89ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7ZS5wb3M8czspe2lmKGUubGV2ZWw8bylmb3Iocj0wO3I8aSYmISh0PW5bcl0oZSwhMSkpO3IrKyk7aWYodCl7aWYoZS5wb3M+PXMpYnJlYWt9ZWxzZSBlLnBlbmRpbmcrPWUuc3JjW2UucG9zKytdfWUucGVuZGluZyYmZS5wdXNoUGVuZGluZygpfSxvLnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbihlLHQscixuKXt2YXIgaSxzLG8sYT1uZXcgdGhpcy5TdGF0ZShlLHQscixuKTtmb3IodGhpcy50b2tlbml6ZShhKSxvPShzPXRoaXMucnVsZXIyLmdldFJ1bGVzKFwiXCIpKS5sZW5ndGgsaT0wO2k8bztpKyspc1tpXShhKX0sby5wcm90b3R5cGUuU3RhdGU9cig2NyksZS5leHBvcnRzPW99LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3N3aXRjaChlKXtjYXNlIDEwOmNhc2UgMzM6Y2FzZSAzNTpjYXNlIDM2OmNhc2UgMzc6Y2FzZSAzODpjYXNlIDQyOmNhc2UgNDM6Y2FzZSA0NTpjYXNlIDU4OmNhc2UgNjA6Y2FzZSA2MTpjYXNlIDYyOmNhc2UgNjQ6Y2FzZSA5MTpjYXNlIDkyOmNhc2UgOTM6Y2FzZSA5NDpjYXNlIDk1OmNhc2UgOTY6Y2FzZSAxMjM6Y2FzZSAxMjU6Y2FzZSAxMjY6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPWUucG9zO3I8ZS5wb3NNYXgmJiFuKGUuc3JjLmNoYXJDb2RlQXQocikpOylyKys7cmV0dXJuIHIhPT1lLnBvcyYmKHR8fChlLnBlbmRpbmcrPWUuc3JjLnNsaWNlKGUucG9zLHIpKSxlLnBvcz1yLCEwKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDApLmlzU3BhY2U7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsaSxzLG89ZS5wb3M7aWYoMTAhPT1lLnNyYy5jaGFyQ29kZUF0KG8pKXJldHVybiExO2lmKHI9ZS5wZW5kaW5nLmxlbmd0aC0xLGk9ZS5wb3NNYXgsIXQpaWYocj49MCYmMzI9PT1lLnBlbmRpbmcuY2hhckNvZGVBdChyKSlpZihyPj0xJiYzMj09PWUucGVuZGluZy5jaGFyQ29kZUF0KHItMSkpe2ZvcihzPXItMTtzPj0xJiYzMj09PWUucGVuZGluZy5jaGFyQ29kZUF0KHMtMSk7KXMtLTtlLnBlbmRpbmc9ZS5wZW5kaW5nLnNsaWNlKDAscyksZS5wdXNoKFwiaGFyZGJyZWFrXCIsXCJiclwiLDApfWVsc2UgZS5wZW5kaW5nPWUucGVuZGluZy5zbGljZSgwLC0xKSxlLnB1c2goXCJzb2Z0YnJlYWtcIixcImJyXCIsMCk7ZWxzZSBlLnB1c2goXCJzb2Z0YnJlYWtcIixcImJyXCIsMCk7Zm9yKG8rKztvPGkmJm4oZS5zcmMuY2hhckNvZGVBdChvKSk7KW8rKztyZXR1cm4gZS5wb3M9bywhMH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmb3IodmFyIG49cigwKS5pc1NwYWNlLGk9W10scz0wO3M8MjU2O3MrKylpLnB1c2goMCk7XCJcXFxcIVxcXCIjJCUmJygpKissLi86Ozw9Pj9AW11eX2B7fH1+LVwiLnNwbGl0KFwiXCIpLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lbZS5jaGFyQ29kZUF0KDApXT0xfSkpLGUuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3ZhciByLHM9ZS5wb3Msbz1lLnBvc01heDtpZig5MiE9PWUuc3JjLmNoYXJDb2RlQXQocykpcmV0dXJuITE7aWYoKytzPG8pe2lmKChyPWUuc3JjLmNoYXJDb2RlQXQocykpPDI1NiYmMCE9PWlbcl0pcmV0dXJuIHR8fChlLnBlbmRpbmcrPWUuc3JjW3NdKSxlLnBvcys9MiwhMDtpZigxMD09PXIpe2Zvcih0fHxlLnB1c2goXCJoYXJkYnJlYWtcIixcImJyXCIsMCkscysrO3M8byYmKHI9ZS5zcmMuY2hhckNvZGVBdChzKSxuKHIpKTspcysrO3JldHVybiBlLnBvcz1zLCEwfX1yZXR1cm4gdHx8KGUucGVuZGluZys9XCJcXFxcXCIpLGUucG9zKyssITB9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLHMsbyxhLGMsbCx1PWUucG9zO2lmKDk2IT09ZS5zcmMuY2hhckNvZGVBdCh1KSlyZXR1cm4hMTtmb3Iocj11LHUrKyxuPWUucG9zTWF4O3U8biYmOTY9PT1lLnNyYy5jaGFyQ29kZUF0KHUpOyl1Kys7aWYoYz0oaT1lLnNyYy5zbGljZShyLHUpKS5sZW5ndGgsZS5iYWNrdGlja3NTY2FubmVkJiYoZS5iYWNrdGlja3NbY118fDApPD1yKXJldHVybiB0fHwoZS5wZW5kaW5nKz1pKSxlLnBvcys9YywhMDtmb3Iobz1hPXU7LTEhPT0obz1lLnNyYy5pbmRleE9mKFwiYFwiLGEpKTspe2ZvcihhPW8rMTthPG4mJjk2PT09ZS5zcmMuY2hhckNvZGVBdChhKTspYSsrO2lmKChsPWEtbyk9PT1jKXJldHVybiB0fHwoKHM9ZS5wdXNoKFwiY29kZV9pbmxpbmVcIixcImNvZGVcIiwwKSkubWFya3VwPWkscy5jb250ZW50PWUuc3JjLnNsaWNlKHUsbykucmVwbGFjZSgvXFxuL2csXCIgXCIpLnJlcGxhY2UoL14gKC4rKSAkLyxcIiQxXCIpKSxlLnBvcz1hLCEwO2UuYmFja3RpY2tzW2xdPW99cmV0dXJuIGUuYmFja3RpY2tzU2Nhbm5lZD0hMCx0fHwoZS5wZW5kaW5nKz1pKSxlLnBvcys9YywhMH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDApLm5vcm1hbGl6ZVJlZmVyZW5jZSxpPXIoMCkuaXNTcGFjZTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgcixzLG8sYSxjLGwsdSxwLGg9XCJcIixmPVwiXCIsZD1lLnBvcyxnPWUucG9zTWF4LG09ZS5wb3MsXz0hMDtpZig5MSE9PWUuc3JjLmNoYXJDb2RlQXQoZS5wb3MpKXJldHVybiExO2lmKGM9ZS5wb3MrMSwoYT1lLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoZSxlLnBvcywhMCkpPDApcmV0dXJuITE7aWYoKGw9YSsxKTxnJiY0MD09PWUuc3JjLmNoYXJDb2RlQXQobCkpe2ZvcihfPSExLGwrKztsPGcmJihzPWUuc3JjLmNoYXJDb2RlQXQobCksaShzKXx8MTA9PT1zKTtsKyspO2lmKGw+PWcpcmV0dXJuITE7aWYobT1sLCh1PWUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihlLnNyYyxsLGUucG9zTWF4KSkub2spe2ZvcihoPWUubWQubm9ybWFsaXplTGluayh1LnN0ciksZS5tZC52YWxpZGF0ZUxpbmsoaCk/bD11LnBvczpoPVwiXCIsbT1sO2w8ZyYmKHM9ZS5zcmMuY2hhckNvZGVBdChsKSxpKHMpfHwxMD09PXMpO2wrKyk7aWYodT1lLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoZS5zcmMsbCxlLnBvc01heCksbDxnJiZtIT09bCYmdS5vaylmb3IoZj11LnN0cixsPXUucG9zO2w8ZyYmKHM9ZS5zcmMuY2hhckNvZGVBdChsKSxpKHMpfHwxMD09PXMpO2wrKyk7fShsPj1nfHw0MSE9PWUuc3JjLmNoYXJDb2RlQXQobCkpJiYoXz0hMCksbCsrfWlmKF8pe2lmKHZvaWQgMD09PWUuZW52LnJlZmVyZW5jZXMpcmV0dXJuITE7aWYobDxnJiY5MT09PWUuc3JjLmNoYXJDb2RlQXQobCk/KG09bCsxLChsPWUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChlLGwpKT49MD9vPWUuc3JjLnNsaWNlKG0sbCsrKTpsPWErMSk6bD1hKzEsb3x8KG89ZS5zcmMuc2xpY2UoYyxhKSksIShwPWUuZW52LnJlZmVyZW5jZXNbbihvKV0pKXJldHVybiBlLnBvcz1kLCExO2g9cC5ocmVmLGY9cC50aXRsZX1yZXR1cm4gdHx8KGUucG9zPWMsZS5wb3NNYXg9YSxlLnB1c2goXCJsaW5rX29wZW5cIixcImFcIiwxKS5hdHRycz1yPVtbXCJocmVmXCIsaF1dLGYmJnIucHVzaChbXCJ0aXRsZVwiLGZdKSxlLm1kLmlubGluZS50b2tlbml6ZShlKSxlLnB1c2goXCJsaW5rX2Nsb3NlXCIsXCJhXCIsLTEpKSxlLnBvcz1sLGUucG9zTWF4PWcsITB9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigwKS5ub3JtYWxpemVSZWZlcmVuY2UsaT1yKDApLmlzU3BhY2U7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHIscyxvLGEsYyxsLHUscCxoLGYsZCxnLG0sXz1cIlwiLGI9ZS5wb3Msaz1lLnBvc01heDtpZigzMyE9PWUuc3JjLmNoYXJDb2RlQXQoZS5wb3MpKXJldHVybiExO2lmKDkxIT09ZS5zcmMuY2hhckNvZGVBdChlLnBvcysxKSlyZXR1cm4hMTtpZihsPWUucG9zKzIsKGM9ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKGUsZS5wb3MrMSwhMSkpPDApcmV0dXJuITE7aWYoKHU9YysxKTxrJiY0MD09PWUuc3JjLmNoYXJDb2RlQXQodSkpe2Zvcih1Kys7dTxrJiYocz1lLnNyYy5jaGFyQ29kZUF0KHUpLGkocyl8fDEwPT09cyk7dSsrKTtpZih1Pj1rKXJldHVybiExO2ZvcihtPXUsKGg9ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKGUuc3JjLHUsZS5wb3NNYXgpKS5vayYmKF89ZS5tZC5ub3JtYWxpemVMaW5rKGguc3RyKSxlLm1kLnZhbGlkYXRlTGluayhfKT91PWgucG9zOl89XCJcIiksbT11O3U8ayYmKHM9ZS5zcmMuY2hhckNvZGVBdCh1KSxpKHMpfHwxMD09PXMpO3UrKyk7aWYoaD1lLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoZS5zcmMsdSxlLnBvc01heCksdTxrJiZtIT09dSYmaC5vaylmb3IoZj1oLnN0cix1PWgucG9zO3U8ayYmKHM9ZS5zcmMuY2hhckNvZGVBdCh1KSxpKHMpfHwxMD09PXMpO3UrKyk7ZWxzZSBmPVwiXCI7aWYodT49a3x8NDEhPT1lLnNyYy5jaGFyQ29kZUF0KHUpKXJldHVybiBlLnBvcz1iLCExO3UrK31lbHNle2lmKHZvaWQgMD09PWUuZW52LnJlZmVyZW5jZXMpcmV0dXJuITE7aWYodTxrJiY5MT09PWUuc3JjLmNoYXJDb2RlQXQodSk/KG09dSsxLCh1PWUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChlLHUpKT49MD9hPWUuc3JjLnNsaWNlKG0sdSsrKTp1PWMrMSk6dT1jKzEsYXx8KGE9ZS5zcmMuc2xpY2UobCxjKSksIShwPWUuZW52LnJlZmVyZW5jZXNbbihhKV0pKXJldHVybiBlLnBvcz1iLCExO189cC5ocmVmLGY9cC50aXRsZX1yZXR1cm4gdHx8KG89ZS5zcmMuc2xpY2UobCxjKSxlLm1kLmlubGluZS5wYXJzZShvLGUubWQsZS5lbnYsZz1bXSksKGQ9ZS5wdXNoKFwiaW1hZ2VcIixcImltZ1wiLDApKS5hdHRycz1yPVtbXCJzcmNcIixfXSxbXCJhbHRcIixcIlwiXV0sZC5jaGlsZHJlbj1nLGQuY29udGVudD1vLGYmJnIucHVzaChbXCJ0aXRsZVwiLGZdKSksZS5wb3M9dSxlLnBvc01heD1rLCEwfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPS9eKFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopJC8saT0vXihbYS16QS1aXVthLXpBLVowLTkrLlxcLV17MSwzMX0pOihbXjw+XFx4MDAtXFx4MjBdKikkLztlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgcixzLG8sYSxjLGwsdT1lLnBvcztpZig2MCE9PWUuc3JjLmNoYXJDb2RlQXQodSkpcmV0dXJuITE7Zm9yKGM9ZS5wb3MsbD1lLnBvc01heDs7KXtpZigrK3U+PWwpcmV0dXJuITE7aWYoNjA9PT0oYT1lLnNyYy5jaGFyQ29kZUF0KHUpKSlyZXR1cm4hMTtpZig2Mj09PWEpYnJlYWt9cmV0dXJuIHI9ZS5zcmMuc2xpY2UoYysxLHUpLGkudGVzdChyKT8ocz1lLm1kLm5vcm1hbGl6ZUxpbmsociksISFlLm1kLnZhbGlkYXRlTGluayhzKSYmKHR8fCgobz1lLnB1c2goXCJsaW5rX29wZW5cIixcImFcIiwxKSkuYXR0cnM9W1tcImhyZWZcIixzXV0sby5tYXJrdXA9XCJhdXRvbGlua1wiLG8uaW5mbz1cImF1dG9cIiwobz1lLnB1c2goXCJ0ZXh0XCIsXCJcIiwwKSkuY29udGVudD1lLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHIpLChvPWUucHVzaChcImxpbmtfY2xvc2VcIixcImFcIiwtMSkpLm1hcmt1cD1cImF1dG9saW5rXCIsby5pbmZvPVwiYXV0b1wiKSxlLnBvcys9ci5sZW5ndGgrMiwhMCkpOiEhbi50ZXN0KHIpJiYocz1lLm1kLm5vcm1hbGl6ZUxpbmsoXCJtYWlsdG86XCIrciksISFlLm1kLnZhbGlkYXRlTGluayhzKSYmKHR8fCgobz1lLnB1c2goXCJsaW5rX29wZW5cIixcImFcIiwxKSkuYXR0cnM9W1tcImhyZWZcIixzXV0sby5tYXJrdXA9XCJhdXRvbGlua1wiLG8uaW5mbz1cImF1dG9cIiwobz1lLnB1c2goXCJ0ZXh0XCIsXCJcIiwwKSkuY29udGVudD1lLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHIpLChvPWUucHVzaChcImxpbmtfY2xvc2VcIixcImFcIiwtMSkpLm1hcmt1cD1cImF1dG9saW5rXCIsby5pbmZvPVwiYXV0b1wiKSxlLnBvcys9ci5sZW5ndGgrMiwhMCkpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMTIpLkhUTUxfVEFHX1JFO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3ZhciByLGkscyxvPWUucG9zO3JldHVybiEhZS5tZC5vcHRpb25zLmh0bWwmJihzPWUucG9zTWF4LCEoNjAhPT1lLnNyYy5jaGFyQ29kZUF0KG8pfHxvKzI+PXMpJiYoISgzMyE9PShyPWUuc3JjLmNoYXJDb2RlQXQobysxKSkmJjYzIT09ciYmNDchPT1yJiYhZnVuY3Rpb24oZSl7dmFyIHQ9MzJ8ZTtyZXR1cm4gdD49OTcmJnQ8PTEyMn0ocikpJiYoISEoaT1lLnNyYy5zbGljZShvKS5tYXRjaChuKSkmJih0fHwoZS5wdXNoKFwiaHRtbF9pbmxpbmVcIixcIlwiLDApLmNvbnRlbnQ9ZS5zcmMuc2xpY2UobyxvK2lbMF0ubGVuZ3RoKSksZS5wb3MrPWlbMF0ubGVuZ3RoLCEwKSkpKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDcpLGk9cigwKS5oYXMscz1yKDApLmlzVmFsaWRFbnRpdHlDb2RlLG89cigwKS5mcm9tQ29kZVBvaW50LGE9L14mIygoPzp4W2EtZjAtOV17MSw2fXxbMC05XXsxLDd9KSk7L2ksYz0vXiYoW2Etel1bYS16MC05XXsxLDMxfSk7L2k7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbCx1PWUucG9zLHA9ZS5wb3NNYXg7aWYoMzghPT1lLnNyYy5jaGFyQ29kZUF0KHUpKXJldHVybiExO2lmKHUrMTxwKWlmKDM1PT09ZS5zcmMuY2hhckNvZGVBdCh1KzEpKXtpZihsPWUuc3JjLnNsaWNlKHUpLm1hdGNoKGEpKXJldHVybiB0fHwocj1cInhcIj09PWxbMV1bMF0udG9Mb3dlckNhc2UoKT9wYXJzZUludChsWzFdLnNsaWNlKDEpLDE2KTpwYXJzZUludChsWzFdLDEwKSxlLnBlbmRpbmcrPXMocik/byhyKTpvKDY1NTMzKSksZS5wb3MrPWxbMF0ubGVuZ3RoLCEwfWVsc2UgaWYoKGw9ZS5zcmMuc2xpY2UodSkubWF0Y2goYykpJiZpKG4sbFsxXSkpcmV0dXJuIHR8fChlLnBlbmRpbmcrPW5bbFsxXV0pLGUucG9zKz1sWzBdLmxlbmd0aCwhMDtyZXR1cm4gdHx8KGUucGVuZGluZys9XCImXCIpLGUucG9zKyssITB9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlLHQpe3ZhciByLG4saSxzLG8sYSxjLGwsdT17fSxwPXQubGVuZ3RoO2lmKHApe3ZhciBoPTAsZj0tMixkPVtdO2ZvcihyPTA7cjxwO3IrKylpZihpPXRbcl0sZC5wdXNoKDApLHRbaF0ubWFya2VyPT09aS5tYXJrZXImJmY9PT1pLnRva2VuLTF8fChoPXIpLGY9aS50b2tlbixpLmxlbmd0aD1pLmxlbmd0aHx8MCxpLmNsb3NlKXtmb3IodS5oYXNPd25Qcm9wZXJ0eShpLm1hcmtlcil8fCh1W2kubWFya2VyXT1bLTEsLTEsLTEsLTEsLTEsLTFdKSxvPXVbaS5tYXJrZXJdWyhpLm9wZW4/MzowKStpLmxlbmd0aCUzXSxhPW49aC1kW2hdLTE7bj5vO24tPWRbbl0rMSlpZigocz10W25dKS5tYXJrZXI9PT1pLm1hcmtlciYmcy5vcGVuJiZzLmVuZDwwJiYoYz0hMSwocy5jbG9zZXx8aS5vcGVuKSYmKHMubGVuZ3RoK2kubGVuZ3RoKSUzPT0wJiYocy5sZW5ndGglMz09MCYmaS5sZW5ndGglMz09MHx8KGM9ITApKSwhYykpe2w9bj4wJiYhdFtuLTFdLm9wZW4/ZFtuLTFdKzE6MCxkW3JdPXItbitsLGRbbl09bCxpLm9wZW49ITEscy5lbmQ9cixzLmNsb3NlPSExLGE9LTEsZj0tMjticmVha30tMSE9PWEmJih1W2kubWFya2VyXVsoaS5vcGVuPzM6MCkrKGkubGVuZ3RofHwwKSUzXT1hKX19fWUuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdCxyPWUudG9rZW5zX21ldGEsaT1lLnRva2Vuc19tZXRhLmxlbmd0aDtmb3IobigwLGUuZGVsaW1pdGVycyksdD0wO3Q8aTt0Kyspclt0XSYmclt0XS5kZWxpbWl0ZXJzJiZuKDAsclt0XS5kZWxpbWl0ZXJzKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQscixuPTAsaT1lLnRva2VucyxzPWUudG9rZW5zLmxlbmd0aDtmb3IodD1yPTA7dDxzO3QrKylpW3RdLm5lc3Rpbmc8MCYmbi0tLGlbdF0ubGV2ZWw9bixpW3RdLm5lc3Rpbmc+MCYmbisrLFwidGV4dFwiPT09aVt0XS50eXBlJiZ0KzE8cyYmXCJ0ZXh0XCI9PT1pW3QrMV0udHlwZT9pW3QrMV0uY29udGVudD1pW3RdLmNvbnRlbnQraVt0KzFdLmNvbnRlbnQ6KHQhPT1yJiYoaVtyXT1pW3RdKSxyKyspO3QhPT1yJiYoaS5sZW5ndGg9cil9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig1KSxpPXIoMCkuaXNXaGl0ZVNwYWNlLHM9cigwKS5pc1B1bmN0Q2hhcixvPXIoMCkuaXNNZEFzY2lpUHVuY3Q7ZnVuY3Rpb24gYShlLHQscixuKXt0aGlzLnNyYz1lLHRoaXMuZW52PXIsdGhpcy5tZD10LHRoaXMudG9rZW5zPW4sdGhpcy50b2tlbnNfbWV0YT1BcnJheShuLmxlbmd0aCksdGhpcy5wb3M9MCx0aGlzLnBvc01heD10aGlzLnNyYy5sZW5ndGgsdGhpcy5sZXZlbD0wLHRoaXMucGVuZGluZz1cIlwiLHRoaXMucGVuZGluZ0xldmVsPTAsdGhpcy5jYWNoZT17fSx0aGlzLmRlbGltaXRlcnM9W10sdGhpcy5fcHJldl9kZWxpbWl0ZXJzPVtdLHRoaXMuYmFja3RpY2tzPXt9LHRoaXMuYmFja3RpY2tzU2Nhbm5lZD0hMX1hLnByb3RvdHlwZS5wdXNoUGVuZGluZz1mdW5jdGlvbigpe3ZhciBlPW5ldyBuKFwidGV4dFwiLFwiXCIsMCk7cmV0dXJuIGUuY29udGVudD10aGlzLnBlbmRpbmcsZS5sZXZlbD10aGlzLnBlbmRpbmdMZXZlbCx0aGlzLnRva2Vucy5wdXNoKGUpLHRoaXMucGVuZGluZz1cIlwiLGV9LGEucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0LHIpe3RoaXMucGVuZGluZyYmdGhpcy5wdXNoUGVuZGluZygpO3ZhciBpPW5ldyBuKGUsdCxyKSxzPW51bGw7cmV0dXJuIHI8MCYmKHRoaXMubGV2ZWwtLSx0aGlzLmRlbGltaXRlcnM9dGhpcy5fcHJldl9kZWxpbWl0ZXJzLnBvcCgpKSxpLmxldmVsPXRoaXMubGV2ZWwscj4wJiYodGhpcy5sZXZlbCsrLHRoaXMuX3ByZXZfZGVsaW1pdGVycy5wdXNoKHRoaXMuZGVsaW1pdGVycyksdGhpcy5kZWxpbWl0ZXJzPVtdLHM9e2RlbGltaXRlcnM6dGhpcy5kZWxpbWl0ZXJzfSksdGhpcy5wZW5kaW5nTGV2ZWw9dGhpcy5sZXZlbCx0aGlzLnRva2Vucy5wdXNoKGkpLHRoaXMudG9rZW5zX21ldGEucHVzaChzKSxpfSxhLnByb3RvdHlwZS5zY2FuRGVsaW1zPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixhLGMsbCx1LHAsaCxmLGQ9ZSxnPSEwLG09ITAsXz10aGlzLnBvc01heCxiPXRoaXMuc3JjLmNoYXJDb2RlQXQoZSk7Zm9yKHI9ZT4wP3RoaXMuc3JjLmNoYXJDb2RlQXQoZS0xKTozMjtkPF8mJnRoaXMuc3JjLmNoYXJDb2RlQXQoZCk9PT1iOylkKys7cmV0dXJuIGE9ZC1lLG49ZDxfP3RoaXMuc3JjLmNoYXJDb2RlQXQoZCk6MzIscD1vKHIpfHxzKFN0cmluZy5mcm9tQ2hhckNvZGUocikpLGY9byhuKXx8cyhTdHJpbmcuZnJvbUNoYXJDb2RlKG4pKSx1PWkociksKGg9aShuKSk/Zz0hMTpmJiYodXx8cHx8KGc9ITEpKSx1P209ITE6cCYmKGh8fGZ8fChtPSExKSksdD8oYz1nLGw9bSk6KGM9ZyYmKCFtfHxwKSxsPW0mJighZ3x8ZikpLHtjYW5fb3BlbjpjLGNhbl9jbG9zZTpsLGxlbmd0aDphfX0sYS5wcm90b3R5cGUuVG9rZW49bixlLmV4cG9ydHM9YX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4oZSl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QmJk9iamVjdC5rZXlzKHQpLmZvckVhY2goKGZ1bmN0aW9uKHIpe2Vbcl09dFtyXX0pKX0pKSxlfWZ1bmN0aW9uIGkoZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKX1mdW5jdGlvbiBzKGUpe3JldHVyblwiW29iamVjdCBGdW5jdGlvbl1cIj09PWkoZSl9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZS5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csXCJcXFxcJCZcIil9dmFyIGE9e2Z1enp5TGluazohMCxmdXp6eUVtYWlsOiEwLGZ1enp5SVA6ITF9O3ZhciBjPXtcImh0dHA6XCI6e3ZhbGlkYXRlOmZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1lLnNsaWNlKHQpO3JldHVybiByLnJlLmh0dHB8fChyLnJlLmh0dHA9bmV3IFJlZ0V4cChcIl5cXFxcL1xcXFwvXCIrci5yZS5zcmNfYXV0aCtyLnJlLnNyY19ob3N0X3BvcnRfc3RyaWN0K3IucmUuc3JjX3BhdGgsXCJpXCIpKSxyLnJlLmh0dHAudGVzdChuKT9uLm1hdGNoKHIucmUuaHR0cClbMF0ubGVuZ3RoOjB9fSxcImh0dHBzOlwiOlwiaHR0cDpcIixcImZ0cDpcIjpcImh0dHA6XCIsXCIvL1wiOnt2YWxpZGF0ZTpmdW5jdGlvbihlLHQscil7dmFyIG49ZS5zbGljZSh0KTtyZXR1cm4gci5yZS5ub19odHRwfHwoci5yZS5ub19odHRwPW5ldyBSZWdFeHAoXCJeXCIrci5yZS5zcmNfYXV0aCtcIig/OmxvY2FsaG9zdHwoPzooPzpcIityLnJlLnNyY19kb21haW4rXCIpXFxcXC4pK1wiK3IucmUuc3JjX2RvbWFpbl9yb290K1wiKVwiK3IucmUuc3JjX3BvcnQrci5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yK3IucmUuc3JjX3BhdGgsXCJpXCIpKSxyLnJlLm5vX2h0dHAudGVzdChuKT90Pj0zJiZcIjpcIj09PWVbdC0zXXx8dD49MyYmXCIvXCI9PT1lW3QtM10/MDpuLm1hdGNoKHIucmUubm9faHR0cClbMF0ubGVuZ3RoOjB9fSxcIm1haWx0bzpcIjp7dmFsaWRhdGU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUuc2xpY2UodCk7cmV0dXJuIHIucmUubWFpbHRvfHwoci5yZS5tYWlsdG89bmV3IFJlZ0V4cChcIl5cIityLnJlLnNyY19lbWFpbF9uYW1lK1wiQFwiK3IucmUuc3JjX2hvc3Rfc3RyaWN0LFwiaVwiKSksci5yZS5tYWlsdG8udGVzdChuKT9uLm1hdGNoKHIucmUubWFpbHRvKVswXS5sZW5ndGg6MH19fSxsPVwiYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcIi5zcGxpdChcInxcIik7ZnVuY3Rpb24gdShlKXt2YXIgdD1lLnJlPXIoNjkpKGUuX19vcHRzX18pLG49ZS5fX3RsZHNfXy5zbGljZSgpO2Z1bmN0aW9uIGEoZSl7cmV0dXJuIGUucmVwbGFjZShcIiVUTERTJVwiLHQuc3JjX3RsZHMpfWUub25Db21waWxlKCksZS5fX3RsZHNfcmVwbGFjZWRfX3x8bi5wdXNoKFwiYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XVwiKSxuLnB1c2godC5zcmNfeG4pLHQuc3JjX3RsZHM9bi5qb2luKFwifFwiKSx0LmVtYWlsX2Z1enp5PVJlZ0V4cChhKHQudHBsX2VtYWlsX2Z1enp5KSxcImlcIiksdC5saW5rX2Z1enp5PVJlZ0V4cChhKHQudHBsX2xpbmtfZnV6enkpLFwiaVwiKSx0Lmxpbmtfbm9faXBfZnV6enk9UmVnRXhwKGEodC50cGxfbGlua19ub19pcF9mdXp6eSksXCJpXCIpLHQuaG9zdF9mdXp6eV90ZXN0PVJlZ0V4cChhKHQudHBsX2hvc3RfZnV6enlfdGVzdCksXCJpXCIpO3ZhciBjPVtdO2Z1bmN0aW9uIGwoZSx0KXt0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJytlKydcIjogJyt0KX1lLl9fY29tcGlsZWRfXz17fSxPYmplY3Qua2V5cyhlLl9fc2NoZW1hc19fKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgcj1lLl9fc2NoZW1hc19fW3RdO2lmKG51bGwhPT1yKXt2YXIgbj17dmFsaWRhdGU6bnVsbCxsaW5rOm51bGx9O2lmKGUuX19jb21waWxlZF9fW3RdPW4sXCJbb2JqZWN0IE9iamVjdF1cIj09PWkocikpcmV0dXJuIWZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBSZWdFeHBdXCI9PT1pKGUpfShyLnZhbGlkYXRlKT9zKHIudmFsaWRhdGUpP24udmFsaWRhdGU9ci52YWxpZGF0ZTpsKHQscik6bi52YWxpZGF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxyKXt2YXIgbj10LnNsaWNlKHIpO3JldHVybiBlLnRlc3Qobik/bi5tYXRjaChlKVswXS5sZW5ndGg6MH19KHIudmFsaWRhdGUpLHZvaWQocyhyLm5vcm1hbGl6ZSk/bi5ub3JtYWxpemU9ci5ub3JtYWxpemU6ci5ub3JtYWxpemU/bCh0LHIpOm4ubm9ybWFsaXplPWZ1bmN0aW9uKGUsdCl7dC5ub3JtYWxpemUoZSl9KTshZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IFN0cmluZ11cIj09PWkoZSl9KHIpP2wodCxyKTpjLnB1c2godCl9fSkpLGMuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5fX2NvbXBpbGVkX19bZS5fX3NjaGVtYXNfX1t0XV0mJihlLl9fY29tcGlsZWRfX1t0XS52YWxpZGF0ZT1lLl9fY29tcGlsZWRfX1tlLl9fc2NoZW1hc19fW3RdXS52YWxpZGF0ZSxlLl9fY29tcGlsZWRfX1t0XS5ub3JtYWxpemU9ZS5fX2NvbXBpbGVkX19bZS5fX3NjaGVtYXNfX1t0XV0ubm9ybWFsaXplKX0pKSxlLl9fY29tcGlsZWRfX1tcIlwiXT17dmFsaWRhdGU6bnVsbCxub3JtYWxpemU6ZnVuY3Rpb24oZSx0KXt0Lm5vcm1hbGl6ZShlKX19O3ZhciB1PU9iamVjdC5rZXlzKGUuX19jb21waWxlZF9fKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aD4wJiZlLl9fY29tcGlsZWRfX1t0XX0pKS5tYXAobykuam9pbihcInxcIik7ZS5yZS5zY2hlbWFfdGVzdD1SZWdFeHAoXCIoXnwoPyFfKSg/Ols+PO+9nF18XCIrdC5zcmNfWlBDYytcIikpKFwiK3UrXCIpXCIsXCJpXCIpLGUucmUuc2NoZW1hX3NlYXJjaD1SZWdFeHAoXCIoXnwoPyFfKSg/Ols+PO+9nF18XCIrdC5zcmNfWlBDYytcIikpKFwiK3UrXCIpXCIsXCJpZ1wiKSxlLnJlLnByZXRlc3Q9UmVnRXhwKFwiKFwiK2UucmUuc2NoZW1hX3Rlc3Quc291cmNlK1wiKXwoXCIrZS5yZS5ob3N0X2Z1enp5X3Rlc3Quc291cmNlK1wiKXxAXCIsXCJpXCIpLGZ1bmN0aW9uKGUpe2UuX19pbmRleF9fPS0xLGUuX190ZXh0X2NhY2hlX189XCJcIn0oZSl9ZnVuY3Rpb24gcChlLHQpe3ZhciByPWUuX19pbmRleF9fLG49ZS5fX2xhc3RfaW5kZXhfXyxpPWUuX190ZXh0X2NhY2hlX18uc2xpY2UocixuKTt0aGlzLnNjaGVtYT1lLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKSx0aGlzLmluZGV4PXIrdCx0aGlzLmxhc3RJbmRleD1uK3QsdGhpcy5yYXc9aSx0aGlzLnRleHQ9aSx0aGlzLnVybD1pfWZ1bmN0aW9uIGgoZSx0KXt2YXIgcj1uZXcgcChlLHQpO3JldHVybiBlLl9fY29tcGlsZWRfX1tyLnNjaGVtYV0ubm9ybWFsaXplKHIsZSkscn1mdW5jdGlvbiBmKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2YgZikpcmV0dXJuIG5ldyBmKGUsdCk7dmFyIHI7dHx8KHI9ZSxPYmplY3Qua2V5cyhyfHx7fSkucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlfHxhLmhhc093blByb3BlcnR5KHQpfSksITEpJiYodD1lLGU9e30pKSx0aGlzLl9fb3B0c19fPW4oe30sYSx0KSx0aGlzLl9faW5kZXhfXz0tMSx0aGlzLl9fbGFzdF9pbmRleF9fPS0xLHRoaXMuX19zY2hlbWFfXz1cIlwiLHRoaXMuX190ZXh0X2NhY2hlX189XCJcIix0aGlzLl9fc2NoZW1hc19fPW4oe30sYyxlKSx0aGlzLl9fY29tcGlsZWRfXz17fSx0aGlzLl9fdGxkc19fPWwsdGhpcy5fX3RsZHNfcmVwbGFjZWRfXz0hMSx0aGlzLnJlPXt9LHUodGhpcyl9Zi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX19zY2hlbWFzX19bZV09dCx1KHRoaXMpLHRoaXN9LGYucHJvdG90eXBlLnNldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fX29wdHNfXz1uKHRoaXMuX19vcHRzX18sZSksdGhpc30sZi5wcm90b3R5cGUudGVzdD1mdW5jdGlvbihlKXtpZih0aGlzLl9fdGV4dF9jYWNoZV9fPWUsdGhpcy5fX2luZGV4X189LTEsIWUubGVuZ3RoKXJldHVybiExO3ZhciB0LHIsbixpLHMsbyxhLGM7aWYodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KGUpKWZvcigoYT10aGlzLnJlLnNjaGVtYV9zZWFyY2gpLmxhc3RJbmRleD0wO251bGwhPT0odD1hLmV4ZWMoZSkpOylpZihpPXRoaXMudGVzdFNjaGVtYUF0KGUsdFsyXSxhLmxhc3RJbmRleCkpe3RoaXMuX19zY2hlbWFfXz10WzJdLHRoaXMuX19pbmRleF9fPXQuaW5kZXgrdFsxXS5sZW5ndGgsdGhpcy5fX2xhc3RfaW5kZXhfXz10LmluZGV4K3RbMF0ubGVuZ3RoK2k7YnJlYWt9cmV0dXJuIHRoaXMuX19vcHRzX18uZnV6enlMaW5rJiZ0aGlzLl9fY29tcGlsZWRfX1tcImh0dHA6XCJdJiYoYz1lLnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdCkpPj0wJiYodGhpcy5fX2luZGV4X188MHx8Yzx0aGlzLl9faW5kZXhfXykmJm51bGwhPT0ocj1lLm1hdGNoKHRoaXMuX19vcHRzX18uZnV6enlJUD90aGlzLnJlLmxpbmtfZnV6enk6dGhpcy5yZS5saW5rX25vX2lwX2Z1enp5KSkmJihzPXIuaW5kZXgrclsxXS5sZW5ndGgsKHRoaXMuX19pbmRleF9fPDB8fHM8dGhpcy5fX2luZGV4X18pJiYodGhpcy5fX3NjaGVtYV9fPVwiXCIsdGhpcy5fX2luZGV4X189cyx0aGlzLl9fbGFzdF9pbmRleF9fPXIuaW5kZXgrclswXS5sZW5ndGgpKSx0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwmJnRoaXMuX19jb21waWxlZF9fW1wibWFpbHRvOlwiXSYmZS5pbmRleE9mKFwiQFwiKT49MCYmbnVsbCE9PShuPWUubWF0Y2godGhpcy5yZS5lbWFpbF9mdXp6eSkpJiYocz1uLmluZGV4K25bMV0ubGVuZ3RoLG89bi5pbmRleCtuWzBdLmxlbmd0aCwodGhpcy5fX2luZGV4X188MHx8czx0aGlzLl9faW5kZXhfX3x8cz09PXRoaXMuX19pbmRleF9fJiZvPnRoaXMuX19sYXN0X2luZGV4X18pJiYodGhpcy5fX3NjaGVtYV9fPVwibWFpbHRvOlwiLHRoaXMuX19pbmRleF9fPXMsdGhpcy5fX2xhc3RfaW5kZXhfXz1vKSksdGhpcy5fX2luZGV4X18+PTB9LGYucHJvdG90eXBlLnByZXRlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmUucHJldGVzdC50ZXN0KGUpfSxmLnByb3RvdHlwZS50ZXN0U2NoZW1hQXQ9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB0aGlzLl9fY29tcGlsZWRfX1t0LnRvTG93ZXJDYXNlKCldP3RoaXMuX19jb21waWxlZF9fW3QudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUoZSxyLHRoaXMpOjB9LGYucHJvdG90eXBlLm1hdGNoPWZ1bmN0aW9uKGUpe3ZhciB0PTAscj1bXTt0aGlzLl9faW5kZXhfXz49MCYmdGhpcy5fX3RleHRfY2FjaGVfXz09PWUmJihyLnB1c2goaCh0aGlzLHQpKSx0PXRoaXMuX19sYXN0X2luZGV4X18pO2Zvcih2YXIgbj10P2Uuc2xpY2UodCk6ZTt0aGlzLnRlc3Qobik7KXIucHVzaChoKHRoaXMsdCkpLG49bi5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKSx0Kz10aGlzLl9fbGFzdF9pbmRleF9fO3JldHVybiByLmxlbmd0aD9yOm51bGx9LGYucHJvdG90eXBlLnRsZHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1BcnJheS5pc0FycmF5KGUpP2U6W2VdLHQ/KHRoaXMuX190bGRzX189dGhpcy5fX3RsZHNfXy5jb25jYXQoZSkuc29ydCgpLmZpbHRlcigoZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlIT09clt0LTFdfSkpLnJldmVyc2UoKSx1KHRoaXMpLHRoaXMpOih0aGlzLl9fdGxkc19fPWUuc2xpY2UoKSx0aGlzLl9fdGxkc19yZXBsYWNlZF9fPSEwLHUodGhpcyksdGhpcyl9LGYucHJvdG90eXBlLm5vcm1hbGl6ZT1mdW5jdGlvbihlKXtlLnNjaGVtYXx8KGUudXJsPVwiaHR0cDovL1wiK2UudXJsKSxcIm1haWx0bzpcIiE9PWUuc2NoZW1hfHwvXm1haWx0bzovaS50ZXN0KGUudXJsKXx8KGUudXJsPVwibWFpbHRvOlwiK2UudXJsKX0sZi5wcm90b3R5cGUub25Db21waWxlPWZ1bmN0aW9uKCl7fSxlLmV4cG9ydHM9Zn0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdD17fTt0LnNyY19Bbnk9cig5KS5zb3VyY2UsdC5zcmNfQ2M9cigxMCkuc291cmNlLHQuc3JjX1o9cigxMSkuc291cmNlLHQuc3JjX1A9cigzKS5zb3VyY2UsdC5zcmNfWlBDYz1bdC5zcmNfWix0LnNyY19QLHQuc3JjX0NjXS5qb2luKFwifFwiKSx0LnNyY19aQ2M9W3Quc3JjX1osdC5zcmNfQ2NdLmpvaW4oXCJ8XCIpO3JldHVybiB0LnNyY19wc2V1ZG9fbGV0dGVyPVwiKD86KD8hWz48772cXXxcIit0LnNyY19aUENjK1wiKVwiK3Quc3JjX0FueStcIilcIix0LnNyY19pcDQ9XCIoPzooMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcXFwuKXszfSgyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXCIsdC5zcmNfYXV0aD1cIig/Oig/Oig/IVwiK3Quc3JjX1pDYytcInxbQC9cXFxcW1xcXFxdKCldKS4pK0ApP1wiLHQuc3JjX3BvcnQ9XCIoPzo6KD86Nig/OlswLTRdXFxcXGR7M318NSg/OlswLTRdXFxcXGR7Mn18NSg/OlswLTJdXFxcXGR8M1swLTVdKSkpfFsxLTVdP1xcXFxkezEsNH0pKT9cIix0LnNyY19ob3N0X3Rlcm1pbmF0b3I9XCIoPz0kfFs+PO+9nF18XCIrdC5zcmNfWlBDYytcIikoPyEtfF98OlxcXFxkfFxcXFwuLXxcXFxcLig/ISR8XCIrdC5zcmNfWlBDYytcIikpXCIsdC5zcmNfcGF0aD1cIig/OlsvPyNdKD86KD8hXCIrdC5zcmNfWkNjK1wifFs+PO+9nF18WygpW1xcXFxde30uLFxcXCInPyFcXFxcLV0pLnxcXFxcWyg/Oig/IVwiK3Quc3JjX1pDYytcInxcXFxcXSkuKSpcXFxcXXxcXFxcKCg/Oig/IVwiK3Quc3JjX1pDYytcInxbKV0pLikqXFxcXCl8XFxcXHsoPzooPyFcIit0LnNyY19aQ2MrJ3xbfV0pLikqXFxcXH18XFxcXFwiKD86KD8hJyt0LnNyY19aQ2MrJ3xbXCJdKS4pK1xcXFxcInxcXFxcXFwnKD86KD8hJyt0LnNyY19aQ2MrXCJ8WyddKS4pK1xcXFwnfFxcXFwnKD89XCIrdC5zcmNfcHNldWRvX2xldHRlcitcInxbLV0pLnxcXFxcLnsyLH1bYS16QS1aMC05JS8mXXxcXFxcLig/IVwiK3Quc3JjX1pDYytcInxbLl0pLnxcIisoZSYmZVtcIi0tLVwiXT9cIlxcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXxcIjpcIlxcXFwtK3xcIikrXCJcXFxcLCg/IVwiK3Quc3JjX1pDYytcIikufFxcXFwhKyg/IVwiK3Quc3JjX1pDYytcInxbIV0pLnxcXFxcPyg/IVwiK3Quc3JjX1pDYytcInxbP10pLikrfFxcXFwvKT9cIix0LnNyY19lbWFpbF9uYW1lPSdbXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcLmEtekEtWjAtOV9dW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXFwiXFxcXC5hLXpBLVowLTlfXSonLHQuc3JjX3huPVwieG4tLVthLXowLTlcXFxcLV17MSw1OX1cIix0LnNyY19kb21haW5fcm9vdD1cIig/OlwiK3Quc3JjX3huK1wifFwiK3Quc3JjX3BzZXVkb19sZXR0ZXIrXCJ7MSw2M30pXCIsdC5zcmNfZG9tYWluPVwiKD86XCIrdC5zcmNfeG4rXCJ8KD86XCIrdC5zcmNfcHNldWRvX2xldHRlcitcIil8KD86XCIrdC5zcmNfcHNldWRvX2xldHRlcitcIig/Oi18XCIrdC5zcmNfcHNldWRvX2xldHRlcitcIil7MCw2MX1cIit0LnNyY19wc2V1ZG9fbGV0dGVyK1wiKSlcIix0LnNyY19ob3N0PVwiKD86KD86KD86KD86XCIrdC5zcmNfZG9tYWluK1wiKVxcXFwuKSpcIit0LnNyY19kb21haW4rXCIpKVwiLHQudHBsX2hvc3RfZnV6enk9XCIoPzpcIit0LnNyY19pcDQrXCJ8KD86KD86KD86XCIrdC5zcmNfZG9tYWluK1wiKVxcXFwuKSsoPzolVExEUyUpKSlcIix0LnRwbF9ob3N0X25vX2lwX2Z1enp5PVwiKD86KD86KD86XCIrdC5zcmNfZG9tYWluK1wiKVxcXFwuKSsoPzolVExEUyUpKVwiLHQuc3JjX2hvc3Rfc3RyaWN0PXQuc3JjX2hvc3QrdC5zcmNfaG9zdF90ZXJtaW5hdG9yLHQudHBsX2hvc3RfZnV6enlfc3RyaWN0PXQudHBsX2hvc3RfZnV6enkrdC5zcmNfaG9zdF90ZXJtaW5hdG9yLHQuc3JjX2hvc3RfcG9ydF9zdHJpY3Q9dC5zcmNfaG9zdCt0LnNyY19wb3J0K3Quc3JjX2hvc3RfdGVybWluYXRvcix0LnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0PXQudHBsX2hvc3RfZnV6enkrdC5zcmNfcG9ydCt0LnNyY19ob3N0X3Rlcm1pbmF0b3IsdC50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdD10LnRwbF9ob3N0X25vX2lwX2Z1enp5K3Quc3JjX3BvcnQrdC5zcmNfaG9zdF90ZXJtaW5hdG9yLHQudHBsX2hvc3RfZnV6enlfdGVzdD1cImxvY2FsaG9zdHx3d3dcXFxcLnxcXFxcLlxcXFxkezEsM31cXFxcLnwoPzpcXFxcLig/OiVUTERTJSkoPzpcIit0LnNyY19aUENjK1wifD58JCkpXCIsdC50cGxfZW1haWxfZnV6enk9JyhefFs+PO+9nF18XCJ8XFxcXCh8Jyt0LnNyY19aQ2MrXCIpKFwiK3Quc3JjX2VtYWlsX25hbWUrXCJAXCIrdC50cGxfaG9zdF9mdXp6eV9zdHJpY3QrXCIpXCIsdC50cGxfbGlua19mdXp6eT1cIihefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHzvvZxdfFwiK3Quc3JjX1pQQ2MrXCIpKSgoPyFbJCs8PT5eYHzvvZxdKVwiK3QudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QrdC5zcmNfcGF0aCtcIilcIix0LnRwbF9saW5rX25vX2lwX2Z1enp5PVwiKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfO+9nF18XCIrdC5zcmNfWlBDYytcIikpKCg/IVskKzw9Pl5gfO+9nF0pXCIrdC50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCt0LnNyY19wYXRoK1wiKVwiLHR9fSxmdW5jdGlvbihlLHQscil7KGZ1bmN0aW9uKGUsbil7dmFyIGk7LyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi8hZnVuY3Rpb24ocyl7dCYmdC5ub2RlVHlwZSxlJiZlLm5vZGVUeXBlO3ZhciBvPVwib2JqZWN0XCI9PXR5cGVvZiBuJiZuO28uZ2xvYmFsIT09byYmby53aW5kb3chPT1vJiZvLnNlbGY7dmFyIGEsYz0yMTQ3NDgzNjQ3LGw9L154bi0tLyx1PS9bXlxceDIwLVxceDdFXS8scD0vW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLGg9e292ZXJmbG93OlwiT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3NcIixcIm5vdC1iYXNpY1wiOlwiSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KVwiLFwiaW52YWxpZC1pbnB1dFwiOlwiSW52YWxpZCBpbnB1dFwifSxmPU1hdGguZmxvb3IsZD1TdHJpbmcuZnJvbUNoYXJDb2RlO2Z1bmN0aW9uIGcoZSl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoaFtlXSl9ZnVuY3Rpb24gbShlLHQpe2Zvcih2YXIgcj1lLmxlbmd0aCxuPVtdO3ItLTspbltyXT10KGVbcl0pO3JldHVybiBufWZ1bmN0aW9uIF8oZSx0KXt2YXIgcj1lLnNwbGl0KFwiQFwiKSxuPVwiXCI7cmV0dXJuIHIubGVuZ3RoPjEmJihuPXJbMF0rXCJAXCIsZT1yWzFdKSxuK20oKGU9ZS5yZXBsYWNlKHAsXCIuXCIpKS5zcGxpdChcIi5cIiksdCkuam9pbihcIi5cIil9ZnVuY3Rpb24gYihlKXtmb3IodmFyIHQscixuPVtdLGk9MCxzPWUubGVuZ3RoO2k8czspKHQ9ZS5jaGFyQ29kZUF0KGkrKykpPj01NTI5NiYmdDw9NTYzMTkmJmk8cz81NjMyMD09KDY0NTEyJihyPWUuY2hhckNvZGVBdChpKyspKSk/bi5wdXNoKCgoMTAyMyZ0KTw8MTApKygxMDIzJnIpKzY1NTM2KToobi5wdXNoKHQpLGktLSk6bi5wdXNoKHQpO3JldHVybiBufWZ1bmN0aW9uIGsoZSl7cmV0dXJuIG0oZSwoZnVuY3Rpb24oZSl7dmFyIHQ9XCJcIjtyZXR1cm4gZT42NTUzNSYmKHQrPWQoKGUtPTY1NTM2KT4+PjEwJjEwMjN8NTUyOTYpLGU9NTYzMjB8MTAyMyZlKSx0Kz1kKGUpfSkpLmpvaW4oXCJcIil9ZnVuY3Rpb24gdihlLHQpe3JldHVybiBlKzIyKzc1KihlPDI2KS0oKDAhPXQpPDw1KX1mdW5jdGlvbiB5KGUsdCxyKXt2YXIgbj0wO2ZvcihlPXI/ZihlLzcwMCk6ZT4+MSxlKz1mKGUvdCk7ZT40NTU7bis9MzYpZT1mKGUvMzUpO3JldHVybiBmKG4rMzYqZS8oZSszOCkpfWZ1bmN0aW9uIHgoZSl7dmFyIHQscixuLGkscyxvLGEsbCx1LHAsaCxkPVtdLG09ZS5sZW5ndGgsXz0wLGI9MTI4LHY9NzI7Zm9yKChyPWUubGFzdEluZGV4T2YoXCItXCIpKTwwJiYocj0wKSxuPTA7bjxyOysrbillLmNoYXJDb2RlQXQobik+PTEyOCYmZyhcIm5vdC1iYXNpY1wiKSxkLnB1c2goZS5jaGFyQ29kZUF0KG4pKTtmb3IoaT1yPjA/cisxOjA7aTxtOyl7Zm9yKHM9XyxvPTEsYT0zNjtpPj1tJiZnKFwiaW52YWxpZC1pbnB1dFwiKSwoKGw9KGg9ZS5jaGFyQ29kZUF0KGkrKykpLTQ4PDEwP2gtMjI6aC02NTwyNj9oLTY1OmgtOTc8MjY/aC05NzozNik+PTM2fHxsPmYoKGMtXykvbykpJiZnKFwib3ZlcmZsb3dcIiksXys9bCpvLCEobDwodT1hPD12PzE6YT49disyNj8yNjphLXYpKTthKz0zNilvPmYoYy8ocD0zNi11KSkmJmcoXCJvdmVyZmxvd1wiKSxvKj1wO3Y9eShfLXMsdD1kLmxlbmd0aCsxLDA9PXMpLGYoXy90KT5jLWImJmcoXCJvdmVyZmxvd1wiKSxiKz1mKF8vdCksXyU9dCxkLnNwbGljZShfKyssMCxiKX1yZXR1cm4gayhkKX1mdW5jdGlvbiBDKGUpe3ZhciB0LHIsbixpLHMsbyxhLGwsdSxwLGgsbSxfLGsseCxDPVtdO2ZvcihtPShlPWIoZSkpLmxlbmd0aCx0PTEyOCxyPTAscz03MixvPTA7bzxtOysrbykoaD1lW29dKTwxMjgmJkMucHVzaChkKGgpKTtmb3Iobj1pPUMubGVuZ3RoLGkmJkMucHVzaChcIi1cIik7bjxtOyl7Zm9yKGE9YyxvPTA7bzxtOysrbykoaD1lW29dKT49dCYmaDxhJiYoYT1oKTtmb3IoYS10PmYoKGMtcikvKF89bisxKSkmJmcoXCJvdmVyZmxvd1wiKSxyKz0oYS10KSpfLHQ9YSxvPTA7bzxtOysrbylpZigoaD1lW29dKTx0JiYrK3I+YyYmZyhcIm92ZXJmbG93XCIpLGg9PXQpe2ZvcihsPXIsdT0zNjshKGw8KHA9dTw9cz8xOnU+PXMrMjY/MjY6dS1zKSk7dSs9MzYpeD1sLXAsaz0zNi1wLEMucHVzaChkKHYocCt4JWssMCkpKSxsPWYoeC9rKTtDLnB1c2goZCh2KGwsMCkpKSxzPXkocixfLG49PWkpLHI9MCwrK259KytyLCsrdH1yZXR1cm4gQy5qb2luKFwiXCIpfWE9e3ZlcnNpb246XCIxLjQuMVwiLHVjczI6e2RlY29kZTpiLGVuY29kZTprfSxkZWNvZGU6eCxlbmNvZGU6Qyx0b0FTQ0lJOmZ1bmN0aW9uKGUpe3JldHVybiBfKGUsKGZ1bmN0aW9uKGUpe3JldHVybiB1LnRlc3QoZSk/XCJ4bi0tXCIrQyhlKTplfSkpfSx0b1VuaWNvZGU6ZnVuY3Rpb24oZSl7cmV0dXJuIF8oZSwoZnVuY3Rpb24oZSl7cmV0dXJuIGwudGVzdChlKT94KGUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSk6ZX0pKX19LHZvaWQgMD09PShpPWZ1bmN0aW9uKCl7cmV0dXJuIGF9LmNhbGwodCxyLHQsZSkpfHwoZS5leHBvcnRzPWkpfSgpfSkuY2FsbCh0aGlzLHIoNzEpKGUpLHIoNzIpKX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUud2VicGFja1BvbHlmaWxsfHwoZS5kZXByZWNhdGU9ZnVuY3Rpb24oKXt9LGUucGF0aHM9W10sZS5jaGlsZHJlbnx8KGUuY2hpbGRyZW49W10pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwibG9hZGVkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUubH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImlkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuaX19KSxlLndlYnBhY2tQb2x5ZmlsbD0xKSxlfX0sZnVuY3Rpb24oZSx0KXt2YXIgcjtyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3I9cnx8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaChlKXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYocj13aW5kb3cpfWUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXtvcHRpb25zOntodG1sOiExLHhodG1sT3V0OiExLGJyZWFrczohMSxsYW5nUHJlZml4OlwibGFuZ3VhZ2UtXCIsbGlua2lmeTohMSx0eXBvZ3JhcGhlcjohMSxxdW90ZXM6XCLigJzigJ3igJjigJlcIixoaWdobGlnaHQ6bnVsbCxtYXhOZXN0aW5nOjEwMH0sY29tcG9uZW50czp7Y29yZTp7fSxibG9jazp7fSxpbmxpbmU6e319fX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17b3B0aW9uczp7aHRtbDohMSx4aHRtbE91dDohMSxicmVha3M6ITEsbGFuZ1ByZWZpeDpcImxhbmd1YWdlLVwiLGxpbmtpZnk6ITEsdHlwb2dyYXBoZXI6ITEscXVvdGVzOlwi4oCc4oCd4oCY4oCZXCIsaGlnaGxpZ2h0Om51bGwsbWF4TmVzdGluZzoyMH0sY29tcG9uZW50czp7Y29yZTp7cnVsZXM6W1wibm9ybWFsaXplXCIsXCJibG9ja1wiLFwiaW5saW5lXCJdfSxibG9jazp7cnVsZXM6W1wicGFyYWdyYXBoXCJdfSxpbmxpbmU6e3J1bGVzOltcInRleHRcIl0scnVsZXMyOltcImJhbGFuY2VfcGFpcnNcIixcInRleHRfY29sbGFwc2VcIl19fX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e29wdGlvbnM6e2h0bWw6ITAseGh0bWxPdXQ6ITAsYnJlYWtzOiExLGxhbmdQcmVmaXg6XCJsYW5ndWFnZS1cIixsaW5raWZ5OiExLHR5cG9ncmFwaGVyOiExLHF1b3RlczpcIuKAnOKAneKAmOKAmVwiLGhpZ2hsaWdodDpudWxsLG1heE5lc3Rpbmc6MjB9LGNvbXBvbmVudHM6e2NvcmU6e3J1bGVzOltcIm5vcm1hbGl6ZVwiLFwiYmxvY2tcIixcImlubGluZVwiXX0sYmxvY2s6e3J1bGVzOltcImJsb2NrcXVvdGVcIixcImNvZGVcIixcImZlbmNlXCIsXCJoZWFkaW5nXCIsXCJoclwiLFwiaHRtbF9ibG9ja1wiLFwibGhlYWRpbmdcIixcImxpc3RcIixcInJlZmVyZW5jZVwiLFwicGFyYWdyYXBoXCJdfSxpbmxpbmU6e3J1bGVzOltcImF1dG9saW5rXCIsXCJiYWNrdGlja3NcIixcImVtcGhhc2lzXCIsXCJlbnRpdHlcIixcImVzY2FwZVwiLFwiaHRtbF9pbmxpbmVcIixcImltYWdlXCIsXCJsaW5rXCIsXCJuZXdsaW5lXCIsXCJ0ZXh0XCJdLHJ1bGVzMjpbXCJiYWxhbmNlX3BhaXJzXCIsXCJlbXBoYXNpc1wiLFwidGV4dF9jb2xsYXBzZVwiXX19fX0sLGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtyLnIodCksci5kKHQsXCJkZWZhdWx0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHN9KSk7dmFyIG49cigxNyksaT1yKDIpO2Z1bmN0aW9uIHMoZSl7dmFyIHQ9dm9pZCAwPT09ZT97fTplLHI9dC5QcmlzbSxzPXQuYmFzZUNvbmZpZyxvPXQuY29kZUJsb2NrQ2xhc3MsYT10LmNvZGVIaWdobGlnaHRFeHRlbnNpb25NYXAsYz12b2lkIDA9PT1hP3t9OmEsbD1PYmplY3Qobi5kZWZhdWx0KShzKTtyZXR1cm4gbC5leHRlbmQoKGZ1bmN0aW9uKGUpe2Uuc2V0KHtoaWdobGlnaHQ6T2JqZWN0KGkuYSkoe2NvZGVIaWdobGlnaHRFeHRlbnNpb25NYXA6YyxoYXNMYW5nOmZ1bmN0aW9uKGUpe3JldHVybiByLmxhbmd1YWdlc1tlXX0sY29kZUJsb2NrQ2xhc3M6byxoaWdobGlnaHQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gci5oaWdobGlnaHQoZSxyLmxhbmd1YWdlc1t0XSx0KX19KX0pfSkpLHtwcmV2aWV3Q2xhc3M6XCJtYXJrZG93bi1ib2R5XCIsZXh0ZW5kOmZ1bmN0aW9uKGUpe2wuZXh0ZW5kKChmdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSsrKW5baV09YXJndW1lbnRzW2ldO2UuYXBwbHkodm9pZCAwLG4uY29uY2F0KFtyXSkpfSkpfSxtYXJrZG93blBhcnNlcjpsLm1hcmtkb3duUGFyc2VyfX19LCxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ci5yKHQpO3ZhciBuPXIoMSksaT1yKDc3KTt0LmRlZmF1bHQ9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD17fSk7dmFyIHI9dCxzPXIuZXh0ZW5kLG89ci5jb25maWcsYT1yLmNvZGVIaWdobGlnaHRFeHRlbnNpb25NYXAsYz1mdW5jdGlvbihlKXt2YXIgdD1PYmplY3QoaS5kZWZhdWx0KSh7UHJpc206ZS5QcmlzbSxjb2RlSGlnaGxpZ2h0RXh0ZW5zaW9uTWFwOmUuY29kZUhpZ2hsaWdodEV4dGVuc2lvbk1hcHx8e30sY29kZUJsb2NrQ2xhc3M6ZS5jb2RlQmxvY2tDbGFzc3x8ZnVuY3Rpb24oZSl7cmV0dXJuXCJ2LW1kLXByaXNtLVwiK2V9LGJhc2VDb25maWc6T2JqZWN0KG4uYSkoe2xpbms6e29wZW5MaW5rSWNvbjohMH19LGUuYmFzZUNvbmZpZyl9KTtyZXR1cm57cHJldmlld0NsYXNzOlwidnVlcHJlc3MtbWFya2Rvd24tYm9keVwiLGV4dGVuZDpmdW5jdGlvbihlKXt0LmV4dGVuZChlKX0sbWFya2Rvd25QYXJzZXI6dC5tYXJrZG93blBhcnNlcn19KHtQcmlzbTpyLlByaXNtLGJhc2VDb25maWc6byxjb2RlSGlnaGxpZ2h0RXh0ZW5zaW9uTWFwOmF9KTtzJiZjLmV4dGVuZChzKSxlLnRoZW1lKGMpfX0sZnVuY3Rpb24oZSx0LHIpe30sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7dmFyIG49KHI9cnx8e30pLm1hcmtlcnx8XCI6XCIsaT1uLmNoYXJDb2RlQXQoMCkscz1uLmxlbmd0aCxvPXIudmFsaWRhdGV8fGZ1bmN0aW9uKGUpe3JldHVybiBlLnRyaW0oKS5zcGxpdChcIiBcIiwyKVswXT09PXR9LGE9ci5yZW5kZXJ8fGZ1bmN0aW9uKGUscixuLGkscyl7cmV0dXJuIDE9PT1lW3JdLm5lc3RpbmcmJmVbcl0uYXR0ckpvaW4oXCJjbGFzc1wiLHQpLHMucmVuZGVyVG9rZW4oZSxyLG4saSxzKX07ZS5ibG9jay5ydWxlci5iZWZvcmUoXCJmZW5jZVwiLFwiY29udGFpbmVyX1wiK3QsKGZ1bmN0aW9uKGUscixhLGMpe3ZhciBsLHUscCxoLGYsZCxnLG0sXz0hMSxiPWUuYk1hcmtzW3JdK2UudFNoaWZ0W3JdLGs9ZS5lTWFya3Nbcl07aWYoaSE9PWUuc3JjLmNoYXJDb2RlQXQoYikpcmV0dXJuITE7Zm9yKGw9YisxO2w8PWsmJm5bKGwtYiklc109PT1lLnNyY1tsXTtsKyspO2lmKChwPU1hdGguZmxvb3IoKGwtYikvcykpPDMpcmV0dXJuITE7aWYobC09KGwtYiklcyxoPWUuc3JjLnNsaWNlKGIsbCksZj1lLnNyYy5zbGljZShsLGspLCFvKGYsaCkpcmV0dXJuITE7aWYoYylyZXR1cm4hMDtmb3IodT1yOyEoKyt1Pj1hKSYmISgoYj1lLmJNYXJrc1t1XStlLnRTaGlmdFt1XSk8KGs9ZS5lTWFya3NbdV0pJiZlLnNDb3VudFt1XTxlLmJsa0luZGVudCk7KWlmKGk9PT1lLnNyYy5jaGFyQ29kZUF0KGIpJiYhKGUuc0NvdW50W3VdLWUuYmxrSW5kZW50Pj00KSl7Zm9yKGw9YisxO2w8PWsmJm5bKGwtYiklc109PT1lLnNyY1tsXTtsKyspO2lmKCEoTWF0aC5mbG9vcigobC1iKS9zKTxwfHwobC09KGwtYiklcywobD1lLnNraXBTcGFjZXMobCkpPGspKSl7Xz0hMDticmVha319cmV0dXJuIGc9ZS5wYXJlbnRUeXBlLG09ZS5saW5lTWF4LGUucGFyZW50VHlwZT1cImNvbnRhaW5lclwiLGUubGluZU1heD11LChkPWUucHVzaChcImNvbnRhaW5lcl9cIit0K1wiX29wZW5cIixcImRpdlwiLDEpKS5tYXJrdXA9aCxkLmJsb2NrPSEwLGQuaW5mbz1mLGQubWFwPVtyLHVdLGUubWQuYmxvY2sudG9rZW5pemUoZSxyKzEsdSksKGQ9ZS5wdXNoKFwiY29udGFpbmVyX1wiK3QrXCJfY2xvc2VcIixcImRpdlwiLC0xKSkubWFya3VwPWUuc3JjLnNsaWNlKGIsbCksZC5ibG9jaz0hMCxlLnBhcmVudFR5cGU9ZyxlLmxpbmVNYXg9bSxlLmxpbmU9dSsoXz8xOjApLCEwfSkse2FsdDpbXCJwYXJhZ3JhcGhcIixcInJlZmVyZW5jZVwiLFwiYmxvY2txdW90ZVwiLFwibGlzdFwiXX0pLGUucmVuZGVyZXIucnVsZXNbXCJjb250YWluZXJfXCIrdCtcIl9vcGVuXCJdPWEsZS5yZW5kZXJlci5ydWxlc1tcImNvbnRhaW5lcl9cIit0K1wiX2Nsb3NlXCJdPWF9fSwsLGZ1bmN0aW9uKGUsdCxyKXt9LGZ1bmN0aW9uKGUsdCxyKXt9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtyLnIodCk7dmFyIG49cig3OSksaT1yKDgxKSxzPXIubihpKTtmdW5jdGlvbiBvKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP2Z1bmN0aW9uKCl7cmV0dXJuIGV9OmV9dmFyIGE9ZnVuY3Rpb24oZSx0KXt2YXIgcj10LnZhbGlkYXRlLG49dC5tYXJrZXIsaT10LnJlbmRlcixhPXQudHlwZSxjPXQuYmVmb3JlLGw9dC5hZnRlcix1PXQuZGVmYXVsdFRpdGxlLHA9dm9pZCAwPT09dT9hLnRvVXBwZXJDYXNlKCk6dSxoPXQuYmxvY2tDbGFzcyxmPXZvaWQgMD09PWg/XCJjdXN0b20tYmxvY2tcIjpoO2lmKGEpe3ZhciBkLGc7aWYoIWkpdm9pZCAwIT09YyYmdm9pZCAwIT09bD8oZD1vKGMpLGc9byhsKSk6KGQ9ZnVuY3Rpb24oZSl7cmV0dXJuJzxkaXYgY2xhc3M9XCInK2YrXCIgXCIrYSsnXCI+JysoZT8nPHAgY2xhc3M9XCInK2YrJy10aXRsZVwiPicrZStcIjwvcD5cIjpcIlwiKStcIlxcblwifSxnPWZ1bmN0aW9uKCl7cmV0dXJuXCI8L2Rpdj5cXG5cIn0pLGk9ZnVuY3Rpb24oZSx0KXt2YXIgcj1lW3RdLG49ci5pbmZvLnRyaW0oKS5zbGljZShhLmxlbmd0aCkudHJpbSgpO3JldHVybiFuJiZwJiYobj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBwP3AoKTpwKSwxPT09ci5uZXN0aW5nP2Qobik6ZyhuKX07ZS51c2Uocy5hLGEse3JlbmRlcjppLHZhbGlkYXRlOnIsbWFya2VyOm59KX19LGM9ZnVuY3Rpb24oZSl7ZS5leHRlbmRNYXJrZG93bigoZnVuY3Rpb24odCl7dmFyIHI9ZnVuY3Rpb24oKXt2YXIgdD1lLmxhbmcuY29uZmlnO3JldHVybiB0LmxhbmdDb25maWdbdC5sYW5nXX07YSh0LHt0eXBlOlwidGlwXCIsZGVmYXVsdFRpdGxlOmZ1bmN0aW9uKCl7cmV0dXJuIHIoKS50aXAudGlwLmRlZmF1bHRUaXRsZX0sYmxvY2tDbGFzczpcInYtbWQtcGx1Z2luLXRpcFwifSksYSh0LHt0eXBlOlwid2FybmluZ1wiLGRlZmF1bHRUaXRsZTpmdW5jdGlvbigpe3JldHVybiByKCkudGlwLndhcm5pbmcuZGVmYXVsdFRpdGxlfSxibG9ja0NsYXNzOlwidi1tZC1wbHVnaW4tdGlwXCJ9KSxhKHQse3R5cGU6XCJkYW5nZXJcIixkZWZhdWx0VGl0bGU6ZnVuY3Rpb24oKXtyZXR1cm4gcigpLnRpcC5kYW5nZXIuZGVmYXVsdFRpdGxlfSxibG9ja0NsYXNzOlwidi1tZC1wbHVnaW4tdGlwXCJ9KSxhKHQse3R5cGU6XCJkZXRhaWxzXCIsZGVmYXVsdFRpdGxlOmZ1bmN0aW9uKCl7cmV0dXJuIHIoKS50aXAuZGV0YWlscy5kZWZhdWx0VGl0bGV9LGJlZm9yZTpmdW5jdGlvbihlKXtyZXR1cm4nPGRldGFpbHMgY2xhc3M9XCJ2LW1kLXBsdWdpbi10aXAgZGV0YWlsc1wiPicrKGU/XCI8c3VtbWFyeT5cIitlK1wiPC9zdW1tYXJ5PlwiOlwiXCIpK1wiXFxuXCJ9LGFmdGVyOmZ1bmN0aW9uKCl7cmV0dXJuXCI8L2RldGFpbHM+XFxuXCJ9fSl9KSksZS5sYW5nLmFkZCh7XCJ6aC1DTlwiOnt0aXA6e3RpcDp7ZGVmYXVsdFRpdGxlOlwi5o+Q56S6XCJ9LHdhcm5pbmc6e2RlZmF1bHRUaXRsZTpcIuazqOaEj1wifSxkYW5nZXI6e2RlZmF1bHRUaXRsZTpcIuitpuWRilwifSxkZXRhaWxzOntkZWZhdWx0VGl0bGU6XCLor6bnu4bkv6Hmga9cIn19fSxcImVuLVVTXCI6e3RpcDp7dGlwOntkZWZhdWx0VGl0bGU6XCJUSVBcIn0sd2FybmluZzp7ZGVmYXVsdFRpdGxlOlwiV0FSTklOR1wifSxkYW5nZXI6e2RlZmF1bHRUaXRsZTpcIkRBTkdFUlwifSxkZXRhaWxzOntkZWZhdWx0VGl0bGU6XCJERVRBSUxTXCJ9fX19KX07cig4MCkscig4NCkscig4NSksdC5kZWZhdWx0PXtpbnN0YWxsOmZ1bmN0aW9uKGUsdCl7dmFyIHIsaSxzLG8sYSxsLHUscCxoLGY9KHM9KGk9dm9pZCAwPT09cj97fTpyKS5uYW1lLG89dm9pZCAwPT09cz9cInRpcFwiOnMsYT1pLmljb24sbD12b2lkIDA9PT1hP1widi1tZC1pY29uLXRpcFwiOmEsdT1pLnRleHQscD1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PVwidGlwXCIpLGUuaW5zZXJ0KChmdW5jdGlvbihyKXt2YXIgbj1yfHxlLmxhbmdDb25maWcudGlwW3RdLnBsYWNlaG9sZGVyO3JldHVybnt0ZXh0OlwiOjo6IFwiK3QrXCJcXG4gIFwiK24rXCJcXG46OjpcIixzZWxlY3RlZDpufX0pKX0saD17dGl0bGU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUubGFuZ0NvbmZpZy50aXAudG9vbGJhcn0saWNvbjpsLHRleHQ6dSxtZW51czpbe25hbWU6XCJ0aXBcIix0ZXh0OmZ1bmN0aW9uKGUpe3JldHVybiBlLmxhbmdDb25maWcudGlwLnRpcC50b29sYmFyfSxhY3Rpb246ZnVuY3Rpb24oZSl7ZS5leGVjQ29tbWFuZChvKX19LHtuYW1lOlwid2FybmluZ1wiLHRleHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUubGFuZ0NvbmZpZy50aXAud2FybmluZy50b29sYmFyfSxhY3Rpb246ZnVuY3Rpb24oZSl7ZS5leGVjQ29tbWFuZChvLFwid2FybmluZ1wiKX19LHtuYW1lOlwiZGFuZ2VyXCIsdGV4dDpmdW5jdGlvbihlKXtyZXR1cm4gZS5sYW5nQ29uZmlnLnRpcC5kYW5nZXIudG9vbGJhcn0sYWN0aW9uOmZ1bmN0aW9uKGUpe2UuZXhlY0NvbW1hbmQobyxcImRhbmdlclwiKX19LHtuYW1lOlwiZGV0YWlsc1wiLHRleHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUubGFuZ0NvbmZpZy50aXAuZGV0YWlscy50b29sYmFyfSxhY3Rpb246ZnVuY3Rpb24oZSl7ZS5leGVjQ29tbWFuZChvLFwiZGV0YWlsc1wiKX19XX0se2luc3RhbGw6ZnVuY3Rpb24oZSl7XCJ2LW1kLWVkaXRvclwiPT09ZS5uYW1lJiYoZS5jb21tYW5kKG8scCksZS50b29sYmFyKG8saCksZS5sYW5nLmFkZCh7XCJ6aC1DTlwiOnt0aXA6e3Rvb2xiYXI6XCLmj5LlhaXmj5DnpLpcIix0aXA6e3Rvb2xiYXI6XCLmj5DnpLpcIixwbGFjZWhvbGRlcjpcIuWcqOatpOi+k+WFpeWGheWuuVwifSx3YXJuaW5nOnt0b29sYmFyOlwi5rOo5oSPXCIscGxhY2Vob2xkZXI6XCLlnKjmraTovpPlhaXlhoXlrrlcIn0sZGFuZ2VyOnt0b29sYmFyOlwi6K2m5ZGKXCIscGxhY2Vob2xkZXI6XCLlnKjmraTovpPlhaXlhoXlrrlcIn0sZGV0YWlsczp7dG9vbGJhcjpcIuivpue7huS/oeaBr1wiLHBsYWNlaG9sZGVyOlwi5YaF5a65XCJ9fX0sXCJlbi1VU1wiOnt0aXA6e3Rvb2xiYXI6XCJJbnNlcnQgdGlwXCIsdGlwOnt0b29sYmFyOlwiVGlwXCIscGxhY2Vob2xkZXI6XCJJbnNlcnQgY29udGVudFwifSx3YXJuaW5nOnt0b29sYmFyOlwiV2FybmluZ1wiLHBsYWNlaG9sZGVyOlwiSW5zZXJ0IGNvbnRlbnRcIn0sZGFuZ2VyOnt0b29sYmFyOlwiRGFuZ2VyXCIscGxhY2Vob2xkZXI6XCJJbnNlcnQgY29udGVudFwifSxkZXRhaWxzOnt0b29sYmFyOlwiRGV0YWlsc1wiLHBsYWNlaG9sZGVyOlwiQ29udGVudFwifX19fSkpLGUudk1kUGFyc2VyLnVzZShjKX19KTtlLnZNZFBhcnNlci51c2Uobi5kZWZhdWx0LHQpLGUudXNlKGYpfX19XSkuZGVmYXVsdH0pKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kangc/v-md-editor/lib/theme/vuepress.js\n");

/***/ }),

/***/ "./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BASE_TRANSITION\": () => (/* binding */ BASE_TRANSITION),\n/* harmony export */   \"CAMELIZE\": () => (/* binding */ CAMELIZE),\n/* harmony export */   \"CAPITALIZE\": () => (/* binding */ CAPITALIZE),\n/* harmony export */   \"CREATE_BLOCK\": () => (/* binding */ CREATE_BLOCK),\n/* harmony export */   \"CREATE_COMMENT\": () => (/* binding */ CREATE_COMMENT),\n/* harmony export */   \"CREATE_ELEMENT_BLOCK\": () => (/* binding */ CREATE_ELEMENT_BLOCK),\n/* harmony export */   \"CREATE_ELEMENT_VNODE\": () => (/* binding */ CREATE_ELEMENT_VNODE),\n/* harmony export */   \"CREATE_SLOTS\": () => (/* binding */ CREATE_SLOTS),\n/* harmony export */   \"CREATE_STATIC\": () => (/* binding */ CREATE_STATIC),\n/* harmony export */   \"CREATE_TEXT\": () => (/* binding */ CREATE_TEXT),\n/* harmony export */   \"CREATE_VNODE\": () => (/* binding */ CREATE_VNODE),\n/* harmony export */   \"FRAGMENT\": () => (/* binding */ FRAGMENT),\n/* harmony export */   \"GUARD_REACTIVE_PROPS\": () => (/* binding */ GUARD_REACTIVE_PROPS),\n/* harmony export */   \"IS_MEMO_SAME\": () => (/* binding */ IS_MEMO_SAME),\n/* harmony export */   \"IS_REF\": () => (/* binding */ IS_REF),\n/* harmony export */   \"KEEP_ALIVE\": () => (/* binding */ KEEP_ALIVE),\n/* harmony export */   \"MERGE_PROPS\": () => (/* binding */ MERGE_PROPS),\n/* harmony export */   \"NORMALIZE_CLASS\": () => (/* binding */ NORMALIZE_CLASS),\n/* harmony export */   \"NORMALIZE_PROPS\": () => (/* binding */ NORMALIZE_PROPS),\n/* harmony export */   \"NORMALIZE_STYLE\": () => (/* binding */ NORMALIZE_STYLE),\n/* harmony export */   \"OPEN_BLOCK\": () => (/* binding */ OPEN_BLOCK),\n/* harmony export */   \"POP_SCOPE_ID\": () => (/* binding */ POP_SCOPE_ID),\n/* harmony export */   \"PUSH_SCOPE_ID\": () => (/* binding */ PUSH_SCOPE_ID),\n/* harmony export */   \"RENDER_LIST\": () => (/* binding */ RENDER_LIST),\n/* harmony export */   \"RENDER_SLOT\": () => (/* binding */ RENDER_SLOT),\n/* harmony export */   \"RESOLVE_COMPONENT\": () => (/* binding */ RESOLVE_COMPONENT),\n/* harmony export */   \"RESOLVE_DIRECTIVE\": () => (/* binding */ RESOLVE_DIRECTIVE),\n/* harmony export */   \"RESOLVE_DYNAMIC_COMPONENT\": () => (/* binding */ RESOLVE_DYNAMIC_COMPONENT),\n/* harmony export */   \"RESOLVE_FILTER\": () => (/* binding */ RESOLVE_FILTER),\n/* harmony export */   \"SET_BLOCK_TRACKING\": () => (/* binding */ SET_BLOCK_TRACKING),\n/* harmony export */   \"SUSPENSE\": () => (/* binding */ SUSPENSE),\n/* harmony export */   \"TELEPORT\": () => (/* binding */ TELEPORT),\n/* harmony export */   \"TO_DISPLAY_STRING\": () => (/* binding */ TO_DISPLAY_STRING),\n/* harmony export */   \"TO_HANDLERS\": () => (/* binding */ TO_HANDLERS),\n/* harmony export */   \"TO_HANDLER_KEY\": () => (/* binding */ TO_HANDLER_KEY),\n/* harmony export */   \"UNREF\": () => (/* binding */ UNREF),\n/* harmony export */   \"WITH_CTX\": () => (/* binding */ WITH_CTX),\n/* harmony export */   \"WITH_DIRECTIVES\": () => (/* binding */ WITH_DIRECTIVES),\n/* harmony export */   \"WITH_MEMO\": () => (/* binding */ WITH_MEMO),\n/* harmony export */   \"advancePositionWithClone\": () => (/* binding */ advancePositionWithClone),\n/* harmony export */   \"advancePositionWithMutation\": () => (/* binding */ advancePositionWithMutation),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"baseCompile\": () => (/* binding */ baseCompile),\n/* harmony export */   \"baseParse\": () => (/* binding */ baseParse),\n/* harmony export */   \"buildDirectiveArgs\": () => (/* binding */ buildDirectiveArgs),\n/* harmony export */   \"buildProps\": () => (/* binding */ buildProps),\n/* harmony export */   \"buildSlots\": () => (/* binding */ buildSlots),\n/* harmony export */   \"checkCompatEnabled\": () => (/* binding */ checkCompatEnabled),\n/* harmony export */   \"createArrayExpression\": () => (/* binding */ createArrayExpression),\n/* harmony export */   \"createAssignmentExpression\": () => (/* binding */ createAssignmentExpression),\n/* harmony export */   \"createBlockStatement\": () => (/* binding */ createBlockStatement),\n/* harmony export */   \"createCacheExpression\": () => (/* binding */ createCacheExpression),\n/* harmony export */   \"createCallExpression\": () => (/* binding */ createCallExpression),\n/* harmony export */   \"createCompilerError\": () => (/* binding */ createCompilerError),\n/* harmony export */   \"createCompoundExpression\": () => (/* binding */ createCompoundExpression),\n/* harmony export */   \"createConditionalExpression\": () => (/* binding */ createConditionalExpression),\n/* harmony export */   \"createForLoopParams\": () => (/* binding */ createForLoopParams),\n/* harmony export */   \"createFunctionExpression\": () => (/* binding */ createFunctionExpression),\n/* harmony export */   \"createIfStatement\": () => (/* binding */ createIfStatement),\n/* harmony export */   \"createInterpolation\": () => (/* binding */ createInterpolation),\n/* harmony export */   \"createObjectExpression\": () => (/* binding */ createObjectExpression),\n/* harmony export */   \"createObjectProperty\": () => (/* binding */ createObjectProperty),\n/* harmony export */   \"createReturnStatement\": () => (/* binding */ createReturnStatement),\n/* harmony export */   \"createRoot\": () => (/* binding */ createRoot),\n/* harmony export */   \"createSequenceExpression\": () => (/* binding */ createSequenceExpression),\n/* harmony export */   \"createSimpleExpression\": () => (/* binding */ createSimpleExpression),\n/* harmony export */   \"createStructuralDirectiveTransform\": () => (/* binding */ createStructuralDirectiveTransform),\n/* harmony export */   \"createTemplateLiteral\": () => (/* binding */ createTemplateLiteral),\n/* harmony export */   \"createTransformContext\": () => (/* binding */ createTransformContext),\n/* harmony export */   \"createVNodeCall\": () => (/* binding */ createVNodeCall),\n/* harmony export */   \"extractIdentifiers\": () => (/* binding */ extractIdentifiers),\n/* harmony export */   \"findDir\": () => (/* binding */ findDir),\n/* harmony export */   \"findProp\": () => (/* binding */ findProp),\n/* harmony export */   \"generate\": () => (/* binding */ generate),\n/* harmony export */   \"generateCodeFrame\": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),\n/* harmony export */   \"getBaseTransformPreset\": () => (/* binding */ getBaseTransformPreset),\n/* harmony export */   \"getConstantType\": () => (/* binding */ getConstantType),\n/* harmony export */   \"getInnerRange\": () => (/* binding */ getInnerRange),\n/* harmony export */   \"getMemoedVNodeCall\": () => (/* binding */ getMemoedVNodeCall),\n/* harmony export */   \"getVNodeBlockHelper\": () => (/* binding */ getVNodeBlockHelper),\n/* harmony export */   \"getVNodeHelper\": () => (/* binding */ getVNodeHelper),\n/* harmony export */   \"hasDynamicKeyVBind\": () => (/* binding */ hasDynamicKeyVBind),\n/* harmony export */   \"hasScopeRef\": () => (/* binding */ hasScopeRef),\n/* harmony export */   \"helperNameMap\": () => (/* binding */ helperNameMap),\n/* harmony export */   \"injectProp\": () => (/* binding */ injectProp),\n/* harmony export */   \"isBuiltInType\": () => (/* binding */ isBuiltInType),\n/* harmony export */   \"isCoreComponent\": () => (/* binding */ isCoreComponent),\n/* harmony export */   \"isFunctionType\": () => (/* binding */ isFunctionType),\n/* harmony export */   \"isInDestructureAssignment\": () => (/* binding */ isInDestructureAssignment),\n/* harmony export */   \"isMemberExpression\": () => (/* binding */ isMemberExpression),\n/* harmony export */   \"isMemberExpressionBrowser\": () => (/* binding */ isMemberExpressionBrowser),\n/* harmony export */   \"isMemberExpressionNode\": () => (/* binding */ isMemberExpressionNode),\n/* harmony export */   \"isReferencedIdentifier\": () => (/* binding */ isReferencedIdentifier),\n/* harmony export */   \"isSimpleIdentifier\": () => (/* binding */ isSimpleIdentifier),\n/* harmony export */   \"isSlotOutlet\": () => (/* binding */ isSlotOutlet),\n/* harmony export */   \"isStaticArgOf\": () => (/* binding */ isStaticArgOf),\n/* harmony export */   \"isStaticExp\": () => (/* binding */ isStaticExp),\n/* harmony export */   \"isStaticProperty\": () => (/* binding */ isStaticProperty),\n/* harmony export */   \"isStaticPropertyKey\": () => (/* binding */ isStaticPropertyKey),\n/* harmony export */   \"isTemplateNode\": () => (/* binding */ isTemplateNode),\n/* harmony export */   \"isText\": () => (/* binding */ isText$1),\n/* harmony export */   \"isVSlot\": () => (/* binding */ isVSlot),\n/* harmony export */   \"locStub\": () => (/* binding */ locStub),\n/* harmony export */   \"makeBlock\": () => (/* binding */ makeBlock),\n/* harmony export */   \"noopDirectiveTransform\": () => (/* binding */ noopDirectiveTransform),\n/* harmony export */   \"processExpression\": () => (/* binding */ processExpression),\n/* harmony export */   \"processFor\": () => (/* binding */ processFor),\n/* harmony export */   \"processIf\": () => (/* binding */ processIf),\n/* harmony export */   \"processSlotOutlet\": () => (/* binding */ processSlotOutlet),\n/* harmony export */   \"registerRuntimeHelpers\": () => (/* binding */ registerRuntimeHelpers),\n/* harmony export */   \"resolveComponentType\": () => (/* binding */ resolveComponentType),\n/* harmony export */   \"stringifyExpression\": () => (/* binding */ stringifyExpression),\n/* harmony export */   \"toValidAssetId\": () => (/* binding */ toValidAssetId),\n/* harmony export */   \"trackSlotScopes\": () => (/* binding */ trackSlotScopes),\n/* harmony export */   \"trackVForSlotScopes\": () => (/* binding */ trackVForSlotScopes),\n/* harmony export */   \"transform\": () => (/* binding */ transform),\n/* harmony export */   \"transformBind\": () => (/* binding */ transformBind),\n/* harmony export */   \"transformElement\": () => (/* binding */ transformElement),\n/* harmony export */   \"transformExpression\": () => (/* binding */ transformExpression),\n/* harmony export */   \"transformModel\": () => (/* binding */ transformModel),\n/* harmony export */   \"transformOn\": () => (/* binding */ transformOn),\n/* harmony export */   \"traverseNode\": () => (/* binding */ traverseNode),\n/* harmony export */   \"walkBlockDeclarations\": () => (/* binding */ walkBlockDeclarations),\n/* harmony export */   \"walkFunctionParams\": () => (/* binding */ walkFunctionParams),\n/* harmony export */   \"walkIdentifiers\": () => (/* binding */ walkIdentifiers),\n/* harmony export */   \"warnDeprecation\": () => (/* binding */ warnDeprecation)\n/* harmony export */ });\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/compiler-core/node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\n\nfunction defaultOnError(error) {\n    throw error;\n}\nfunction defaultOnWarn(msg) {\n    ( true) && console.warn(`[Vue warn] ${msg.message}`);\n}\nfunction createCompilerError(code, loc, messages, additionalMessage) {\n    const msg =  true\n        ? (messages || errorMessages)[code] + (additionalMessage || ``)\n        : 0;\n    const error = new SyntaxError(String(msg));\n    error.code = code;\n    error.loc = loc;\n    return error;\n}\nconst errorMessages = {\n    // parse errors\n    [0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',\n    [1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',\n    [2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',\n    [3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',\n    [4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */]: \"Illegal '/' in tags.\",\n    [5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',\n    [6 /* ErrorCodes.EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',\n    [7 /* ErrorCodes.EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',\n    [8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',\n    [9 /* ErrorCodes.EOF_IN_TAG */]: 'Unexpected EOF in tag.',\n    [10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',\n    [11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',\n    [12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: \"Illegal tag name. Use '&lt;' to print '<'.\",\n    [13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',\n    [14 /* ErrorCodes.MISSING_END_TAG_NAME */]: 'End tag name was expected.',\n    [15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',\n    [16 /* ErrorCodes.NESTED_COMMENT */]: \"Unexpected '<!--' in comment.\",\n    [17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\n    [18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\n    [19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: \"Attribute name cannot start with '='.\",\n    [21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: \"'<?' is allowed only in XML context.\",\n    [20 /* ErrorCodes.UNEXPECTED_NULL_CHARACTER */]: `Unexpected null character.`,\n    [22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */]: \"Illegal '/' in tags.\",\n    // Vue-specific parse errors\n    [23 /* ErrorCodes.X_INVALID_END_TAG */]: 'Invalid end tag.',\n    [24 /* ErrorCodes.X_MISSING_END_TAG */]: 'Element is missing end tag.',\n    [25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',\n    [27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +\n        'Note that dynamic directive argument cannot contain spaces.',\n    [26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */]: 'Legal directive name was expected.',\n    // transform errors\n    [28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,\n    [29 /* ErrorCodes.X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,\n    [30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\n    [31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,\n    [32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,\n    [33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,\n    [34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,\n    [35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,\n    [36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,\n    [37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>. ` +\n        `When there are multiple named slots, all slots should use <template> ` +\n        `syntax to avoid scope ambiguity.`,\n    [38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,\n    [39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +\n        `default slot. These children will be ignored.`,\n    [40 /* ErrorCodes.X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,\n    [41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,\n    [42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,\n    [43 /* ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n    [44 /* ErrorCodes.X_V_MODEL_ON_PROPS */]: `v-model cannot be used on a prop, because local prop bindings are not writable.\\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,\n    [45 /* ErrorCodes.X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,\n    [46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,\n    // generic errors\n    [47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n    [48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,\n    [49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\n    [50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */]: `\"scopeId\" option is only supported in module mode.`,\n    // just to fulfill types\n    [51 /* ErrorCodes.__EXTEND_POINT__ */]: ``\n};\n\nconst FRAGMENT = Symbol(( true) ? `Fragment` : 0);\nconst TELEPORT = Symbol(( true) ? `Teleport` : 0);\nconst SUSPENSE = Symbol(( true) ? `Suspense` : 0);\nconst KEEP_ALIVE = Symbol(( true) ? `KeepAlive` : 0);\nconst BASE_TRANSITION = Symbol(( true) ? `BaseTransition` : 0);\nconst OPEN_BLOCK = Symbol(( true) ? `openBlock` : 0);\nconst CREATE_BLOCK = Symbol(( true) ? `createBlock` : 0);\nconst CREATE_ELEMENT_BLOCK = Symbol(( true) ? `createElementBlock` : 0);\nconst CREATE_VNODE = Symbol(( true) ? `createVNode` : 0);\nconst CREATE_ELEMENT_VNODE = Symbol(( true) ? `createElementVNode` : 0);\nconst CREATE_COMMENT = Symbol(( true) ? `createCommentVNode` : 0);\nconst CREATE_TEXT = Symbol(( true) ? `createTextVNode` : 0);\nconst CREATE_STATIC = Symbol(( true) ? `createStaticVNode` : 0);\nconst RESOLVE_COMPONENT = Symbol(( true) ? `resolveComponent` : 0);\nconst RESOLVE_DYNAMIC_COMPONENT = Symbol(( true) ? `resolveDynamicComponent` : 0);\nconst RESOLVE_DIRECTIVE = Symbol(( true) ? `resolveDirective` : 0);\nconst RESOLVE_FILTER = Symbol(( true) ? `resolveFilter` : 0);\nconst WITH_DIRECTIVES = Symbol(( true) ? `withDirectives` : 0);\nconst RENDER_LIST = Symbol(( true) ? `renderList` : 0);\nconst RENDER_SLOT = Symbol(( true) ? `renderSlot` : 0);\nconst CREATE_SLOTS = Symbol(( true) ? `createSlots` : 0);\nconst TO_DISPLAY_STRING = Symbol(( true) ? `toDisplayString` : 0);\nconst MERGE_PROPS = Symbol(( true) ? `mergeProps` : 0);\nconst NORMALIZE_CLASS = Symbol(( true) ? `normalizeClass` : 0);\nconst NORMALIZE_STYLE = Symbol(( true) ? `normalizeStyle` : 0);\nconst NORMALIZE_PROPS = Symbol(( true) ? `normalizeProps` : 0);\nconst GUARD_REACTIVE_PROPS = Symbol(( true) ? `guardReactiveProps` : 0);\nconst TO_HANDLERS = Symbol(( true) ? `toHandlers` : 0);\nconst CAMELIZE = Symbol(( true) ? `camelize` : 0);\nconst CAPITALIZE = Symbol(( true) ? `capitalize` : 0);\nconst TO_HANDLER_KEY = Symbol(( true) ? `toHandlerKey` : 0);\nconst SET_BLOCK_TRACKING = Symbol(( true) ? `setBlockTracking` : 0);\nconst PUSH_SCOPE_ID = Symbol(( true) ? `pushScopeId` : 0);\nconst POP_SCOPE_ID = Symbol(( true) ? `popScopeId` : 0);\nconst WITH_CTX = Symbol(( true) ? `withCtx` : 0);\nconst UNREF = Symbol(( true) ? `unref` : 0);\nconst IS_REF = Symbol(( true) ? `isRef` : 0);\nconst WITH_MEMO = Symbol(( true) ? `withMemo` : 0);\nconst IS_MEMO_SAME = Symbol(( true) ? `isMemoSame` : 0);\n// Name mapping for runtime helpers that need to be imported from 'vue' in\n// generated code. Make sure these are correctly exported in the runtime!\nconst helperNameMap = {\n    [FRAGMENT]: `Fragment`,\n    [TELEPORT]: `Teleport`,\n    [SUSPENSE]: `Suspense`,\n    [KEEP_ALIVE]: `KeepAlive`,\n    [BASE_TRANSITION]: `BaseTransition`,\n    [OPEN_BLOCK]: `openBlock`,\n    [CREATE_BLOCK]: `createBlock`,\n    [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\n    [CREATE_VNODE]: `createVNode`,\n    [CREATE_ELEMENT_VNODE]: `createElementVNode`,\n    [CREATE_COMMENT]: `createCommentVNode`,\n    [CREATE_TEXT]: `createTextVNode`,\n    [CREATE_STATIC]: `createStaticVNode`,\n    [RESOLVE_COMPONENT]: `resolveComponent`,\n    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n    [RESOLVE_DIRECTIVE]: `resolveDirective`,\n    [RESOLVE_FILTER]: `resolveFilter`,\n    [WITH_DIRECTIVES]: `withDirectives`,\n    [RENDER_LIST]: `renderList`,\n    [RENDER_SLOT]: `renderSlot`,\n    [CREATE_SLOTS]: `createSlots`,\n    [TO_DISPLAY_STRING]: `toDisplayString`,\n    [MERGE_PROPS]: `mergeProps`,\n    [NORMALIZE_CLASS]: `normalizeClass`,\n    [NORMALIZE_STYLE]: `normalizeStyle`,\n    [NORMALIZE_PROPS]: `normalizeProps`,\n    [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\n    [TO_HANDLERS]: `toHandlers`,\n    [CAMELIZE]: `camelize`,\n    [CAPITALIZE]: `capitalize`,\n    [TO_HANDLER_KEY]: `toHandlerKey`,\n    [SET_BLOCK_TRACKING]: `setBlockTracking`,\n    [PUSH_SCOPE_ID]: `pushScopeId`,\n    [POP_SCOPE_ID]: `popScopeId`,\n    [WITH_CTX]: `withCtx`,\n    [UNREF]: `unref`,\n    [IS_REF]: `isRef`,\n    [WITH_MEMO]: `withMemo`,\n    [IS_MEMO_SAME]: `isMemoSame`\n};\nfunction registerRuntimeHelpers(helpers) {\n    Object.getOwnPropertySymbols(helpers).forEach(s => {\n        helperNameMap[s] = helpers[s];\n    });\n}\n\n// AST Utilities ---------------------------------------------------------------\n// Some expressions, e.g. sequence and conditional expressions, are never\n// associated with template nodes, so their source locations are just a stub.\n// Container types like CompoundExpression also don't need a real location.\nconst locStub = {\n    source: '',\n    start: { line: 1, column: 1, offset: 0 },\n    end: { line: 1, column: 1, offset: 0 }\n};\nfunction createRoot(children, loc = locStub) {\n    return {\n        type: 0 /* NodeTypes.ROOT */,\n        children,\n        helpers: new Set(),\n        components: [],\n        directives: [],\n        hoists: [],\n        imports: [],\n        cached: 0,\n        temps: 0,\n        codegenNode: undefined,\n        loc\n    };\n}\nfunction createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, isComponent = false, loc = locStub) {\n    if (context) {\n        if (isBlock) {\n            context.helper(OPEN_BLOCK);\n            context.helper(getVNodeBlockHelper(context.inSSR, isComponent));\n        }\n        else {\n            context.helper(getVNodeHelper(context.inSSR, isComponent));\n        }\n        if (directives) {\n            context.helper(WITH_DIRECTIVES);\n        }\n    }\n    return {\n        type: 13 /* NodeTypes.VNODE_CALL */,\n        tag,\n        props,\n        children,\n        patchFlag,\n        dynamicProps,\n        directives,\n        isBlock,\n        disableTracking,\n        isComponent,\n        loc\n    };\n}\nfunction createArrayExpression(elements, loc = locStub) {\n    return {\n        type: 17 /* NodeTypes.JS_ARRAY_EXPRESSION */,\n        loc,\n        elements\n    };\n}\nfunction createObjectExpression(properties, loc = locStub) {\n    return {\n        type: 15 /* NodeTypes.JS_OBJECT_EXPRESSION */,\n        loc,\n        properties\n    };\n}\nfunction createObjectProperty(key, value) {\n    return {\n        type: 16 /* NodeTypes.JS_PROPERTY */,\n        loc: locStub,\n        key: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(key) ? createSimpleExpression(key, true) : key,\n        value\n    };\n}\nfunction createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0 /* ConstantTypes.NOT_CONSTANT */) {\n    return {\n        type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,\n        loc,\n        content,\n        isStatic,\n        constType: isStatic ? 3 /* ConstantTypes.CAN_STRINGIFY */ : constType\n    };\n}\nfunction createInterpolation(content, loc) {\n    return {\n        type: 5 /* NodeTypes.INTERPOLATION */,\n        loc,\n        content: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(content)\n            ? createSimpleExpression(content, false, loc)\n            : content\n    };\n}\nfunction createCompoundExpression(children, loc = locStub) {\n    return {\n        type: 8 /* NodeTypes.COMPOUND_EXPRESSION */,\n        loc,\n        children\n    };\n}\nfunction createCallExpression(callee, args = [], loc = locStub) {\n    return {\n        type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,\n        loc,\n        callee,\n        arguments: args\n    };\n}\nfunction createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {\n    return {\n        type: 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */,\n        params,\n        returns,\n        newline,\n        isSlot,\n        loc\n    };\n}\nfunction createConditionalExpression(test, consequent, alternate, newline = true) {\n    return {\n        type: 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */,\n        test,\n        consequent,\n        alternate,\n        newline,\n        loc: locStub\n    };\n}\nfunction createCacheExpression(index, value, isVNode = false) {\n    return {\n        type: 20 /* NodeTypes.JS_CACHE_EXPRESSION */,\n        index,\n        value,\n        isVNode,\n        loc: locStub\n    };\n}\nfunction createBlockStatement(body) {\n    return {\n        type: 21 /* NodeTypes.JS_BLOCK_STATEMENT */,\n        body,\n        loc: locStub\n    };\n}\nfunction createTemplateLiteral(elements) {\n    return {\n        type: 22 /* NodeTypes.JS_TEMPLATE_LITERAL */,\n        elements,\n        loc: locStub\n    };\n}\nfunction createIfStatement(test, consequent, alternate) {\n    return {\n        type: 23 /* NodeTypes.JS_IF_STATEMENT */,\n        test,\n        consequent,\n        alternate,\n        loc: locStub\n    };\n}\nfunction createAssignmentExpression(left, right) {\n    return {\n        type: 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */,\n        left,\n        right,\n        loc: locStub\n    };\n}\nfunction createSequenceExpression(expressions) {\n    return {\n        type: 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */,\n        expressions,\n        loc: locStub\n    };\n}\nfunction createReturnStatement(returns) {\n    return {\n        type: 26 /* NodeTypes.JS_RETURN_STATEMENT */,\n        returns,\n        loc: locStub\n    };\n}\n\nconst isStaticExp = (p) => p.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && p.isStatic;\nconst isBuiltInType = (tag, expected) => tag === expected || tag === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hyphenate)(expected);\nfunction isCoreComponent(tag) {\n    if (isBuiltInType(tag, 'Teleport')) {\n        return TELEPORT;\n    }\n    else if (isBuiltInType(tag, 'Suspense')) {\n        return SUSPENSE;\n    }\n    else if (isBuiltInType(tag, 'KeepAlive')) {\n        return KEEP_ALIVE;\n    }\n    else if (isBuiltInType(tag, 'BaseTransition')) {\n        return BASE_TRANSITION;\n    }\n}\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/;\nconst isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/;\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/;\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g;\n/**\n * Simple lexer to check if an expression is a member expression. This is\n * lax and only checks validity at the root level (i.e. does not validate exps\n * inside square brackets), but it's ok since these are only used on template\n * expressions and false positives are invalid expressions in the first place.\n */\nconst isMemberExpressionBrowser = (path) => {\n    // remove whitespaces around . or [ first\n    path = path.trim().replace(whitespaceRE, s => s.trim());\n    let state = 0 /* MemberExpLexState.inMemberExp */;\n    let stateStack = [];\n    let currentOpenBracketCount = 0;\n    let currentOpenParensCount = 0;\n    let currentStringType = null;\n    for (let i = 0; i < path.length; i++) {\n        const char = path.charAt(i);\n        switch (state) {\n            case 0 /* MemberExpLexState.inMemberExp */:\n                if (char === '[') {\n                    stateStack.push(state);\n                    state = 1 /* MemberExpLexState.inBrackets */;\n                    currentOpenBracketCount++;\n                }\n                else if (char === '(') {\n                    stateStack.push(state);\n                    state = 2 /* MemberExpLexState.inParens */;\n                    currentOpenParensCount++;\n                }\n                else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {\n                    return false;\n                }\n                break;\n            case 1 /* MemberExpLexState.inBrackets */:\n                if (char === `'` || char === `\"` || char === '`') {\n                    stateStack.push(state);\n                    state = 3 /* MemberExpLexState.inString */;\n                    currentStringType = char;\n                }\n                else if (char === `[`) {\n                    currentOpenBracketCount++;\n                }\n                else if (char === `]`) {\n                    if (!--currentOpenBracketCount) {\n                        state = stateStack.pop();\n                    }\n                }\n                break;\n            case 2 /* MemberExpLexState.inParens */:\n                if (char === `'` || char === `\"` || char === '`') {\n                    stateStack.push(state);\n                    state = 3 /* MemberExpLexState.inString */;\n                    currentStringType = char;\n                }\n                else if (char === `(`) {\n                    currentOpenParensCount++;\n                }\n                else if (char === `)`) {\n                    // if the exp ends as a call then it should not be considered valid\n                    if (i === path.length - 1) {\n                        return false;\n                    }\n                    if (!--currentOpenParensCount) {\n                        state = stateStack.pop();\n                    }\n                }\n                break;\n            case 3 /* MemberExpLexState.inString */:\n                if (char === currentStringType) {\n                    state = stateStack.pop();\n                    currentStringType = null;\n                }\n                break;\n        }\n    }\n    return !currentOpenBracketCount && !currentOpenParensCount;\n};\nconst isMemberExpressionNode = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP\n    ;\nconst isMemberExpression = isMemberExpressionBrowser\n    ;\nfunction getInnerRange(loc, offset, length) {\n    const source = loc.source.slice(offset, offset + length);\n    const newLoc = {\n        source,\n        start: advancePositionWithClone(loc.start, loc.source, offset),\n        end: loc.end\n    };\n    if (length != null) {\n        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\n    }\n    return newLoc;\n}\nfunction advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\n    return advancePositionWithMutation((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, pos), source, numberOfCharacters);\n}\n// advance by mutation without cloning (for performance reasons), since this\n// gets called a lot in the parser\nfunction advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\n    let linesCount = 0;\n    let lastNewLinePos = -1;\n    for (let i = 0; i < numberOfCharacters; i++) {\n        if (source.charCodeAt(i) === 10 /* newline char code */) {\n            linesCount++;\n            lastNewLinePos = i;\n        }\n    }\n    pos.offset += numberOfCharacters;\n    pos.line += linesCount;\n    pos.column =\n        lastNewLinePos === -1\n            ? pos.column + numberOfCharacters\n            : numberOfCharacters - lastNewLinePos;\n    return pos;\n}\nfunction assert(condition, msg) {\n    /* istanbul ignore if */\n    if (!condition) {\n        throw new Error(msg || `unexpected compiler condition`);\n    }\n}\nfunction findDir(node, name, allowEmpty = false) {\n    for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i];\n        if (p.type === 7 /* NodeTypes.DIRECTIVE */ &&\n            (allowEmpty || p.exp) &&\n            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? p.name === name : name.test(p.name))) {\n            return p;\n        }\n    }\n}\nfunction findProp(node, name, dynamicOnly = false, allowEmpty = false) {\n    for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i];\n        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {\n            if (dynamicOnly)\n                continue;\n            if (p.name === name && (p.value || allowEmpty)) {\n                return p;\n            }\n        }\n        else if (p.name === 'bind' &&\n            (p.exp || allowEmpty) &&\n            isStaticArgOf(p.arg, name)) {\n            return p;\n        }\n    }\n}\nfunction isStaticArgOf(arg, name) {\n    return !!(arg && isStaticExp(arg) && arg.content === name);\n}\nfunction hasDynamicKeyVBind(node) {\n    return node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&\n        p.name === 'bind' &&\n        (!p.arg || // v-bind=\"obj\"\n            p.arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]\n            !p.arg.isStatic) // v-bind:[foo]\n    );\n}\nfunction isText$1(node) {\n    return node.type === 5 /* NodeTypes.INTERPOLATION */ || node.type === 2 /* NodeTypes.TEXT */;\n}\nfunction isVSlot(p) {\n    return p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'slot';\n}\nfunction isTemplateNode(node) {\n    return (node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 3 /* ElementTypes.TEMPLATE */);\n}\nfunction isSlotOutlet(node) {\n    return node.type === 1 /* NodeTypes.ELEMENT */ && node.tagType === 2 /* ElementTypes.SLOT */;\n}\nfunction getVNodeHelper(ssr, isComponent) {\n    return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE;\n}\nfunction getVNodeBlockHelper(ssr, isComponent) {\n    return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;\n}\nconst propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);\nfunction getUnnormalizedProps(props, callPath = []) {\n    if (props &&\n        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&\n        props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n        const callee = props.callee;\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(callee) && propsHelperSet.has(callee)) {\n            return getUnnormalizedProps(props.arguments[0], callPath.concat(props));\n        }\n    }\n    return [props, callPath];\n}\nfunction injectProp(node, prop, context) {\n    let propsWithInjection;\n    /**\n     * 1. mergeProps(...)\n     * 2. toHandlers(...)\n     * 3. normalizeProps(...)\n     * 4. normalizeProps(guardReactiveProps(...))\n     *\n     * we need to get the real props before normalization\n     */\n    let props = node.type === 13 /* NodeTypes.VNODE_CALL */ ? node.props : node.arguments[2];\n    let callPath = [];\n    let parentCall;\n    if (props &&\n        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props) &&\n        props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n        const ret = getUnnormalizedProps(props);\n        props = ret[0];\n        callPath = ret[1];\n        parentCall = callPath[callPath.length - 1];\n    }\n    if (props == null || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(props)) {\n        propsWithInjection = createObjectExpression([prop]);\n    }\n    else if (props.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n        // merged props... add ours\n        // only inject key to object literal if it's the first argument so that\n        // if doesn't override user provided keys\n        const first = props.arguments[0];\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(first) && first.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {\n            // #6631\n            if (!hasProp(prop, first)) {\n                first.properties.unshift(prop);\n            }\n        }\n        else {\n            if (props.callee === TO_HANDLERS) {\n                // #2366\n                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n                    createObjectExpression([prop]),\n                    props\n                ]);\n            }\n            else {\n                props.arguments.unshift(createObjectExpression([prop]));\n            }\n        }\n        !propsWithInjection && (propsWithInjection = props);\n    }\n    else if (props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {\n        if (!hasProp(prop, props)) {\n            props.properties.unshift(prop);\n        }\n        propsWithInjection = props;\n    }\n    else {\n        // single v-bind with expression, return a merged replacement\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n            createObjectExpression([prop]),\n            props\n        ]);\n        // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,\n        // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,\n        // the `guardReactiveProps` will no longer be needed\n        if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\n            parentCall = callPath[callPath.length - 2];\n        }\n    }\n    if (node.type === 13 /* NodeTypes.VNODE_CALL */) {\n        if (parentCall) {\n            parentCall.arguments[0] = propsWithInjection;\n        }\n        else {\n            node.props = propsWithInjection;\n        }\n    }\n    else {\n        if (parentCall) {\n            parentCall.arguments[0] = propsWithInjection;\n        }\n        else {\n            node.arguments[2] = propsWithInjection;\n        }\n    }\n}\n// check existing key to avoid overriding user provided keys\nfunction hasProp(prop, props) {\n    let result = false;\n    if (prop.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        const propKeyName = prop.key.content;\n        result = props.properties.some(p => p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&\n            p.key.content === propKeyName);\n    }\n    return result;\n}\nfunction toValidAssetId(name, type) {\n    // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character\n    return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\n        return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString();\n    })}`;\n}\n// Check if a node contains expressions that reference current context scope ids\nfunction hasScopeRef(node, ids) {\n    if (!node || Object.keys(ids).length === 0) {\n        return false;\n    }\n    switch (node.type) {\n        case 1 /* NodeTypes.ELEMENT */:\n            for (let i = 0; i < node.props.length; i++) {\n                const p = node.props[i];\n                if (p.type === 7 /* NodeTypes.DIRECTIVE */ &&\n                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {\n                    return true;\n                }\n            }\n            return node.children.some(c => hasScopeRef(c, ids));\n        case 11 /* NodeTypes.FOR */:\n            if (hasScopeRef(node.source, ids)) {\n                return true;\n            }\n            return node.children.some(c => hasScopeRef(c, ids));\n        case 9 /* NodeTypes.IF */:\n            return node.branches.some(b => hasScopeRef(b, ids));\n        case 10 /* NodeTypes.IF_BRANCH */:\n            if (hasScopeRef(node.condition, ids)) {\n                return true;\n            }\n            return node.children.some(c => hasScopeRef(c, ids));\n        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:\n            return (!node.isStatic &&\n                isSimpleIdentifier(node.content) &&\n                !!ids[node.content]);\n        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:\n            return node.children.some(c => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(c) && hasScopeRef(c, ids));\n        case 5 /* NodeTypes.INTERPOLATION */:\n        case 12 /* NodeTypes.TEXT_CALL */:\n            return hasScopeRef(node.content, ids);\n        case 2 /* NodeTypes.TEXT */:\n        case 3 /* NodeTypes.COMMENT */:\n            return false;\n        default:\n            if ((true)) ;\n            return false;\n    }\n}\nfunction getMemoedVNodeCall(node) {\n    if (node.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ && node.callee === WITH_MEMO) {\n        return node.arguments[1].returns;\n    }\n    else {\n        return node;\n    }\n}\nfunction makeBlock(node, { helper, removeHelper, inSSR }) {\n    if (!node.isBlock) {\n        node.isBlock = true;\n        removeHelper(getVNodeHelper(inSSR, node.isComponent));\n        helper(OPEN_BLOCK);\n        helper(getVNodeBlockHelper(inSSR, node.isComponent));\n    }\n}\n\nconst deprecationData = {\n    [\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */]: {\n        message: `Platform-native elements with \"is\" prop will no longer be ` +\n            `treated as components in Vue 3 unless the \"is\" value is explicitly ` +\n            `prefixed with \"vue:\".`,\n        link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`\n    },\n    [\"COMPILER_V_BIND_SYNC\" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */]: {\n        message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +\n            `argument instead. \\`v-bind:${key}.sync\\` should be changed to ` +\n            `\\`v-model:${key}\\`.`,\n        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\n    },\n    [\"COMPILER_V_BIND_PROP\" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */]: {\n        message: `.prop modifier for v-bind has been removed and no longer necessary. ` +\n            `Vue 3 will automatically set a binding as DOM property when appropriate.`\n    },\n    [\"COMPILER_V_BIND_OBJECT_ORDER\" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */]: {\n        message: `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript ` +\n            `object spread: it will now overwrite an existing non-mergeable attribute ` +\n            `that appears before v-bind in the case of conflict. ` +\n            `To retain 2.x behavior, move v-bind to make it the first attribute. ` +\n            `You can also suppress this warning if the usage is intended.`,\n        link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`\n    },\n    [\"COMPILER_V_ON_NATIVE\" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */]: {\n        message: `.native modifier for v-on has been removed as is no longer necessary.`,\n        link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`\n    },\n    [\"COMPILER_V_IF_V_FOR_PRECEDENCE\" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */]: {\n        message: `v-if / v-for precedence when used on the same element has changed ` +\n            `in Vue 3: v-if now takes higher precedence and will no longer have ` +\n            `access to v-for scope variables. It is best to avoid the ambiguity ` +\n            `with <template> tags or use a computed property that filters v-for ` +\n            `data source.`,\n        link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`\n    },\n    [\"COMPILER_NATIVE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */]: {\n        message: `<template> with no special directives will render as a native template ` +\n            `element instead of its inner content in Vue 3.`\n    },\n    [\"COMPILER_INLINE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */]: {\n        message: `\"inline-template\" has been removed in Vue 3.`,\n        link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`\n    },\n    [\"COMPILER_FILTER\" /* CompilerDeprecationTypes.COMPILER_FILTERS */]: {\n        message: `filters have been removed in Vue 3. ` +\n            `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` +\n            `Use method calls or computed properties instead.`,\n        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\n    }\n};\nfunction getCompatValue(key, context) {\n    const config = context.options\n        ? context.options.compatConfig\n        : context.compatConfig;\n    const value = config && config[key];\n    if (key === 'MODE') {\n        return value || 3; // compiler defaults to v3 behavior\n    }\n    else {\n        return value;\n    }\n}\nfunction isCompatEnabled(key, context) {\n    const mode = getCompatValue('MODE', context);\n    const value = getCompatValue(key, context);\n    // in v3 mode, only enable if explicitly set to true\n    // otherwise enable for any non-false value\n    return mode === 3 ? value === true : value !== false;\n}\nfunction checkCompatEnabled(key, context, loc, ...args) {\n    const enabled = isCompatEnabled(key, context);\n    if (( true) && enabled) {\n        warnDeprecation(key, context, loc, ...args);\n    }\n    return enabled;\n}\nfunction warnDeprecation(key, context, loc, ...args) {\n    const val = getCompatValue(key, context);\n    if (val === 'suppress-warning') {\n        return;\n    }\n    const { message, link } = deprecationData[key];\n    const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\\n  Details: ${link}` : ``}`;\n    const err = new SyntaxError(msg);\n    err.code = key;\n    if (loc)\n        err.loc = loc;\n    context.onWarn(err);\n}\n\n// The default decoder only provides escapes for characters reserved as part of\n// the template syntax, and is only used if the custom renderer did not provide\n// a platform-specific decoder.\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g;\nconst decodeMap = {\n    gt: '>',\n    lt: '<',\n    amp: '&',\n    apos: \"'\",\n    quot: '\"'\n};\nconst defaultParserOptions = {\n    delimiters: [`{{`, `}}`],\n    getNamespace: () => 0 /* Namespaces.HTML */,\n    getTextMode: () => 0 /* TextModes.DATA */,\n    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,\n    isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,\n    isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NO,\n    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\n    onError: defaultOnError,\n    onWarn: defaultOnWarn,\n    comments: (\"development\" !== 'production')\n};\nfunction baseParse(content, options = {}) {\n    const context = createParserContext(content, options);\n    const start = getCursor(context);\n    return createRoot(parseChildren(context, 0 /* TextModes.DATA */, []), getSelection(context, start));\n}\nfunction createParserContext(content, rawOptions) {\n    const options = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultParserOptions);\n    let key;\n    for (key in rawOptions) {\n        // @ts-ignore\n        options[key] =\n            rawOptions[key] === undefined\n                ? defaultParserOptions[key]\n                : rawOptions[key];\n    }\n    return {\n        options,\n        column: 1,\n        line: 1,\n        offset: 0,\n        originalSource: content,\n        source: content,\n        inPre: false,\n        inVPre: false,\n        onWarn: options.onWarn\n    };\n}\nfunction parseChildren(context, mode, ancestors) {\n    const parent = last(ancestors);\n    const ns = parent ? parent.ns : 0 /* Namespaces.HTML */;\n    const nodes = [];\n    while (!isEnd(context, mode, ancestors)) {\n        const s = context.source;\n        let node = undefined;\n        if (mode === 0 /* TextModes.DATA */ || mode === 1 /* TextModes.RCDATA */) {\n            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\n                // '{{'\n                node = parseInterpolation(context, mode);\n            }\n            else if (mode === 0 /* TextModes.DATA */ && s[0] === '<') {\n                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\n                if (s.length === 1) {\n                    emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 1);\n                }\n                else if (s[1] === '!') {\n                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\n                    if (startsWith(s, '<!--')) {\n                        node = parseComment(context);\n                    }\n                    else if (startsWith(s, '<!DOCTYPE')) {\n                        // Ignore DOCTYPE by a limitation.\n                        node = parseBogusComment(context);\n                    }\n                    else if (startsWith(s, '<![CDATA[')) {\n                        if (ns !== 0 /* Namespaces.HTML */) {\n                            node = parseCDATA(context, ancestors);\n                        }\n                        else {\n                            emitError(context, 1 /* ErrorCodes.CDATA_IN_HTML_CONTENT */);\n                            node = parseBogusComment(context);\n                        }\n                    }\n                    else {\n                        emitError(context, 11 /* ErrorCodes.INCORRECTLY_OPENED_COMMENT */);\n                        node = parseBogusComment(context);\n                    }\n                }\n                else if (s[1] === '/') {\n                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n                    if (s.length === 2) {\n                        emitError(context, 5 /* ErrorCodes.EOF_BEFORE_TAG_NAME */, 2);\n                    }\n                    else if (s[2] === '>') {\n                        emitError(context, 14 /* ErrorCodes.MISSING_END_TAG_NAME */, 2);\n                        advanceBy(context, 3);\n                        continue;\n                    }\n                    else if (/[a-z]/i.test(s[2])) {\n                        emitError(context, 23 /* ErrorCodes.X_INVALID_END_TAG */);\n                        parseTag(context, 1 /* TagType.End */, parent);\n                        continue;\n                    }\n                    else {\n                        emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\n                        node = parseBogusComment(context);\n                    }\n                }\n                else if (/[a-z]/i.test(s[1])) {\n                    node = parseElement(context, ancestors);\n                    // 2.x <template> with no directive compat\n                    if (isCompatEnabled(\"COMPILER_NATIVE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context) &&\n                        node &&\n                        node.tag === 'template' &&\n                        !node.props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&\n                            isSpecialTemplateDirective(p.name))) {\n                        ( true) &&\n                            warnDeprecation(\"COMPILER_NATIVE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE */, context, node.loc);\n                        node = node.children;\n                    }\n                }\n                else if (s[1] === '?') {\n                    emitError(context, 21 /* ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\n                    node = parseBogusComment(context);\n                }\n                else {\n                    emitError(context, 12 /* ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\n                }\n            }\n        }\n        if (!node) {\n            node = parseText(context, mode);\n        }\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {\n            for (let i = 0; i < node.length; i++) {\n                pushNode(nodes, node[i]);\n            }\n        }\n        else {\n            pushNode(nodes, node);\n        }\n    }\n    // Whitespace handling strategy like v2\n    let removedWhitespace = false;\n    if (mode !== 2 /* TextModes.RAWTEXT */ && mode !== 1 /* TextModes.RCDATA */) {\n        const shouldCondense = context.options.whitespace !== 'preserve';\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (node.type === 2 /* NodeTypes.TEXT */) {\n                if (!context.inPre) {\n                    if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\n                        const prev = nodes[i - 1];\n                        const next = nodes[i + 1];\n                        // Remove if:\n                        // - the whitespace is the first or last node, or:\n                        // - (condense mode) the whitespace is between twos comments, or:\n                        // - (condense mode) the whitespace is between comment and element, or:\n                        // - (condense mode) the whitespace is between two elements AND contains newline\n                        if (!prev ||\n                            !next ||\n                            (shouldCondense &&\n                                ((prev.type === 3 /* NodeTypes.COMMENT */ &&\n                                    next.type === 3 /* NodeTypes.COMMENT */) ||\n                                    (prev.type === 3 /* NodeTypes.COMMENT */ &&\n                                        next.type === 1 /* NodeTypes.ELEMENT */) ||\n                                    (prev.type === 1 /* NodeTypes.ELEMENT */ &&\n                                        next.type === 3 /* NodeTypes.COMMENT */) ||\n                                    (prev.type === 1 /* NodeTypes.ELEMENT */ &&\n                                        next.type === 1 /* NodeTypes.ELEMENT */ &&\n                                        /[\\r\\n]/.test(node.content))))) {\n                            removedWhitespace = true;\n                            nodes[i] = null;\n                        }\n                        else {\n                            // Otherwise, the whitespace is condensed into a single space\n                            node.content = ' ';\n                        }\n                    }\n                    else if (shouldCondense) {\n                        // in condense mode, consecutive whitespaces in text are condensed\n                        // down to a single space.\n                        node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ');\n                    }\n                }\n                else {\n                    // #6410 normalize windows newlines in <pre>:\n                    // in SSR, browsers normalize server-rendered \\r\\n into a single \\n\n                    // in the DOM\n                    node.content = node.content.replace(/\\r\\n/g, '\\n');\n                }\n            }\n            // Remove comment nodes if desired by configuration.\n            else if (node.type === 3 /* NodeTypes.COMMENT */ && !context.options.comments) {\n                removedWhitespace = true;\n                nodes[i] = null;\n            }\n        }\n        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\n            // remove leading newline per html spec\n            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\n            const first = nodes[0];\n            if (first && first.type === 2 /* NodeTypes.TEXT */) {\n                first.content = first.content.replace(/^\\r?\\n/, '');\n            }\n        }\n    }\n    return removedWhitespace ? nodes.filter(Boolean) : nodes;\n}\nfunction pushNode(nodes, node) {\n    if (node.type === 2 /* NodeTypes.TEXT */) {\n        const prev = last(nodes);\n        // Merge if both this and the previous node are text and those are\n        // consecutive. This happens for cases like \"a < b\".\n        if (prev &&\n            prev.type === 2 /* NodeTypes.TEXT */ &&\n            prev.loc.end.offset === node.loc.start.offset) {\n            prev.content += node.content;\n            prev.loc.end = node.loc.end;\n            prev.loc.source += node.loc.source;\n            return;\n        }\n    }\n    nodes.push(node);\n}\nfunction parseCDATA(context, ancestors) {\n    advanceBy(context, 9);\n    const nodes = parseChildren(context, 3 /* TextModes.CDATA */, ancestors);\n    if (context.source.length === 0) {\n        emitError(context, 6 /* ErrorCodes.EOF_IN_CDATA */);\n    }\n    else {\n        advanceBy(context, 3);\n    }\n    return nodes;\n}\nfunction parseComment(context) {\n    const start = getCursor(context);\n    let content;\n    // Regular comment.\n    const match = /--(\\!)?>/.exec(context.source);\n    if (!match) {\n        content = context.source.slice(4);\n        advanceBy(context, context.source.length);\n        emitError(context, 7 /* ErrorCodes.EOF_IN_COMMENT */);\n    }\n    else {\n        if (match.index <= 3) {\n            emitError(context, 0 /* ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\n        }\n        if (match[1]) {\n            emitError(context, 10 /* ErrorCodes.INCORRECTLY_CLOSED_COMMENT */);\n        }\n        content = context.source.slice(4, match.index);\n        // Advancing with reporting nested comments.\n        const s = context.source.slice(0, match.index);\n        let prevIndex = 1, nestedIndex = 0;\n        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\n            advanceBy(context, nestedIndex - prevIndex + 1);\n            if (nestedIndex + 4 < s.length) {\n                emitError(context, 16 /* ErrorCodes.NESTED_COMMENT */);\n            }\n            prevIndex = nestedIndex + 1;\n        }\n        advanceBy(context, match.index + match[0].length - prevIndex + 1);\n    }\n    return {\n        type: 3 /* NodeTypes.COMMENT */,\n        content,\n        loc: getSelection(context, start)\n    };\n}\nfunction parseBogusComment(context) {\n    const start = getCursor(context);\n    const contentStart = context.source[1] === '?' ? 1 : 2;\n    let content;\n    const closeIndex = context.source.indexOf('>');\n    if (closeIndex === -1) {\n        content = context.source.slice(contentStart);\n        advanceBy(context, context.source.length);\n    }\n    else {\n        content = context.source.slice(contentStart, closeIndex);\n        advanceBy(context, closeIndex + 1);\n    }\n    return {\n        type: 3 /* NodeTypes.COMMENT */,\n        content,\n        loc: getSelection(context, start)\n    };\n}\nfunction parseElement(context, ancestors) {\n    // Start tag.\n    const wasInPre = context.inPre;\n    const wasInVPre = context.inVPre;\n    const parent = last(ancestors);\n    const element = parseTag(context, 0 /* TagType.Start */, parent);\n    const isPreBoundary = context.inPre && !wasInPre;\n    const isVPreBoundary = context.inVPre && !wasInVPre;\n    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n        // #4030 self-closing <pre> tag\n        if (isPreBoundary) {\n            context.inPre = false;\n        }\n        if (isVPreBoundary) {\n            context.inVPre = false;\n        }\n        return element;\n    }\n    // Children.\n    ancestors.push(element);\n    const mode = context.options.getTextMode(element, parent);\n    const children = parseChildren(context, mode, ancestors);\n    ancestors.pop();\n    // 2.x inline-template compat\n    {\n        const inlineTemplateProp = element.props.find(p => p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'inline-template');\n        if (inlineTemplateProp &&\n            checkCompatEnabled(\"COMPILER_INLINE_TEMPLATE\" /* CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {\n            const loc = getSelection(context, element.loc.end);\n            inlineTemplateProp.value = {\n                type: 2 /* NodeTypes.TEXT */,\n                content: loc.source,\n                loc\n            };\n        }\n    }\n    element.children = children;\n    // End tag.\n    if (startsWithEndTagOpen(context.source, element.tag)) {\n        parseTag(context, 1 /* TagType.End */, parent);\n    }\n    else {\n        emitError(context, 24 /* ErrorCodes.X_MISSING_END_TAG */, 0, element.loc.start);\n        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\n            const first = children[0];\n            if (first && startsWith(first.loc.source, '<!--')) {\n                emitError(context, 8 /* ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\n            }\n        }\n    }\n    element.loc = getSelection(context, element.loc.start);\n    if (isPreBoundary) {\n        context.inPre = false;\n    }\n    if (isVPreBoundary) {\n        context.inVPre = false;\n    }\n    return element;\n}\nconst isSpecialTemplateDirective = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`if,else,else-if,for,slot`);\nfunction parseTag(context, type, parent) {\n    // Tag open.\n    const start = getCursor(context);\n    const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\n    const tag = match[1];\n    const ns = context.options.getNamespace(tag, parent);\n    advanceBy(context, match[0].length);\n    advanceSpaces(context);\n    // save current state in case we need to re-parse attributes with v-pre\n    const cursor = getCursor(context);\n    const currentSource = context.source;\n    // check <pre> tag\n    if (context.options.isPreTag(tag)) {\n        context.inPre = true;\n    }\n    // Attributes.\n    let props = parseAttributes(context, type);\n    // check v-pre\n    if (type === 0 /* TagType.Start */ &&\n        !context.inVPre &&\n        props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'pre')) {\n        context.inVPre = true;\n        // reset context\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(context, cursor);\n        context.source = currentSource;\n        // re-parse attrs and filter out v-pre itself\n        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');\n    }\n    // Tag close.\n    let isSelfClosing = false;\n    if (context.source.length === 0) {\n        emitError(context, 9 /* ErrorCodes.EOF_IN_TAG */);\n    }\n    else {\n        isSelfClosing = startsWith(context.source, '/>');\n        if (type === 1 /* TagType.End */ && isSelfClosing) {\n            emitError(context, 4 /* ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS */);\n        }\n        advanceBy(context, isSelfClosing ? 2 : 1);\n    }\n    if (type === 1 /* TagType.End */) {\n        return;\n    }\n    // 2.x deprecation checks\n    if (( true) &&\n        isCompatEnabled(\"COMPILER_V_IF_V_FOR_PRECEDENCE\" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {\n        let hasIf = false;\n        let hasFor = false;\n        for (let i = 0; i < props.length; i++) {\n            const p = props[i];\n            if (p.type === 7 /* NodeTypes.DIRECTIVE */) {\n                if (p.name === 'if') {\n                    hasIf = true;\n                }\n                else if (p.name === 'for') {\n                    hasFor = true;\n                }\n            }\n            if (hasIf && hasFor) {\n                warnDeprecation(\"COMPILER_V_IF_V_FOR_PRECEDENCE\" /* CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));\n                break;\n            }\n        }\n    }\n    let tagType = 0 /* ElementTypes.ELEMENT */;\n    if (!context.inVPre) {\n        if (tag === 'slot') {\n            tagType = 2 /* ElementTypes.SLOT */;\n        }\n        else if (tag === 'template') {\n            if (props.some(p => p.type === 7 /* NodeTypes.DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {\n                tagType = 3 /* ElementTypes.TEMPLATE */;\n            }\n        }\n        else if (isComponent(tag, props, context)) {\n            tagType = 1 /* ElementTypes.COMPONENT */;\n        }\n    }\n    return {\n        type: 1 /* NodeTypes.ELEMENT */,\n        ns,\n        tag,\n        tagType,\n        props,\n        isSelfClosing,\n        children: [],\n        loc: getSelection(context, start),\n        codegenNode: undefined // to be created during transform phase\n    };\n}\nfunction isComponent(tag, props, context) {\n    const options = context.options;\n    if (options.isCustomElement(tag)) {\n        return false;\n    }\n    if (tag === 'component' ||\n        /^[A-Z]/.test(tag) ||\n        isCoreComponent(tag) ||\n        (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\n        (options.isNativeTag && !options.isNativeTag(tag))) {\n        return true;\n    }\n    // at this point the tag should be a native tag, but check for potential \"is\"\n    // casting\n    for (let i = 0; i < props.length; i++) {\n        const p = props[i];\n        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {\n            if (p.name === 'is' && p.value) {\n                if (p.value.content.startsWith('vue:')) {\n                    return true;\n                }\n                else if (checkCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            // directive\n            // v-is (TODO Deprecate)\n            if (p.name === 'is') {\n                return true;\n            }\n            else if (\n            // :is on plain element - only treat as component in compat mode\n            p.name === 'bind' &&\n                isStaticArgOf(p.arg, 'is') &&\n                true &&\n                checkCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context, p.loc)) {\n                return true;\n            }\n        }\n    }\n}\nfunction parseAttributes(context, type) {\n    const props = [];\n    const attributeNames = new Set();\n    while (context.source.length > 0 &&\n        !startsWith(context.source, '>') &&\n        !startsWith(context.source, '/>')) {\n        if (startsWith(context.source, '/')) {\n            emitError(context, 22 /* ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG */);\n            advanceBy(context, 1);\n            advanceSpaces(context);\n            continue;\n        }\n        if (type === 1 /* TagType.End */) {\n            emitError(context, 3 /* ErrorCodes.END_TAG_WITH_ATTRIBUTES */);\n        }\n        const attr = parseAttribute(context, attributeNames);\n        // Trim whitespace between class\n        // https://github.com/vuejs/core/issues/4251\n        if (attr.type === 6 /* NodeTypes.ATTRIBUTE */ &&\n            attr.value &&\n            attr.name === 'class') {\n            attr.value.content = attr.value.content.replace(/\\s+/g, ' ').trim();\n        }\n        if (type === 0 /* TagType.Start */) {\n            props.push(attr);\n        }\n        if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n            emitError(context, 15 /* ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\n        }\n        advanceSpaces(context);\n    }\n    return props;\n}\nfunction parseAttribute(context, nameSet) {\n    // Name.\n    const start = getCursor(context);\n    const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\n    const name = match[0];\n    if (nameSet.has(name)) {\n        emitError(context, 2 /* ErrorCodes.DUPLICATE_ATTRIBUTE */);\n    }\n    nameSet.add(name);\n    if (name[0] === '=') {\n        emitError(context, 19 /* ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\n    }\n    {\n        const pattern = /[\"'<]/g;\n        let m;\n        while ((m = pattern.exec(name))) {\n            emitError(context, 17 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\n        }\n    }\n    advanceBy(context, name.length);\n    // Value\n    let value = undefined;\n    if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n        advanceSpaces(context);\n        advanceBy(context, 1);\n        advanceSpaces(context);\n        value = parseAttributeValue(context);\n        if (!value) {\n            emitError(context, 13 /* ErrorCodes.MISSING_ATTRIBUTE_VALUE */);\n        }\n    }\n    const loc = getSelection(context, start);\n    if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\n        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(name);\n        let isPropShorthand = startsWith(name, '.');\n        let dirName = match[1] ||\n            (isPropShorthand || startsWith(name, ':')\n                ? 'bind'\n                : startsWith(name, '@')\n                    ? 'on'\n                    : 'slot');\n        let arg;\n        if (match[2]) {\n            const isSlot = dirName === 'slot';\n            const startOffset = name.lastIndexOf(match[2]);\n            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));\n            let content = match[2];\n            let isStatic = true;\n            if (content.startsWith('[')) {\n                isStatic = false;\n                if (!content.endsWith(']')) {\n                    emitError(context, 27 /* ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\n                    content = content.slice(1);\n                }\n                else {\n                    content = content.slice(1, content.length - 1);\n                }\n            }\n            else if (isSlot) {\n                // #1241 special case for v-slot: vuetify relies extensively on slot\n                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\n                // supports such usage so we are keeping it consistent with 2.x.\n                content += match[3] || '';\n            }\n            arg = {\n                type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,\n                content,\n                isStatic,\n                constType: isStatic\n                    ? 3 /* ConstantTypes.CAN_STRINGIFY */\n                    : 0 /* ConstantTypes.NOT_CONSTANT */,\n                loc\n            };\n        }\n        if (value && value.isQuoted) {\n            const valueLoc = value.loc;\n            valueLoc.start.offset++;\n            valueLoc.start.column++;\n            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\n            valueLoc.source = valueLoc.source.slice(1, -1);\n        }\n        const modifiers = match[3] ? match[3].slice(1).split('.') : [];\n        if (isPropShorthand)\n            modifiers.push('prop');\n        // 2.x compat v-bind:foo.sync -> v-model:foo\n        if (dirName === 'bind' && arg) {\n            if (modifiers.includes('sync') &&\n                checkCompatEnabled(\"COMPILER_V_BIND_SYNC\" /* CompilerDeprecationTypes.COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {\n                dirName = 'model';\n                modifiers.splice(modifiers.indexOf('sync'), 1);\n            }\n            if (( true) && modifiers.includes('prop')) {\n                checkCompatEnabled(\"COMPILER_V_BIND_PROP\" /* CompilerDeprecationTypes.COMPILER_V_BIND_PROP */, context, loc);\n            }\n        }\n        return {\n            type: 7 /* NodeTypes.DIRECTIVE */,\n            name: dirName,\n            exp: value && {\n                type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,\n                content: value.content,\n                isStatic: false,\n                // Treat as non-constant by default. This can be potentially set to\n                // other values by `transformExpression` to make it eligible for hoisting.\n                constType: 0 /* ConstantTypes.NOT_CONSTANT */,\n                loc: value.loc\n            },\n            arg,\n            modifiers,\n            loc\n        };\n    }\n    // missing directive name or illegal directive name\n    if (!context.inVPre && startsWith(name, 'v-')) {\n        emitError(context, 26 /* ErrorCodes.X_MISSING_DIRECTIVE_NAME */);\n    }\n    return {\n        type: 6 /* NodeTypes.ATTRIBUTE */,\n        name,\n        value: value && {\n            type: 2 /* NodeTypes.TEXT */,\n            content: value.content,\n            loc: value.loc\n        },\n        loc\n    };\n}\nfunction parseAttributeValue(context) {\n    const start = getCursor(context);\n    let content;\n    const quote = context.source[0];\n    const isQuoted = quote === `\"` || quote === `'`;\n    if (isQuoted) {\n        // Quoted value.\n        advanceBy(context, 1);\n        const endIndex = context.source.indexOf(quote);\n        if (endIndex === -1) {\n            content = parseTextData(context, context.source.length, 4 /* TextModes.ATTRIBUTE_VALUE */);\n        }\n        else {\n            content = parseTextData(context, endIndex, 4 /* TextModes.ATTRIBUTE_VALUE */);\n            advanceBy(context, 1);\n        }\n    }\n    else {\n        // Unquoted\n        const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\n        if (!match) {\n            return undefined;\n        }\n        const unexpectedChars = /[\"'<=`]/g;\n        let m;\n        while ((m = unexpectedChars.exec(match[0]))) {\n            emitError(context, 18 /* ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\n        }\n        content = parseTextData(context, match[0].length, 4 /* TextModes.ATTRIBUTE_VALUE */);\n    }\n    return { content, isQuoted, loc: getSelection(context, start) };\n}\nfunction parseInterpolation(context, mode) {\n    const [open, close] = context.options.delimiters;\n    const closeIndex = context.source.indexOf(close, open.length);\n    if (closeIndex === -1) {\n        emitError(context, 25 /* ErrorCodes.X_MISSING_INTERPOLATION_END */);\n        return undefined;\n    }\n    const start = getCursor(context);\n    advanceBy(context, open.length);\n    const innerStart = getCursor(context);\n    const innerEnd = getCursor(context);\n    const rawContentLength = closeIndex - open.length;\n    const rawContent = context.source.slice(0, rawContentLength);\n    const preTrimContent = parseTextData(context, rawContentLength, mode);\n    const content = preTrimContent.trim();\n    const startOffset = preTrimContent.indexOf(content);\n    if (startOffset > 0) {\n        advancePositionWithMutation(innerStart, rawContent, startOffset);\n    }\n    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\n    advancePositionWithMutation(innerEnd, rawContent, endOffset);\n    advanceBy(context, close.length);\n    return {\n        type: 5 /* NodeTypes.INTERPOLATION */,\n        content: {\n            type: 4 /* NodeTypes.SIMPLE_EXPRESSION */,\n            isStatic: false,\n            // Set `isConstant` to false by default and will decide in transformExpression\n            constType: 0 /* ConstantTypes.NOT_CONSTANT */,\n            content,\n            loc: getSelection(context, innerStart, innerEnd)\n        },\n        loc: getSelection(context, start)\n    };\n}\nfunction parseText(context, mode) {\n    const endTokens = mode === 3 /* TextModes.CDATA */ ? [']]>'] : ['<', context.options.delimiters[0]];\n    let endIndex = context.source.length;\n    for (let i = 0; i < endTokens.length; i++) {\n        const index = context.source.indexOf(endTokens[i], 1);\n        if (index !== -1 && endIndex > index) {\n            endIndex = index;\n        }\n    }\n    const start = getCursor(context);\n    const content = parseTextData(context, endIndex, mode);\n    return {\n        type: 2 /* NodeTypes.TEXT */,\n        content,\n        loc: getSelection(context, start)\n    };\n}\n/**\n * Get text data with a given length from the current location.\n * This translates HTML entities in the text data.\n */\nfunction parseTextData(context, length, mode) {\n    const rawText = context.source.slice(0, length);\n    advanceBy(context, length);\n    if (mode === 2 /* TextModes.RAWTEXT */ ||\n        mode === 3 /* TextModes.CDATA */ ||\n        !rawText.includes('&')) {\n        return rawText;\n    }\n    else {\n        // DATA or RCDATA containing \"&\"\". Entity decoding required.\n        return context.options.decodeEntities(rawText, mode === 4 /* TextModes.ATTRIBUTE_VALUE */);\n    }\n}\nfunction getCursor(context) {\n    const { column, line, offset } = context;\n    return { column, line, offset };\n}\nfunction getSelection(context, start, end) {\n    end = end || getCursor(context);\n    return {\n        start,\n        end,\n        source: context.originalSource.slice(start.offset, end.offset)\n    };\n}\nfunction last(xs) {\n    return xs[xs.length - 1];\n}\nfunction startsWith(source, searchString) {\n    return source.startsWith(searchString);\n}\nfunction advanceBy(context, numberOfCharacters) {\n    const { source } = context;\n    advancePositionWithMutation(context, source, numberOfCharacters);\n    context.source = source.slice(numberOfCharacters);\n}\nfunction advanceSpaces(context) {\n    const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\n    if (match) {\n        advanceBy(context, match[0].length);\n    }\n}\nfunction getNewPosition(context, start, numberOfCharacters) {\n    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\n}\nfunction emitError(context, code, offset, loc = getCursor(context)) {\n    if (offset) {\n        loc.offset += offset;\n        loc.column += offset;\n    }\n    context.options.onError(createCompilerError(code, {\n        start: loc,\n        end: loc,\n        source: ''\n    }));\n}\nfunction isEnd(context, mode, ancestors) {\n    const s = context.source;\n    switch (mode) {\n        case 0 /* TextModes.DATA */:\n            if (startsWith(s, '</')) {\n                // TODO: probably bad performance\n                for (let i = ancestors.length - 1; i >= 0; --i) {\n                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n                        return true;\n                    }\n                }\n            }\n            break;\n        case 1 /* TextModes.RCDATA */:\n        case 2 /* TextModes.RAWTEXT */: {\n            const parent = last(ancestors);\n            if (parent && startsWithEndTagOpen(s, parent.tag)) {\n                return true;\n            }\n            break;\n        }\n        case 3 /* TextModes.CDATA */:\n            if (startsWith(s, ']]>')) {\n                return true;\n            }\n            break;\n    }\n    return !s;\n}\nfunction startsWithEndTagOpen(source, tag) {\n    return (startsWith(source, '</') &&\n        source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&\n        /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>'));\n}\n\nfunction hoistStatic(root, context) {\n    walk(root, context, \n    // Root node is unfortunately non-hoistable due to potential parent\n    // fallthrough attributes.\n    isSingleElementRoot(root, root.children[0]));\n}\nfunction isSingleElementRoot(root, child) {\n    const { children } = root;\n    return (children.length === 1 &&\n        child.type === 1 /* NodeTypes.ELEMENT */ &&\n        !isSlotOutlet(child));\n}\nfunction walk(node, context, doNotHoistNode = false) {\n    const { children } = node;\n    const originalCount = children.length;\n    let hoistedCount = 0;\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        // only plain elements & text calls are eligible for hoisting.\n        if (child.type === 1 /* NodeTypes.ELEMENT */ &&\n            child.tagType === 0 /* ElementTypes.ELEMENT */) {\n            const constantType = doNotHoistNode\n                ? 0 /* ConstantTypes.NOT_CONSTANT */\n                : getConstantType(child, context);\n            if (constantType > 0 /* ConstantTypes.NOT_CONSTANT */) {\n                if (constantType >= 2 /* ConstantTypes.CAN_HOIST */) {\n                    child.codegenNode.patchFlag =\n                        -1 /* PatchFlags.HOISTED */ + (( true) ? ` /* HOISTED */` : 0);\n                    child.codegenNode = context.hoist(child.codegenNode);\n                    hoistedCount++;\n                    continue;\n                }\n            }\n            else {\n                // node may contain dynamic children, but its props may be eligible for\n                // hoisting.\n                const codegenNode = child.codegenNode;\n                if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {\n                    const flag = getPatchFlag(codegenNode);\n                    if ((!flag ||\n                        flag === 512 /* PatchFlags.NEED_PATCH */ ||\n                        flag === 1 /* PatchFlags.TEXT */) &&\n                        getGeneratedPropsConstantType(child, context) >=\n                            2 /* ConstantTypes.CAN_HOIST */) {\n                        const props = getNodeProps(child);\n                        if (props) {\n                            codegenNode.props = context.hoist(props);\n                        }\n                    }\n                    if (codegenNode.dynamicProps) {\n                        codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);\n                    }\n                }\n            }\n        }\n        // walk further\n        if (child.type === 1 /* NodeTypes.ELEMENT */) {\n            const isComponent = child.tagType === 1 /* ElementTypes.COMPONENT */;\n            if (isComponent) {\n                context.scopes.vSlot++;\n            }\n            walk(child, context);\n            if (isComponent) {\n                context.scopes.vSlot--;\n            }\n        }\n        else if (child.type === 11 /* NodeTypes.FOR */) {\n            // Do not hoist v-for single child because it has to be a block\n            walk(child, context, child.children.length === 1);\n        }\n        else if (child.type === 9 /* NodeTypes.IF */) {\n            for (let i = 0; i < child.branches.length; i++) {\n                // Do not hoist v-if single child because it has to be a block\n                walk(child.branches[i], context, child.branches[i].children.length === 1);\n            }\n        }\n    }\n    if (hoistedCount && context.transformHoist) {\n        context.transformHoist(children, context, node);\n    }\n    // all children were hoisted - the entire children array is hoistable.\n    if (hoistedCount &&\n        hoistedCount === originalCount &&\n        node.type === 1 /* NodeTypes.ELEMENT */ &&\n        node.tagType === 0 /* ElementTypes.ELEMENT */ &&\n        node.codegenNode &&\n        node.codegenNode.type === 13 /* NodeTypes.VNODE_CALL */ &&\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.codegenNode.children)) {\n        node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));\n    }\n}\nfunction getConstantType(node, context) {\n    const { constantCache } = context;\n    switch (node.type) {\n        case 1 /* NodeTypes.ELEMENT */:\n            if (node.tagType !== 0 /* ElementTypes.ELEMENT */) {\n                return 0 /* ConstantTypes.NOT_CONSTANT */;\n            }\n            const cached = constantCache.get(node);\n            if (cached !== undefined) {\n                return cached;\n            }\n            const codegenNode = node.codegenNode;\n            if (codegenNode.type !== 13 /* NodeTypes.VNODE_CALL */) {\n                return 0 /* ConstantTypes.NOT_CONSTANT */;\n            }\n            if (codegenNode.isBlock &&\n                node.tag !== 'svg' &&\n                node.tag !== 'foreignObject') {\n                return 0 /* ConstantTypes.NOT_CONSTANT */;\n            }\n            const flag = getPatchFlag(codegenNode);\n            if (!flag) {\n                let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;\n                // Element itself has no patch flag. However we still need to check:\n                // 1. Even for a node with no patch flag, it is possible for it to contain\n                // non-hoistable expressions that refers to scope variables, e.g. compiler\n                // injected keys or cached event handlers. Therefore we need to always\n                // check the codegenNode's props to be sure.\n                const generatedPropsType = getGeneratedPropsConstantType(node, context);\n                if (generatedPropsType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                    constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n                    return 0 /* ConstantTypes.NOT_CONSTANT */;\n                }\n                if (generatedPropsType < returnType) {\n                    returnType = generatedPropsType;\n                }\n                // 2. its children.\n                for (let i = 0; i < node.children.length; i++) {\n                    const childType = getConstantType(node.children[i], context);\n                    if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                        constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n                        return 0 /* ConstantTypes.NOT_CONSTANT */;\n                    }\n                    if (childType < returnType) {\n                        returnType = childType;\n                    }\n                }\n                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\n                // type, check if any of the props can cause the type to be lowered\n                // we can skip can_patch because it's guaranteed by the absence of a\n                // patchFlag.\n                if (returnType > 1 /* ConstantTypes.CAN_SKIP_PATCH */) {\n                    for (let i = 0; i < node.props.length; i++) {\n                        const p = node.props[i];\n                        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'bind' && p.exp) {\n                            const expType = getConstantType(p.exp, context);\n                            if (expType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                                constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n                                return 0 /* ConstantTypes.NOT_CONSTANT */;\n                            }\n                            if (expType < returnType) {\n                                returnType = expType;\n                            }\n                        }\n                    }\n                }\n                // only svg/foreignObject could be block here, however if they are\n                // static then they don't need to be blocks since there will be no\n                // nested updates.\n                if (codegenNode.isBlock) {\n                    // except set custom directives.\n                    for (let i = 0; i < node.props.length; i++) {\n                        const p = node.props[i];\n                        if (p.type === 7 /* NodeTypes.DIRECTIVE */) {\n                            constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n                            return 0 /* ConstantTypes.NOT_CONSTANT */;\n                        }\n                    }\n                    context.removeHelper(OPEN_BLOCK);\n                    context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));\n                    codegenNode.isBlock = false;\n                    context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));\n                }\n                constantCache.set(node, returnType);\n                return returnType;\n            }\n            else {\n                constantCache.set(node, 0 /* ConstantTypes.NOT_CONSTANT */);\n                return 0 /* ConstantTypes.NOT_CONSTANT */;\n            }\n        case 2 /* NodeTypes.TEXT */:\n        case 3 /* NodeTypes.COMMENT */:\n            return 3 /* ConstantTypes.CAN_STRINGIFY */;\n        case 9 /* NodeTypes.IF */:\n        case 11 /* NodeTypes.FOR */:\n        case 10 /* NodeTypes.IF_BRANCH */:\n            return 0 /* ConstantTypes.NOT_CONSTANT */;\n        case 5 /* NodeTypes.INTERPOLATION */:\n        case 12 /* NodeTypes.TEXT_CALL */:\n            return getConstantType(node.content, context);\n        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:\n            return node.constType;\n        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:\n            let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(child)) {\n                    continue;\n                }\n                const childType = getConstantType(child, context);\n                if (childType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                    return 0 /* ConstantTypes.NOT_CONSTANT */;\n                }\n                else if (childType < returnType) {\n                    returnType = childType;\n                }\n            }\n            return returnType;\n        default:\n            if ((true)) ;\n            return 0 /* ConstantTypes.NOT_CONSTANT */;\n    }\n}\nconst allowHoistedHelperSet = new Set([\n    NORMALIZE_CLASS,\n    NORMALIZE_STYLE,\n    NORMALIZE_PROPS,\n    GUARD_REACTIVE_PROPS\n]);\nfunction getConstantTypeOfHelperCall(value, context) {\n    if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */ &&\n        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(value.callee) &&\n        allowHoistedHelperSet.has(value.callee)) {\n        const arg = value.arguments[0];\n        if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n            return getConstantType(arg, context);\n        }\n        else if (arg.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n            // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`\n            return getConstantTypeOfHelperCall(arg, context);\n        }\n    }\n    return 0 /* ConstantTypes.NOT_CONSTANT */;\n}\nfunction getGeneratedPropsConstantType(node, context) {\n    let returnType = 3 /* ConstantTypes.CAN_STRINGIFY */;\n    const props = getNodeProps(node);\n    if (props && props.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {\n        const { properties } = props;\n        for (let i = 0; i < properties.length; i++) {\n            const { key, value } = properties[i];\n            const keyType = getConstantType(key, context);\n            if (keyType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                return keyType;\n            }\n            if (keyType < returnType) {\n                returnType = keyType;\n            }\n            let valueType;\n            if (value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n                valueType = getConstantType(value, context);\n            }\n            else if (value.type === 14 /* NodeTypes.JS_CALL_EXPRESSION */) {\n                // some helper calls can be hoisted,\n                // such as the `normalizeProps` generated by the compiler for pre-normalize class,\n                // in this case we need to respect the ConstantType of the helper's arguments\n                valueType = getConstantTypeOfHelperCall(value, context);\n            }\n            else {\n                valueType = 0 /* ConstantTypes.NOT_CONSTANT */;\n            }\n            if (valueType === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                return valueType;\n            }\n            if (valueType < returnType) {\n                returnType = valueType;\n            }\n        }\n    }\n    return returnType;\n}\nfunction getNodeProps(node) {\n    const codegenNode = node.codegenNode;\n    if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {\n        return codegenNode.props;\n    }\n}\nfunction getPatchFlag(node) {\n    const flag = node.patchFlag;\n    return flag ? parseInt(flag, 10) : undefined;\n}\n\nfunction createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, isCustomElement = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {\n    const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/);\n    const context = {\n        // options\n        selfName: nameMatch && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(nameMatch[1])),\n        prefixIdentifiers,\n        hoistStatic,\n        cacheHandlers,\n        nodeTransforms,\n        directiveTransforms,\n        transformHoist,\n        isBuiltInComponent,\n        isCustomElement,\n        expressionPlugins,\n        scopeId,\n        slotted,\n        ssr,\n        inSSR,\n        ssrCssVars,\n        bindingMetadata,\n        inline,\n        isTS,\n        onError,\n        onWarn,\n        compatConfig,\n        // state\n        root,\n        helpers: new Map(),\n        components: new Set(),\n        directives: new Set(),\n        hoists: [],\n        imports: [],\n        constantCache: new Map(),\n        temps: 0,\n        cached: 0,\n        identifiers: Object.create(null),\n        scopes: {\n            vFor: 0,\n            vSlot: 0,\n            vPre: 0,\n            vOnce: 0\n        },\n        parent: null,\n        currentNode: root,\n        childIndex: 0,\n        inVOnce: false,\n        // methods\n        helper(name) {\n            const count = context.helpers.get(name) || 0;\n            context.helpers.set(name, count + 1);\n            return name;\n        },\n        removeHelper(name) {\n            const count = context.helpers.get(name);\n            if (count) {\n                const currentCount = count - 1;\n                if (!currentCount) {\n                    context.helpers.delete(name);\n                }\n                else {\n                    context.helpers.set(name, currentCount);\n                }\n            }\n        },\n        helperString(name) {\n            return `_${helperNameMap[context.helper(name)]}`;\n        },\n        replaceNode(node) {\n            /* istanbul ignore if */\n            if ((true)) {\n                if (!context.currentNode) {\n                    throw new Error(`Node being replaced is already removed.`);\n                }\n                if (!context.parent) {\n                    throw new Error(`Cannot replace root node.`);\n                }\n            }\n            context.parent.children[context.childIndex] = context.currentNode = node;\n        },\n        removeNode(node) {\n            if (( true) && !context.parent) {\n                throw new Error(`Cannot remove root node.`);\n            }\n            const list = context.parent.children;\n            const removalIndex = node\n                ? list.indexOf(node)\n                : context.currentNode\n                    ? context.childIndex\n                    : -1;\n            /* istanbul ignore if */\n            if (( true) && removalIndex < 0) {\n                throw new Error(`node being removed is not a child of current parent`);\n            }\n            if (!node || node === context.currentNode) {\n                // current node removed\n                context.currentNode = null;\n                context.onNodeRemoved();\n            }\n            else {\n                // sibling node removed\n                if (context.childIndex > removalIndex) {\n                    context.childIndex--;\n                    context.onNodeRemoved();\n                }\n            }\n            context.parent.children.splice(removalIndex, 1);\n        },\n        onNodeRemoved: () => { },\n        addIdentifiers(exp) {\n        },\n        removeIdentifiers(exp) {\n        },\n        hoist(exp) {\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp))\n                exp = createSimpleExpression(exp);\n            context.hoists.push(exp);\n            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* ConstantTypes.CAN_HOIST */);\n            identifier.hoisted = exp;\n            return identifier;\n        },\n        cache(exp, isVNode = false) {\n            return createCacheExpression(context.cached++, exp, isVNode);\n        }\n    };\n    {\n        context.filters = new Set();\n    }\n    return context;\n}\nfunction transform(root, options) {\n    const context = createTransformContext(root, options);\n    traverseNode(root, context);\n    if (options.hoistStatic) {\n        hoistStatic(root, context);\n    }\n    if (!options.ssr) {\n        createRootCodegen(root, context);\n    }\n    // finalize meta information\n    root.helpers = new Set([...context.helpers.keys()]);\n    root.components = [...context.components];\n    root.directives = [...context.directives];\n    root.imports = context.imports;\n    root.hoists = context.hoists;\n    root.temps = context.temps;\n    root.cached = context.cached;\n    {\n        root.filters = [...context.filters];\n    }\n}\nfunction createRootCodegen(root, context) {\n    const { helper } = context;\n    const { children } = root;\n    if (children.length === 1) {\n        const child = children[0];\n        // if the single child is an element, turn it into a block.\n        if (isSingleElementRoot(root, child) && child.codegenNode) {\n            // single element root is never hoisted so codegenNode will never be\n            // SimpleExpressionNode\n            const codegenNode = child.codegenNode;\n            if (codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {\n                makeBlock(codegenNode, context);\n            }\n            root.codegenNode = codegenNode;\n        }\n        else {\n            // - single <slot/>, IfNode, ForNode: already blocks.\n            // - single text node: always patched.\n            // root codegen falls through via genNode()\n            root.codegenNode = child;\n        }\n    }\n    else if (children.length > 1) {\n        // root has multiple nodes - return a fragment block.\n        let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;\n        let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];\n        // check if the fragment actually contains a single valid child with\n        // the rest being comments\n        if (( true) &&\n            children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {\n            patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;\n            patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;\n        }\n        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, undefined, false /* isComponent */);\n    }\n    else ;\n}\nfunction traverseChildren(parent, context) {\n    let i = 0;\n    const nodeRemoved = () => {\n        i--;\n    };\n    for (; i < parent.children.length; i++) {\n        const child = parent.children[i];\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child))\n            continue;\n        context.parent = parent;\n        context.childIndex = i;\n        context.onNodeRemoved = nodeRemoved;\n        traverseNode(child, context);\n    }\n}\nfunction traverseNode(node, context) {\n    context.currentNode = node;\n    // apply transform plugins\n    const { nodeTransforms } = context;\n    const exitFns = [];\n    for (let i = 0; i < nodeTransforms.length; i++) {\n        const onExit = nodeTransforms[i](node, context);\n        if (onExit) {\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(onExit)) {\n                exitFns.push(...onExit);\n            }\n            else {\n                exitFns.push(onExit);\n            }\n        }\n        if (!context.currentNode) {\n            // node was removed\n            return;\n        }\n        else {\n            // node may have been replaced\n            node = context.currentNode;\n        }\n    }\n    switch (node.type) {\n        case 3 /* NodeTypes.COMMENT */:\n            if (!context.ssr) {\n                // inject import for the Comment symbol, which is needed for creating\n                // comment nodes with `createVNode`\n                context.helper(CREATE_COMMENT);\n            }\n            break;\n        case 5 /* NodeTypes.INTERPOLATION */:\n            // no need to traverse, but we need to inject toString helper\n            if (!context.ssr) {\n                context.helper(TO_DISPLAY_STRING);\n            }\n            break;\n        // for container types, further traverse downwards\n        case 9 /* NodeTypes.IF */:\n            for (let i = 0; i < node.branches.length; i++) {\n                traverseNode(node.branches[i], context);\n            }\n            break;\n        case 10 /* NodeTypes.IF_BRANCH */:\n        case 11 /* NodeTypes.FOR */:\n        case 1 /* NodeTypes.ELEMENT */:\n        case 0 /* NodeTypes.ROOT */:\n            traverseChildren(node, context);\n            break;\n    }\n    // exit transforms\n    context.currentNode = node;\n    let i = exitFns.length;\n    while (i--) {\n        exitFns[i]();\n    }\n}\nfunction createStructuralDirectiveTransform(name, fn) {\n    const matches = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(name)\n        ? (n) => n === name\n        : (n) => name.test(n);\n    return (node, context) => {\n        if (node.type === 1 /* NodeTypes.ELEMENT */) {\n            const { props } = node;\n            // structural directive transforms are not concerned with slots\n            // as they are handled separately in vSlot.ts\n            if (node.tagType === 3 /* ElementTypes.TEMPLATE */ && props.some(isVSlot)) {\n                return;\n            }\n            const exitFns = [];\n            for (let i = 0; i < props.length; i++) {\n                const prop = props[i];\n                if (prop.type === 7 /* NodeTypes.DIRECTIVE */ && matches(prop.name)) {\n                    // structural directives are removed to avoid infinite recursion\n                    // also we remove them *before* applying so that it can further\n                    // traverse itself in case it moves the node around\n                    props.splice(i, 1);\n                    i--;\n                    const onExit = fn(node, prop, context);\n                    if (onExit)\n                        exitFns.push(onExit);\n                }\n            }\n            return exitFns;\n        }\n    };\n}\n\nconst PURE_ANNOTATION = `/*#__PURE__*/`;\nconst aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\nfunction createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssrRuntimeModuleName = 'vue/server-renderer', ssr = false, isTS = false, inSSR = false }) {\n    const context = {\n        mode,\n        prefixIdentifiers,\n        sourceMap,\n        filename,\n        scopeId,\n        optimizeImports,\n        runtimeGlobalName,\n        runtimeModuleName,\n        ssrRuntimeModuleName,\n        ssr,\n        isTS,\n        inSSR,\n        source: ast.loc.source,\n        code: ``,\n        column: 1,\n        line: 1,\n        offset: 0,\n        indentLevel: 0,\n        pure: false,\n        map: undefined,\n        helper(key) {\n            return `_${helperNameMap[key]}`;\n        },\n        push(code, node) {\n            context.code += code;\n        },\n        indent() {\n            newline(++context.indentLevel);\n        },\n        deindent(withoutNewLine = false) {\n            if (withoutNewLine) {\n                --context.indentLevel;\n            }\n            else {\n                newline(--context.indentLevel);\n            }\n        },\n        newline() {\n            newline(context.indentLevel);\n        }\n    };\n    function newline(n) {\n        context.push('\\n' + `  `.repeat(n));\n    }\n    return context;\n}\nfunction generate(ast, options = {}) {\n    const context = createCodegenContext(ast, options);\n    if (options.onContextCreated)\n        options.onContextCreated(context);\n    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;\n    const helpers = Array.from(ast.helpers);\n    const hasHelpers = helpers.length > 0;\n    const useWithBlock = !prefixIdentifiers && mode !== 'module';\n    const isSetupInlined = !true ;\n    // preambles\n    // in setup() inline mode, the preamble is generated in a sub context\n    // and returned separately.\n    const preambleContext = isSetupInlined\n        ? createCodegenContext(ast, options)\n        : context;\n    {\n        genFunctionPreamble(ast, preambleContext);\n    }\n    // enter render function\n    const functionName = ssr ? `ssrRender` : `render`;\n    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];\n    const signature = args.join(', ');\n    {\n        push(`function ${functionName}(${signature}) {`);\n    }\n    indent();\n    if (useWithBlock) {\n        push(`with (_ctx) {`);\n        indent();\n        // function mode const declarations should be inside with block\n        // also they should be renamed to avoid collision with user properties\n        if (hasHelpers) {\n            push(`const { ${helpers.map(aliasHelper).join(', ')} } = _Vue`);\n            push(`\\n`);\n            newline();\n        }\n    }\n    // generate asset resolution statements\n    if (ast.components.length) {\n        genAssets(ast.components, 'component', context);\n        if (ast.directives.length || ast.temps > 0) {\n            newline();\n        }\n    }\n    if (ast.directives.length) {\n        genAssets(ast.directives, 'directive', context);\n        if (ast.temps > 0) {\n            newline();\n        }\n    }\n    if (ast.filters && ast.filters.length) {\n        newline();\n        genAssets(ast.filters, 'filter', context);\n        newline();\n    }\n    if (ast.temps > 0) {\n        push(`let `);\n        for (let i = 0; i < ast.temps; i++) {\n            push(`${i > 0 ? `, ` : ``}_temp${i}`);\n        }\n    }\n    if (ast.components.length || ast.directives.length || ast.temps) {\n        push(`\\n`);\n        newline();\n    }\n    // generate the VNode tree expression\n    if (!ssr) {\n        push(`return `);\n    }\n    if (ast.codegenNode) {\n        genNode(ast.codegenNode, context);\n    }\n    else {\n        push(`null`);\n    }\n    if (useWithBlock) {\n        deindent();\n        push(`}`);\n    }\n    deindent();\n    push(`}`);\n    return {\n        ast,\n        code: context.code,\n        preamble: isSetupInlined ? preambleContext.code : ``,\n        // SourceMapGenerator does have toJSON() method but it's not in the types\n        map: context.map ? context.map.toJSON() : undefined\n    };\n}\nfunction genFunctionPreamble(ast, context) {\n    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName, ssrRuntimeModuleName } = context;\n    const VueBinding = runtimeGlobalName;\n    // Generate const declaration for helpers\n    // In prefix mode, we place the const declaration at top so it's done\n    // only once; But if we not prefixing, we place the declaration inside the\n    // with block so it doesn't incur the `in` check cost for every helper access.\n    const helpers = Array.from(ast.helpers);\n    if (helpers.length > 0) {\n        {\n            // \"with\" mode.\n            // save Vue in a separate variable to avoid collision\n            push(`const _Vue = ${VueBinding}\\n`);\n            // in \"with\" mode, helpers are declared inside the with block to avoid\n            // has check cost, but hoists are lifted out of the function - we need\n            // to provide the helper here.\n            if (ast.hoists.length) {\n                const staticHelpers = [\n                    CREATE_VNODE,\n                    CREATE_ELEMENT_VNODE,\n                    CREATE_COMMENT,\n                    CREATE_TEXT,\n                    CREATE_STATIC\n                ]\n                    .filter(helper => helpers.includes(helper))\n                    .map(aliasHelper)\n                    .join(', ');\n                push(`const { ${staticHelpers} } = _Vue\\n`);\n            }\n        }\n    }\n    genHoists(ast.hoists, context);\n    newline();\n    push(`return `);\n}\nfunction genAssets(assets, type, { helper, push, newline, isTS }) {\n    const resolver = helper(type === 'filter'\n        ? RESOLVE_FILTER\n        : type === 'component'\n            ? RESOLVE_COMPONENT\n            : RESOLVE_DIRECTIVE);\n    for (let i = 0; i < assets.length; i++) {\n        let id = assets[i];\n        // potential component implicit self-reference inferred from SFC filename\n        const maybeSelfReference = id.endsWith('__self');\n        if (maybeSelfReference) {\n            id = id.slice(0, -6);\n        }\n        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);\n        if (i < assets.length - 1) {\n            newline();\n        }\n    }\n}\nfunction genHoists(hoists, context) {\n    if (!hoists.length) {\n        return;\n    }\n    context.pure = true;\n    const { push, newline, helper, scopeId, mode } = context;\n    newline();\n    for (let i = 0; i < hoists.length; i++) {\n        const exp = hoists[i];\n        if (exp) {\n            push(`const _hoisted_${i + 1} = ${``}`);\n            genNode(exp, context);\n            newline();\n        }\n    }\n    context.pure = false;\n}\nfunction isText(n) {\n    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(n) ||\n        n.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||\n        n.type === 2 /* NodeTypes.TEXT */ ||\n        n.type === 5 /* NodeTypes.INTERPOLATION */ ||\n        n.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */);\n}\nfunction genNodeListAsArray(nodes, context) {\n    const multilines = nodes.length > 3 ||\n        ((( true)) && nodes.some(n => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(n) || !isText(n)));\n    context.push(`[`);\n    multilines && context.indent();\n    genNodeList(nodes, context, multilines);\n    multilines && context.deindent();\n    context.push(`]`);\n}\nfunction genNodeList(nodes, context, multilines = false, comma = true) {\n    const { push, newline } = context;\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {\n            push(node);\n        }\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(node)) {\n            genNodeListAsArray(node, context);\n        }\n        else {\n            genNode(node, context);\n        }\n        if (i < nodes.length - 1) {\n            if (multilines) {\n                comma && push(',');\n                newline();\n            }\n            else {\n                comma && push(', ');\n            }\n        }\n    }\n}\nfunction genNode(node, context) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node)) {\n        context.push(node);\n        return;\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(node)) {\n        context.push(context.helper(node));\n        return;\n    }\n    switch (node.type) {\n        case 1 /* NodeTypes.ELEMENT */:\n        case 9 /* NodeTypes.IF */:\n        case 11 /* NodeTypes.FOR */:\n            ( true) &&\n                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +\n                    `Apply appropriate transforms first.`);\n            genNode(node.codegenNode, context);\n            break;\n        case 2 /* NodeTypes.TEXT */:\n            genText(node, context);\n            break;\n        case 4 /* NodeTypes.SIMPLE_EXPRESSION */:\n            genExpression(node, context);\n            break;\n        case 5 /* NodeTypes.INTERPOLATION */:\n            genInterpolation(node, context);\n            break;\n        case 12 /* NodeTypes.TEXT_CALL */:\n            genNode(node.codegenNode, context);\n            break;\n        case 8 /* NodeTypes.COMPOUND_EXPRESSION */:\n            genCompoundExpression(node, context);\n            break;\n        case 3 /* NodeTypes.COMMENT */:\n            genComment(node, context);\n            break;\n        case 13 /* NodeTypes.VNODE_CALL */:\n            genVNodeCall(node, context);\n            break;\n        case 14 /* NodeTypes.JS_CALL_EXPRESSION */:\n            genCallExpression(node, context);\n            break;\n        case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:\n            genObjectExpression(node, context);\n            break;\n        case 17 /* NodeTypes.JS_ARRAY_EXPRESSION */:\n            genArrayExpression(node, context);\n            break;\n        case 18 /* NodeTypes.JS_FUNCTION_EXPRESSION */:\n            genFunctionExpression(node, context);\n            break;\n        case 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */:\n            genConditionalExpression(node, context);\n            break;\n        case 20 /* NodeTypes.JS_CACHE_EXPRESSION */:\n            genCacheExpression(node, context);\n            break;\n        case 21 /* NodeTypes.JS_BLOCK_STATEMENT */:\n            genNodeList(node.body, context, true, false);\n            break;\n        // SSR only types\n        case 22 /* NodeTypes.JS_TEMPLATE_LITERAL */:\n            break;\n        case 23 /* NodeTypes.JS_IF_STATEMENT */:\n            break;\n        case 24 /* NodeTypes.JS_ASSIGNMENT_EXPRESSION */:\n            break;\n        case 25 /* NodeTypes.JS_SEQUENCE_EXPRESSION */:\n            break;\n        case 26 /* NodeTypes.JS_RETURN_STATEMENT */:\n            break;\n        /* istanbul ignore next */\n        case 10 /* NodeTypes.IF_BRANCH */:\n            // noop\n            break;\n        default:\n            if ((true)) {\n                assert(false, `unhandled codegen node type: ${node.type}`);\n                // make sure we exhaust all possible types\n                const exhaustiveCheck = node;\n                return exhaustiveCheck;\n            }\n    }\n}\nfunction genText(node, context) {\n    context.push(JSON.stringify(node.content), node);\n}\nfunction genExpression(node, context) {\n    const { content, isStatic } = node;\n    context.push(isStatic ? JSON.stringify(content) : content, node);\n}\nfunction genInterpolation(node, context) {\n    const { push, helper, pure } = context;\n    if (pure)\n        push(PURE_ANNOTATION);\n    push(`${helper(TO_DISPLAY_STRING)}(`);\n    genNode(node.content, context);\n    push(`)`);\n}\nfunction genCompoundExpression(node, context) {\n    for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {\n            context.push(child);\n        }\n        else {\n            genNode(child, context);\n        }\n    }\n}\nfunction genExpressionAsPropertyKey(node, context) {\n    const { push } = context;\n    if (node.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {\n        push(`[`);\n        genCompoundExpression(node, context);\n        push(`]`);\n    }\n    else if (node.isStatic) {\n        // only quote keys if necessary\n        const text = isSimpleIdentifier(node.content)\n            ? node.content\n            : JSON.stringify(node.content);\n        push(text, node);\n    }\n    else {\n        push(`[${node.content}]`, node);\n    }\n}\nfunction genComment(node, context) {\n    const { push, helper, pure } = context;\n    if (pure) {\n        push(PURE_ANNOTATION);\n    }\n    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);\n}\nfunction genVNodeCall(node, context) {\n    const { push, helper, pure } = context;\n    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking, isComponent } = node;\n    if (directives) {\n        push(helper(WITH_DIRECTIVES) + `(`);\n    }\n    if (isBlock) {\n        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\n    }\n    if (pure) {\n        push(PURE_ANNOTATION);\n    }\n    const callHelper = isBlock\n        ? getVNodeBlockHelper(context.inSSR, isComponent)\n        : getVNodeHelper(context.inSSR, isComponent);\n    push(helper(callHelper) + `(`, node);\n    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);\n    push(`)`);\n    if (isBlock) {\n        push(`)`);\n    }\n    if (directives) {\n        push(`, `);\n        genNode(directives, context);\n        push(`)`);\n    }\n}\nfunction genNullableArgs(args) {\n    let i = args.length;\n    while (i--) {\n        if (args[i] != null)\n            break;\n    }\n    return args.slice(0, i + 1).map(arg => arg || `null`);\n}\n// JavaScript\nfunction genCallExpression(node, context) {\n    const { push, helper, pure } = context;\n    const callee = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(node.callee) ? node.callee : helper(node.callee);\n    if (pure) {\n        push(PURE_ANNOTATION);\n    }\n    push(callee + `(`, node);\n    genNodeList(node.arguments, context);\n    push(`)`);\n}\nfunction genObjectExpression(node, context) {\n    const { push, indent, deindent, newline } = context;\n    const { properties } = node;\n    if (!properties.length) {\n        push(`{}`, node);\n        return;\n    }\n    const multilines = properties.length > 1 ||\n        ((( true)) &&\n            properties.some(p => p.value.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */));\n    push(multilines ? `{` : `{ `);\n    multilines && indent();\n    for (let i = 0; i < properties.length; i++) {\n        const { key, value } = properties[i];\n        // key\n        genExpressionAsPropertyKey(key, context);\n        push(`: `);\n        // value\n        genNode(value, context);\n        if (i < properties.length - 1) {\n            // will only reach this if it's multilines\n            push(`,`);\n            newline();\n        }\n    }\n    multilines && deindent();\n    push(multilines ? `}` : ` }`);\n}\nfunction genArrayExpression(node, context) {\n    genNodeListAsArray(node.elements, context);\n}\nfunction genFunctionExpression(node, context) {\n    const { push, indent, deindent } = context;\n    const { params, returns, body, newline, isSlot } = node;\n    if (isSlot) {\n        // wrap slot functions with owner context\n        push(`_${helperNameMap[WITH_CTX]}(`);\n    }\n    push(`(`, node);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(params)) {\n        genNodeList(params, context);\n    }\n    else if (params) {\n        genNode(params, context);\n    }\n    push(`) => `);\n    if (newline || body) {\n        push(`{`);\n        indent();\n    }\n    if (returns) {\n        if (newline) {\n            push(`return `);\n        }\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(returns)) {\n            genNodeListAsArray(returns, context);\n        }\n        else {\n            genNode(returns, context);\n        }\n    }\n    else if (body) {\n        genNode(body, context);\n    }\n    if (newline || body) {\n        deindent();\n        push(`}`);\n    }\n    if (isSlot) {\n        if (node.isNonScopedSlot) {\n            push(`, undefined, true`);\n        }\n        push(`)`);\n    }\n}\nfunction genConditionalExpression(node, context) {\n    const { test, consequent, alternate, newline: needNewline } = node;\n    const { push, indent, deindent, newline } = context;\n    if (test.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        const needsParens = !isSimpleIdentifier(test.content);\n        needsParens && push(`(`);\n        genExpression(test, context);\n        needsParens && push(`)`);\n    }\n    else {\n        push(`(`);\n        genNode(test, context);\n        push(`)`);\n    }\n    needNewline && indent();\n    context.indentLevel++;\n    needNewline || push(` `);\n    push(`? `);\n    genNode(consequent, context);\n    context.indentLevel--;\n    needNewline && newline();\n    needNewline || push(` `);\n    push(`: `);\n    const isNested = alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */;\n    if (!isNested) {\n        context.indentLevel++;\n    }\n    genNode(alternate, context);\n    if (!isNested) {\n        context.indentLevel--;\n    }\n    needNewline && deindent(true /* without newline */);\n}\nfunction genCacheExpression(node, context) {\n    const { push, helper, indent, deindent, newline } = context;\n    push(`_cache[${node.index}] || (`);\n    if (node.isVNode) {\n        indent();\n        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\n        newline();\n    }\n    push(`_cache[${node.index}] = `);\n    genNode(node.value, context);\n    if (node.isVNode) {\n        push(`,`);\n        newline();\n        push(`${helper(SET_BLOCK_TRACKING)}(1),`);\n        newline();\n        push(`_cache[${node.index}]`);\n        deindent();\n    }\n    push(`)`);\n}\n\nfunction walkIdentifiers(root, onIdentifier, includeAll = false, parentStack = [], knownIds = Object.create(null)) {\n    {\n        return;\n    }\n}\nfunction isReferencedIdentifier(id, parent, parentStack) {\n    {\n        return false;\n    }\n}\nfunction isInDestructureAssignment(parent, parentStack) {\n    if (parent &&\n        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {\n        let i = parentStack.length;\n        while (i--) {\n            const p = parentStack[i];\n            if (p.type === 'AssignmentExpression') {\n                return true;\n            }\n            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\n                break;\n            }\n        }\n    }\n    return false;\n}\nfunction walkFunctionParams(node, onIdent) {\n    for (const p of node.params) {\n        for (const id of extractIdentifiers(p)) {\n            onIdent(id);\n        }\n    }\n}\nfunction walkBlockDeclarations(block, onIdent) {\n    for (const stmt of block.body) {\n        if (stmt.type === 'VariableDeclaration') {\n            if (stmt.declare)\n                continue;\n            for (const decl of stmt.declarations) {\n                for (const id of extractIdentifiers(decl.id)) {\n                    onIdent(id);\n                }\n            }\n        }\n        else if (stmt.type === 'FunctionDeclaration' ||\n            stmt.type === 'ClassDeclaration') {\n            if (stmt.declare || !stmt.id)\n                continue;\n            onIdent(stmt.id);\n        }\n    }\n}\nfunction extractIdentifiers(param, nodes = []) {\n    switch (param.type) {\n        case 'Identifier':\n            nodes.push(param);\n            break;\n        case 'MemberExpression':\n            let object = param;\n            while (object.type === 'MemberExpression') {\n                object = object.object;\n            }\n            nodes.push(object);\n            break;\n        case 'ObjectPattern':\n            for (const prop of param.properties) {\n                if (prop.type === 'RestElement') {\n                    extractIdentifiers(prop.argument, nodes);\n                }\n                else {\n                    extractIdentifiers(prop.value, nodes);\n                }\n            }\n            break;\n        case 'ArrayPattern':\n            param.elements.forEach(element => {\n                if (element)\n                    extractIdentifiers(element, nodes);\n            });\n            break;\n        case 'RestElement':\n            extractIdentifiers(param.argument, nodes);\n            break;\n        case 'AssignmentPattern':\n            extractIdentifiers(param.left, nodes);\n            break;\n    }\n    return nodes;\n}\nconst isFunctionType = (node) => {\n    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);\n};\nconst isStaticProperty = (node) => node &&\n    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\n    !node.computed;\nconst isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;\n\n// these keywords should not appear inside expressions, but operators like\n// 'typeof', 'instanceof', and 'in' are allowed\nconst prohibitedKeywordRE = new RegExp('\\\\b' +\n    ('arguments,await,break,case,catch,class,const,continue,debugger,default,' +\n        'delete,do,else,export,extends,finally,for,function,if,import,let,new,' +\n        'return,super,switch,throw,try,var,void,while,with,yield')\n        .split(',')\n        .join('\\\\b|\\\\b') +\n    '\\\\b');\n// strip strings in expressions\nconst stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n/**\n * Validate a non-prefixed expression.\n * This is only called when using the in-browser runtime compiler since it\n * doesn't prefix expressions.\n */\nfunction validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {\n    const exp = node.content;\n    // empty expressions are validated per-directive since some directives\n    // do allow empty expressions.\n    if (!exp.trim()) {\n        return;\n    }\n    try {\n        new Function(asRawStatements\n            ? ` ${exp} `\n            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);\n    }\n    catch (e) {\n        let message = e.message;\n        const keywordMatch = exp\n            .replace(stripStringRE, '')\n            .match(prohibitedKeywordRE);\n        if (keywordMatch) {\n            message = `avoid using JavaScript keyword as property name: \"${keywordMatch[0]}\"`;\n        }\n        context.onError(createCompilerError(45 /* ErrorCodes.X_INVALID_EXPRESSION */, node.loc, undefined, message));\n    }\n}\n\nconst transformExpression = (node, context) => {\n    if (node.type === 5 /* NodeTypes.INTERPOLATION */) {\n        node.content = processExpression(node.content, context);\n    }\n    else if (node.type === 1 /* NodeTypes.ELEMENT */) {\n        // handle directives on element\n        for (let i = 0; i < node.props.length; i++) {\n            const dir = node.props[i];\n            // do not process for v-on & v-for since they are special handled\n            if (dir.type === 7 /* NodeTypes.DIRECTIVE */ && dir.name !== 'for') {\n                const exp = dir.exp;\n                const arg = dir.arg;\n                // do not process exp if this is v-on:arg - we need special handling\n                // for wrapping inline statements.\n                if (exp &&\n                    exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&\n                    !(dir.name === 'on' && arg)) {\n                    dir.exp = processExpression(exp, context, \n                    // slot args must be processed as function params\n                    dir.name === 'slot');\n                }\n                if (arg && arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !arg.isStatic) {\n                    dir.arg = processExpression(arg, context);\n                }\n            }\n        }\n    }\n};\n// Important: since this function uses Node.js only dependencies, it should\n// always be used with a leading !true check so that it can be\n// tree-shaken from the browser build.\nfunction processExpression(node, context, \n// some expressions like v-slot props & v-for aliases should be parsed as\n// function params\nasParams = false, \n// v-on handler values may contain multiple statements\nasRawStatements = false, localVars = Object.create(context.identifiers)) {\n    {\n        if ((true)) {\n            // simple in-browser validation (same logic in 2.x)\n            validateBrowserExpression(node, context, asParams, asRawStatements);\n        }\n        return node;\n    }\n}\nfunction stringifyExpression(exp) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(exp)) {\n        return exp;\n    }\n    else if (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        return exp.content;\n    }\n    else {\n        return exp.children\n            .map(stringifyExpression)\n            .join('');\n    }\n}\n\nconst transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\n        // #1587: We need to dynamically increment the key based on the current\n        // node's sibling nodes, since chained v-if/else branches are\n        // rendered at the same depth\n        const siblings = context.parent.children;\n        let i = siblings.indexOf(ifNode);\n        let key = 0;\n        while (i-- >= 0) {\n            const sibling = siblings[i];\n            if (sibling && sibling.type === 9 /* NodeTypes.IF */) {\n                key += sibling.branches.length;\n            }\n        }\n        // Exit callback. Complete the codegenNode when all children have been\n        // transformed.\n        return () => {\n            if (isRoot) {\n                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);\n            }\n            else {\n                // attach this branch's codegen node to the v-if root.\n                const parentCondition = getParentCondition(ifNode.codegenNode);\n                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);\n            }\n        };\n    });\n});\n// target-agnostic transform used for both Client and SSR\nfunction processIf(node, dir, context, processCodegen) {\n    if (dir.name !== 'else' &&\n        (!dir.exp || !dir.exp.content.trim())) {\n        const loc = dir.exp ? dir.exp.loc : node.loc;\n        context.onError(createCompilerError(28 /* ErrorCodes.X_V_IF_NO_EXPRESSION */, dir.loc));\n        dir.exp = createSimpleExpression(`true`, false, loc);\n    }\n    if ( true && dir.exp) {\n        validateBrowserExpression(dir.exp, context);\n    }\n    if (dir.name === 'if') {\n        const branch = createIfBranch(node, dir);\n        const ifNode = {\n            type: 9 /* NodeTypes.IF */,\n            loc: node.loc,\n            branches: [branch]\n        };\n        context.replaceNode(ifNode);\n        if (processCodegen) {\n            return processCodegen(ifNode, branch, true);\n        }\n    }\n    else {\n        // locate the adjacent v-if\n        const siblings = context.parent.children;\n        const comments = [];\n        let i = siblings.indexOf(node);\n        while (i-- >= -1) {\n            const sibling = siblings[i];\n            if (sibling && sibling.type === 3 /* NodeTypes.COMMENT */) {\n                context.removeNode(sibling);\n                ( true) && comments.unshift(sibling);\n                continue;\n            }\n            if (sibling &&\n                sibling.type === 2 /* NodeTypes.TEXT */ &&\n                !sibling.content.trim().length) {\n                context.removeNode(sibling);\n                continue;\n            }\n            if (sibling && sibling.type === 9 /* NodeTypes.IF */) {\n                // Check if v-else was followed by v-else-if\n                if (dir.name === 'else-if' &&\n                    sibling.branches[sibling.branches.length - 1].condition === undefined) {\n                    context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));\n                }\n                // move the node to the if node's branches\n                context.removeNode();\n                const branch = createIfBranch(node, dir);\n                if (( true) &&\n                    comments.length &&\n                    // #3619 ignore comments if the v-if is direct child of <transition>\n                    !(context.parent &&\n                        context.parent.type === 1 /* NodeTypes.ELEMENT */ &&\n                        isBuiltInType(context.parent.tag, 'transition'))) {\n                    branch.children = [...comments, ...branch.children];\n                }\n                // check if user is forcing same key on different branches\n                if (true) {\n                    const key = branch.userKey;\n                    if (key) {\n                        sibling.branches.forEach(({ userKey }) => {\n                            if (isSameKey(userKey, key)) {\n                                context.onError(createCompilerError(29 /* ErrorCodes.X_V_IF_SAME_KEY */, branch.userKey.loc));\n                            }\n                        });\n                    }\n                }\n                sibling.branches.push(branch);\n                const onExit = processCodegen && processCodegen(sibling, branch, false);\n                // since the branch was removed, it will not be traversed.\n                // make sure to traverse here.\n                traverseNode(branch, context);\n                // call on exit\n                if (onExit)\n                    onExit();\n                // make sure to reset currentNode after traversal to indicate this\n                // node has been removed.\n                context.currentNode = null;\n            }\n            else {\n                context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, node.loc));\n            }\n            break;\n        }\n    }\n}\nfunction createIfBranch(node, dir) {\n    const isTemplateIf = node.tagType === 3 /* ElementTypes.TEMPLATE */;\n    return {\n        type: 10 /* NodeTypes.IF_BRANCH */,\n        loc: node.loc,\n        condition: dir.name === 'else' ? undefined : dir.exp,\n        children: isTemplateIf && !findDir(node, 'for') ? node.children : [node],\n        userKey: findProp(node, `key`),\n        isTemplateIf\n    };\n}\nfunction createCodegenNodeForBranch(branch, keyIndex, context) {\n    if (branch.condition) {\n        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), \n        // make sure to pass in asBlock: true so that the comment node call\n        // closes the current block.\n        createCallExpression(context.helper(CREATE_COMMENT), [\n            ( true) ? '\"v-if\"' : 0,\n            'true'\n        ]));\n    }\n    else {\n        return createChildrenCodegenNode(branch, keyIndex, context);\n    }\n}\nfunction createChildrenCodegenNode(branch, keyIndex, context) {\n    const { helper } = context;\n    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* ConstantTypes.CAN_HOIST */));\n    const { children } = branch;\n    const firstChild = children[0];\n    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* NodeTypes.ELEMENT */;\n    if (needFragmentWrapper) {\n        if (children.length === 1 && firstChild.type === 11 /* NodeTypes.FOR */) {\n            // optimize away nested fragments when child is a ForNode\n            const vnodeCall = firstChild.codegenNode;\n            injectProp(vnodeCall, keyProperty, context);\n            return vnodeCall;\n        }\n        else {\n            let patchFlag = 64 /* PatchFlags.STABLE_FRAGMENT */;\n            let patchFlagText = _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64];\n            // check if the fragment actually contains a single valid child with\n            // the rest being comments\n            if (( true) &&\n                !branch.isTemplateIf &&\n                children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */).length === 1) {\n                patchFlag |= 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */;\n                patchFlagText += `, ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[2048]}`;\n            }\n            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (( true) ? ` /* ${patchFlagText} */` : 0), undefined, undefined, true, false, false /* isComponent */, branch.loc);\n        }\n    }\n    else {\n        const ret = firstChild.codegenNode;\n        const vnodeCall = getMemoedVNodeCall(ret);\n        // Change createVNode to createBlock.\n        if (vnodeCall.type === 13 /* NodeTypes.VNODE_CALL */) {\n            makeBlock(vnodeCall, context);\n        }\n        // inject branch key\n        injectProp(vnodeCall, keyProperty, context);\n        return ret;\n    }\n}\nfunction isSameKey(a, b) {\n    if (!a || a.type !== b.type) {\n        return false;\n    }\n    if (a.type === 6 /* NodeTypes.ATTRIBUTE */) {\n        if (a.value.content !== b.value.content) {\n            return false;\n        }\n    }\n    else {\n        // directive\n        const exp = a.exp;\n        const branchExp = b.exp;\n        if (exp.type !== branchExp.type) {\n            return false;\n        }\n        if (exp.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||\n            exp.isStatic !== branchExp.isStatic ||\n            exp.content !== branchExp.content) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getParentCondition(node) {\n    while (true) {\n        if (node.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {\n            if (node.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {\n                node = node.alternate;\n            }\n            else {\n                return node;\n            }\n        }\n        else if (node.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */) {\n            node = node.value;\n        }\n    }\n}\n\nconst transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {\n    const { helper, removeHelper } = context;\n    return processFor(node, dir, context, forNode => {\n        // create the loop render function expression now, and add the\n        // iterator on exit after all children have been traversed\n        const renderExp = createCallExpression(helper(RENDER_LIST), [\n            forNode.source\n        ]);\n        const isTemplate = isTemplateNode(node);\n        const memo = findDir(node, 'memo');\n        const keyProp = findProp(node, `key`);\n        const keyExp = keyProp &&\n            (keyProp.type === 6 /* NodeTypes.ATTRIBUTE */\n                ? createSimpleExpression(keyProp.value.content, true)\n                : keyProp.exp);\n        const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;\n        const isStableFragment = forNode.source.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&\n            forNode.source.constType > 0 /* ConstantTypes.NOT_CONSTANT */;\n        const fragmentFlag = isStableFragment\n            ? 64 /* PatchFlags.STABLE_FRAGMENT */\n            : keyProp\n                ? 128 /* PatchFlags.KEYED_FRAGMENT */\n                : 256 /* PatchFlags.UNKEYED_FRAGMENT */;\n        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +\n            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[fragmentFlag]} */` : 0), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, false /* isComponent */, node.loc);\n        return () => {\n            // finish the codegen now that all children have been traversed\n            let childBlock;\n            const { children } = forNode;\n            // check <template v-for> key placement\n            if (( true) && isTemplate) {\n                node.children.some(c => {\n                    if (c.type === 1 /* NodeTypes.ELEMENT */) {\n                        const key = findProp(c, 'key');\n                        if (key) {\n                            context.onError(createCompilerError(33 /* ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));\n                            return true;\n                        }\n                    }\n                });\n            }\n            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* NodeTypes.ELEMENT */;\n            const slotOutlet = isSlotOutlet(node)\n                ? node\n                : isTemplate &&\n                    node.children.length === 1 &&\n                    isSlotOutlet(node.children[0])\n                    ? node.children[0] // api-extractor somehow fails to infer this\n                    : null;\n            if (slotOutlet) {\n                // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\n                childBlock = slotOutlet.codegenNode;\n                if (isTemplate && keyProperty) {\n                    // <template v-for=\"...\" :key=\"...\"><slot/></template>\n                    // we need to inject the key to the renderSlot() call.\n                    // the props for renderSlot is passed as the 3rd argument.\n                    injectProp(childBlock, keyProperty, context);\n                }\n            }\n            else if (needFragmentWrapper) {\n                // <template v-for=\"...\"> with text or multi-elements\n                // should generate a fragment block for each loop\n                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* PatchFlags.STABLE_FRAGMENT */ +\n                    (( true)\n                        ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[64]} */`\n                        : 0), undefined, undefined, true, undefined, false /* isComponent */);\n            }\n            else {\n                // Normal element v-for. Directly use the child's codegenNode\n                // but mark it as a block.\n                childBlock = children[0]\n                    .codegenNode;\n                if (isTemplate && keyProperty) {\n                    injectProp(childBlock, keyProperty, context);\n                }\n                if (childBlock.isBlock !== !isStableFragment) {\n                    if (childBlock.isBlock) {\n                        // switch from block to vnode\n                        removeHelper(OPEN_BLOCK);\n                        removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));\n                    }\n                    else {\n                        // switch from vnode to block\n                        removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));\n                    }\n                }\n                childBlock.isBlock = !isStableFragment;\n                if (childBlock.isBlock) {\n                    helper(OPEN_BLOCK);\n                    helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));\n                }\n                else {\n                    helper(getVNodeHelper(context.inSSR, childBlock.isComponent));\n                }\n            }\n            if (memo) {\n                const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [\n                    createSimpleExpression(`_cached`)\n                ]));\n                loop.body = createBlockStatement([\n                    createCompoundExpression([`const _memo = (`, memo.exp, `)`]),\n                    createCompoundExpression([\n                        `if (_cached`,\n                        ...(keyExp ? [` && _cached.key === `, keyExp] : []),\n                        ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`\n                    ]),\n                    createCompoundExpression([`const _item = `, childBlock]),\n                    createSimpleExpression(`_item.memo = _memo`),\n                    createSimpleExpression(`return _item`)\n                ]);\n                renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));\n            }\n            else {\n                renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));\n            }\n        };\n    });\n});\n// target-agnostic transform used for both Client and SSR\nfunction processFor(node, dir, context, processCodegen) {\n    if (!dir.exp) {\n        context.onError(createCompilerError(31 /* ErrorCodes.X_V_FOR_NO_EXPRESSION */, dir.loc));\n        return;\n    }\n    const parseResult = parseForExpression(\n    // can only be simple expression because vFor transform is applied\n    // before expression transform.\n    dir.exp, context);\n    if (!parseResult) {\n        context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));\n        return;\n    }\n    const { addIdentifiers, removeIdentifiers, scopes } = context;\n    const { source, value, key, index } = parseResult;\n    const forNode = {\n        type: 11 /* NodeTypes.FOR */,\n        loc: dir.loc,\n        source,\n        valueAlias: value,\n        keyAlias: key,\n        objectIndexAlias: index,\n        parseResult,\n        children: isTemplateNode(node) ? node.children : [node]\n    };\n    context.replaceNode(forNode);\n    // bookkeeping\n    scopes.vFor++;\n    const onExit = processCodegen && processCodegen(forNode);\n    return () => {\n        scopes.vFor--;\n        if (onExit)\n            onExit();\n    };\n}\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n// This regex doesn't cover the case if key or index aliases have destructuring,\n// but those do not make sense in the first place, so this works in practice.\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nconst stripParensRE = /^\\(|\\)$/g;\nfunction parseForExpression(input, context) {\n    const loc = input.loc;\n    const exp = input.content;\n    const inMatch = exp.match(forAliasRE);\n    if (!inMatch)\n        return;\n    const [, LHS, RHS] = inMatch;\n    const result = {\n        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\n        value: undefined,\n        key: undefined,\n        index: undefined\n    };\n    if (true) {\n        validateBrowserExpression(result.source, context);\n    }\n    let valueContent = LHS.trim().replace(stripParensRE, '').trim();\n    const trimmedOffset = LHS.indexOf(valueContent);\n    const iteratorMatch = valueContent.match(forIteratorRE);\n    if (iteratorMatch) {\n        valueContent = valueContent.replace(forIteratorRE, '').trim();\n        const keyContent = iteratorMatch[1].trim();\n        let keyOffset;\n        if (keyContent) {\n            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\n            result.key = createAliasExpression(loc, keyContent, keyOffset);\n            if (true) {\n                validateBrowserExpression(result.key, context, true);\n            }\n        }\n        if (iteratorMatch[2]) {\n            const indexContent = iteratorMatch[2].trim();\n            if (indexContent) {\n                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key\n                    ? keyOffset + keyContent.length\n                    : trimmedOffset + valueContent.length));\n                if (true) {\n                    validateBrowserExpression(result.index, context, true);\n                }\n            }\n        }\n    }\n    if (valueContent) {\n        result.value = createAliasExpression(loc, valueContent, trimmedOffset);\n        if (true) {\n            validateBrowserExpression(result.value, context, true);\n        }\n    }\n    return result;\n}\nfunction createAliasExpression(range, content, offset) {\n    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\n}\nfunction createForLoopParams({ value, key, index }, memoArgs = []) {\n    return createParamsList([value, key, index, ...memoArgs]);\n}\nfunction createParamsList(args) {\n    let i = args.length;\n    while (i--) {\n        if (args[i])\n            break;\n    }\n    return args\n        .slice(0, i + 1)\n        .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false));\n}\n\nconst defaultFallback = createSimpleExpression(`undefined`, false);\n// A NodeTransform that:\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\n//    by transformExpression. This is only applied in non-browser builds with\n//    { prefixIdentifiers: true }.\n// 2. Track v-slot depths so that we know a slot is inside another slot.\n//    Note the exit callback is executed before buildSlots() on the same node,\n//    so only nested slots see positive numbers.\nconst trackSlotScopes = (node, context) => {\n    if (node.type === 1 /* NodeTypes.ELEMENT */ &&\n        (node.tagType === 1 /* ElementTypes.COMPONENT */ ||\n            node.tagType === 3 /* ElementTypes.TEMPLATE */)) {\n        // We are only checking non-empty v-slot here\n        // since we only care about slots that introduce scope variables.\n        const vSlot = findDir(node, 'slot');\n        if (vSlot) {\n            vSlot.exp;\n            context.scopes.vSlot++;\n            return () => {\n                context.scopes.vSlot--;\n            };\n        }\n    }\n};\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\nconst trackVForSlotScopes = (node, context) => {\n    let vFor;\n    if (isTemplateNode(node) &&\n        node.props.some(isVSlot) &&\n        (vFor = findDir(node, 'for'))) {\n        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));\n        if (result) {\n            const { value, key, index } = result;\n            const { addIdentifiers, removeIdentifiers } = context;\n            value && addIdentifiers(value);\n            key && addIdentifiers(key);\n            index && addIdentifiers(index);\n            return () => {\n                value && removeIdentifiers(value);\n                key && removeIdentifiers(key);\n                index && removeIdentifiers(index);\n            };\n        }\n    }\n};\nconst buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\n// Instead of being a DirectiveTransform, v-slot processing is called during\n// transformElement to build the slots object for a component.\nfunction buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\n    context.helper(WITH_CTX);\n    const { children, loc } = node;\n    const slotsProperties = [];\n    const dynamicSlots = [];\n    // If the slot is inside a v-for or another v-slot, force it to be dynamic\n    // since it likely uses a scope variable.\n    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\n    // 1. Check for slot with slotProps on component itself.\n    //    <Comp v-slot=\"{ prop }\"/>\n    const onComponentSlot = findDir(node, 'slot', true);\n    if (onComponentSlot) {\n        const { arg, exp } = onComponentSlot;\n        if (arg && !isStaticExp(arg)) {\n            hasDynamicSlots = true;\n        }\n        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));\n    }\n    // 2. Iterate through children and check for template slots\n    //    <template v-slot:foo=\"{ prop }\">\n    let hasTemplateSlots = false;\n    let hasNamedDefaultSlot = false;\n    const implicitDefaultChildren = [];\n    const seenSlotNames = new Set();\n    let conditionalBranchIndex = 0;\n    for (let i = 0; i < children.length; i++) {\n        const slotElement = children[i];\n        let slotDir;\n        if (!isTemplateNode(slotElement) ||\n            !(slotDir = findDir(slotElement, 'slot', true))) {\n            // not a <template v-slot>, skip.\n            if (slotElement.type !== 3 /* NodeTypes.COMMENT */) {\n                implicitDefaultChildren.push(slotElement);\n            }\n            continue;\n        }\n        if (onComponentSlot) {\n            // already has on-component slot - this is incorrect usage.\n            context.onError(createCompilerError(37 /* ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\n            break;\n        }\n        hasTemplateSlots = true;\n        const { children: slotChildren, loc: slotLoc } = slotElement;\n        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\n        // check if name is dynamic.\n        let staticSlotName;\n        if (isStaticExp(slotName)) {\n            staticSlotName = slotName ? slotName.content : `default`;\n        }\n        else {\n            hasDynamicSlots = true;\n        }\n        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\n        // check if this slot is conditional (v-if/v-for)\n        let vIf;\n        let vElse;\n        let vFor;\n        if ((vIf = findDir(slotElement, 'if'))) {\n            hasDynamicSlots = true;\n            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback));\n        }\n        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\n            // find adjacent v-if\n            let j = i;\n            let prev;\n            while (j--) {\n                prev = children[j];\n                if (prev.type !== 3 /* NodeTypes.COMMENT */) {\n                    break;\n                }\n            }\n            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\n                // remove node\n                children.splice(i, 1);\n                i--;\n                // attach this slot to previous conditional\n                let conditional = dynamicSlots[dynamicSlots.length - 1];\n                while (conditional.alternate.type === 19 /* NodeTypes.JS_CONDITIONAL_EXPRESSION */) {\n                    conditional = conditional.alternate;\n                }\n                conditional.alternate = vElse.exp\n                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++), defaultFallback)\n                    : buildDynamicSlot(slotName, slotFunction, conditionalBranchIndex++);\n            }\n            else {\n                context.onError(createCompilerError(30 /* ErrorCodes.X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\n            }\n        }\n        else if ((vFor = findDir(slotElement, 'for'))) {\n            hasDynamicSlots = true;\n            const parseResult = vFor.parseResult ||\n                parseForExpression(vFor.exp, context);\n            if (parseResult) {\n                // Render the dynamic slots as an array and add it to the createSlot()\n                // args. The runtime knows how to handle it appropriately.\n                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\n                    parseResult.source,\n                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)\n                ]));\n            }\n            else {\n                context.onError(createCompilerError(32 /* ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\n            }\n        }\n        else {\n            // check duplicate static names\n            if (staticSlotName) {\n                if (seenSlotNames.has(staticSlotName)) {\n                    context.onError(createCompilerError(38 /* ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\n                    continue;\n                }\n                seenSlotNames.add(staticSlotName);\n                if (staticSlotName === 'default') {\n                    hasNamedDefaultSlot = true;\n                }\n            }\n            slotsProperties.push(createObjectProperty(slotName, slotFunction));\n        }\n    }\n    if (!onComponentSlot) {\n        const buildDefaultSlotProperty = (props, children) => {\n            const fn = buildSlotFn(props, children, loc);\n            if (context.compatConfig) {\n                fn.isNonScopedSlot = true;\n            }\n            return createObjectProperty(`default`, fn);\n        };\n        if (!hasTemplateSlots) {\n            // implicit default slot (on component)\n            slotsProperties.push(buildDefaultSlotProperty(undefined, children));\n        }\n        else if (implicitDefaultChildren.length &&\n            // #3766\n            // with whitespace: 'preserve', whitespaces between slots will end up in\n            // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\n            implicitDefaultChildren.some(node => isNonWhitespaceContent(node))) {\n            // implicit default slot (mixed with named slots)\n            if (hasNamedDefaultSlot) {\n                context.onError(createCompilerError(39 /* ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\n            }\n            else {\n                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\n            }\n        }\n    }\n    const slotFlag = hasDynamicSlots\n        ? 2 /* SlotFlags.DYNAMIC */\n        : hasForwardedSlots(node.children)\n            ? 3 /* SlotFlags.FORWARDED */\n            : 1 /* SlotFlags.STABLE */;\n    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, \n    // 2 = compiled but dynamic = can skip normalization, but must run diff\n    // 1 = compiled and static = can skip normalization AND diff as optimized\n    createSimpleExpression(slotFlag + (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.slotFlagsText[slotFlag]} */` : 0), false))), loc);\n    if (dynamicSlots.length) {\n        slots = createCallExpression(context.helper(CREATE_SLOTS), [\n            slots,\n            createArrayExpression(dynamicSlots)\n        ]);\n    }\n    return {\n        slots,\n        hasDynamicSlots\n    };\n}\nfunction buildDynamicSlot(name, fn, index) {\n    const props = [\n        createObjectProperty(`name`, name),\n        createObjectProperty(`fn`, fn)\n    ];\n    if (index != null) {\n        props.push(createObjectProperty(`key`, createSimpleExpression(String(index), true)));\n    }\n    return createObjectExpression(props);\n}\nfunction hasForwardedSlots(children) {\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case 1 /* NodeTypes.ELEMENT */:\n                if (child.tagType === 2 /* ElementTypes.SLOT */ ||\n                    hasForwardedSlots(child.children)) {\n                    return true;\n                }\n                break;\n            case 9 /* NodeTypes.IF */:\n                if (hasForwardedSlots(child.branches))\n                    return true;\n                break;\n            case 10 /* NodeTypes.IF_BRANCH */:\n            case 11 /* NodeTypes.FOR */:\n                if (hasForwardedSlots(child.children))\n                    return true;\n                break;\n        }\n    }\n    return false;\n}\nfunction isNonWhitespaceContent(node) {\n    if (node.type !== 2 /* NodeTypes.TEXT */ && node.type !== 12 /* NodeTypes.TEXT_CALL */)\n        return true;\n    return node.type === 2 /* NodeTypes.TEXT */\n        ? !!node.content.trim()\n        : isNonWhitespaceContent(node.content);\n}\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\n// import, which should be used instead of a resolveDirective call.\nconst directiveImportMap = new WeakMap();\n// generate a JavaScript AST for this element's codegen\nconst transformElement = (node, context) => {\n    // perform the work on exit, after all child expressions have been\n    // processed and merged.\n    return function postTransformElement() {\n        node = context.currentNode;\n        if (!(node.type === 1 /* NodeTypes.ELEMENT */ &&\n            (node.tagType === 0 /* ElementTypes.ELEMENT */ ||\n                node.tagType === 1 /* ElementTypes.COMPONENT */))) {\n            return;\n        }\n        const { tag, props } = node;\n        const isComponent = node.tagType === 1 /* ElementTypes.COMPONENT */;\n        // The goal of the transform is to create a codegenNode implementing the\n        // VNodeCall interface.\n        let vnodeTag = isComponent\n            ? resolveComponentType(node, context)\n            : `\"${tag}\"`;\n        const isDynamicComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\n        let vnodeProps;\n        let vnodeChildren;\n        let vnodePatchFlag;\n        let patchFlag = 0;\n        let vnodeDynamicProps;\n        let dynamicPropNames;\n        let vnodeDirectives;\n        let shouldUseBlock = \n        // dynamic component may resolve to plain elements\n        isDynamicComponent ||\n            vnodeTag === TELEPORT ||\n            vnodeTag === SUSPENSE ||\n            (!isComponent &&\n                // <svg> and <foreignObject> must be forced into blocks so that block\n                // updates inside get proper isSVG flag at runtime. (#639, #643)\n                // This is technically web-specific, but splitting the logic out of core\n                // leads to too much unnecessary complexity.\n                (tag === 'svg' || tag === 'foreignObject'));\n        // props\n        if (props.length > 0) {\n            const propsBuildResult = buildProps(node, context, undefined, isComponent, isDynamicComponent);\n            vnodeProps = propsBuildResult.props;\n            patchFlag = propsBuildResult.patchFlag;\n            dynamicPropNames = propsBuildResult.dynamicPropNames;\n            const directives = propsBuildResult.directives;\n            vnodeDirectives =\n                directives && directives.length\n                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))\n                    : undefined;\n            if (propsBuildResult.shouldUseBlock) {\n                shouldUseBlock = true;\n            }\n        }\n        // children\n        if (node.children.length > 0) {\n            if (vnodeTag === KEEP_ALIVE) {\n                // Although a built-in component, we compile KeepAlive with raw children\n                // instead of slot functions so that it can be used inside Transition\n                // or other Transition-wrapping HOCs.\n                // To ensure correct updates with block optimizations, we need to:\n                // 1. Force keep-alive into a block. This avoids its children being\n                //    collected by a parent block.\n                shouldUseBlock = true;\n                // 2. Force keep-alive to always be updated, since it uses raw children.\n                patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;\n                if (( true) && node.children.length > 1) {\n                    context.onError(createCompilerError(46 /* ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN */, {\n                        start: node.children[0].loc.start,\n                        end: node.children[node.children.length - 1].loc.end,\n                        source: ''\n                    }));\n                }\n            }\n            const shouldBuildAsSlots = isComponent &&\n                // Teleport is not a real component and has dedicated runtime handling\n                vnodeTag !== TELEPORT &&\n                // explained above.\n                vnodeTag !== KEEP_ALIVE;\n            if (shouldBuildAsSlots) {\n                const { slots, hasDynamicSlots } = buildSlots(node, context);\n                vnodeChildren = slots;\n                if (hasDynamicSlots) {\n                    patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;\n                }\n            }\n            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\n                const child = node.children[0];\n                const type = child.type;\n                // check for dynamic text children\n                const hasDynamicTextChild = type === 5 /* NodeTypes.INTERPOLATION */ ||\n                    type === 8 /* NodeTypes.COMPOUND_EXPRESSION */;\n                if (hasDynamicTextChild &&\n                    getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                    patchFlag |= 1 /* PatchFlags.TEXT */;\n                }\n                // pass directly if the only child is a text node\n                // (plain / interpolation / expression)\n                if (hasDynamicTextChild || type === 2 /* NodeTypes.TEXT */) {\n                    vnodeChildren = child;\n                }\n                else {\n                    vnodeChildren = node.children;\n                }\n            }\n            else {\n                vnodeChildren = node.children;\n            }\n        }\n        // patchFlag & dynamicPropNames\n        if (patchFlag !== 0) {\n            if ((true)) {\n                if (patchFlag < 0) {\n                    // special flags (negative and mutually exclusive)\n                    vnodePatchFlag = patchFlag + ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[patchFlag]} */`;\n                }\n                else {\n                    // bitwise flags\n                    const flagNames = Object.keys(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames)\n                        .map(Number)\n                        .filter(n => n > 0 && patchFlag & n)\n                        .map(n => _vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[n])\n                        .join(`, `);\n                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;\n                }\n            }\n            else {}\n            if (dynamicPropNames && dynamicPropNames.length) {\n                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\n            }\n        }\n        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, isComponent, node.loc);\n    };\n};\nfunction resolveComponentType(node, context, ssr = false) {\n    let { tag } = node;\n    // 1. dynamic component\n    const isExplicitDynamic = isComponentTag(tag);\n    const isProp = findProp(node, 'is');\n    if (isProp) {\n        if (isExplicitDynamic ||\n            (isCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))) {\n            const exp = isProp.type === 6 /* NodeTypes.ATTRIBUTE */\n                ? isProp.value && createSimpleExpression(isProp.value.content, true)\n                : isProp.exp;\n            if (exp) {\n                return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n                    exp\n                ]);\n            }\n        }\n        else if (isProp.type === 6 /* NodeTypes.ATTRIBUTE */ &&\n            isProp.value.content.startsWith('vue:')) {\n            // <button is=\"vue:xxx\">\n            // if not <component>, only is value that starts with \"vue:\" will be\n            // treated as component by the parse phase and reach here, unless it's\n            // compat mode where all is values are considered components\n            tag = isProp.value.content.slice(4);\n        }\n    }\n    // 1.5 v-is (TODO: Deprecate)\n    const isDir = !isExplicitDynamic && findDir(node, 'is');\n    if (isDir && isDir.exp) {\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n            isDir.exp\n        ]);\n    }\n    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\n    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\n    if (builtIn) {\n        // built-ins are simply fallthroughs / have special handling during ssr\n        // so we don't need to import their runtime equivalents\n        if (!ssr)\n            context.helper(builtIn);\n        return builtIn;\n    }\n    // 5. user component (resolve)\n    context.helper(RESOLVE_COMPONENT);\n    context.components.add(tag);\n    return toValidAssetId(tag, `component`);\n}\nfunction buildProps(node, context, props = node.props, isComponent, isDynamicComponent, ssr = false) {\n    const { tag, loc: elementLoc, children } = node;\n    let properties = [];\n    const mergeArgs = [];\n    const runtimeDirectives = [];\n    const hasChildren = children.length > 0;\n    let shouldUseBlock = false;\n    // patchFlag analysis\n    let patchFlag = 0;\n    let hasRef = false;\n    let hasClassBinding = false;\n    let hasStyleBinding = false;\n    let hasHydrationEventBinding = false;\n    let hasDynamicKeys = false;\n    let hasVnodeHook = false;\n    const dynamicPropNames = [];\n    const pushMergeArg = (arg) => {\n        if (properties.length) {\n            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\n            properties = [];\n        }\n        if (arg)\n            mergeArgs.push(arg);\n    };\n    const analyzePatchFlag = ({ key, value }) => {\n        if (isStaticExp(key)) {\n            const name = key.content;\n            const isEventHandler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name);\n            if (isEventHandler &&\n                (!isComponent || isDynamicComponent) &&\n                // omit the flag for click handlers because hydration gives click\n                // dedicated fast path.\n                name.toLowerCase() !== 'onclick' &&\n                // omit v-model handlers\n                name !== 'onUpdate:modelValue' &&\n                // omit onVnodeXXX hooks\n                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {\n                hasHydrationEventBinding = true;\n            }\n            if (isEventHandler && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isReservedProp)(name)) {\n                hasVnodeHook = true;\n            }\n            if (value.type === 20 /* NodeTypes.JS_CACHE_EXPRESSION */ ||\n                ((value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||\n                    value.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) &&\n                    getConstantType(value, context) > 0)) {\n                // skip if the prop is a cached handler or has constant value\n                return;\n            }\n            if (name === 'ref') {\n                hasRef = true;\n            }\n            else if (name === 'class') {\n                hasClassBinding = true;\n            }\n            else if (name === 'style') {\n                hasStyleBinding = true;\n            }\n            else if (name !== 'key' && !dynamicPropNames.includes(name)) {\n                dynamicPropNames.push(name);\n            }\n            // treat the dynamic class and style binding of the component as dynamic props\n            if (isComponent &&\n                (name === 'class' || name === 'style') &&\n                !dynamicPropNames.includes(name)) {\n                dynamicPropNames.push(name);\n            }\n        }\n        else {\n            hasDynamicKeys = true;\n        }\n    };\n    for (let i = 0; i < props.length; i++) {\n        // static attribute\n        const prop = props[i];\n        if (prop.type === 6 /* NodeTypes.ATTRIBUTE */) {\n            const { loc, name, value } = prop;\n            let isStatic = true;\n            if (name === 'ref') {\n                hasRef = true;\n                if (context.scopes.vFor > 0) {\n                    properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));\n                }\n            }\n            // skip is on <component>, or is=\"vue:xxx\"\n            if (name === 'is' &&\n                (isComponentTag(tag) ||\n                    (value && value.content.startsWith('vue:')) ||\n                    (isCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context)))) {\n                continue;\n            }\n            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));\n        }\n        else {\n            // directives\n            const { name, arg, exp, loc } = prop;\n            const isVBind = name === 'bind';\n            const isVOn = name === 'on';\n            // skip v-slot - it is handled by its dedicated transform.\n            if (name === 'slot') {\n                if (!isComponent) {\n                    context.onError(createCompilerError(40 /* ErrorCodes.X_V_SLOT_MISPLACED */, loc));\n                }\n                continue;\n            }\n            // skip v-once/v-memo - they are handled by dedicated transforms.\n            if (name === 'once' || name === 'memo') {\n                continue;\n            }\n            // skip v-is and :is on <component>\n            if (name === 'is' ||\n                (isVBind &&\n                    isStaticArgOf(arg, 'is') &&\n                    (isComponentTag(tag) ||\n                        (isCompatEnabled(\"COMPILER_IS_ON_ELEMENT\" /* CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT */, context))))) {\n                continue;\n            }\n            // skip v-on in SSR compilation\n            if (isVOn && ssr) {\n                continue;\n            }\n            if (\n            // #938: elements with dynamic keys should be forced into blocks\n            (isVBind && isStaticArgOf(arg, 'key')) ||\n                // inline before-update hooks need to force block so that it is invoked\n                // before children\n                (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))) {\n                shouldUseBlock = true;\n            }\n            if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {\n                properties.push(createObjectProperty(createSimpleExpression('ref_for', true), createSimpleExpression('true')));\n            }\n            // special case for v-bind and v-on with no argument\n            if (!arg && (isVBind || isVOn)) {\n                hasDynamicKeys = true;\n                if (exp) {\n                    if (isVBind) {\n                        // have to merge early for compat build check\n                        pushMergeArg();\n                        {\n                            // 2.x v-bind object order compat\n                            if ((true)) {\n                                const hasOverridableKeys = mergeArgs.some(arg => {\n                                    if (arg.type === 15 /* NodeTypes.JS_OBJECT_EXPRESSION */) {\n                                        return arg.properties.some(({ key }) => {\n                                            if (key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */ ||\n                                                !key.isStatic) {\n                                                return true;\n                                            }\n                                            return (key.content !== 'class' &&\n                                                key.content !== 'style' &&\n                                                !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(key.content));\n                                        });\n                                    }\n                                    else {\n                                        // dynamic expression\n                                        return true;\n                                    }\n                                });\n                                if (hasOverridableKeys) {\n                                    checkCompatEnabled(\"COMPILER_V_BIND_OBJECT_ORDER\" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context, loc);\n                                }\n                            }\n                            if (isCompatEnabled(\"COMPILER_V_BIND_OBJECT_ORDER\" /* CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER */, context)) {\n                                mergeArgs.unshift(exp);\n                                continue;\n                            }\n                        }\n                        mergeArgs.push(exp);\n                    }\n                    else {\n                        // v-on=\"obj\" -> toHandlers(obj)\n                        pushMergeArg({\n                            type: 14 /* NodeTypes.JS_CALL_EXPRESSION */,\n                            loc,\n                            callee: context.helper(TO_HANDLERS),\n                            arguments: isComponent ? [exp] : [exp, `true`]\n                        });\n                    }\n                }\n                else {\n                    context.onError(createCompilerError(isVBind\n                        ? 34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */\n                        : 35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));\n                }\n                continue;\n            }\n            const directiveTransform = context.directiveTransforms[name];\n            if (directiveTransform) {\n                // has built-in directive transform.\n                const { props, needRuntime } = directiveTransform(prop, node, context);\n                !ssr && props.forEach(analyzePatchFlag);\n                if (isVOn && arg && !isStaticExp(arg)) {\n                    pushMergeArg(createObjectExpression(props, elementLoc));\n                }\n                else {\n                    properties.push(...props);\n                }\n                if (needRuntime) {\n                    runtimeDirectives.push(prop);\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(needRuntime)) {\n                        directiveImportMap.set(prop, needRuntime);\n                    }\n                }\n            }\n            else if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isBuiltInDirective)(name)) {\n                // no built-in transform, this is a user custom directive.\n                runtimeDirectives.push(prop);\n                // custom dirs may use beforeUpdate so they need to force blocks\n                // to ensure before-update gets called before children update\n                if (hasChildren) {\n                    shouldUseBlock = true;\n                }\n            }\n        }\n    }\n    let propsExpression = undefined;\n    // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\n    if (mergeArgs.length) {\n        // close up any not-yet-merged props\n        pushMergeArg();\n        if (mergeArgs.length > 1) {\n            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\n        }\n        else {\n            // single v-bind with nothing else - no need for a mergeProps call\n            propsExpression = mergeArgs[0];\n        }\n    }\n    else if (properties.length) {\n        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\n    }\n    // patchFlag analysis\n    if (hasDynamicKeys) {\n        patchFlag |= 16 /* PatchFlags.FULL_PROPS */;\n    }\n    else {\n        if (hasClassBinding && !isComponent) {\n            patchFlag |= 2 /* PatchFlags.CLASS */;\n        }\n        if (hasStyleBinding && !isComponent) {\n            patchFlag |= 4 /* PatchFlags.STYLE */;\n        }\n        if (dynamicPropNames.length) {\n            patchFlag |= 8 /* PatchFlags.PROPS */;\n        }\n        if (hasHydrationEventBinding) {\n            patchFlag |= 32 /* PatchFlags.HYDRATE_EVENTS */;\n        }\n    }\n    if (!shouldUseBlock &&\n        (patchFlag === 0 || patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) &&\n        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\n        patchFlag |= 512 /* PatchFlags.NEED_PATCH */;\n    }\n    // pre-normalize props, SSR is skipped for now\n    if (!context.inSSR && propsExpression) {\n        switch (propsExpression.type) {\n            case 15 /* NodeTypes.JS_OBJECT_EXPRESSION */:\n                // means that there is no v-bind,\n                // but still need to deal with dynamic key binding\n                let classKeyIndex = -1;\n                let styleKeyIndex = -1;\n                let hasDynamicKey = false;\n                for (let i = 0; i < propsExpression.properties.length; i++) {\n                    const key = propsExpression.properties[i].key;\n                    if (isStaticExp(key)) {\n                        if (key.content === 'class') {\n                            classKeyIndex = i;\n                        }\n                        else if (key.content === 'style') {\n                            styleKeyIndex = i;\n                        }\n                    }\n                    else if (!key.isHandlerKey) {\n                        hasDynamicKey = true;\n                    }\n                }\n                const classProp = propsExpression.properties[classKeyIndex];\n                const styleProp = propsExpression.properties[styleKeyIndex];\n                // no dynamic key\n                if (!hasDynamicKey) {\n                    if (classProp && !isStaticExp(classProp.value)) {\n                        classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);\n                    }\n                    if (styleProp &&\n                        // the static style is compiled into an object,\n                        // so use `hasStyleBinding` to ensure that it is a dynamic style binding\n                        (hasStyleBinding ||\n                            (styleProp.value.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&\n                                styleProp.value.content.trim()[0] === `[`) ||\n                            // v-bind:style and style both exist,\n                            // v-bind:style with static literal object\n                            styleProp.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */)) {\n                        styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);\n                    }\n                }\n                else {\n                    // dynamic key binding, wrap with `normalizeProps`\n                    propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);\n                }\n                break;\n            case 14 /* NodeTypes.JS_CALL_EXPRESSION */:\n                // mergeProps call, do nothing\n                break;\n            default:\n                // single v-bind\n                propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [\n                    createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\n                        propsExpression\n                    ])\n                ]);\n                break;\n        }\n    }\n    return {\n        props: propsExpression,\n        directives: runtimeDirectives,\n        patchFlag,\n        dynamicPropNames,\n        shouldUseBlock\n    };\n}\n// Dedupe props in an object literal.\n// Literal duplicated attributes would have been warned during the parse phase,\n// however, it's possible to encounter duplicated `onXXX` handlers with different\n// modifiers. We also need to merge static and dynamic class / style attributes.\n// - onXXX handlers / style: merge into array\n// - class: merge into single expression with concatenation\nfunction dedupeProperties(properties) {\n    const knownProps = new Map();\n    const deduped = [];\n    for (let i = 0; i < properties.length; i++) {\n        const prop = properties[i];\n        // dynamic keys are always allowed\n        if (prop.key.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\n            deduped.push(prop);\n            continue;\n        }\n        const name = prop.key.content;\n        const existing = knownProps.get(name);\n        if (existing) {\n            if (name === 'style' || name === 'class' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isOn)(name)) {\n                mergeAsArray(existing, prop);\n            }\n            // unexpected duplicate, should have emitted error during parse\n        }\n        else {\n            knownProps.set(name, prop);\n            deduped.push(prop);\n        }\n    }\n    return deduped;\n}\nfunction mergeAsArray(existing, incoming) {\n    if (existing.value.type === 17 /* NodeTypes.JS_ARRAY_EXPRESSION */) {\n        existing.value.elements.push(incoming.value);\n    }\n    else {\n        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\n    }\n}\nfunction buildDirectiveArgs(dir, context) {\n    const dirArgs = [];\n    const runtime = directiveImportMap.get(dir);\n    if (runtime) {\n        // built-in directive with runtime\n        dirArgs.push(context.helperString(runtime));\n    }\n    else {\n        {\n            // inject statement for resolving directive\n            context.helper(RESOLVE_DIRECTIVE);\n            context.directives.add(dir.name);\n            dirArgs.push(toValidAssetId(dir.name, `directive`));\n        }\n    }\n    const { loc } = dir;\n    if (dir.exp)\n        dirArgs.push(dir.exp);\n    if (dir.arg) {\n        if (!dir.exp) {\n            dirArgs.push(`void 0`);\n        }\n        dirArgs.push(dir.arg);\n    }\n    if (Object.keys(dir.modifiers).length) {\n        if (!dir.arg) {\n            if (!dir.exp) {\n                dirArgs.push(`void 0`);\n            }\n            dirArgs.push(`void 0`);\n        }\n        const trueExpression = createSimpleExpression(`true`, false, loc);\n        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));\n    }\n    return createArrayExpression(dirArgs, dir.loc);\n}\nfunction stringifyDynamicPropNames(props) {\n    let propsNamesString = `[`;\n    for (let i = 0, l = props.length; i < l; i++) {\n        propsNamesString += JSON.stringify(props[i]);\n        if (i < l - 1)\n            propsNamesString += ', ';\n    }\n    return propsNamesString + `]`;\n}\nfunction isComponentTag(tag) {\n    return tag === 'component' || tag === 'Component';\n}\n\n( true)\n    ? Object.freeze({})\n    : 0;\n( true) ? Object.freeze([]) : 0;\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\n\nconst transformSlotOutlet = (node, context) => {\n    if (isSlotOutlet(node)) {\n        const { children, loc } = node;\n        const { slotName, slotProps } = processSlotOutlet(node, context);\n        const slotArgs = [\n            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\n            slotName,\n            '{}',\n            'undefined',\n            'true'\n        ];\n        let expectedLen = 2;\n        if (slotProps) {\n            slotArgs[2] = slotProps;\n            expectedLen = 3;\n        }\n        if (children.length) {\n            slotArgs[3] = createFunctionExpression([], children, false, false, loc);\n            expectedLen = 4;\n        }\n        if (context.scopeId && !context.slotted) {\n            expectedLen = 5;\n        }\n        slotArgs.splice(expectedLen); // remove unused arguments\n        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);\n    }\n};\nfunction processSlotOutlet(node, context) {\n    let slotName = `\"default\"`;\n    let slotProps = undefined;\n    const nonNameProps = [];\n    for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i];\n        if (p.type === 6 /* NodeTypes.ATTRIBUTE */) {\n            if (p.value) {\n                if (p.name === 'name') {\n                    slotName = JSON.stringify(p.value.content);\n                }\n                else {\n                    p.name = camelize(p.name);\n                    nonNameProps.push(p);\n                }\n            }\n        }\n        else {\n            if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {\n                if (p.exp)\n                    slotName = p.exp;\n            }\n            else {\n                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\n                    p.arg.content = camelize(p.arg.content);\n                }\n                nonNameProps.push(p);\n            }\n        }\n    }\n    if (nonNameProps.length > 0) {\n        const { props, directives } = buildProps(node, context, nonNameProps, false, false);\n        slotProps = props;\n        if (directives.length) {\n            context.onError(createCompilerError(36 /* ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));\n        }\n    }\n    return {\n        slotName,\n        slotProps\n    };\n}\n\nconst fnExpRE = /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*(:[^=]+)?=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/;\nconst transformOn = (dir, node, context, augmentor) => {\n    const { loc, modifiers, arg } = dir;\n    if (!dir.exp && !modifiers.length) {\n        context.onError(createCompilerError(35 /* ErrorCodes.X_V_ON_NO_EXPRESSION */, loc));\n    }\n    let eventName;\n    if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        if (arg.isStatic) {\n            let rawName = arg.content;\n            // TODO deprecate @vnodeXXX usage\n            if (rawName.startsWith('vue:')) {\n                rawName = `vnode-${rawName.slice(4)}`;\n            }\n            const eventString = node.tagType !== 0 /* ElementTypes.ELEMENT */ ||\n                rawName.startsWith('vnode') ||\n                !/[A-Z]/.test(rawName)\n                ? // for non-element and vnode lifecycle event listeners, auto convert\n                    // it to camelCase. See issue #2249\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(rawName))\n                : // preserve case for plain element listeners that have uppercase\n                    // letters, as these may be custom elements' custom events\n                    `on:${rawName}`;\n            eventName = createSimpleExpression(eventString, true, arg.loc);\n        }\n        else {\n            // #2388\n            eventName = createCompoundExpression([\n                `${context.helperString(TO_HANDLER_KEY)}(`,\n                arg,\n                `)`\n            ]);\n        }\n    }\n    else {\n        // already a compound expression.\n        eventName = arg;\n        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\n        eventName.children.push(`)`);\n    }\n    // handler processing\n    let exp = dir.exp;\n    if (exp && !exp.content.trim()) {\n        exp = undefined;\n    }\n    let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;\n    if (exp) {\n        const isMemberExp = isMemberExpression(exp.content);\n        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\n        const hasMultipleStatements = exp.content.includes(`;`);\n        if (true) {\n            validateBrowserExpression(exp, context, false, hasMultipleStatements);\n        }\n        if (isInlineStatement || (shouldCache && isMemberExp)) {\n            // wrap inline statement in a function expression\n            exp = createCompoundExpression([\n                `${isInlineStatement\n                    ? `$event`\n                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\n                exp,\n                hasMultipleStatements ? `}` : `)`\n            ]);\n        }\n    }\n    let ret = {\n        props: [\n            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))\n        ]\n    };\n    // apply extended compiler augmentor\n    if (augmentor) {\n        ret = augmentor(ret);\n    }\n    if (shouldCache) {\n        // cache handlers so that it's always the same handler being passed down.\n        // this avoids unnecessary re-renders when users use inline handlers on\n        // components.\n        ret.props[0].value = context.cache(ret.props[0].value);\n    }\n    // mark the key as handler for props normalization check\n    ret.props.forEach(p => (p.key.isHandlerKey = true));\n    return ret;\n};\n\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\n// codegen for the entire props object. This transform here is only for v-bind\n// *with* args.\nconst transformBind = (dir, _node, context) => {\n    const { exp, modifiers, loc } = dir;\n    const arg = dir.arg;\n    if (arg.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        arg.children.unshift(`(`);\n        arg.children.push(`) || \"\"`);\n    }\n    else if (!arg.isStatic) {\n        arg.content = `${arg.content} || \"\"`;\n    }\n    // .sync is replaced by v-model:arg\n    if (modifiers.includes('camel')) {\n        if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n            if (arg.isStatic) {\n                arg.content = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content);\n            }\n            else {\n                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\n            }\n        }\n        else {\n            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\n            arg.children.push(`)`);\n        }\n    }\n    if (!context.inSSR) {\n        if (modifiers.includes('prop')) {\n            injectPrefix(arg, '.');\n        }\n        if (modifiers.includes('attr')) {\n            injectPrefix(arg, '^');\n        }\n    }\n    if (!exp ||\n        (exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ && !exp.content.trim())) {\n        context.onError(createCompilerError(34 /* ErrorCodes.X_V_BIND_NO_EXPRESSION */, loc));\n        return {\n            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\n        };\n    }\n    return {\n        props: [createObjectProperty(arg, exp)]\n    };\n};\nconst injectPrefix = (arg, prefix) => {\n    if (arg.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        if (arg.isStatic) {\n            arg.content = prefix + arg.content;\n        }\n        else {\n            arg.content = `\\`${prefix}\\${${arg.content}}\\``;\n        }\n    }\n    else {\n        arg.children.unshift(`'${prefix}' + (`);\n        arg.children.push(`)`);\n    }\n};\n\n// Merge adjacent text nodes and expressions into a single expression\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\nconst transformText = (node, context) => {\n    if (node.type === 0 /* NodeTypes.ROOT */ ||\n        node.type === 1 /* NodeTypes.ELEMENT */ ||\n        node.type === 11 /* NodeTypes.FOR */ ||\n        node.type === 10 /* NodeTypes.IF_BRANCH */) {\n        // perform the transform on node exit so that all expressions have already\n        // been processed.\n        return () => {\n            const children = node.children;\n            let currentContainer = undefined;\n            let hasText = false;\n            for (let i = 0; i < children.length; i++) {\n                const child = children[i];\n                if (isText$1(child)) {\n                    hasText = true;\n                    for (let j = i + 1; j < children.length; j++) {\n                        const next = children[j];\n                        if (isText$1(next)) {\n                            if (!currentContainer) {\n                                currentContainer = children[i] = createCompoundExpression([child], child.loc);\n                            }\n                            // merge adjacent text node into current\n                            currentContainer.children.push(` + `, next);\n                            children.splice(j, 1);\n                            j--;\n                        }\n                        else {\n                            currentContainer = undefined;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!hasText ||\n                // if this is a plain element with a single text child, leave it\n                // as-is since the runtime has dedicated fast path for this by directly\n                // setting textContent of the element.\n                // for component root it's always normalized anyway.\n                (children.length === 1 &&\n                    (node.type === 0 /* NodeTypes.ROOT */ ||\n                        (node.type === 1 /* NodeTypes.ELEMENT */ &&\n                            node.tagType === 0 /* ElementTypes.ELEMENT */ &&\n                            // #3756\n                            // custom directives can potentially add DOM elements arbitrarily,\n                            // we need to avoid setting textContent of the element at runtime\n                            // to avoid accidentally overwriting the DOM elements added\n                            // by the user through custom directives.\n                            !node.props.find(p => p.type === 7 /* NodeTypes.DIRECTIVE */ &&\n                                !context.directiveTransforms[p.name]) &&\n                            // in compat mode, <template> tags with no special directives\n                            // will be rendered as a fragment so its children must be\n                            // converted into vnodes.\n                            !(node.tag === 'template'))))) {\n                return;\n            }\n            // pre-convert text nodes into createTextVNode(text) calls to avoid\n            // runtime normalization.\n            for (let i = 0; i < children.length; i++) {\n                const child = children[i];\n                if (isText$1(child) || child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {\n                    const callArgs = [];\n                    // createTextVNode defaults to single whitespace, so if it is a\n                    // single space the code could be an empty call to save bytes.\n                    if (child.type !== 2 /* NodeTypes.TEXT */ || child.content !== ' ') {\n                        callArgs.push(child);\n                    }\n                    // mark dynamic text with flag so it gets patched inside a block\n                    if (!context.ssr &&\n                        getConstantType(child, context) === 0 /* ConstantTypes.NOT_CONSTANT */) {\n                        callArgs.push(1 /* PatchFlags.TEXT */ +\n                            (( true) ? ` /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__.PatchFlagNames[1]} */` : 0));\n                    }\n                    children[i] = {\n                        type: 12 /* NodeTypes.TEXT_CALL */,\n                        content: child,\n                        loc: child.loc,\n                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)\n                    };\n                }\n            }\n        };\n    }\n};\n\nconst seen$1 = new WeakSet();\nconst transformOnce = (node, context) => {\n    if (node.type === 1 /* NodeTypes.ELEMENT */ && findDir(node, 'once', true)) {\n        if (seen$1.has(node) || context.inVOnce) {\n            return;\n        }\n        seen$1.add(node);\n        context.inVOnce = true;\n        context.helper(SET_BLOCK_TRACKING);\n        return () => {\n            context.inVOnce = false;\n            const cur = context.currentNode;\n            if (cur.codegenNode) {\n                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);\n            }\n        };\n    }\n};\n\nconst transformModel = (dir, node, context) => {\n    const { exp, arg } = dir;\n    if (!exp) {\n        context.onError(createCompilerError(41 /* ErrorCodes.X_V_MODEL_NO_EXPRESSION */, dir.loc));\n        return createTransformProps();\n    }\n    const rawExp = exp.loc.source;\n    const expString = exp.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ ? exp.content : rawExp;\n    // im SFC <script setup> inline mode, the exp may have been transformed into\n    // _unref(exp)\n    const bindingType = context.bindingMetadata[rawExp];\n    // check props\n    if (bindingType === \"props\" /* BindingTypes.PROPS */ ||\n        bindingType === \"props-aliased\" /* BindingTypes.PROPS_ALIASED */) {\n        context.onError(createCompilerError(44 /* ErrorCodes.X_V_MODEL_ON_PROPS */, exp.loc));\n        return createTransformProps();\n    }\n    const maybeRef = !true  ;\n    if (!expString.trim() ||\n        (!isMemberExpression(expString) && !maybeRef)) {\n        context.onError(createCompilerError(42 /* ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));\n        return createTransformProps();\n    }\n    const propName = arg ? arg : createSimpleExpression('modelValue', true);\n    const eventName = arg\n        ? isStaticExp(arg)\n            ? `onUpdate:${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.camelize)(arg.content)}`\n            : createCompoundExpression(['\"onUpdate:\" + ', arg])\n        : `onUpdate:modelValue`;\n    let assignmentExp;\n    const eventArg = context.isTS ? `($event: any)` : `$event`;\n    {\n        assignmentExp = createCompoundExpression([\n            `${eventArg} => ((`,\n            exp,\n            `) = $event)`\n        ]);\n    }\n    const props = [\n        // modelValue: foo\n        createObjectProperty(propName, dir.exp),\n        // \"onUpdate:modelValue\": $event => (foo = $event)\n        createObjectProperty(eventName, assignmentExp)\n    ];\n    // modelModifiers: { foo: true, \"bar-baz\": true }\n    if (dir.modifiers.length && node.tagType === 1 /* ElementTypes.COMPONENT */) {\n        const modifiers = dir.modifiers\n            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\n            .join(`, `);\n        const modifiersKey = arg\n            ? isStaticExp(arg)\n                ? `${arg.content}Modifiers`\n                : createCompoundExpression([arg, ' + \"Modifiers\"'])\n            : `modelModifiers`;\n        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* ConstantTypes.CAN_HOIST */)));\n    }\n    return createTransformProps(props);\n};\nfunction createTransformProps(props = []) {\n    return { props };\n}\n\nconst validDivisionCharRE = /[\\w).+\\-_$\\]]/;\nconst transformFilter = (node, context) => {\n    if (!isCompatEnabled(\"COMPILER_FILTER\" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context)) {\n        return;\n    }\n    if (node.type === 5 /* NodeTypes.INTERPOLATION */) {\n        // filter rewrite is applied before expression transform so only\n        // simple expressions are possible at this stage\n        rewriteFilter(node.content, context);\n    }\n    if (node.type === 1 /* NodeTypes.ELEMENT */) {\n        node.props.forEach((prop) => {\n            if (prop.type === 7 /* NodeTypes.DIRECTIVE */ &&\n                prop.name !== 'for' &&\n                prop.exp) {\n                rewriteFilter(prop.exp, context);\n            }\n        });\n    }\n};\nfunction rewriteFilter(node, context) {\n    if (node.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n        parseFilter(node, context);\n    }\n    else {\n        for (let i = 0; i < node.children.length; i++) {\n            const child = node.children[i];\n            if (typeof child !== 'object')\n                continue;\n            if (child.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */) {\n                parseFilter(child, context);\n            }\n            else if (child.type === 8 /* NodeTypes.COMPOUND_EXPRESSION */) {\n                rewriteFilter(node, context);\n            }\n            else if (child.type === 5 /* NodeTypes.INTERPOLATION */) {\n                rewriteFilter(child.content, context);\n            }\n        }\n    }\n}\nfunction parseFilter(node, context) {\n    const exp = node.content;\n    let inSingle = false;\n    let inDouble = false;\n    let inTemplateString = false;\n    let inRegex = false;\n    let curly = 0;\n    let square = 0;\n    let paren = 0;\n    let lastFilterIndex = 0;\n    let c, prev, i, expression, filters = [];\n    for (i = 0; i < exp.length; i++) {\n        prev = c;\n        c = exp.charCodeAt(i);\n        if (inSingle) {\n            if (c === 0x27 && prev !== 0x5c)\n                inSingle = false;\n        }\n        else if (inDouble) {\n            if (c === 0x22 && prev !== 0x5c)\n                inDouble = false;\n        }\n        else if (inTemplateString) {\n            if (c === 0x60 && prev !== 0x5c)\n                inTemplateString = false;\n        }\n        else if (inRegex) {\n            if (c === 0x2f && prev !== 0x5c)\n                inRegex = false;\n        }\n        else if (c === 0x7c && // pipe\n            exp.charCodeAt(i + 1) !== 0x7c &&\n            exp.charCodeAt(i - 1) !== 0x7c &&\n            !curly &&\n            !square &&\n            !paren) {\n            if (expression === undefined) {\n                // first filter, end of expression\n                lastFilterIndex = i + 1;\n                expression = exp.slice(0, i).trim();\n            }\n            else {\n                pushFilter();\n            }\n        }\n        else {\n            switch (c) {\n                case 0x22:\n                    inDouble = true;\n                    break; // \"\n                case 0x27:\n                    inSingle = true;\n                    break; // '\n                case 0x60:\n                    inTemplateString = true;\n                    break; // `\n                case 0x28:\n                    paren++;\n                    break; // (\n                case 0x29:\n                    paren--;\n                    break; // )\n                case 0x5b:\n                    square++;\n                    break; // [\n                case 0x5d:\n                    square--;\n                    break; // ]\n                case 0x7b:\n                    curly++;\n                    break; // {\n                case 0x7d:\n                    curly--;\n                    break; // }\n            }\n            if (c === 0x2f) {\n                // /\n                let j = i - 1;\n                let p;\n                // find first non-whitespace prev char\n                for (; j >= 0; j--) {\n                    p = exp.charAt(j);\n                    if (p !== ' ')\n                        break;\n                }\n                if (!p || !validDivisionCharRE.test(p)) {\n                    inRegex = true;\n                }\n            }\n        }\n    }\n    if (expression === undefined) {\n        expression = exp.slice(0, i).trim();\n    }\n    else if (lastFilterIndex !== 0) {\n        pushFilter();\n    }\n    function pushFilter() {\n        filters.push(exp.slice(lastFilterIndex, i).trim());\n        lastFilterIndex = i + 1;\n    }\n    if (filters.length) {\n        ( true) &&\n            warnDeprecation(\"COMPILER_FILTER\" /* CompilerDeprecationTypes.COMPILER_FILTERS */, context, node.loc);\n        for (i = 0; i < filters.length; i++) {\n            expression = wrapFilter(expression, filters[i], context);\n        }\n        node.content = expression;\n    }\n}\nfunction wrapFilter(exp, filter, context) {\n    context.helper(RESOLVE_FILTER);\n    const i = filter.indexOf('(');\n    if (i < 0) {\n        context.filters.add(filter);\n        return `${toValidAssetId(filter, 'filter')}(${exp})`;\n    }\n    else {\n        const name = filter.slice(0, i);\n        const args = filter.slice(i + 1);\n        context.filters.add(name);\n        return `${toValidAssetId(name, 'filter')}(${exp}${args !== ')' ? ',' + args : args}`;\n    }\n}\n\nconst seen = new WeakSet();\nconst transformMemo = (node, context) => {\n    if (node.type === 1 /* NodeTypes.ELEMENT */) {\n        const dir = findDir(node, 'memo');\n        if (!dir || seen.has(node)) {\n            return;\n        }\n        seen.add(node);\n        return () => {\n            const codegenNode = node.codegenNode ||\n                context.currentNode.codegenNode;\n            if (codegenNode && codegenNode.type === 13 /* NodeTypes.VNODE_CALL */) {\n                // non-component sub tree should be turned into a block\n                if (node.tagType !== 1 /* ElementTypes.COMPONENT */) {\n                    makeBlock(codegenNode, context);\n                }\n                node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\n                    dir.exp,\n                    createFunctionExpression(undefined, codegenNode),\n                    `_cache`,\n                    String(context.cached++)\n                ]);\n            }\n        };\n    }\n};\n\nfunction getBaseTransformPreset(prefixIdentifiers) {\n    return [\n        [\n            transformOnce,\n            transformIf,\n            transformMemo,\n            transformFor,\n            ...([transformFilter] ),\n            ...(( true)\n                    ? [transformExpression]\n                    : 0),\n            transformSlotOutlet,\n            transformElement,\n            trackSlotScopes,\n            transformText\n        ],\n        {\n            on: transformOn,\n            bind: transformBind,\n            model: transformModel\n        }\n    ];\n}\n// we name it `baseCompile` so that higher order compilers like\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\nfunction baseCompile(template, options = {}) {\n    const onError = options.onError || defaultOnError;\n    const isModuleMode = options.mode === 'module';\n    /* istanbul ignore if */\n    {\n        if (options.prefixIdentifiers === true) {\n            onError(createCompilerError(47 /* ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED */));\n        }\n        else if (isModuleMode) {\n            onError(createCompilerError(48 /* ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED */));\n        }\n    }\n    const prefixIdentifiers = !true ;\n    if (options.cacheHandlers) {\n        onError(createCompilerError(49 /* ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED */));\n    }\n    if (options.scopeId && !isModuleMode) {\n        onError(createCompilerError(50 /* ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED */));\n    }\n    const ast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(template) ? baseParse(template, options) : template;\n    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\n    transform(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {\n        prefixIdentifiers,\n        nodeTransforms: [\n            ...nodeTransforms,\n            ...(options.nodeTransforms || []) // user transforms\n        ],\n        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, directiveTransforms, options.directiveTransforms || {} // user transforms\n        )\n    }));\n    return generate(ast, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {\n        prefixIdentifiers\n    }));\n}\n\nconst noopDirectiveTransform = () => ({ props: [] });\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL2Rpc3QvY29tcGlsZXItY29yZS5lc20tYnVuZGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdQO0FBQ2hNOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssS0FBcUMsZ0NBQWdDLFlBQVk7QUFDdEY7QUFDQTtBQUNBLGdCQUFnQixLQUFnRDtBQUNoRTtBQUNBLFVBQVUsQ0FBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsS0FBcUMsaUJBQWlCLENBQUU7QUFDakYseUJBQXlCLEtBQXFDLGlCQUFpQixDQUFFO0FBQ2pGLHlCQUF5QixLQUFxQyxpQkFBaUIsQ0FBRTtBQUNqRiwyQkFBMkIsS0FBcUMsa0JBQWtCLENBQUU7QUFDcEYsZ0NBQWdDLEtBQXFDLHVCQUF1QixDQUFFO0FBQzlGLDJCQUEyQixLQUFxQyxrQkFBa0IsQ0FBRTtBQUNwRiw2QkFBNkIsS0FBcUMs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLHNEQUFTO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFPO0FBQ25CLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0RBQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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YnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL2Rpc3QvY29tcGlsZXItY29yZS5lc20tYnVuZGxlci5qcz8xZDI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU3RyaW5nLCBoeXBoZW5hdGUsIE5PT1AsIGV4dGVuZCwgaXNPYmplY3QsIE5PLCBpc0FycmF5LCBtYWtlTWFwLCBpc1N5bWJvbCwgY2FwaXRhbGl6ZSwgY2FtZWxpemUgYXMgY2FtZWxpemUkMSwgRU1QVFlfT0JKLCBQYXRjaEZsYWdOYW1lcywgc2xvdEZsYWdzVGV4dCwgaXNPbiwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc1Jlc2VydmVkUHJvcCwgdG9IYW5kbGVyS2V5IH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuZXhwb3J0IHsgZ2VuZXJhdGVDb2RlRnJhbWUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRPbkVycm9yKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25XYXJuKG1zZykge1xuICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHttc2cubWVzc2FnZX1gKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jLCBtZXNzYWdlcywgYWRkaXRpb25hbE1lc3NhZ2UpIHtcbiAgICBjb25zdCBtc2cgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWVcbiAgICAgICAgPyAobWVzc2FnZXMgfHwgZXJyb3JNZXNzYWdlcylbY29kZV0gKyAoYWRkaXRpb25hbE1lc3NhZ2UgfHwgYGApXG4gICAgICAgIDogY29kZTtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTeW50YXhFcnJvcihTdHJpbmcobXNnKSk7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgZXJyb3IubG9jID0gbG9jO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbmNvbnN0IGVycm9yTWVzc2FnZXMgPSB7XG4gICAgLy8gcGFyc2UgZXJyb3JzXG4gICAgWzAgLyogRXJyb3JDb2Rlcy5BQlJVUFRfQ0xPU0lOR19PRl9FTVBUWV9DT01NRU5UICovXTogJ0lsbGVnYWwgY29tbWVudC4nLFxuICAgIFsxIC8qIEVycm9yQ29kZXMuQ0RBVEFfSU5fSFRNTF9DT05URU5UICovXTogJ0NEQVRBIHNlY3Rpb24gaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LicsXG4gICAgWzIgLyogRXJyb3JDb2Rlcy5EVVBMSUNBVEVfQVRUUklCVVRFICovXTogJ0R1cGxpY2F0ZSBhdHRyaWJ1dGUuJyxcbiAgICBbMyAvKiBFcnJvckNvZGVzLkVORF9UQUdfV0lUSF9BVFRSSUJVVEVTICovXTogJ0VuZCB0YWcgY2Fubm90IGhhdmUgYXR0cmlidXRlcy4nLFxuICAgIFs0IC8qIEVycm9yQ29kZXMuRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi9dOiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXG4gICAgWzUgLyogRXJyb3JDb2Rlcy5FT0ZfQkVGT1JFX1RBR19OQU1FICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIHRhZy4nLFxuICAgIFs2IC8qIEVycm9yQ29kZXMuRU9GX0lOX0NEQVRBICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIENEQVRBIHNlY3Rpb24uJyxcbiAgICBbNyAvKiBFcnJvckNvZGVzLkVPRl9JTl9DT01NRU5UICovXTogJ1VuZXhwZWN0ZWQgRU9GIGluIGNvbW1lbnQuJyxcbiAgICBbOCAvKiBFcnJvckNvZGVzLkVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqL106ICdVbmV4cGVjdGVkIEVPRiBpbiBzY3JpcHQuJyxcbiAgICBbOSAvKiBFcnJvckNvZGVzLkVPRl9JTl9UQUcgKi9dOiAnVW5leHBlY3RlZCBFT0YgaW4gdGFnLicsXG4gICAgWzEwIC8qIEVycm9yQ29kZXMuSU5DT1JSRUNUTFlfQ0xPU0VEX0NPTU1FTlQgKi9dOiAnSW5jb3JyZWN0bHkgY2xvc2VkIGNvbW1lbnQuJyxcbiAgICBbMTEgLyogRXJyb3JDb2Rlcy5JTkNPUlJFQ1RMWV9PUEVORURfQ09NTUVOVCAqL106ICdJbmNvcnJlY3RseSBvcGVuZWQgY29tbWVudC4nLFxuICAgIFsxMiAvKiBFcnJvckNvZGVzLklOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovXTogXCJJbGxlZ2FsIHRhZyBuYW1lLiBVc2UgJyZsdDsnIHRvIHByaW50ICc8Jy5cIixcbiAgICBbMTMgLyogRXJyb3JDb2Rlcy5NSVNTSU5HX0FUVFJJQlVURV9WQUxVRSAqL106ICdBdHRyaWJ1dGUgdmFsdWUgd2FzIGV4cGVjdGVkLicsXG4gICAgWzE0IC8qIEVycm9yQ29kZXMuTUlTU0lOR19FTkRfVEFHX05BTUUgKi9dOiAnRW5kIHRhZyBuYW1lIHdhcyBleHBlY3RlZC4nLFxuICAgIFsxNSAvKiBFcnJvckNvZGVzLk1JU1NJTkdfV0hJVEVTUEFDRV9CRVRXRUVOX0FUVFJJQlVURVMgKi9dOiAnV2hpdGVzcGFjZSB3YXMgZXhwZWN0ZWQuJyxcbiAgICBbMTYgLyogRXJyb3JDb2Rlcy5ORVNURURfQ09NTUVOVCAqL106IFwiVW5leHBlY3RlZCAnPCEtLScgaW4gY29tbWVudC5cIixcbiAgICBbMTcgLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqL106ICdBdHRyaWJ1dGUgbmFtZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3IChcXCcpLCBhbmQgVSswMDNDICg8KS4nLFxuICAgIFsxOCAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqL106ICdVbnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgY2Fubm90IGNvbnRhaW4gVSswMDIyIChcIiksIFUrMDAyNyAoXFwnKSwgVSswMDNDICg8KSwgVSswMDNEICg9KSwgYW5kIFUrMDA2MCAoYCkuJyxcbiAgICBbMTkgLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0VRVUFMU19TSUdOX0JFRk9SRV9BVFRSSUJVVEVfTkFNRSAqL106IFwiQXR0cmlidXRlIG5hbWUgY2Fubm90IHN0YXJ0IHdpdGggJz0nLlwiLFxuICAgIFsyMSAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfUVVFU1RJT05fTUFSS19JTlNURUFEX09GX1RBR19OQU1FICovXTogXCInPD8nIGlzIGFsbG93ZWQgb25seSBpbiBYTUwgY29udGV4dC5cIixcbiAgICBbMjAgLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX05VTExfQ0hBUkFDVEVSICovXTogYFVuZXhwZWN0ZWQgbnVsbCBjaGFyYWN0ZXIuYCxcbiAgICBbMjIgLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovXTogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxuICAgIC8vIFZ1ZS1zcGVjaWZpYyBwYXJzZSBlcnJvcnNcbiAgICBbMjMgLyogRXJyb3JDb2Rlcy5YX0lOVkFMSURfRU5EX1RBRyAqL106ICdJbnZhbGlkIGVuZCB0YWcuJyxcbiAgICBbMjQgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfRU5EX1RBRyAqL106ICdFbGVtZW50IGlzIG1pc3NpbmcgZW5kIHRhZy4nLFxuICAgIFsyNSAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19JTlRFUlBPTEFUSU9OX0VORCAqL106ICdJbnRlcnBvbGF0aW9uIGVuZCBzaWduIHdhcyBub3QgZm91bmQuJyxcbiAgICBbMjcgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfRFlOQU1JQ19ESVJFQ1RJVkVfQVJHVU1FTlRfRU5EICovXTogJ0VuZCBicmFja2V0IGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCB3YXMgbm90IGZvdW5kLiAnICtcbiAgICAgICAgJ05vdGUgdGhhdCBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCBjYW5ub3QgY29udGFpbiBzcGFjZXMuJyxcbiAgICBbMjYgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfRElSRUNUSVZFX05BTUUgKi9dOiAnTGVnYWwgZGlyZWN0aXZlIG5hbWUgd2FzIGV4cGVjdGVkLicsXG4gICAgLy8gdHJhbnNmb3JtIGVycm9yc1xuICAgIFsyOCAvKiBFcnJvckNvZGVzLlhfVl9JRl9OT19FWFBSRVNTSU9OICovXTogYHYtaWYvdi1lbHNlLWlmIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFsyOSAvKiBFcnJvckNvZGVzLlhfVl9JRl9TQU1FX0tFWSAqL106IGB2LWlmL2Vsc2UgYnJhbmNoZXMgbXVzdCB1c2UgdW5pcXVlIGtleXMuYCxcbiAgICBbMzAgLyogRXJyb3JDb2Rlcy5YX1ZfRUxTRV9OT19BREpBQ0VOVF9JRiAqL106IGB2LWVsc2Uvdi1lbHNlLWlmIGhhcyBubyBhZGphY2VudCB2LWlmIG9yIHYtZWxzZS1pZi5gLFxuICAgIFszMSAvKiBFcnJvckNvZGVzLlhfVl9GT1JfTk9fRVhQUkVTU0lPTiAqL106IGB2LWZvciBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgICBbMzIgLyogRXJyb3JDb2Rlcy5YX1ZfRk9SX01BTEZPUk1FRF9FWFBSRVNTSU9OICovXTogYHYtZm9yIGhhcyBpbnZhbGlkIGV4cHJlc3Npb24uYCxcbiAgICBbMzMgLyogRXJyb3JDb2Rlcy5YX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi9dOiBgPHRlbXBsYXRlIHYtZm9yPiBrZXkgc2hvdWxkIGJlIHBsYWNlZCBvbiB0aGUgPHRlbXBsYXRlPiB0YWcuYCxcbiAgICBbMzQgLyogRXJyb3JDb2Rlcy5YX1ZfQklORF9OT19FWFBSRVNTSU9OICovXTogYHYtYmluZCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uYCxcbiAgICBbMzUgLyogRXJyb3JDb2Rlcy5YX1ZfT05fTk9fRVhQUkVTU0lPTiAqL106IGB2LW9uIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICAgIFszNiAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovXTogYFVuZXhwZWN0ZWQgY3VzdG9tIGRpcmVjdGl2ZSBvbiA8c2xvdD4gb3V0bGV0LmAsXG4gICAgWzM3IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRSAqL106IGBNaXhlZCB2LXNsb3QgdXNhZ2Ugb24gYm90aCB0aGUgY29tcG9uZW50IGFuZCBuZXN0ZWQgPHRlbXBsYXRlPi4gYCArXG4gICAgICAgIGBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBuYW1lZCBzbG90cywgYWxsIHNsb3RzIHNob3VsZCB1c2UgPHRlbXBsYXRlPiBgICtcbiAgICAgICAgYHN5bnRheCB0byBhdm9pZCBzY29wZSBhbWJpZ3VpdHkuYCxcbiAgICBbMzggLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FUyAqL106IGBEdXBsaWNhdGUgc2xvdCBuYW1lcyBmb3VuZC4gYCxcbiAgICBbMzkgLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqL106IGBFeHRyYW5lb3VzIGNoaWxkcmVuIGZvdW5kIHdoZW4gY29tcG9uZW50IGFscmVhZHkgaGFzIGV4cGxpY2l0bHkgbmFtZWQgYCArXG4gICAgICAgIGBkZWZhdWx0IHNsb3QuIFRoZXNlIGNoaWxkcmVuIHdpbGwgYmUgaWdub3JlZC5gLFxuICAgIFs0MCAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX01JU1BMQUNFRCAqL106IGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4gdGFncy5gLFxuICAgIFs0MSAvKiBFcnJvckNvZGVzLlhfVl9NT0RFTF9OT19FWFBSRVNTSU9OICovXTogYHYtbW9kZWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gICAgWzQyIC8qIEVycm9yQ29kZXMuWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovXTogYHYtbW9kZWwgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIEphdmFTY3JpcHQgbWVtYmVyIGV4cHJlc3Npb24uYCxcbiAgICBbNDMgLyogRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfT05fU0NPUEVfVkFSSUFCTEUgKi9dOiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiB2LWZvciBvciB2LXNsb3Qgc2NvcGUgdmFyaWFibGVzIGJlY2F1c2UgdGhleSBhcmUgbm90IHdyaXRhYmxlLmAsXG4gICAgWzQ0IC8qIEVycm9yQ29kZXMuWF9WX01PREVMX09OX1BST1BTICovXTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gYSBwcm9wLCBiZWNhdXNlIGxvY2FsIHByb3AgYmluZGluZ3MgYXJlIG5vdCB3cml0YWJsZS5cXG5Vc2UgYSB2LWJpbmQgYmluZGluZyBjb21iaW5lZCB3aXRoIGEgdi1vbiBsaXN0ZW5lciB0aGF0IGVtaXRzIHVwZGF0ZTp4IGV2ZW50IGluc3RlYWQuYCxcbiAgICBbNDUgLyogRXJyb3JDb2Rlcy5YX0lOVkFMSURfRVhQUkVTU0lPTiAqL106IGBFcnJvciBwYXJzaW5nIEphdmFTY3JpcHQgZXhwcmVzc2lvbjogYCxcbiAgICBbNDYgLyogRXJyb3JDb2Rlcy5YX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTiAqL106IGA8S2VlcEFsaXZlPiBleHBlY3RzIGV4YWN0bHkgb25lIGNoaWxkIGNvbXBvbmVudC5gLFxuICAgIC8vIGdlbmVyaWMgZXJyb3JzXG4gICAgWzQ3IC8qIEVycm9yQ29kZXMuWF9QUkVGSVhfSURfTk9UX1NVUFBPUlRFRCAqL106IGBcInByZWZpeElkZW50aWZpZXJzXCIgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5gLFxuICAgIFs0OCAvKiBFcnJvckNvZGVzLlhfTU9EVUxFX01PREVfTk9UX1NVUFBPUlRFRCAqL106IGBFUyBtb2R1bGUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgY29tcGlsZXIuYCxcbiAgICBbNDkgLyogRXJyb3JDb2Rlcy5YX0NBQ0hFX0hBTkRMRVJfTk9UX1NVUFBPUlRFRCAqL106IGBcImNhY2hlSGFuZGxlcnNcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB0aGUgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBlbmFibGVkLmAsXG4gICAgWzUwIC8qIEVycm9yQ29kZXMuWF9TQ09QRV9JRF9OT1RfU1VQUE9SVEVEICovXTogYFwic2NvcGVJZFwiIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBtb2R1bGUgbW9kZS5gLFxuICAgIC8vIGp1c3QgdG8gZnVsZmlsbCB0eXBlc1xuICAgIFs1MSAvKiBFcnJvckNvZGVzLl9fRVhURU5EX1BPSU5UX18gKi9dOiBgYFxufTtcblxuY29uc3QgRlJBR01FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYEZyYWdtZW50YCA6IGBgKTtcbmNvbnN0IFRFTEVQT1JUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUZWxlcG9ydGAgOiBgYCk7XG5jb25zdCBTVVNQRU5TRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgU3VzcGVuc2VgIDogYGApO1xuY29uc3QgS0VFUF9BTElWRSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgS2VlcEFsaXZlYCA6IGBgKTtcbmNvbnN0IEJBU0VfVFJBTlNJVElPTiA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgQmFzZVRyYW5zaXRpb25gIDogYGApO1xuY29uc3QgT1BFTl9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgb3BlbkJsb2NrYCA6IGBgKTtcbmNvbnN0IENSRUFURV9CTE9DSyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlQmxvY2tgIDogYGApO1xuY29uc3QgQ1JFQVRFX0VMRU1FTlRfQkxPQ0sgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUVsZW1lbnRCbG9ja2AgOiBgYCk7XG5jb25zdCBDUkVBVEVfVk5PREUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVZOb2RlYCA6IGBgKTtcbmNvbnN0IENSRUFURV9FTEVNRU5UX1ZOT0RFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVFbGVtZW50Vk5vZGVgIDogYGApO1xuY29uc3QgQ1JFQVRFX0NPTU1FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZUNvbW1lbnRWTm9kZWAgOiBgYCk7XG5jb25zdCBDUkVBVEVfVEVYVCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgY3JlYXRlVGV4dFZOb2RlYCA6IGBgKTtcbmNvbnN0IENSRUFURV9TVEFUSUMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNyZWF0ZVN0YXRpY1ZOb2RlYCA6IGBgKTtcbmNvbnN0IFJFU09MVkVfQ09NUE9ORU5UID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlQ29tcG9uZW50YCA6IGBgKTtcbmNvbnN0IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCA6IGBgKTtcbmNvbnN0IFJFU09MVkVfRElSRUNUSVZFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRGlyZWN0aXZlYCA6IGBgKTtcbmNvbnN0IFJFU09MVkVfRklMVEVSID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGByZXNvbHZlRmlsdGVyYCA6IGBgKTtcbmNvbnN0IFdJVEhfRElSRUNUSVZFUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aERpcmVjdGl2ZXNgIDogYGApO1xuY29uc3QgUkVOREVSX0xJU1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlckxpc3RgIDogYGApO1xuY29uc3QgUkVOREVSX1NMT1QgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHJlbmRlclNsb3RgIDogYGApO1xuY29uc3QgQ1JFQVRFX1NMT1RTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBjcmVhdGVTbG90c2AgOiBgYCk7XG5jb25zdCBUT19ESVNQTEFZX1NUUklORyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdG9EaXNwbGF5U3RyaW5nYCA6IGBgKTtcbmNvbnN0IE1FUkdFX1BST1BTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBtZXJnZVByb3BzYCA6IGBgKTtcbmNvbnN0IE5PUk1BTElaRV9DTEFTUyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgbm9ybWFsaXplQ2xhc3NgIDogYGApO1xuY29uc3QgTk9STUFMSVpFX1NUWUxFID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBub3JtYWxpemVTdHlsZWAgOiBgYCk7XG5jb25zdCBOT1JNQUxJWkVfUFJPUFMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYG5vcm1hbGl6ZVByb3BzYCA6IGBgKTtcbmNvbnN0IEdVQVJEX1JFQUNUSVZFX1BST1BTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBndWFyZFJlYWN0aXZlUHJvcHNgIDogYGApO1xuY29uc3QgVE9fSEFORExFUlMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcnNgIDogYGApO1xuY29uc3QgQ0FNRUxJWkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNhbWVsaXplYCA6IGBgKTtcbmNvbnN0IENBUElUQUxJWkUgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGNhcGl0YWxpemVgIDogYGApO1xuY29uc3QgVE9fSEFORExFUl9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHRvSGFuZGxlcktleWAgOiBgYCk7XG5jb25zdCBTRVRfQkxPQ0tfVFJBQ0tJTkcgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHNldEJsb2NrVHJhY2tpbmdgIDogYGApO1xuY29uc3QgUFVTSF9TQ09QRV9JRCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgcHVzaFNjb3BlSWRgIDogYGApO1xuY29uc3QgUE9QX1NDT1BFX0lEID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBwb3BTY29wZUlkYCA6IGBgKTtcbmNvbnN0IFdJVEhfQ1RYID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB3aXRoQ3R4YCA6IGBgKTtcbmNvbnN0IFVOUkVGID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB1bnJlZmAgOiBgYCk7XG5jb25zdCBJU19SRUYgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYGlzUmVmYCA6IGBgKTtcbmNvbnN0IFdJVEhfTUVNTyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgd2l0aE1lbW9gIDogYGApO1xuY29uc3QgSVNfTUVNT19TQU1FID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBpc01lbW9TYW1lYCA6IGBgKTtcbi8vIE5hbWUgbWFwcGluZyBmb3IgcnVudGltZSBoZWxwZXJzIHRoYXQgbmVlZCB0byBiZSBpbXBvcnRlZCBmcm9tICd2dWUnIGluXG4vLyBnZW5lcmF0ZWQgY29kZS4gTWFrZSBzdXJlIHRoZXNlIGFyZSBjb3JyZWN0bHkgZXhwb3J0ZWQgaW4gdGhlIHJ1bnRpbWUhXG5jb25zdCBoZWxwZXJOYW1lTWFwID0ge1xuICAgIFtGUkFHTUVOVF06IGBGcmFnbWVudGAsXG4gICAgW1RFTEVQT1JUXTogYFRlbGVwb3J0YCxcbiAgICBbU1VTUEVOU0VdOiBgU3VzcGVuc2VgLFxuICAgIFtLRUVQX0FMSVZFXTogYEtlZXBBbGl2ZWAsXG4gICAgW0JBU0VfVFJBTlNJVElPTl06IGBCYXNlVHJhbnNpdGlvbmAsXG4gICAgW09QRU5fQkxPQ0tdOiBgb3BlbkJsb2NrYCxcbiAgICBbQ1JFQVRFX0JMT0NLXTogYGNyZWF0ZUJsb2NrYCxcbiAgICBbQ1JFQVRFX0VMRU1FTlRfQkxPQ0tdOiBgY3JlYXRlRWxlbWVudEJsb2NrYCxcbiAgICBbQ1JFQVRFX1ZOT0RFXTogYGNyZWF0ZVZOb2RlYCxcbiAgICBbQ1JFQVRFX0VMRU1FTlRfVk5PREVdOiBgY3JlYXRlRWxlbWVudFZOb2RlYCxcbiAgICBbQ1JFQVRFX0NPTU1FTlRdOiBgY3JlYXRlQ29tbWVudFZOb2RlYCxcbiAgICBbQ1JFQVRFX1RFWFRdOiBgY3JlYXRlVGV4dFZOb2RlYCxcbiAgICBbQ1JFQVRFX1NUQVRJQ106IGBjcmVhdGVTdGF0aWNWTm9kZWAsXG4gICAgW1JFU09MVkVfQ09NUE9ORU5UXTogYHJlc29sdmVDb21wb25lbnRgLFxuICAgIFtSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5UXTogYHJlc29sdmVEeW5hbWljQ29tcG9uZW50YCxcbiAgICBbUkVTT0xWRV9ESVJFQ1RJVkVdOiBgcmVzb2x2ZURpcmVjdGl2ZWAsXG4gICAgW1JFU09MVkVfRklMVEVSXTogYHJlc29sdmVGaWx0ZXJgLFxuICAgIFtXSVRIX0RJUkVDVElWRVNdOiBgd2l0aERpcmVjdGl2ZXNgLFxuICAgIFtSRU5ERVJfTElTVF06IGByZW5kZXJMaXN0YCxcbiAgICBbUkVOREVSX1NMT1RdOiBgcmVuZGVyU2xvdGAsXG4gICAgW0NSRUFURV9TTE9UU106IGBjcmVhdGVTbG90c2AsXG4gICAgW1RPX0RJU1BMQVlfU1RSSU5HXTogYHRvRGlzcGxheVN0cmluZ2AsXG4gICAgW01FUkdFX1BST1BTXTogYG1lcmdlUHJvcHNgLFxuICAgIFtOT1JNQUxJWkVfQ0xBU1NdOiBgbm9ybWFsaXplQ2xhc3NgLFxuICAgIFtOT1JNQUxJWkVfU1RZTEVdOiBgbm9ybWFsaXplU3R5bGVgLFxuICAgIFtOT1JNQUxJWkVfUFJPUFNdOiBgbm9ybWFsaXplUHJvcHNgLFxuICAgIFtHVUFSRF9SRUFDVElWRV9QUk9QU106IGBndWFyZFJlYWN0aXZlUHJvcHNgLFxuICAgIFtUT19IQU5ETEVSU106IGB0b0hhbmRsZXJzYCxcbiAgICBbQ0FNRUxJWkVdOiBgY2FtZWxpemVgLFxuICAgIFtDQVBJVEFMSVpFXTogYGNhcGl0YWxpemVgLFxuICAgIFtUT19IQU5ETEVSX0tFWV06IGB0b0hhbmRsZXJLZXlgLFxuICAgIFtTRVRfQkxPQ0tfVFJBQ0tJTkddOiBgc2V0QmxvY2tUcmFja2luZ2AsXG4gICAgW1BVU0hfU0NPUEVfSURdOiBgcHVzaFNjb3BlSWRgLFxuICAgIFtQT1BfU0NPUEVfSURdOiBgcG9wU2NvcGVJZGAsXG4gICAgW1dJVEhfQ1RYXTogYHdpdGhDdHhgLFxuICAgIFtVTlJFRl06IGB1bnJlZmAsXG4gICAgW0lTX1JFRl06IGBpc1JlZmAsXG4gICAgW1dJVEhfTUVNT106IGB3aXRoTWVtb2AsXG4gICAgW0lTX01FTU9fU0FNRV06IGBpc01lbW9TYW1lYFxufTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUhlbHBlcnMoaGVscGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaGVscGVycykuZm9yRWFjaChzID0+IHtcbiAgICAgICAgaGVscGVyTmFtZU1hcFtzXSA9IGhlbHBlcnNbc107XG4gICAgfSk7XG59XG5cbi8vIEFTVCBVdGlsaXRpZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTb21lIGV4cHJlc3Npb25zLCBlLmcuIHNlcXVlbmNlIGFuZCBjb25kaXRpb25hbCBleHByZXNzaW9ucywgYXJlIG5ldmVyXG4vLyBhc3NvY2lhdGVkIHdpdGggdGVtcGxhdGUgbm9kZXMsIHNvIHRoZWlyIHNvdXJjZSBsb2NhdGlvbnMgYXJlIGp1c3QgYSBzdHViLlxuLy8gQ29udGFpbmVyIHR5cGVzIGxpa2UgQ29tcG91bmRFeHByZXNzaW9uIGFsc28gZG9uJ3QgbmVlZCBhIHJlYWwgbG9jYXRpb24uXG5jb25zdCBsb2NTdHViID0ge1xuICAgIHNvdXJjZTogJycsXG4gICAgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcbiAgICBlbmQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2hpbGRyZW4sIGxvYyA9IGxvY1N0dWIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIE5vZGVUeXBlcy5ST09UICovLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaGVscGVyczogbmV3IFNldCgpLFxuICAgICAgICBjb21wb25lbnRzOiBbXSxcbiAgICAgICAgZGlyZWN0aXZlczogW10sXG4gICAgICAgIGhvaXN0czogW10sXG4gICAgICAgIGltcG9ydHM6IFtdLFxuICAgICAgICBjYWNoZWQ6IDAsXG4gICAgICAgIHRlbXBzOiAwLFxuICAgICAgICBjb2RlZ2VuTm9kZTogdW5kZWZpbmVkLFxuICAgICAgICBsb2NcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jayA9IGZhbHNlLCBkaXNhYmxlVHJhY2tpbmcgPSBmYWxzZSwgaXNDb21wb25lbnQgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgaXNDb21wb25lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGlzQ29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKFdJVEhfRElSRUNUSVZFUyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi8sXG4gICAgICAgIHRhZyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBwYXRjaEZsYWcsXG4gICAgICAgIGR5bmFtaWNQcm9wcyxcbiAgICAgICAgZGlyZWN0aXZlcyxcbiAgICAgICAgaXNCbG9jayxcbiAgICAgICAgZGlzYWJsZVRyYWNraW5nLFxuICAgICAgICBpc0NvbXBvbmVudCxcbiAgICAgICAgbG9jXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihlbGVtZW50cywgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE3IC8qIE5vZGVUeXBlcy5KU19BUlJBWV9FWFBSRVNTSU9OICovLFxuICAgICAgICBsb2MsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcywgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxNiAvKiBOb2RlVHlwZXMuSlNfUFJPUEVSVFkgKi8sXG4gICAgICAgIGxvYzogbG9jU3R1YixcbiAgICAgICAga2V5OiBpc1N0cmluZyhrZXkpID8gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihrZXksIHRydWUpIDoga2V5LFxuICAgICAgICB2YWx1ZVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGlzU3RhdGljID0gZmFsc2UsIGxvYyA9IGxvY1N0dWIsIGNvbnN0VHlwZSA9IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBpc1N0YXRpYyxcbiAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpYyA/IDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovIDogY29uc3RUeXBlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oY29udGVudCwgbG9jKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjb250ZW50OiBpc1N0cmluZyhjb250ZW50KVxuICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBsb2MpXG4gICAgICAgICAgICA6IGNvbnRlbnRcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKGNoaWxkcmVuLCBsb2MgPSBsb2NTdHViKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbG9jLFxuICAgICAgICBjaGlsZHJlblxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MgPSBbXSwgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8sXG4gICAgICAgIGxvYyxcbiAgICAgICAgY2FsbGVlLFxuICAgICAgICBhcmd1bWVudHM6IGFyZ3NcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHBhcmFtcywgcmV0dXJucyA9IHVuZGVmaW5lZCwgbmV3bGluZSA9IGZhbHNlLCBpc1Nsb3QgPSBmYWxzZSwgbG9jID0gbG9jU3R1Yikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDE4IC8qIE5vZGVUeXBlcy5KU19GVU5DVElPTl9FWFBSRVNTSU9OICovLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHJldHVybnMsXG4gICAgICAgIG5ld2xpbmUsXG4gICAgICAgIGlzU2xvdCxcbiAgICAgICAgbG9jXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmUgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMTkgLyogTm9kZVR5cGVzLkpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8sXG4gICAgICAgIHRlc3QsXG4gICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgIGFsdGVybmF0ZSxcbiAgICAgICAgbmV3bGluZSxcbiAgICAgICAgbG9jOiBsb2NTdHViXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihpbmRleCwgdmFsdWUsIGlzVk5vZGUgPSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIwIC8qIE5vZGVUeXBlcy5KU19DQUNIRV9FWFBSRVNTSU9OICovLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzVk5vZGUsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9ja1N0YXRlbWVudChib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMjEgLyogTm9kZVR5cGVzLkpTX0JMT0NLX1NUQVRFTUVOVCAqLyxcbiAgICAgICAgYm9keSxcbiAgICAgICAgbG9jOiBsb2NTdHViXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlTGl0ZXJhbChlbGVtZW50cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIyIC8qIE5vZGVUeXBlcy5KU19URU1QTEFURV9MSVRFUkFMICovLFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgbG9jOiBsb2NTdHViXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIzIC8qIE5vZGVUeXBlcy5KU19JRl9TVEFURU1FTlQgKi8sXG4gICAgICAgIHRlc3QsXG4gICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgIGFsdGVybmF0ZSxcbiAgICAgICAgbG9jOiBsb2NTdHViXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMjQgLyogTm9kZVR5cGVzLkpTX0FTU0lHTk1FTlRfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAyNSAvKiBOb2RlVHlwZXMuSlNfU0VRVUVOQ0VfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgZXhwcmVzc2lvbnMsXG4gICAgICAgIGxvYzogbG9jU3R1YlxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQocmV0dXJucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDI2IC8qIE5vZGVUeXBlcy5KU19SRVRVUk5fU1RBVEVNRU5UICovLFxuICAgICAgICByZXR1cm5zLFxuICAgICAgICBsb2M6IGxvY1N0dWJcbiAgICB9O1xufVxuXG5jb25zdCBpc1N0YXRpY0V4cCA9IChwKSA9PiBwLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmIHAuaXNTdGF0aWM7XG5jb25zdCBpc0J1aWx0SW5UeXBlID0gKHRhZywgZXhwZWN0ZWQpID0+IHRhZyA9PT0gZXhwZWN0ZWQgfHwgdGFnID09PSBoeXBoZW5hdGUoZXhwZWN0ZWQpO1xuZnVuY3Rpb24gaXNDb3JlQ29tcG9uZW50KHRhZykge1xuICAgIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1RlbGVwb3J0JykpIHtcbiAgICAgICAgcmV0dXJuIFRFTEVQT1JUO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ1N1c3BlbnNlJykpIHtcbiAgICAgICAgcmV0dXJuIFNVU1BFTlNFO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0tlZXBBbGl2ZScpKSB7XG4gICAgICAgIHJldHVybiBLRUVQX0FMSVZFO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1aWx0SW5UeXBlKHRhZywgJ0Jhc2VUcmFuc2l0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuIEJBU0VfVFJBTlNJVElPTjtcbiAgICB9XG59XG5jb25zdCBub25JZGVudGlmaWVyUkUgPSAvXlxcZHxbXlxcJFxcd10vO1xuY29uc3QgaXNTaW1wbGVJZGVudGlmaWVyID0gKG5hbWUpID0+ICFub25JZGVudGlmaWVyUkUudGVzdChuYW1lKTtcbmNvbnN0IHZhbGlkRmlyc3RJZGVudENoYXJSRSA9IC9bQS1aYS16XyRcXHhBMC1cXHVGRkZGXS87XG5jb25zdCB2YWxpZElkZW50Q2hhclJFID0gL1tcXC5cXD9cXHckXFx4QTAtXFx1RkZGRl0vO1xuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccytbLltdXFxzKnxcXHMqWy5bXVxccysvZztcbi8qKlxuICogU2ltcGxlIGxleGVyIHRvIGNoZWNrIGlmIGFuIGV4cHJlc3Npb24gaXMgYSBtZW1iZXIgZXhwcmVzc2lvbi4gVGhpcyBpc1xuICogbGF4IGFuZCBvbmx5IGNoZWNrcyB2YWxpZGl0eSBhdCB0aGUgcm9vdCBsZXZlbCAoaS5lLiBkb2VzIG5vdCB2YWxpZGF0ZSBleHBzXG4gKiBpbnNpZGUgc3F1YXJlIGJyYWNrZXRzKSwgYnV0IGl0J3Mgb2sgc2luY2UgdGhlc2UgYXJlIG9ubHkgdXNlZCBvbiB0ZW1wbGF0ZVxuICogZXhwcmVzc2lvbnMgYW5kIGZhbHNlIHBvc2l0aXZlcyBhcmUgaW52YWxpZCBleHByZXNzaW9ucyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gKi9cbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXIgPSAocGF0aCkgPT4ge1xuICAgIC8vIHJlbW92ZSB3aGl0ZXNwYWNlcyBhcm91bmQgLiBvciBbIGZpcnN0XG4gICAgcGF0aCA9IHBhdGgudHJpbSgpLnJlcGxhY2Uod2hpdGVzcGFjZVJFLCBzID0+IHMudHJpbSgpKTtcbiAgICBsZXQgc3RhdGUgPSAwIC8qIE1lbWJlckV4cExleFN0YXRlLmluTWVtYmVyRXhwICovO1xuICAgIGxldCBzdGF0ZVN0YWNrID0gW107XG4gICAgbGV0IGN1cnJlbnRPcGVuQnJhY2tldENvdW50ID0gMDtcbiAgICBsZXQgY3VycmVudE9wZW5QYXJlbnNDb3VudCA9IDA7XG4gICAgbGV0IGN1cnJlbnRTdHJpbmdUeXBlID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHBhdGguY2hhckF0KGkpO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogTWVtYmVyRXhwTGV4U3RhdGUuaW5NZW1iZXJFeHAgKi86XG4gICAgICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0YWNrLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDEgLyogTWVtYmVyRXhwTGV4U3RhdGUuaW5CcmFja2V0cyAqLztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5CcmFja2V0Q291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMiAvKiBNZW1iZXJFeHBMZXhTdGF0ZS5pblBhcmVucyAqLztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5QYXJlbnNDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKGkgPT09IDAgPyB2YWxpZEZpcnN0SWRlbnRDaGFyUkUgOiB2YWxpZElkZW50Q2hhclJFKS50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogTWVtYmVyRXhwTGV4U3RhdGUuaW5CcmFja2V0cyAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gYCdgIHx8IGNoYXIgPT09IGBcImAgfHwgY2hhciA9PT0gJ2AnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RhY2sucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMyAvKiBNZW1iZXJFeHBMZXhTdGF0ZS5pblN0cmluZyAqLztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cmluZ1R5cGUgPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBgW2ApIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wZW5CcmFja2V0Q291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gYF1gKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1jdXJyZW50T3BlbkJyYWNrZXRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1lbWJlckV4cExleFN0YXRlLmluUGFyZW5zICovOlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBgJ2AgfHwgY2hhciA9PT0gYFwiYCB8fCBjaGFyID09PSAnYCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTdGFjay5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIE1lbWJlckV4cExleFN0YXRlLmluU3RyaW5nICovO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RyaW5nVHlwZSA9IGNoYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGAoYCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3BlblBhcmVuc0NvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGApYCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZXhwIGVuZHMgYXMgYSBjYWxsIHRoZW4gaXQgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tY3VycmVudE9wZW5QYXJlbnNDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIE1lbWJlckV4cExleFN0YXRlLmluU3RyaW5nICovOlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSBjdXJyZW50U3RyaW5nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJpbmdUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFjdXJyZW50T3BlbkJyYWNrZXRDb3VudCAmJiAhY3VycmVudE9wZW5QYXJlbnNDb3VudDtcbn07XG5jb25zdCBpc01lbWJlckV4cHJlc3Npb25Ob2RlID0gTk9PUFxuICAgIDtcbmNvbnN0IGlzTWVtYmVyRXhwcmVzc2lvbiA9IGlzTWVtYmVyRXhwcmVzc2lvbkJyb3dzZXJcbiAgICA7XG5mdW5jdGlvbiBnZXRJbm5lclJhbmdlKGxvYywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBsb2Muc291cmNlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICBjb25zdCBuZXdMb2MgPSB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc3RhcnQ6IGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZShsb2Muc3RhcnQsIGxvYy5zb3VyY2UsIG9mZnNldCksXG4gICAgICAgIGVuZDogbG9jLmVuZFxuICAgIH07XG4gICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIG5ld0xvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUobG9jLnN0YXJ0LCBsb2Muc291cmNlLCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TG9jO1xufVxuZnVuY3Rpb24gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHBvcywgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihleHRlbmQoe30sIHBvcyksIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcbn1cbi8vIGFkdmFuY2UgYnkgbXV0YXRpb24gd2l0aG91dCBjbG9uaW5nIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyksIHNpbmNlIHRoaXNcbi8vIGdldHMgY2FsbGVkIGEgbG90IGluIHRoZSBwYXJzZXJcbmZ1bmN0aW9uIGFkdmFuY2VQb3NpdGlvbldpdGhNdXRhdGlvbihwb3MsIHNvdXJjZSwgbnVtYmVyT2ZDaGFyYWN0ZXJzID0gc291cmNlLmxlbmd0aCkge1xuICAgIGxldCBsaW5lc0NvdW50ID0gMDtcbiAgICBsZXQgbGFzdE5ld0xpbmVQb3MgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2hhcmFjdGVyczsgaSsrKSB7XG4gICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpKSA9PT0gMTAgLyogbmV3bGluZSBjaGFyIGNvZGUgKi8pIHtcbiAgICAgICAgICAgIGxpbmVzQ291bnQrKztcbiAgICAgICAgICAgIGxhc3ROZXdMaW5lUG9zID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3Mub2Zmc2V0ICs9IG51bWJlck9mQ2hhcmFjdGVycztcbiAgICBwb3MubGluZSArPSBsaW5lc0NvdW50O1xuICAgIHBvcy5jb2x1bW4gPVxuICAgICAgICBsYXN0TmV3TGluZVBvcyA9PT0gLTFcbiAgICAgICAgICAgID8gcG9zLmNvbHVtbiArIG51bWJlck9mQ2hhcmFjdGVyc1xuICAgICAgICAgICAgOiBudW1iZXJPZkNoYXJhY3RlcnMgLSBsYXN0TmV3TGluZVBvcztcbiAgICByZXR1cm4gcG9zO1xufVxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCBgdW5leHBlY3RlZCBjb21waWxlciBjb25kaXRpb25gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlyKG5vZGUsIG5hbWUsIGFsbG93RW1wdHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gbm9kZS5wcm9wc1tpXTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmXG4gICAgICAgICAgICAoYWxsb3dFbXB0eSB8fCBwLmV4cCkgJiZcbiAgICAgICAgICAgIChpc1N0cmluZyhuYW1lKSA/IHAubmFtZSA9PT0gbmFtZSA6IG5hbWUudGVzdChwLm5hbWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kUHJvcChub2RlLCBuYW1lLCBkeW5hbWljT25seSA9IGZhbHNlLCBhbGxvd0VtcHR5ID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLykge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNPbmx5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gbmFtZSAmJiAocC52YWx1ZSB8fCBhbGxvd0VtcHR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmXG4gICAgICAgICAgICAocC5leHAgfHwgYWxsb3dFbXB0eSkgJiZcbiAgICAgICAgICAgIGlzU3RhdGljQXJnT2YocC5hcmcsIG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU3RhdGljQXJnT2YoYXJnLCBuYW1lKSB7XG4gICAgcmV0dXJuICEhKGFyZyAmJiBpc1N0YXRpY0V4cChhcmcpICYmIGFyZy5jb250ZW50ID09PSBuYW1lKTtcbn1cbmZ1bmN0aW9uIGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmXG4gICAgICAgIHAubmFtZSA9PT0gJ2JpbmQnICYmXG4gICAgICAgICghcC5hcmcgfHwgLy8gdi1iaW5kPVwib2JqXCJcbiAgICAgICAgICAgIHAuYXJnLnR5cGUgIT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovIHx8IC8vIHYtYmluZDpbX2N0eC5mb29dXG4gICAgICAgICAgICAhcC5hcmcuaXNTdGF0aWMpIC8vIHYtYmluZDpbZm9vXVxuICAgICk7XG59XG5mdW5jdGlvbiBpc1RleHQkMShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLyB8fCBub2RlLnR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi87XG59XG5mdW5jdGlvbiBpc1ZTbG90KHApIHtcbiAgICByZXR1cm4gcC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnc2xvdCc7XG59XG5mdW5jdGlvbiBpc1RlbXBsYXRlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiYgbm9kZS50YWdUeXBlID09PSAzIC8qIEVsZW1lbnRUeXBlcy5URU1QTEFURSAqLyk7XG59XG5mdW5jdGlvbiBpc1Nsb3RPdXRsZXQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiYgbm9kZS50YWdUeXBlID09PSAyIC8qIEVsZW1lbnRUeXBlcy5TTE9UICovO1xufVxuZnVuY3Rpb24gZ2V0Vk5vZGVIZWxwZXIoc3NyLCBpc0NvbXBvbmVudCkge1xuICAgIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfVk5PREUgOiBDUkVBVEVfRUxFTUVOVF9WTk9ERTtcbn1cbmZ1bmN0aW9uIGdldFZOb2RlQmxvY2tIZWxwZXIoc3NyLCBpc0NvbXBvbmVudCkge1xuICAgIHJldHVybiBzc3IgfHwgaXNDb21wb25lbnQgPyBDUkVBVEVfQkxPQ0sgOiBDUkVBVEVfRUxFTUVOVF9CTE9DSztcbn1cbmNvbnN0IHByb3BzSGVscGVyU2V0ID0gbmV3IFNldChbTk9STUFMSVpFX1BST1BTLCBHVUFSRF9SRUFDVElWRV9QUk9QU10pO1xuZnVuY3Rpb24gZ2V0VW5ub3JtYWxpemVkUHJvcHMocHJvcHMsIGNhbGxQYXRoID0gW10pIHtcbiAgICBpZiAocHJvcHMgJiZcbiAgICAgICAgIWlzU3RyaW5nKHByb3BzKSAmJlxuICAgICAgICBwcm9wcy50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIGNvbnN0IGNhbGxlZSA9IHByb3BzLmNhbGxlZTtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhjYWxsZWUpICYmIHByb3BzSGVscGVyU2V0LmhhcyhjYWxsZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VW5ub3JtYWxpemVkUHJvcHMocHJvcHMuYXJndW1lbnRzWzBdLCBjYWxsUGF0aC5jb25jYXQocHJvcHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3Byb3BzLCBjYWxsUGF0aF07XG59XG5mdW5jdGlvbiBpbmplY3RQcm9wKG5vZGUsIHByb3AsIGNvbnRleHQpIHtcbiAgICBsZXQgcHJvcHNXaXRoSW5qZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIDEuIG1lcmdlUHJvcHMoLi4uKVxuICAgICAqIDIuIHRvSGFuZGxlcnMoLi4uKVxuICAgICAqIDMuIG5vcm1hbGl6ZVByb3BzKC4uLilcbiAgICAgKiA0LiBub3JtYWxpemVQcm9wcyhndWFyZFJlYWN0aXZlUHJvcHMoLi4uKSlcbiAgICAgKlxuICAgICAqIHdlIG5lZWQgdG8gZ2V0IHRoZSByZWFsIHByb3BzIGJlZm9yZSBub3JtYWxpemF0aW9uXG4gICAgICovXG4gICAgbGV0IHByb3BzID0gbm9kZS50eXBlID09PSAxMyAvKiBOb2RlVHlwZXMuVk5PREVfQ0FMTCAqLyA/IG5vZGUucHJvcHMgOiBub2RlLmFyZ3VtZW50c1syXTtcbiAgICBsZXQgY2FsbFBhdGggPSBbXTtcbiAgICBsZXQgcGFyZW50Q2FsbDtcbiAgICBpZiAocHJvcHMgJiZcbiAgICAgICAgIWlzU3RyaW5nKHByb3BzKSAmJlxuICAgICAgICBwcm9wcy50eXBlID09PSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFVubm9ybWFsaXplZFByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSByZXRbMF07XG4gICAgICAgIGNhbGxQYXRoID0gcmV0WzFdO1xuICAgICAgICBwYXJlbnRDYWxsID0gY2FsbFBhdGhbY2FsbFBhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGlmIChwcm9wcyA9PSBudWxsIHx8IGlzU3RyaW5nKHByb3BzKSkge1xuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BzLnR5cGUgPT09IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgLy8gbWVyZ2VkIHByb3BzLi4uIGFkZCBvdXJzXG4gICAgICAgIC8vIG9ubHkgaW5qZWN0IGtleSB0byBvYmplY3QgbGl0ZXJhbCBpZiBpdCdzIHRoZSBmaXJzdCBhcmd1bWVudCBzbyB0aGF0XG4gICAgICAgIC8vIGlmIGRvZXNuJ3Qgb3ZlcnJpZGUgdXNlciBwcm92aWRlZCBrZXlzXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gcHJvcHMuYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKGZpcnN0KSAmJiBmaXJzdC50eXBlID09PSAxNSAvKiBOb2RlVHlwZXMuSlNfT0JKRUNUX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgIC8vICM2NjMxXG4gICAgICAgICAgICBpZiAoIWhhc1Byb3AocHJvcCwgZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QucHJvcGVydGllcy51bnNoaWZ0KHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNhbGxlZSA9PT0gVE9fSEFORExFUlMpIHtcbiAgICAgICAgICAgICAgICAvLyAjMjM2NlxuICAgICAgICAgICAgICAgIHByb3BzV2l0aEluamVjdGlvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgW1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSksXG4gICAgICAgICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5hcmd1bWVudHMudW5zaGlmdChjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICFwcm9wc1dpdGhJbmplY3Rpb24gJiYgKHByb3BzV2l0aEluamVjdGlvbiA9IHByb3BzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gMTUgLyogTm9kZVR5cGVzLkpTX09CSkVDVF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIGlmICghaGFzUHJvcChwcm9wLCBwcm9wcykpIHtcbiAgICAgICAgICAgIHByb3BzLnByb3BlcnRpZXMudW5zaGlmdChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wc1dpdGhJbmplY3Rpb24gPSBwcm9wcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBleHByZXNzaW9uLCByZXR1cm4gYSBtZXJnZWQgcmVwbGFjZW1lbnRcbiAgICAgICAgcHJvcHNXaXRoSW5qZWN0aW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTUVSR0VfUFJPUFMpLCBbXG4gICAgICAgICAgICBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtwcm9wXSksXG4gICAgICAgICAgICBwcm9wc1xuICAgICAgICBdKTtcbiAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgbmVzdGVkIGhlbHBlciBjYWxsLCBlLmcuIGBub3JtYWxpemVQcm9wcyhndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpKWAsXG4gICAgICAgIC8vIGl0IHdpbGwgYmUgcmV3cml0dGVuIGFzIGBub3JtYWxpemVQcm9wcyhtZXJnZVByb3BzKHsga2V5OiAwIH0sIHByb3BzKSlgLFxuICAgICAgICAvLyB0aGUgYGd1YXJkUmVhY3RpdmVQcm9wc2Agd2lsbCBubyBsb25nZXIgYmUgbmVlZGVkXG4gICAgICAgIGlmIChwYXJlbnRDYWxsICYmIHBhcmVudENhbGwuY2FsbGVlID09PSBHVUFSRF9SRUFDVElWRV9QUk9QUykge1xuICAgICAgICAgICAgcGFyZW50Q2FsbCA9IGNhbGxQYXRoW2NhbGxQYXRoLmxlbmd0aCAtIDJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgIGlmIChwYXJlbnRDYWxsKSB7XG4gICAgICAgICAgICBwYXJlbnRDYWxsLmFyZ3VtZW50c1swXSA9IHByb3BzV2l0aEluamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucHJvcHMgPSBwcm9wc1dpdGhJbmplY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChwYXJlbnRDYWxsKSB7XG4gICAgICAgICAgICBwYXJlbnRDYWxsLmFyZ3VtZW50c1swXSA9IHByb3BzV2l0aEluamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuYXJndW1lbnRzWzJdID0gcHJvcHNXaXRoSW5qZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gY2hlY2sgZXhpc3Rpbmcga2V5IHRvIGF2b2lkIG92ZXJyaWRpbmcgdXNlciBwcm92aWRlZCBrZXlzXG5mdW5jdGlvbiBoYXNQcm9wKHByb3AsIHByb3BzKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChwcm9wLmtleS50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBjb25zdCBwcm9wS2V5TmFtZSA9IHByb3Aua2V5LmNvbnRlbnQ7XG4gICAgICAgIHJlc3VsdCA9IHByb3BzLnByb3BlcnRpZXMuc29tZShwID0+IHAua2V5LnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmXG4gICAgICAgICAgICBwLmtleS5jb250ZW50ID09PSBwcm9wS2V5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1ZhbGlkQXNzZXRJZChuYW1lLCB0eXBlKSB7XG4gICAgLy8gc2VlIGlzc3VlIzQ0MjIsIHdlIG5lZWQgYWRkaW5nIGlkZW50aWZpZXIgb24gdmFsaWRBc3NldElkIGlmIHZhcmlhYmxlIGBuYW1lYCBoYXMgc3BlY2lmaWMgY2hhcmFjdGVyXG4gICAgcmV0dXJuIGBfJHt0eXBlfV8ke25hbWUucmVwbGFjZSgvW15cXHddL2csIChzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBzZWFyY2hWYWx1ZSA9PT0gJy0nID8gJ18nIDogbmFtZS5jaGFyQ29kZUF0KHJlcGxhY2VWYWx1ZSkudG9TdHJpbmcoKTtcbiAgICB9KX1gO1xufVxuLy8gQ2hlY2sgaWYgYSBub2RlIGNvbnRhaW5zIGV4cHJlc3Npb25zIHRoYXQgcmVmZXJlbmNlIGN1cnJlbnQgY29udGV4dCBzY29wZSBpZHNcbmZ1bmN0aW9uIGhhc1Njb3BlUmVmKG5vZGUsIGlkcykge1xuICAgIGlmICghbm9kZSB8fCBPYmplY3Qua2V5cyhpZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAoaGFzU2NvcGVSZWYocC5hcmcsIGlkcykgfHwgaGFzU2NvcGVSZWYocC5leHAsIGlkcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBoYXNTY29wZVJlZihjLCBpZHMpKTtcbiAgICAgICAgY2FzZSAxMSAvKiBOb2RlVHlwZXMuRk9SICovOlxuICAgICAgICAgICAgaWYgKGhhc1Njb3BlUmVmKG5vZGUuc291cmNlLCBpZHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4gaGFzU2NvcGVSZWYoYywgaWRzKSk7XG4gICAgICAgIGNhc2UgOSAvKiBOb2RlVHlwZXMuSUYgKi86XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5icmFuY2hlcy5zb21lKGIgPT4gaGFzU2NvcGVSZWYoYiwgaWRzKSk7XG4gICAgICAgIGNhc2UgMTAgLyogTm9kZVR5cGVzLklGX0JSQU5DSCAqLzpcbiAgICAgICAgICAgIGlmIChoYXNTY29wZVJlZihub2RlLmNvbmRpdGlvbiwgaWRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4uc29tZShjID0+IGhhc1Njb3BlUmVmKGMsIGlkcykpO1xuICAgICAgICBjYXNlIDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgcmV0dXJuICghbm9kZS5pc1N0YXRpYyAmJlxuICAgICAgICAgICAgICAgIGlzU2ltcGxlSWRlbnRpZmllcihub2RlLmNvbnRlbnQpICYmXG4gICAgICAgICAgICAgICAgISFpZHNbbm9kZS5jb250ZW50XSk7XG4gICAgICAgIGNhc2UgOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLnNvbWUoYyA9PiBpc09iamVjdChjKSAmJiBoYXNTY29wZVJlZihjLCBpZHMpKTtcbiAgICAgICAgY2FzZSA1IC8qIE5vZGVUeXBlcy5JTlRFUlBPTEFUSU9OICovOlxuICAgICAgICBjYXNlIDEyIC8qIE5vZGVUeXBlcy5URVhUX0NBTEwgKi86XG4gICAgICAgICAgICByZXR1cm4gaGFzU2NvcGVSZWYobm9kZS5jb250ZW50LCBpZHMpO1xuICAgICAgICBjYXNlIDIgLyogTm9kZVR5cGVzLlRFWFQgKi86XG4gICAgICAgIGNhc2UgMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRNZW1vZWRWTm9kZUNhbGwobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8gJiYgbm9kZS5jYWxsZWUgPT09IFdJVEhfTUVNTykge1xuICAgICAgICByZXR1cm4gbm9kZS5hcmd1bWVudHNbMV0ucmV0dXJucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VCbG9jayhub2RlLCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyLCBpblNTUiB9KSB7XG4gICAgaWYgKCFub2RlLmlzQmxvY2spIHtcbiAgICAgICAgbm9kZS5pc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlSGVscGVyKGluU1NSLCBub2RlLmlzQ29tcG9uZW50KSk7XG4gICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICAgICAgaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoaW5TU1IsIG5vZGUuaXNDb21wb25lbnQpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRlcHJlY2F0aW9uRGF0YSA9IHtcbiAgICBbXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGBQbGF0Zm9ybS1uYXRpdmUgZWxlbWVudHMgd2l0aCBcImlzXCIgcHJvcCB3aWxsIG5vIGxvbmdlciBiZSBgICtcbiAgICAgICAgICAgIGB0cmVhdGVkIGFzIGNvbXBvbmVudHMgaW4gVnVlIDMgdW5sZXNzIHRoZSBcImlzXCIgdmFsdWUgaXMgZXhwbGljaXRseSBgICtcbiAgICAgICAgICAgIGBwcmVmaXhlZCB3aXRoIFwidnVlOlwiLmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9jdXN0b20tZWxlbWVudHMtaW50ZXJvcC5odG1sYFxuICAgIH0sXG4gICAgW1wiQ09NUElMRVJfVl9CSU5EX1NZTkNcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX1NZTkMgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGtleSA9PiBgLnN5bmMgbW9kaWZpZXIgZm9yIHYtYmluZCBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugdi1tb2RlbCB3aXRoIGAgK1xuICAgICAgICAgICAgYGFyZ3VtZW50IGluc3RlYWQuIFxcYHYtYmluZDoke2tleX0uc3luY1xcYCBzaG91bGQgYmUgY2hhbmdlZCB0byBgICtcbiAgICAgICAgICAgIGBcXGB2LW1vZGVsOiR7a2V5fVxcYC5gLFxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1tb2RlbC5odG1sYFxuICAgIH0sXG4gICAgW1wiQ09NUElMRVJfVl9CSU5EX1BST1BcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX1BST1AgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGAucHJvcCBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQgYW5kIG5vIGxvbmdlciBuZWNlc3NhcnkuIGAgK1xuICAgICAgICAgICAgYFZ1ZSAzIHdpbGwgYXV0b21hdGljYWxseSBzZXQgYSBiaW5kaW5nIGFzIERPTSBwcm9wZXJ0eSB3aGVuIGFwcHJvcHJpYXRlLmBcbiAgICB9LFxuICAgIFtcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqL106IHtcbiAgICAgICAgbWVzc2FnZTogYHYtYmluZD1cIm9ialwiIHVzYWdlIGlzIG5vdyBvcmRlciBzZW5zaXRpdmUgYW5kIGJlaGF2ZXMgbGlrZSBKYXZhU2NyaXB0IGAgK1xuICAgICAgICAgICAgYG9iamVjdCBzcHJlYWQ6IGl0IHdpbGwgbm93IG92ZXJ3cml0ZSBhbiBleGlzdGluZyBub24tbWVyZ2VhYmxlIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgICAgIGB0aGF0IGFwcGVhcnMgYmVmb3JlIHYtYmluZCBpbiB0aGUgY2FzZSBvZiBjb25mbGljdC4gYCArXG4gICAgICAgICAgICBgVG8gcmV0YWluIDIueCBiZWhhdmlvciwgbW92ZSB2LWJpbmQgdG8gbWFrZSBpdCB0aGUgZmlyc3QgYXR0cmlidXRlLiBgICtcbiAgICAgICAgICAgIGBZb3UgY2FuIGFsc28gc3VwcHJlc3MgdGhpcyB3YXJuaW5nIGlmIHRoZSB1c2FnZSBpcyBpbnRlbmRlZC5gLFxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1iaW5kLmh0bWxgXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9WX09OX05BVElWRVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX09OX05BVElWRSAqL106IHtcbiAgICAgICAgbWVzc2FnZTogYC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaGFzIGJlZW4gcmVtb3ZlZCBhcyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LW9uLW5hdGl2ZS1tb2RpZmllci1yZW1vdmVkLmh0bWxgXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0VcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9JRl9WX0ZPUl9QUkVDRURFTkNFICovXToge1xuICAgICAgICBtZXNzYWdlOiBgdi1pZiAvIHYtZm9yIHByZWNlZGVuY2Ugd2hlbiB1c2VkIG9uIHRoZSBzYW1lIGVsZW1lbnQgaGFzIGNoYW5nZWQgYCArXG4gICAgICAgICAgICBgaW4gVnVlIDM6IHYtaWYgbm93IHRha2VzIGhpZ2hlciBwcmVjZWRlbmNlIGFuZCB3aWxsIG5vIGxvbmdlciBoYXZlIGAgK1xuICAgICAgICAgICAgYGFjY2VzcyB0byB2LWZvciBzY29wZSB2YXJpYWJsZXMuIEl0IGlzIGJlc3QgdG8gYXZvaWQgdGhlIGFtYmlndWl0eSBgICtcbiAgICAgICAgICAgIGB3aXRoIDx0ZW1wbGF0ZT4gdGFncyBvciB1c2UgYSBjb21wdXRlZCBwcm9wZXJ0eSB0aGF0IGZpbHRlcnMgdi1mb3IgYCArXG4gICAgICAgICAgICBgZGF0YSBzb3VyY2UuYCxcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtaWYtdi1mb3IuaHRtbGBcbiAgICB9LFxuICAgIFtcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9OQVRJVkVfVEVNUExBVEUgKi9dOiB7XG4gICAgICAgIG1lc3NhZ2U6IGA8dGVtcGxhdGU+IHdpdGggbm8gc3BlY2lhbCBkaXJlY3RpdmVzIHdpbGwgcmVuZGVyIGFzIGEgbmF0aXZlIHRlbXBsYXRlIGAgK1xuICAgICAgICAgICAgYGVsZW1lbnQgaW5zdGVhZCBvZiBpdHMgaW5uZXIgY29udGVudCBpbiBWdWUgMy5gXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9JTkxJTkVfVEVNUExBVEVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFICovXToge1xuICAgICAgICBtZXNzYWdlOiBgXCJpbmxpbmUtdGVtcGxhdGVcIiBoYXMgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9pbmxpbmUtdGVtcGxhdGUtYXR0cmlidXRlLmh0bWxgXG4gICAgfSxcbiAgICBbXCJDT01QSUxFUl9GSUxURVJcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfRklMVEVSUyAqL106IHtcbiAgICAgICAgbWVzc2FnZTogYGZpbHRlcnMgaGF2ZSBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuIGAgK1xuICAgICAgICAgICAgYFRoZSBcInxcIiBzeW1ib2wgd2lsbCBiZSB0cmVhdGVkIGFzIG5hdGl2ZSBKYXZhU2NyaXB0IGJpdHdpc2UgT1Igb3BlcmF0b3IuIGAgK1xuICAgICAgICAgICAgYFVzZSBtZXRob2QgY2FsbHMgb3IgY29tcHV0ZWQgcHJvcGVydGllcyBpbnN0ZWFkLmAsXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9maWx0ZXJzLmh0bWxgXG4gICAgfVxufTtcbmZ1bmN0aW9uIGdldENvbXBhdFZhbHVlKGtleSwgY29udGV4dCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IGNvbnRleHQub3B0aW9uc1xuICAgICAgICA/IGNvbnRleHQub3B0aW9ucy5jb21wYXRDb25maWdcbiAgICAgICAgOiBjb250ZXh0LmNvbXBhdENvbmZpZztcbiAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZyAmJiBjb25maWdba2V5XTtcbiAgICBpZiAoa2V5ID09PSAnTU9ERScpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IDM7IC8vIGNvbXBpbGVyIGRlZmF1bHRzIHRvIHYzIGJlaGF2aW9yXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCkge1xuICAgIGNvbnN0IG1vZGUgPSBnZXRDb21wYXRWYWx1ZSgnTU9ERScsIGNvbnRleHQpO1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KTtcbiAgICAvLyBpbiB2MyBtb2RlLCBvbmx5IGVuYWJsZSBpZiBleHBsaWNpdGx5IHNldCB0byB0cnVlXG4gICAgLy8gb3RoZXJ3aXNlIGVuYWJsZSBmb3IgYW55IG5vbi1mYWxzZSB2YWx1ZVxuICAgIHJldHVybiBtb2RlID09PSAzID8gdmFsdWUgPT09IHRydWUgOiB2YWx1ZSAhPT0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0NvbXBhdEVuYWJsZWQoa2V5LCBjb250ZXh0LCBsb2MsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBlbmFibGVkID0gaXNDb21wYXRFbmFibGVkKGtleSwgY29udGV4dCk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlbmFibGVkKSB7XG4gICAgICAgIHdhcm5EZXByZWNhdGlvbihrZXksIGNvbnRleHQsIGxvYywgLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBlbmFibGVkO1xufVxuZnVuY3Rpb24gd2FybkRlcHJlY2F0aW9uKGtleSwgY29udGV4dCwgbG9jLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgdmFsID0gZ2V0Q29tcGF0VmFsdWUoa2V5LCBjb250ZXh0KTtcbiAgICBpZiAodmFsID09PSAnc3VwcHJlc3Mtd2FybmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IG1lc3NhZ2UsIGxpbmsgfSA9IGRlcHJlY2F0aW9uRGF0YVtrZXldO1xuICAgIGNvbnN0IG1zZyA9IGAoZGVwcmVjYXRpb24gJHtrZXl9KSAke3R5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nID8gbWVzc2FnZSguLi5hcmdzKSA6IG1lc3NhZ2V9JHtsaW5rID8gYFxcbiAgRGV0YWlsczogJHtsaW5rfWAgOiBgYH1gO1xuICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihtc2cpO1xuICAgIGVyci5jb2RlID0ga2V5O1xuICAgIGlmIChsb2MpXG4gICAgICAgIGVyci5sb2MgPSBsb2M7XG4gICAgY29udGV4dC5vbldhcm4oZXJyKTtcbn1cblxuLy8gVGhlIGRlZmF1bHQgZGVjb2RlciBvbmx5IHByb3ZpZGVzIGVzY2FwZXMgZm9yIGNoYXJhY3RlcnMgcmVzZXJ2ZWQgYXMgcGFydCBvZlxuLy8gdGhlIHRlbXBsYXRlIHN5bnRheCwgYW5kIGlzIG9ubHkgdXNlZCBpZiB0aGUgY3VzdG9tIHJlbmRlcmVyIGRpZCBub3QgcHJvdmlkZVxuLy8gYSBwbGF0Zm9ybS1zcGVjaWZpYyBkZWNvZGVyLlxuY29uc3QgZGVjb2RlUkUgPSAvJihndHxsdHxhbXB8YXBvc3xxdW90KTsvZztcbmNvbnN0IGRlY29kZU1hcCA9IHtcbiAgICBndDogJz4nLFxuICAgIGx0OiAnPCcsXG4gICAgYW1wOiAnJicsXG4gICAgYXBvczogXCInXCIsXG4gICAgcXVvdDogJ1wiJ1xufTtcbmNvbnN0IGRlZmF1bHRQYXJzZXJPcHRpb25zID0ge1xuICAgIGRlbGltaXRlcnM6IFtge3tgLCBgfX1gXSxcbiAgICBnZXROYW1lc3BhY2U6ICgpID0+IDAgLyogTmFtZXNwYWNlcy5IVE1MICovLFxuICAgIGdldFRleHRNb2RlOiAoKSA9PiAwIC8qIFRleHRNb2Rlcy5EQVRBICovLFxuICAgIGlzVm9pZFRhZzogTk8sXG4gICAgaXNQcmVUYWc6IE5PLFxuICAgIGlzQ3VzdG9tRWxlbWVudDogTk8sXG4gICAgZGVjb2RlRW50aXRpZXM6IChyYXdUZXh0KSA9PiByYXdUZXh0LnJlcGxhY2UoZGVjb2RlUkUsIChfLCBwMSkgPT4gZGVjb2RlTWFwW3AxXSksXG4gICAgb25FcnJvcjogZGVmYXVsdE9uRXJyb3IsXG4gICAgb25XYXJuOiBkZWZhdWx0T25XYXJuLFxuICAgIGNvbW1lbnRzOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbn07XG5mdW5jdGlvbiBiYXNlUGFyc2UoY29udGVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZVBhcnNlckNvbnRleHQoY29udGVudCwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgcmV0dXJuIGNyZWF0ZVJvb3QocGFyc2VDaGlsZHJlbihjb250ZXh0LCAwIC8qIFRleHRNb2Rlcy5EQVRBICovLCBbXSksIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyQ29udGV4dChjb250ZW50LCByYXdPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdFBhcnNlck9wdGlvbnMpO1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gcmF3T3B0aW9ucykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG9wdGlvbnNba2V5XSA9XG4gICAgICAgICAgICByYXdPcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFBhcnNlck9wdGlvbnNba2V5XVxuICAgICAgICAgICAgICAgIDogcmF3T3B0aW9uc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgIGxpbmU6IDEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgb3JpZ2luYWxTb3VyY2U6IGNvbnRlbnQsXG4gICAgICAgIHNvdXJjZTogY29udGVudCxcbiAgICAgICAgaW5QcmU6IGZhbHNlLFxuICAgICAgICBpblZQcmU6IGZhbHNlLFxuICAgICAgICBvbldhcm46IG9wdGlvbnMub25XYXJuXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xuICAgIGNvbnN0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogMCAvKiBOYW1lc3BhY2VzLkhUTUwgKi87XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICB3aGlsZSAoIWlzRW5kKGNvbnRleHQsIG1vZGUsIGFuY2VzdG9ycykpIHtcbiAgICAgICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlO1xuICAgICAgICBsZXQgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1vZGUgPT09IDAgLyogVGV4dE1vZGVzLkRBVEEgKi8gfHwgbW9kZSA9PT0gMSAvKiBUZXh0TW9kZXMuUkNEQVRBICovKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuaW5WUHJlICYmIHN0YXJ0c1dpdGgocywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gJ3t7J1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSAwIC8qIFRleHRNb2Rlcy5EQVRBICovICYmIHNbMF0gPT09ICc8Jykge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCN0YWctb3Blbi1zdGF0ZVxuICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgNSAvKiBFcnJvckNvZGVzLkVPRl9CRUZPUkVfVEFHX05BTUUgKi8sIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI21hcmt1cC1kZWNsYXJhdGlvbi1vcGVuLXN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8IS0tJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUNvbW1lbnQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRzV2l0aChzLCAnPCFET0NUWVBFJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBET0NUWVBFIGJ5IGEgbGltaXRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydHNXaXRoKHMsICc8IVtDREFUQVsnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5zICE9PSAwIC8qIE5hbWVzcGFjZXMuSFRNTCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUNEQVRBKGNvbnRleHQsIGFuY2VzdG9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMSAvKiBFcnJvckNvZGVzLkNEQVRBX0lOX0hUTUxfQ09OVEVOVCAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDExIC8qIEVycm9yQ29kZXMuSU5DT1JSRUNUTFlfT1BFTkVEX0NPTU1FTlQgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHBhcnNlQm9ndXNDb21tZW50KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNbMV0gPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjZW5kLXRhZy1vcGVuLXN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDUgLyogRXJyb3JDb2Rlcy5FT0ZfQkVGT1JFX1RBR19OQU1FICovLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzJdID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxNCAvKiBFcnJvckNvZGVzLk1JU1NJTkdfRU5EX1RBR19OQU1FICovLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9bYS16XS9pLnRlc3Qoc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyMyAvKiBFcnJvckNvZGVzLlhfSU5WQUxJRF9FTkRfVEFHICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlVGFnKGNvbnRleHQsIDEgLyogVGFnVHlwZS5FbmQgKi8sIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMiAvKiBFcnJvckNvZGVzLklOVkFMSURfRklSU1RfQ0hBUkFDVEVSX09GX1RBR19OQU1FICovLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvW2Etel0vaS50ZXN0KHNbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJzZUVsZW1lbnQoY29udGV4dCwgYW5jZXN0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gMi54IDx0ZW1wbGF0ZT4gd2l0aCBubyBkaXJlY3RpdmUgY29tcGF0XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovLCBjb250ZXh0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50YWcgPT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFub2RlLnByb3BzLnNvbWUocCA9PiBwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJDT01QSUxFUl9OQVRJVkVfVEVNUExBVEVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFICovLCBjb250ZXh0LCBub2RlLmxvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzFdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDIxIC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9RVUVTVElPTl9NQVJLX0lOU1RFQURfT0ZfVEFHX05BTUUgKi8sIDEpO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VCb2d1c0NvbW1lbnQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTIgLyogRXJyb3JDb2Rlcy5JTlZBTElEX0ZJUlNUX0NIQVJBQ1RFUl9PRl9UQUdfTkFNRSAqLywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgbm9kZSA9IHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHVzaE5vZGUobm9kZXMsIG5vZGVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHVzaE5vZGUobm9kZXMsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdoaXRlc3BhY2UgaGFuZGxpbmcgc3RyYXRlZ3kgbGlrZSB2MlxuICAgIGxldCByZW1vdmVkV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgIGlmIChtb2RlICE9PSAyIC8qIFRleHRNb2Rlcy5SQVdURVhUICovICYmIG1vZGUgIT09IDEgLyogVGV4dE1vZGVzLlJDREFUQSAqLykge1xuICAgICAgICBjb25zdCBzaG91bGRDb25kZW5zZSA9IGNvbnRleHQub3B0aW9ucy53aGl0ZXNwYWNlICE9PSAncHJlc2VydmUnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LmluUHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghL1teXFx0XFxyXFxuXFxmIF0vLnRlc3Qobm9kZS5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG5vZGVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2Rlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgaWY6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHRoZSB3aGl0ZXNwYWNlIGlzIHRoZSBmaXJzdCBvciBsYXN0IG5vZGUsIG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSAoY29uZGVuc2UgbW9kZSkgdGhlIHdoaXRlc3BhY2UgaXMgYmV0d2VlbiB0d29zIGNvbW1lbnRzLCBvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gKGNvbmRlbnNlIG1vZGUpIHRoZSB3aGl0ZXNwYWNlIGlzIGJldHdlZW4gY29tbWVudCBhbmQgZWxlbWVudCwgb3I6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtIChjb25kZW5zZSBtb2RlKSB0aGUgd2hpdGVzcGFjZSBpcyBiZXR3ZWVuIHR3byBlbGVtZW50cyBBTkQgY29udGFpbnMgbmV3bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIW5leHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2hvdWxkQ29uZGVuc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChwcmV2LnR5cGUgPT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQudHlwZSA9PT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2LnR5cGUgPT09IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJldi50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC50eXBlID09PSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZXYudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9bXFxyXFxuXS8udGVzdChub2RlLmNvbnRlbnQpKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFdoaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHdoaXRlc3BhY2UgaXMgY29uZGVuc2VkIGludG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hvdWxkQ29uZGVuc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGluIHRleHQgYXJlIGNvbmRlbnNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0byBhIHNpbmdsZSBzcGFjZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9IG5vZGUuY29udGVudC5yZXBsYWNlKC9bXFx0XFxyXFxuXFxmIF0rL2csICcgJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICM2NDEwIG5vcm1hbGl6ZSB3aW5kb3dzIG5ld2xpbmVzIGluIDxwcmU+OlxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBTU1IsIGJyb3dzZXJzIG5vcm1hbGl6ZSBzZXJ2ZXItcmVuZGVyZWQgXFxyXFxuIGludG8gYSBzaW5nbGUgXFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBET01cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50ID0gbm9kZS5jb250ZW50LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnQgbm9kZXMgaWYgZGVzaXJlZCBieSBjb25maWd1cmF0aW9uLlxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovICYmICFjb250ZXh0Lm9wdGlvbnMuY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkV2hpdGVzcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmluUHJlICYmIHBhcmVudCAmJiBjb250ZXh0Lm9wdGlvbnMuaXNQcmVUYWcocGFyZW50LnRhZykpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIG5ld2xpbmUgcGVyIGh0bWwgc3BlY1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZ3JvdXBpbmctY29udGVudC5odG1sI3RoZS1wcmUtZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBmaXJzdC50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovKSB7XG4gICAgICAgICAgICAgICAgZmlyc3QuY29udGVudCA9IGZpcnN0LmNvbnRlbnQucmVwbGFjZSgvXlxccj9cXG4vLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWRXaGl0ZXNwYWNlID8gbm9kZXMuZmlsdGVyKEJvb2xlYW4pIDogbm9kZXM7XG59XG5mdW5jdGlvbiBwdXNoTm9kZShub2Rlcywgbm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgY29uc3QgcHJldiA9IGxhc3Qobm9kZXMpO1xuICAgICAgICAvLyBNZXJnZSBpZiBib3RoIHRoaXMgYW5kIHRoZSBwcmV2aW91cyBub2RlIGFyZSB0ZXh0IGFuZCB0aG9zZSBhcmVcbiAgICAgICAgLy8gY29uc2VjdXRpdmUuIFRoaXMgaGFwcGVucyBmb3IgY2FzZXMgbGlrZSBcImEgPCBiXCIuXG4gICAgICAgIGlmIChwcmV2ICYmXG4gICAgICAgICAgICBwcmV2LnR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8gJiZcbiAgICAgICAgICAgIHByZXYubG9jLmVuZC5vZmZzZXQgPT09IG5vZGUubG9jLnN0YXJ0Lm9mZnNldCkge1xuICAgICAgICAgICAgcHJldi5jb250ZW50ICs9IG5vZGUuY29udGVudDtcbiAgICAgICAgICAgIHByZXYubG9jLmVuZCA9IG5vZGUubG9jLmVuZDtcbiAgICAgICAgICAgIHByZXYubG9jLnNvdXJjZSArPSBub2RlLmxvYy5zb3VyY2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm9kZXMucHVzaChub2RlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ0RBVEEoY29udGV4dCwgYW5jZXN0b3JzKSB7XG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIDkpO1xuICAgIGNvbnN0IG5vZGVzID0gcGFyc2VDaGlsZHJlbihjb250ZXh0LCAzIC8qIFRleHRNb2Rlcy5DREFUQSAqLywgYW5jZXN0b3JzKTtcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA2IC8qIEVycm9yQ29kZXMuRU9GX0lOX0NEQVRBICovKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gcGFyc2VDb21tZW50KGNvbnRleHQpIHtcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcbiAgICBsZXQgY29udGVudDtcbiAgICAvLyBSZWd1bGFyIGNvbW1lbnQuXG4gICAgY29uc3QgbWF0Y2ggPSAvLS0oXFwhKT8+Ly5leGVjKGNvbnRleHQuc291cmNlKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZSg0KTtcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCk7XG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA3IC8qIEVycm9yQ29kZXMuRU9GX0lOX0NPTU1FTlQgKi8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1hdGNoLmluZGV4IDw9IDMpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAwIC8qIEVycm9yQ29kZXMuQUJSVVBUX0NMT1NJTkdfT0ZfRU1QVFlfQ09NTUVOVCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTAgLyogRXJyb3JDb2Rlcy5JTkNPUlJFQ1RMWV9DTE9TRURfQ09NTUVOVCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDQsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgLy8gQWR2YW5jaW5nIHdpdGggcmVwb3J0aW5nIG5lc3RlZCBjb21tZW50cy5cbiAgICAgICAgY29uc3QgcyA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgbGV0IHByZXZJbmRleCA9IDEsIG5lc3RlZEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChuZXN0ZWRJbmRleCA9IHMuaW5kZXhPZignPCEtLScsIHByZXZJbmRleCkpICE9PSAtMSkge1xuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5lc3RlZEluZGV4IC0gcHJldkluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobmVzdGVkSW5kZXggKyA0IDwgcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTYgLyogRXJyb3JDb2Rlcy5ORVNURURfQ09NTUVOVCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2SW5kZXggPSBuZXN0ZWRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gcHJldkluZGV4ICsgMSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi8sXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUJvZ3VzQ29tbWVudChjb250ZXh0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgY29udGVudFN0YXJ0ID0gY29udGV4dC5zb3VyY2VbMV0gPT09ICc/JyA/IDEgOiAyO1xuICAgIGxldCBjb250ZW50O1xuICAgIGNvbnN0IGNsb3NlSW5kZXggPSBjb250ZXh0LnNvdXJjZS5pbmRleE9mKCc+Jyk7XG4gICAgaWYgKGNsb3NlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZShjb250ZW50U3RhcnQpO1xuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY29udGV4dC5zb3VyY2UubGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZXh0LnNvdXJjZS5zbGljZShjb250ZW50U3RhcnQsIGNsb3NlSW5kZXgpO1xuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgY2xvc2VJbmRleCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VFbGVtZW50KGNvbnRleHQsIGFuY2VzdG9ycykge1xuICAgIC8vIFN0YXJ0IHRhZy5cbiAgICBjb25zdCB3YXNJblByZSA9IGNvbnRleHQuaW5QcmU7XG4gICAgY29uc3Qgd2FzSW5WUHJlID0gY29udGV4dC5pblZQcmU7XG4gICAgY29uc3QgcGFyZW50ID0gbGFzdChhbmNlc3RvcnMpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZVRhZyhjb250ZXh0LCAwIC8qIFRhZ1R5cGUuU3RhcnQgKi8sIHBhcmVudCk7XG4gICAgY29uc3QgaXNQcmVCb3VuZGFyeSA9IGNvbnRleHQuaW5QcmUgJiYgIXdhc0luUHJlO1xuICAgIGNvbnN0IGlzVlByZUJvdW5kYXJ5ID0gY29udGV4dC5pblZQcmUgJiYgIXdhc0luVlByZTtcbiAgICBpZiAoZWxlbWVudC5pc1NlbGZDbG9zaW5nIHx8IGNvbnRleHQub3B0aW9ucy5pc1ZvaWRUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIC8vICM0MDMwIHNlbGYtY2xvc2luZyA8cHJlPiB0YWdcbiAgICAgICAgaWYgKGlzUHJlQm91bmRhcnkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5QcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWUHJlQm91bmRhcnkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5WUHJlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIC8vIENoaWxkcmVuLlxuICAgIGFuY2VzdG9ycy5wdXNoKGVsZW1lbnQpO1xuICAgIGNvbnN0IG1vZGUgPSBjb250ZXh0Lm9wdGlvbnMuZ2V0VGV4dE1vZGUoZWxlbWVudCwgcGFyZW50KTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcnNlQ2hpbGRyZW4oY29udGV4dCwgbW9kZSwgYW5jZXN0b3JzKTtcbiAgICBhbmNlc3RvcnMucG9wKCk7XG4gICAgLy8gMi54IGlubGluZS10ZW1wbGF0ZSBjb21wYXRcbiAgICB7XG4gICAgICAgIGNvbnN0IGlubGluZVRlbXBsYXRlUHJvcCA9IGVsZW1lbnQucHJvcHMuZmluZChwID0+IHAudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovICYmIHAubmFtZSA9PT0gJ2lubGluZS10ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoaW5saW5lVGVtcGxhdGVQcm9wICYmXG4gICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JTkxJTkVfVEVNUExBVEVcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSU5MSU5FX1RFTVBMQVRFICovLCBjb250ZXh0LCBpbmxpbmVUZW1wbGF0ZVByb3AubG9jKSkge1xuICAgICAgICAgICAgY29uc3QgbG9jID0gZ2V0U2VsZWN0aW9uKGNvbnRleHQsIGVsZW1lbnQubG9jLmVuZCk7XG4gICAgICAgICAgICBpbmxpbmVUZW1wbGF0ZVByb3AudmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBsb2Muc291cmNlLFxuICAgICAgICAgICAgICAgIGxvY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgLy8gRW5kIHRhZy5cbiAgICBpZiAoc3RhcnRzV2l0aEVuZFRhZ09wZW4oY29udGV4dC5zb3VyY2UsIGVsZW1lbnQudGFnKSkge1xuICAgICAgICBwYXJzZVRhZyhjb250ZXh0LCAxIC8qIFRhZ1R5cGUuRW5kICovLCBwYXJlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDI0IC8qIEVycm9yQ29kZXMuWF9NSVNTSU5HX0VORF9UQUcgKi8sIDAsIGVsZW1lbnQubG9jLnN0YXJ0KTtcbiAgICAgICAgaWYgKGNvbnRleHQuc291cmNlLmxlbmd0aCA9PT0gMCAmJiBlbGVtZW50LnRhZy50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBjaGlsZHJlblswXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCAmJiBzdGFydHNXaXRoKGZpcnN0LmxvYy5zb3VyY2UsICc8IS0tJykpIHtcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgOCAvKiBFcnJvckNvZGVzLkVPRl9JTl9TQ1JJUFRfSFRNTF9DT01NRU5UX0xJS0VfVEVYVCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5sb2MgPSBnZXRTZWxlY3Rpb24oY29udGV4dCwgZWxlbWVudC5sb2Muc3RhcnQpO1xuICAgIGlmIChpc1ByZUJvdW5kYXJ5KSB7XG4gICAgICAgIGNvbnRleHQuaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzVlByZUJvdW5kYXJ5KSB7XG4gICAgICAgIGNvbnRleHQuaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuY29uc3QgaXNTcGVjaWFsVGVtcGxhdGVEaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGlmLGVsc2UsZWxzZS1pZixmb3Isc2xvdGApO1xuZnVuY3Rpb24gcGFyc2VUYWcoY29udGV4dCwgdHlwZSwgcGFyZW50KSB7XG4gICAgLy8gVGFnIG9wZW4uXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgbWF0Y2ggPSAvXjxcXC8/KFthLXpdW15cXHRcXHJcXG5cXGYgLz5dKikvaS5leGVjKGNvbnRleHQuc291cmNlKTtcbiAgICBjb25zdCB0YWcgPSBtYXRjaFsxXTtcbiAgICBjb25zdCBucyA9IGNvbnRleHQub3B0aW9ucy5nZXROYW1lc3BhY2UodGFnLCBwYXJlbnQpO1xuICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xuICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XG4gICAgLy8gc2F2ZSBjdXJyZW50IHN0YXRlIGluIGNhc2Ugd2UgbmVlZCB0byByZS1wYXJzZSBhdHRyaWJ1dGVzIHdpdGggdi1wcmVcbiAgICBjb25zdCBjdXJzb3IgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgY3VycmVudFNvdXJjZSA9IGNvbnRleHQuc291cmNlO1xuICAgIC8vIGNoZWNrIDxwcmU+IHRhZ1xuICAgIGlmIChjb250ZXh0Lm9wdGlvbnMuaXNQcmVUYWcodGFnKSkge1xuICAgICAgICBjb250ZXh0LmluUHJlID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQXR0cmlidXRlcy5cbiAgICBsZXQgcHJvcHMgPSBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSk7XG4gICAgLy8gY2hlY2sgdi1wcmVcbiAgICBpZiAodHlwZSA9PT0gMCAvKiBUYWdUeXBlLlN0YXJ0ICovICYmXG4gICAgICAgICFjb250ZXh0LmluVlByZSAmJlxuICAgICAgICBwcm9wcy5zb21lKHAgPT4gcC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAncHJlJykpIHtcbiAgICAgICAgY29udGV4dC5pblZQcmUgPSB0cnVlO1xuICAgICAgICAvLyByZXNldCBjb250ZXh0XG4gICAgICAgIGV4dGVuZChjb250ZXh0LCBjdXJzb3IpO1xuICAgICAgICBjb250ZXh0LnNvdXJjZSA9IGN1cnJlbnRTb3VyY2U7XG4gICAgICAgIC8vIHJlLXBhcnNlIGF0dHJzIGFuZCBmaWx0ZXIgb3V0IHYtcHJlIGl0c2VsZlxuICAgICAgICBwcm9wcyA9IHBhcnNlQXR0cmlidXRlcyhjb250ZXh0LCB0eXBlKS5maWx0ZXIocCA9PiBwLm5hbWUgIT09ICd2LXByZScpO1xuICAgIH1cbiAgICAvLyBUYWcgY2xvc2UuXG4gICAgbGV0IGlzU2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICBpZiAoY29udGV4dC5zb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA5IC8qIEVycm9yQ29kZXMuRU9GX0lOX1RBRyAqLyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpc1NlbGZDbG9zaW5nID0gc3RhcnRzV2l0aChjb250ZXh0LnNvdXJjZSwgJy8+Jyk7XG4gICAgICAgIGlmICh0eXBlID09PSAxIC8qIFRhZ1R5cGUuRW5kICovICYmIGlzU2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCA0IC8qIEVycm9yQ29kZXMuRU5EX1RBR19XSVRIX1RSQUlMSU5HX1NPTElEVVMgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBpc1NlbGZDbG9zaW5nID8gMiA6IDEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gMSAvKiBUYWdUeXBlLkVuZCAqLykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIDIueCBkZXByZWNhdGlvbiBjaGVja3NcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgIGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQpKSB7XG4gICAgICAgIGxldCBoYXNJZiA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFzRm9yID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLykge1xuICAgICAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdpZicpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzSWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwLm5hbWUgPT09ICdmb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0ZvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0lmICYmIGhhc0Zvcikge1xuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX0lGX1ZfRk9SX1BSRUNFREVOQ0UgKi8sIGNvbnRleHQsIGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdUeXBlID0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLztcbiAgICBpZiAoIWNvbnRleHQuaW5WUHJlKSB7XG4gICAgICAgIGlmICh0YWcgPT09ICdzbG90Jykge1xuICAgICAgICAgICAgdGFnVHlwZSA9IDIgLyogRWxlbWVudFR5cGVzLlNMT1QgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuc29tZShwID0+IHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIGlzU3BlY2lhbFRlbXBsYXRlRGlyZWN0aXZlKHAubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgdGFnVHlwZSA9IDMgLyogRWxlbWVudFR5cGVzLlRFTVBMQVRFICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ29tcG9uZW50KHRhZywgcHJvcHMsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICB0YWdUeXBlID0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8sXG4gICAgICAgIG5zLFxuICAgICAgICB0YWcsXG4gICAgICAgIHRhZ1R5cGUsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBpc1NlbGZDbG9zaW5nLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIGxvYzogZ2V0U2VsZWN0aW9uKGNvbnRleHQsIHN0YXJ0KSxcbiAgICAgICAgY29kZWdlbk5vZGU6IHVuZGVmaW5lZCAvLyB0byBiZSBjcmVhdGVkIGR1cmluZyB0cmFuc2Zvcm0gcGhhc2VcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNDb21wb25lbnQodGFnLCBwcm9wcywgY29udGV4dCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMuaXNDdXN0b21FbGVtZW50KHRhZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnY29tcG9uZW50JyB8fFxuICAgICAgICAvXltBLVpdLy50ZXN0KHRhZykgfHxcbiAgICAgICAgaXNDb3JlQ29tcG9uZW50KHRhZykgfHxcbiAgICAgICAgKG9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50ICYmIG9wdGlvbnMuaXNCdWlsdEluQ29tcG9uZW50KHRhZykpIHx8XG4gICAgICAgIChvcHRpb25zLmlzTmF0aXZlVGFnICYmICFvcHRpb25zLmlzTmF0aXZlVGFnKHRhZykpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSB0YWcgc2hvdWxkIGJlIGEgbmF0aXZlIHRhZywgYnV0IGNoZWNrIGZvciBwb3RlbnRpYWwgXCJpc1wiXG4gICAgLy8gY2FzdGluZ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcCA9IHByb3BzW2ldO1xuICAgICAgICBpZiAocC50eXBlID09PSA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8pIHtcbiAgICAgICAgICAgIGlmIChwLm5hbWUgPT09ICdpcycgJiYgcC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChwLnZhbHVlLmNvbnRlbnQuc3RhcnRzV2l0aCgndnVlOicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQsIHAubG9jKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVcbiAgICAgICAgICAgIC8vIHYtaXMgKFRPRE8gRGVwcmVjYXRlKVxuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2lzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAvLyA6aXMgb24gcGxhaW4gZWxlbWVudCAtIG9ubHkgdHJlYXQgYXMgY29tcG9uZW50IGluIGNvbXBhdCBtb2RlXG4gICAgICAgICAgICBwLm5hbWUgPT09ICdiaW5kJyAmJlxuICAgICAgICAgICAgICAgIGlzU3RhdGljQXJnT2YocC5hcmcsICdpcycpICYmXG4gICAgICAgICAgICAgICAgdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCwgcC5sb2MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoY29udGV4dCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKGNvbnRleHQuc291cmNlLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgIXN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICc+JykgJiZcbiAgICAgICAgIXN0YXJ0c1dpdGgoY29udGV4dC5zb3VyY2UsICcvPicpKSB7XG4gICAgICAgIGlmIChzdGFydHNXaXRoKGNvbnRleHQuc291cmNlLCAnLycpKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjIgLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX1NPTElEVVNfSU5fVEFHICovKTtcbiAgICAgICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCAxKTtcbiAgICAgICAgICAgIGFkdmFuY2VTcGFjZXMoY29udGV4dCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gMSAvKiBUYWdUeXBlLkVuZCAqLykge1xuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDMgLyogRXJyb3JDb2Rlcy5FTkRfVEFHX1dJVEhfQVRUUklCVVRFUyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0ciA9IHBhcnNlQXR0cmlidXRlKGNvbnRleHQsIGF0dHJpYnV0ZU5hbWVzKTtcbiAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlIGJldHdlZW4gY2xhc3NcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL2NvcmUvaXNzdWVzLzQyNTFcbiAgICAgICAgaWYgKGF0dHIudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovICYmXG4gICAgICAgICAgICBhdHRyLnZhbHVlICYmXG4gICAgICAgICAgICBhdHRyLm5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIGF0dHIudmFsdWUuY29udGVudCA9IGF0dHIudmFsdWUuY29udGVudC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAwIC8qIFRhZ1R5cGUuU3RhcnQgKi8pIHtcbiAgICAgICAgICAgIHByb3BzLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eW15cXHRcXHJcXG5cXGYgLz5dLy50ZXN0KGNvbnRleHQuc291cmNlKSkge1xuICAgICAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE1IC8qIEVycm9yQ29kZXMuTUlTU0lOR19XSElURVNQQUNFX0JFVFdFRU5fQVRUUklCVVRFUyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGUoY29udGV4dCwgbmFtZVNldCkge1xuICAgIC8vIE5hbWUuXG4gICAgY29uc3Qgc3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgbWF0Y2ggPSAvXlteXFx0XFxyXFxuXFxmIC8+XVteXFx0XFxyXFxuXFxmIC8+PV0qLy5leGVjKGNvbnRleHQuc291cmNlKTtcbiAgICBjb25zdCBuYW1lID0gbWF0Y2hbMF07XG4gICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyIC8qIEVycm9yQ29kZXMuRFVQTElDQVRFX0FUVFJJQlVURSAqLyk7XG4gICAgfVxuICAgIG5hbWVTZXQuYWRkKG5hbWUpO1xuICAgIGlmIChuYW1lWzBdID09PSAnPScpIHtcbiAgICAgICAgZW1pdEVycm9yKGNvbnRleHQsIDE5IC8qIEVycm9yQ29kZXMuVU5FWFBFQ1RFRF9FUVVBTFNfU0lHTl9CRUZPUkVfQVRUUklCVVRFX05BTUUgKi8pO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAvW1wiJzxdL2c7XG4gICAgICAgIGxldCBtO1xuICAgICAgICB3aGlsZSAoKG0gPSBwYXR0ZXJuLmV4ZWMobmFtZSkpKSB7XG4gICAgICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMTcgLyogRXJyb3JDb2Rlcy5VTkVYUEVDVEVEX0NIQVJBQ1RFUl9JTl9BVFRSSUJVVEVfTkFNRSAqLywgbS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIG5hbWUubGVuZ3RoKTtcbiAgICAvLyBWYWx1ZVxuICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoL15bXFx0XFxyXFxuXFxmIF0qPS8udGVzdChjb250ZXh0LnNvdXJjZSkpIHtcbiAgICAgICAgYWR2YW5jZVNwYWNlcyhjb250ZXh0KTtcbiAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xuICAgICAgICBhZHZhbmNlU3BhY2VzKGNvbnRleHQpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlQXR0cmlidXRlVmFsdWUoY29udGV4dCk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxMyAvKiBFcnJvckNvZGVzLk1JU1NJTkdfQVRUUklCVVRFX1ZBTFVFICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsb2MgPSBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpO1xuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgL14odi1bQS1aYS16MC05LV18OnxcXC58QHwjKS8udGVzdChuYW1lKSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IC8oPzpedi0oW2EtejAtOS1dKykpPyg/Oig/Ojp8XlxcLnxeQHxeIykoXFxbW15cXF1dK1xcXXxbXlxcLl0rKSk/KC4rKT8kL2kuZXhlYyhuYW1lKTtcbiAgICAgICAgbGV0IGlzUHJvcFNob3J0aGFuZCA9IHN0YXJ0c1dpdGgobmFtZSwgJy4nKTtcbiAgICAgICAgbGV0IGRpck5hbWUgPSBtYXRjaFsxXSB8fFxuICAgICAgICAgICAgKGlzUHJvcFNob3J0aGFuZCB8fCBzdGFydHNXaXRoKG5hbWUsICc6JylcbiAgICAgICAgICAgICAgICA/ICdiaW5kJ1xuICAgICAgICAgICAgICAgIDogc3RhcnRzV2l0aChuYW1lLCAnQCcpXG4gICAgICAgICAgICAgICAgICAgID8gJ29uJ1xuICAgICAgICAgICAgICAgICAgICA6ICdzbG90Jyk7XG4gICAgICAgIGxldCBhcmc7XG4gICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgY29uc3QgaXNTbG90ID0gZGlyTmFtZSA9PT0gJ3Nsb3QnO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuYW1lLmxhc3RJbmRleE9mKG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IGdldFNlbGVjdGlvbihjb250ZXh0LCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQpLCBnZXROZXdQb3NpdGlvbihjb250ZXh0LCBzdGFydCwgc3RhcnRPZmZzZXQgKyBtYXRjaFsyXS5sZW5ndGggKyAoKGlzU2xvdCAmJiBtYXRjaFszXSkgfHwgJycpLmxlbmd0aCkpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIGxldCBpc1N0YXRpYyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY29udGVudC5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghY29udGVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAyNyAvKiBFcnJvckNvZGVzLlhfTUlTU0lOR19EWU5BTUlDX0RJUkVDVElWRV9BUkdVTUVOVF9FTkQgKi8pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEsIGNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTbG90KSB7XG4gICAgICAgICAgICAgICAgLy8gIzEyNDEgc3BlY2lhbCBjYXNlIGZvciB2LXNsb3Q6IHZ1ZXRpZnkgcmVsaWVzIGV4dGVuc2l2ZWx5IG9uIHNsb3RcbiAgICAgICAgICAgICAgICAvLyBuYW1lcyBjb250YWluaW5nIGRvdHMuIHYtc2xvdCBkb2Vzbid0IGhhdmUgYW55IG1vZGlmaWVycyBhbmQgVnVlIDIueFxuICAgICAgICAgICAgICAgIC8vIHN1cHBvcnRzIHN1Y2ggdXNhZ2Ugc28gd2UgYXJlIGtlZXBpbmcgaXQgY29uc2lzdGVudCB3aXRoIDIueC5cbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IG1hdGNoWzNdIHx8ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMsXG4gICAgICAgICAgICAgICAgY29uc3RUeXBlOiBpc1N0YXRpY1xuICAgICAgICAgICAgICAgICAgICA/IDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovXG4gICAgICAgICAgICAgICAgICAgIDogMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyxcbiAgICAgICAgICAgICAgICBsb2NcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzUXVvdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUxvYyA9IHZhbHVlLmxvYztcbiAgICAgICAgICAgIHZhbHVlTG9jLnN0YXJ0Lm9mZnNldCsrO1xuICAgICAgICAgICAgdmFsdWVMb2Muc3RhcnQuY29sdW1uKys7XG4gICAgICAgICAgICB2YWx1ZUxvYy5lbmQgPSBhZHZhbmNlUG9zaXRpb25XaXRoQ2xvbmUodmFsdWVMb2Muc3RhcnQsIHZhbHVlLmNvbnRlbnQpO1xuICAgICAgICAgICAgdmFsdWVMb2Muc291cmNlID0gdmFsdWVMb2Muc291cmNlLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSBtYXRjaFszXSA/IG1hdGNoWzNdLnNsaWNlKDEpLnNwbGl0KCcuJykgOiBbXTtcbiAgICAgICAgaWYgKGlzUHJvcFNob3J0aGFuZClcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcm9wJyk7XG4gICAgICAgIC8vIDIueCBjb21wYXQgdi1iaW5kOmZvby5zeW5jIC0+IHYtbW9kZWw6Zm9vXG4gICAgICAgIGlmIChkaXJOYW1lID09PSAnYmluZCcgJiYgYXJnKSB7XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdzeW5jJykgJiZcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfU1lOQ1wiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX0JJTkRfU1lOQyAqLywgY29udGV4dCwgbG9jLCBhcmcubG9jLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBkaXJOYW1lID0gJ21vZGVsJztcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMuc3BsaWNlKG1vZGlmaWVycy5pbmRleE9mKCdzeW5jJyksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtb2RpZmllcnMuaW5jbHVkZXMoJ3Byb3AnKSkge1xuICAgICAgICAgICAgICAgIGNoZWNrQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9QUk9QXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX1ZfQklORF9QUk9QICovLCBjb250ZXh0LCBsb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8sXG4gICAgICAgICAgICBuYW1lOiBkaXJOYW1lLFxuICAgICAgICAgICAgZXhwOiB2YWx1ZSAmJiB7XG4gICAgICAgICAgICAgICAgdHlwZTogNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8sXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcbiAgICAgICAgICAgICAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgYXMgbm9uLWNvbnN0YW50IGJ5IGRlZmF1bHQuIFRoaXMgY2FuIGJlIHBvdGVudGlhbGx5IHNldCB0b1xuICAgICAgICAgICAgICAgIC8vIG90aGVyIHZhbHVlcyBieSBgdHJhbnNmb3JtRXhwcmVzc2lvbmAgdG8gbWFrZSBpdCBlbGlnaWJsZSBmb3IgaG9pc3RpbmcuXG4gICAgICAgICAgICAgICAgY29uc3RUeXBlOiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovLFxuICAgICAgICAgICAgICAgIGxvYzogdmFsdWUubG9jXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgbG9jXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIG1pc3NpbmcgZGlyZWN0aXZlIG5hbWUgb3IgaWxsZWdhbCBkaXJlY3RpdmUgbmFtZVxuICAgIGlmICghY29udGV4dC5pblZQcmUgJiYgc3RhcnRzV2l0aChuYW1lLCAndi0nKSkge1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjYgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfRElSRUNUSVZFX05BTUUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSAmJiB7XG4gICAgICAgICAgICB0eXBlOiAyIC8qIE5vZGVUeXBlcy5URVhUICovLFxuICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudCxcbiAgICAgICAgICAgIGxvYzogdmFsdWUubG9jXG4gICAgICAgIH0sXG4gICAgICAgIGxvY1xuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVZhbHVlKGNvbnRleHQpIHtcbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcbiAgICBsZXQgY29udGVudDtcbiAgICBjb25zdCBxdW90ZSA9IGNvbnRleHQuc291cmNlWzBdO1xuICAgIGNvbnN0IGlzUXVvdGVkID0gcXVvdGUgPT09IGBcImAgfHwgcXVvdGUgPT09IGAnYDtcbiAgICBpZiAoaXNRdW90ZWQpIHtcbiAgICAgICAgLy8gUXVvdGVkIHZhbHVlLlxuICAgICAgICBhZHZhbmNlQnkoY29udGV4dCwgMSk7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihxdW90ZSk7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGNvbnRleHQuc291cmNlLmxlbmd0aCwgNCAvKiBUZXh0TW9kZXMuQVRUUklCVVRFX1ZBTFVFICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCA0IC8qIFRleHRNb2Rlcy5BVFRSSUJVVEVfVkFMVUUgKi8pO1xuICAgICAgICAgICAgYWR2YW5jZUJ5KGNvbnRleHQsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVbnF1b3RlZFxuICAgICAgICBjb25zdCBtYXRjaCA9IC9eW15cXHRcXHJcXG5cXGYgPl0rLy5leGVjKGNvbnRleHQuc291cmNlKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmV4cGVjdGVkQ2hhcnMgPSAvW1wiJzw9YF0vZztcbiAgICAgICAgbGV0IG07XG4gICAgICAgIHdoaWxlICgobSA9IHVuZXhwZWN0ZWRDaGFycy5leGVjKG1hdGNoWzBdKSkpIHtcbiAgICAgICAgICAgIGVtaXRFcnJvcihjb250ZXh0LCAxOCAvKiBFcnJvckNvZGVzLlVORVhQRUNURURfQ0hBUkFDVEVSX0lOX1VOUVVPVEVEX0FUVFJJQlVURV9WQUxVRSAqLywgbS5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IHBhcnNlVGV4dERhdGEoY29udGV4dCwgbWF0Y2hbMF0ubGVuZ3RoLCA0IC8qIFRleHRNb2Rlcy5BVFRSSUJVVEVfVkFMVUUgKi8pO1xuICAgIH1cbiAgICByZXR1cm4geyBjb250ZW50LCBpc1F1b3RlZCwgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpIH07XG59XG5mdW5jdGlvbiBwYXJzZUludGVycG9sYXRpb24oY29udGV4dCwgbW9kZSkge1xuICAgIGNvbnN0IFtvcGVuLCBjbG9zZV0gPSBjb250ZXh0Lm9wdGlvbnMuZGVsaW1pdGVycztcbiAgICBjb25zdCBjbG9zZUluZGV4ID0gY29udGV4dC5zb3VyY2UuaW5kZXhPZihjbG9zZSwgb3Blbi5sZW5ndGgpO1xuICAgIGlmIChjbG9zZUluZGV4ID09PSAtMSkge1xuICAgICAgICBlbWl0RXJyb3IoY29udGV4dCwgMjUgLyogRXJyb3JDb2Rlcy5YX01JU1NJTkdfSU5URVJQT0xBVElPTl9FTkQgKi8pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IGdldEN1cnNvcihjb250ZXh0KTtcbiAgICBhZHZhbmNlQnkoY29udGV4dCwgb3Blbi5sZW5ndGgpO1xuICAgIGNvbnN0IGlubmVyU3RhcnQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgaW5uZXJFbmQgPSBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgY29uc3QgcmF3Q29udGVudExlbmd0aCA9IGNsb3NlSW5kZXggLSBvcGVuLmxlbmd0aDtcbiAgICBjb25zdCByYXdDb250ZW50ID0gY29udGV4dC5zb3VyY2Uuc2xpY2UoMCwgcmF3Q29udGVudExlbmd0aCk7XG4gICAgY29uc3QgcHJlVHJpbUNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIHJhd0NvbnRlbnRMZW5ndGgsIG1vZGUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVUcmltQ29udGVudC50cmltKCk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBwcmVUcmltQ29udGVudC5pbmRleE9mKGNvbnRlbnQpO1xuICAgIGlmIChzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uKGlubmVyU3RhcnQsIHJhd0NvbnRlbnQsIHN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gcmF3Q29udGVudExlbmd0aCAtIChwcmVUcmltQ29udGVudC5sZW5ndGggLSBjb250ZW50Lmxlbmd0aCAtIHN0YXJ0T2Zmc2V0KTtcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oaW5uZXJFbmQsIHJhd0NvbnRlbnQsIGVuZE9mZnNldCk7XG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIGNsb3NlLmxlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLyxcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgdHlwZTogNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8sXG4gICAgICAgICAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgICAvLyBTZXQgYGlzQ29uc3RhbnRgIHRvIGZhbHNlIGJ5IGRlZmF1bHQgYW5kIHdpbGwgZGVjaWRlIGluIHRyYW5zZm9ybUV4cHJlc3Npb25cbiAgICAgICAgICAgIGNvbnN0VHlwZTogMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBpbm5lclN0YXJ0LCBpbm5lckVuZClcbiAgICAgICAgfSxcbiAgICAgICAgbG9jOiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGV4dChjb250ZXh0LCBtb2RlKSB7XG4gICAgY29uc3QgZW5kVG9rZW5zID0gbW9kZSA9PT0gMyAvKiBUZXh0TW9kZXMuQ0RBVEEgKi8gPyBbJ11dPiddIDogWyc8JywgY29udGV4dC5vcHRpb25zLmRlbGltaXRlcnNbMF1dO1xuICAgIGxldCBlbmRJbmRleCA9IGNvbnRleHQuc291cmNlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNvbnRleHQuc291cmNlLmluZGV4T2YoZW5kVG9rZW5zW2ldLCAxKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBlbmRJbmRleCA+IGluZGV4KSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Q3Vyc29yKGNvbnRleHQpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZVRleHREYXRhKGNvbnRleHQsIGVuZEluZGV4LCBtb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAyIC8qIE5vZGVUeXBlcy5URVhUICovLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBsb2M6IGdldFNlbGVjdGlvbihjb250ZXh0LCBzdGFydClcbiAgICB9O1xufVxuLyoqXG4gKiBHZXQgdGV4dCBkYXRhIHdpdGggYSBnaXZlbiBsZW5ndGggZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqIFRoaXMgdHJhbnNsYXRlcyBIVE1MIGVudGl0aWVzIGluIHRoZSB0ZXh0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEoY29udGV4dCwgbGVuZ3RoLCBtb2RlKSB7XG4gICAgY29uc3QgcmF3VGV4dCA9IGNvbnRleHQuc291cmNlLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgYWR2YW5jZUJ5KGNvbnRleHQsIGxlbmd0aCk7XG4gICAgaWYgKG1vZGUgPT09IDIgLyogVGV4dE1vZGVzLlJBV1RFWFQgKi8gfHxcbiAgICAgICAgbW9kZSA9PT0gMyAvKiBUZXh0TW9kZXMuQ0RBVEEgKi8gfHxcbiAgICAgICAgIXJhd1RleHQuaW5jbHVkZXMoJyYnKSkge1xuICAgICAgICByZXR1cm4gcmF3VGV4dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIERBVEEgb3IgUkNEQVRBIGNvbnRhaW5pbmcgXCImXCJcIi4gRW50aXR5IGRlY29kaW5nIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gY29udGV4dC5vcHRpb25zLmRlY29kZUVudGl0aWVzKHJhd1RleHQsIG1vZGUgPT09IDQgLyogVGV4dE1vZGVzLkFUVFJJQlVURV9WQUxVRSAqLyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q3Vyc29yKGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH0gPSBjb250ZXh0O1xuICAgIHJldHVybiB7IGNvbHVtbiwgbGluZSwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oY29udGV4dCwgc3RhcnQsIGVuZCkge1xuICAgIGVuZCA9IGVuZCB8fCBnZXRDdXJzb3IoY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgc291cmNlOiBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldClcbiAgICB9O1xufVxuZnVuY3Rpb24gbGFzdCh4cykge1xuICAgIHJldHVybiB4c1t4cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc291cmNlLCBzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gc291cmNlLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIGFkdmFuY2VCeShjb250ZXh0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gY29udGV4dDtcbiAgICBhZHZhbmNlUG9zaXRpb25XaXRoTXV0YXRpb24oY29udGV4dCwgc291cmNlLCBudW1iZXJPZkNoYXJhY3RlcnMpO1xuICAgIGNvbnRleHQuc291cmNlID0gc291cmNlLnNsaWNlKG51bWJlck9mQ2hhcmFjdGVycyk7XG59XG5mdW5jdGlvbiBhZHZhbmNlU3BhY2VzKGNvbnRleHQpIHtcbiAgICBjb25zdCBtYXRjaCA9IC9eW1xcdFxcclxcblxcZiBdKy8uZXhlYyhjb250ZXh0LnNvdXJjZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGFkdmFuY2VCeShjb250ZXh0LCBtYXRjaFswXS5sZW5ndGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE5ld1Bvc2l0aW9uKGNvbnRleHQsIHN0YXJ0LCBudW1iZXJPZkNoYXJhY3RlcnMpIHtcbiAgICByZXR1cm4gYWR2YW5jZVBvc2l0aW9uV2l0aENsb25lKHN0YXJ0LCBjb250ZXh0Lm9yaWdpbmFsU291cmNlLnNsaWNlKHN0YXJ0Lm9mZnNldCwgbnVtYmVyT2ZDaGFyYWN0ZXJzKSwgbnVtYmVyT2ZDaGFyYWN0ZXJzKTtcbn1cbmZ1bmN0aW9uIGVtaXRFcnJvcihjb250ZXh0LCBjb2RlLCBvZmZzZXQsIGxvYyA9IGdldEN1cnNvcihjb250ZXh0KSkge1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgbG9jLm9mZnNldCArPSBvZmZzZXQ7XG4gICAgICAgIGxvYy5jb2x1bW4gKz0gb2Zmc2V0O1xuICAgIH1cbiAgICBjb250ZXh0Lm9wdGlvbnMub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGNvZGUsIHtcbiAgICAgICAgc3RhcnQ6IGxvYyxcbiAgICAgICAgZW5kOiBsb2MsXG4gICAgICAgIHNvdXJjZTogJydcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBpc0VuZChjb250ZXh0LCBtb2RlLCBhbmNlc3RvcnMpIHtcbiAgICBjb25zdCBzID0gY29udGV4dC5zb3VyY2U7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgMCAvKiBUZXh0TW9kZXMuREFUQSAqLzpcbiAgICAgICAgICAgIGlmIChzdGFydHNXaXRoKHMsICc8LycpKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcHJvYmFibHkgYmFkIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgYW5jZXN0b3JzW2ldLnRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBUZXh0TW9kZXMuUkNEQVRBICovOlxuICAgICAgICBjYXNlIDIgLyogVGV4dE1vZGVzLlJBV1RFWFQgKi86IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGxhc3QoYW5jZXN0b3JzKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgc3RhcnRzV2l0aEVuZFRhZ09wZW4ocywgcGFyZW50LnRhZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMyAvKiBUZXh0TW9kZXMuQ0RBVEEgKi86XG4gICAgICAgICAgICBpZiAoc3RhcnRzV2l0aChzLCAnXV0+JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gIXM7XG59XG5mdW5jdGlvbiBzdGFydHNXaXRoRW5kVGFnT3Blbihzb3VyY2UsIHRhZykge1xuICAgIHJldHVybiAoc3RhcnRzV2l0aChzb3VyY2UsICc8LycpICYmXG4gICAgICAgIHNvdXJjZS5zbGljZSgyLCAyICsgdGFnLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgL1tcXHRcXHJcXG5cXGYgLz5dLy50ZXN0KHNvdXJjZVsyICsgdGFnLmxlbmd0aF0gfHwgJz4nKSk7XG59XG5cbmZ1bmN0aW9uIGhvaXN0U3RhdGljKHJvb3QsIGNvbnRleHQpIHtcbiAgICB3YWxrKHJvb3QsIGNvbnRleHQsIFxuICAgIC8vIFJvb3Qgbm9kZSBpcyB1bmZvcnR1bmF0ZWx5IG5vbi1ob2lzdGFibGUgZHVlIHRvIHBvdGVudGlhbCBwYXJlbnRcbiAgICAvLyBmYWxsdGhyb3VnaCBhdHRyaWJ1dGVzLlxuICAgIGlzU2luZ2xlRWxlbWVudFJvb3Qocm9vdCwgcm9vdC5jaGlsZHJlblswXSkpO1xufVxuZnVuY3Rpb24gaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XG4gICAgcmV0dXJuIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAhaXNTbG90T3V0bGV0KGNoaWxkKSk7XG59XG5mdW5jdGlvbiB3YWxrKG5vZGUsIGNvbnRleHQsIGRvTm90SG9pc3ROb2RlID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBub2RlO1xuICAgIGNvbnN0IG9yaWdpbmFsQ291bnQgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgbGV0IGhvaXN0ZWRDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyBvbmx5IHBsYWluIGVsZW1lbnRzICYgdGV4dCBjYWxscyBhcmUgZWxpZ2libGUgZm9yIGhvaXN0aW5nLlxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgY2hpbGQudGFnVHlwZSA9PT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgY29uc3QgY29uc3RhbnRUeXBlID0gZG9Ob3RIb2lzdE5vZGVcbiAgICAgICAgICAgICAgICA/IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi9cbiAgICAgICAgICAgICAgICA6IGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY29uc3RhbnRUeXBlID4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdGFudFR5cGUgPj0gMiAvKiBDb25zdGFudFR5cGVzLkNBTl9IT0lTVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb2RlZ2VuTm9kZS5wYXRjaEZsYWcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgLTEgLyogUGF0Y2hGbGFncy5IT0lTVEVEICovICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogSE9JU1RFRCAqL2AgOiBgYCk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmNvZGVnZW5Ob2RlID0gY29udGV4dC5ob2lzdChjaGlsZC5jb2RlZ2VuTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBjb250YWluIGR5bmFtaWMgY2hpbGRyZW4sIGJ1dCBpdHMgcHJvcHMgbWF5IGJlIGVsaWdpYmxlIGZvclxuICAgICAgICAgICAgICAgIC8vIGhvaXN0aW5nLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gY2hpbGQuY29kZWdlbk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBnZXRQYXRjaEZsYWcoY29kZWdlbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKCFmbGFnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnID09PSA1MTIgLyogUGF0Y2hGbGFncy5ORUVEX1BBVENIICovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnID09PSAxIC8qIFBhdGNoRmxhZ3MuVEVYVCAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEdlbmVyYXRlZFByb3BzQ29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KSA+PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgLyogQ29uc3RhbnRUeXBlcy5DQU5fSE9JU1QgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2V0Tm9kZVByb3BzKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVnZW5Ob2RlLnByb3BzID0gY29udGV4dC5ob2lzdChwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLmR5bmFtaWNQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWdlbk5vZGUuZHluYW1pY1Byb3BzID0gY29udGV4dC5ob2lzdChjb2RlZ2VuTm9kZS5keW5hbWljUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdhbGsgZnVydGhlclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgY29uc3QgaXNDb21wb25lbnQgPSBjaGlsZC50YWdUeXBlID09PSAxIC8qIEVsZW1lbnRUeXBlcy5DT01QT05FTlQgKi87XG4gICAgICAgICAgICBpZiAoaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FsayhjaGlsZCwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDExIC8qIE5vZGVUeXBlcy5GT1IgKi8pIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBob2lzdCB2LWZvciBzaW5nbGUgY2hpbGQgYmVjYXVzZSBpdCBoYXMgdG8gYmUgYSBibG9ja1xuICAgICAgICAgICAgd2FsayhjaGlsZCwgY29udGV4dCwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSA5IC8qIE5vZGVUeXBlcy5JRiAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZC5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBob2lzdCB2LWlmIHNpbmdsZSBjaGlsZCBiZWNhdXNlIGl0IGhhcyB0byBiZSBhIGJsb2NrXG4gICAgICAgICAgICAgICAgd2FsayhjaGlsZC5icmFuY2hlc1tpXSwgY29udGV4dCwgY2hpbGQuYnJhbmNoZXNbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaG9pc3RlZENvdW50ICYmIGNvbnRleHQudHJhbnNmb3JtSG9pc3QpIHtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1Ib2lzdChjaGlsZHJlbiwgY29udGV4dCwgbm9kZSk7XG4gICAgfVxuICAgIC8vIGFsbCBjaGlsZHJlbiB3ZXJlIGhvaXN0ZWQgLSB0aGUgZW50aXJlIGNoaWxkcmVuIGFycmF5IGlzIGhvaXN0YWJsZS5cbiAgICBpZiAoaG9pc3RlZENvdW50ICYmXG4gICAgICAgIGhvaXN0ZWRDb3VudCA9PT0gb3JpZ2luYWxDb3VudCAmJlxuICAgICAgICBub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgbm9kZS50YWdUeXBlID09PSAwIC8qIEVsZW1lbnRUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgJiZcbiAgICAgICAgbm9kZS5jb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBOb2RlVHlwZXMuVk5PREVfQ0FMTCAqLyAmJlxuICAgICAgICBpc0FycmF5KG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUuY2hpbGRyZW4gPSBjb250ZXh0LmhvaXN0KGNyZWF0ZUFycmF5RXhwcmVzc2lvbihub2RlLmNvZGVnZW5Ob2RlLmNoaWxkcmVuKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29uc3RhbnRUeXBlKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGNvbnN0YW50Q2FjaGUgfSA9IGNvbnRleHQ7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovOlxuICAgICAgICAgICAgaWYgKG5vZGUudGFnVHlwZSAhPT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY29uc3RhbnRDYWNoZS5nZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBub2RlLmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlLnR5cGUgIT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZWdlbk5vZGUuaXNCbG9jayAmJlxuICAgICAgICAgICAgICAgIG5vZGUudGFnICE9PSAnc3ZnJyAmJlxuICAgICAgICAgICAgICAgIG5vZGUudGFnICE9PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBnZXRQYXRjaEZsYWcoY29kZWdlbk5vZGUpO1xuICAgICAgICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENvbnN0YW50VHlwZXMuQ0FOX1NUUklOR0lGWSAqLztcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGl0c2VsZiBoYXMgbm8gcGF0Y2ggZmxhZy4gSG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrOlxuICAgICAgICAgICAgICAgIC8vIDEuIEV2ZW4gZm9yIGEgbm9kZSB3aXRoIG5vIHBhdGNoIGZsYWcsIGl0IGlzIHBvc3NpYmxlIGZvciBpdCB0byBjb250YWluXG4gICAgICAgICAgICAgICAgLy8gbm9uLWhvaXN0YWJsZSBleHByZXNzaW9ucyB0aGF0IHJlZmVycyB0byBzY29wZSB2YXJpYWJsZXMsIGUuZy4gY29tcGlsZXJcbiAgICAgICAgICAgICAgICAvLyBpbmplY3RlZCBrZXlzIG9yIGNhY2hlZCBldmVudCBoYW5kbGVycy4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gYWx3YXlzXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGNvZGVnZW5Ob2RlJ3MgcHJvcHMgdG8gYmUgc3VyZS5cbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRQcm9wc1R5cGUgPSBnZXRHZW5lcmF0ZWRQcm9wc0NvbnN0YW50VHlwZShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkUHJvcHNUeXBlID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZFByb3BzVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGdlbmVyYXRlZFByb3BzVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMi4gaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBnZXRDb25zdGFudFR5cGUobm9kZS5jaGlsZHJlbltpXSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFR5cGUgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gMy4gaWYgdGhlIHR5cGUgaXMgbm90IGFscmVhZHkgQ0FOX1NLSVBfUEFUQ0ggd2hpY2ggaXMgdGhlIGxvd2VzdCBub24tMFxuICAgICAgICAgICAgICAgIC8vIHR5cGUsIGNoZWNrIGlmIGFueSBvZiB0aGUgcHJvcHMgY2FuIGNhdXNlIHRoZSB0eXBlIHRvIGJlIGxvd2VyZWRcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gc2tpcCBjYW5fcGF0Y2ggYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgYnkgdGhlIGFic2VuY2Ugb2YgYVxuICAgICAgICAgICAgICAgIC8vIHBhdGNoRmxhZy5cbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVHlwZSA+IDEgLyogQ29uc3RhbnRUeXBlcy5DQU5fU0tJUF9QQVRDSCAqLykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmIHAubmFtZSA9PT0gJ2JpbmQnICYmIHAuZXhwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwVHlwZSA9IGdldENvbnN0YW50VHlwZShwLmV4cCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cFR5cGUgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwVHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZSA9IGV4cFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9ubHkgc3ZnL2ZvcmVpZ25PYmplY3QgY291bGQgYmUgYmxvY2sgaGVyZSwgaG93ZXZlciBpZiB0aGV5IGFyZVxuICAgICAgICAgICAgICAgIC8vIHN0YXRpYyB0aGVuIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBibG9ja3Mgc2luY2UgdGhlcmUgd2lsbCBiZSBub1xuICAgICAgICAgICAgICAgIC8vIG5lc3RlZCB1cGRhdGVzLlxuICAgICAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VwdCBzZXQgY3VzdG9tIGRpcmVjdGl2ZXMuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudENhY2hlLnNldChub2RlLCAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbW92ZUhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVIZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjb2RlZ2VuTm9kZS5pc0NvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZS5pc0Jsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNvZGVnZW5Ob2RlLmlzQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0YW50Q2FjaGUuc2V0KG5vZGUsIHJldHVyblR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5UeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3RhbnRDYWNoZS5zZXQobm9kZSwgMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMiAvKiBOb2RlVHlwZXMuVEVYVCAqLzpcbiAgICAgICAgY2FzZSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovOlxuICAgICAgICAgICAgcmV0dXJuIDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovO1xuICAgICAgICBjYXNlIDkgLyogTm9kZVR5cGVzLklGICovOlxuICAgICAgICBjYXNlIDExIC8qIE5vZGVUeXBlcy5GT1IgKi86XG4gICAgICAgIGNhc2UgMTAgLyogTm9kZVR5cGVzLklGX0JSQU5DSCAqLzpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICBjYXNlIDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi86XG4gICAgICAgIGNhc2UgMTIgLyogTm9kZVR5cGVzLlRFWFRfQ0FMTCAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZXRDb25zdGFudFR5cGUobm9kZS5jb250ZW50LCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnN0VHlwZTtcbiAgICAgICAgY2FzZSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgbGV0IHJldHVyblR5cGUgPSAzIC8qIENvbnN0YW50VHlwZXMuQ0FOX1NUUklOR0lGWSAqLztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoY2hpbGQpIHx8IGlzU3ltYm9sKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gZ2V0Q29uc3RhbnRUeXBlKGNoaWxkLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZFR5cGUgPCByZXR1cm5UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSBjaGlsZFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblR5cGU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSA7XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLztcbiAgICB9XG59XG5jb25zdCBhbGxvd0hvaXN0ZWRIZWxwZXJTZXQgPSBuZXcgU2V0KFtcbiAgICBOT1JNQUxJWkVfQ0xBU1MsXG4gICAgTk9STUFMSVpFX1NUWUxFLFxuICAgIE5PUk1BTElaRV9QUk9QUyxcbiAgICBHVUFSRF9SRUFDVElWRV9QUk9QU1xuXSk7XG5mdW5jdGlvbiBnZXRDb25zdGFudFR5cGVPZkhlbHBlckNhbGwodmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLyAmJlxuICAgICAgICAhaXNTdHJpbmcodmFsdWUuY2FsbGVlKSAmJlxuICAgICAgICBhbGxvd0hvaXN0ZWRIZWxwZXJTZXQuaGFzKHZhbHVlLmNhbGxlZSkpIHtcbiAgICAgICAgY29uc3QgYXJnID0gdmFsdWUuYXJndW1lbnRzWzBdO1xuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29uc3RhbnRUeXBlKGFyZywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnLnR5cGUgPT09IDE0IC8qIE5vZGVUeXBlcy5KU19DQUxMX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIG5lc3RlZCBoZWxwZXIgY2FsbCwgZS5nLiBgbm9ybWFsaXplUHJvcHMoZ3VhcmRSZWFjdGl2ZVByb3BzKGV4cCkpYFxuICAgICAgICAgICAgcmV0dXJuIGdldENvbnN0YW50VHlwZU9mSGVscGVyQ2FsbChhcmcsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xufVxuZnVuY3Rpb24gZ2V0R2VuZXJhdGVkUHJvcHNDb25zdGFudFR5cGUobm9kZSwgY29udGV4dCkge1xuICAgIGxldCByZXR1cm5UeXBlID0gMyAvKiBDb25zdGFudFR5cGVzLkNBTl9TVFJJTkdJRlkgKi87XG4gICAgY29uc3QgcHJvcHMgPSBnZXROb2RlUHJvcHMobm9kZSk7XG4gICAgaWYgKHByb3BzICYmIHByb3BzLnR5cGUgPT09IDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBjb25zdCB7IHByb3BlcnRpZXMgfSA9IHByb3BzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGtleVR5cGUgPSBnZXRDb25zdGFudFR5cGUoa2V5LCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChrZXlUeXBlID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5VHlwZSA8IHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5UeXBlID0ga2V5VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWx1ZVR5cGU7XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSBnZXRDb25zdGFudFR5cGUodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgaGVscGVyIGNhbGxzIGNhbiBiZSBob2lzdGVkLFxuICAgICAgICAgICAgICAgIC8vIHN1Y2ggYXMgdGhlIGBub3JtYWxpemVQcm9wc2AgZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciBmb3IgcHJlLW5vcm1hbGl6ZSBjbGFzcyxcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byByZXNwZWN0IHRoZSBDb25zdGFudFR5cGUgb2YgdGhlIGhlbHBlcidzIGFyZ3VtZW50c1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IGdldENvbnN0YW50VHlwZU9mSGVscGVyQ2FsbCh2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gMCAvKiBDb25zdGFudFR5cGVzLk5PVF9DT05TVEFOVCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWVUeXBlIDwgcmV0dXJuVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVyblR5cGUgPSB2YWx1ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblR5cGU7XG59XG5mdW5jdGlvbiBnZXROb2RlUHJvcHMobm9kZSkge1xuICAgIGNvbnN0IGNvZGVnZW5Ob2RlID0gbm9kZS5jb2RlZ2VuTm9kZTtcbiAgICBpZiAoY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi8pIHtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5Ob2RlLnByb3BzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFBhdGNoRmxhZyhub2RlKSB7XG4gICAgY29uc3QgZmxhZyA9IG5vZGUucGF0Y2hGbGFnO1xuICAgIHJldHVybiBmbGFnID8gcGFyc2VJbnQoZmxhZywgMTApIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0KHJvb3QsIHsgZmlsZW5hbWUgPSAnJywgcHJlZml4SWRlbnRpZmllcnMgPSBmYWxzZSwgaG9pc3RTdGF0aWMgPSBmYWxzZSwgY2FjaGVIYW5kbGVycyA9IGZhbHNlLCBub2RlVHJhbnNmb3JtcyA9IFtdLCBkaXJlY3RpdmVUcmFuc2Zvcm1zID0ge30sIHRyYW5zZm9ybUhvaXN0ID0gbnVsbCwgaXNCdWlsdEluQ29tcG9uZW50ID0gTk9PUCwgaXNDdXN0b21FbGVtZW50ID0gTk9PUCwgZXhwcmVzc2lvblBsdWdpbnMgPSBbXSwgc2NvcGVJZCA9IG51bGwsIHNsb3R0ZWQgPSB0cnVlLCBzc3IgPSBmYWxzZSwgaW5TU1IgPSBmYWxzZSwgc3NyQ3NzVmFycyA9IGBgLCBiaW5kaW5nTWV0YWRhdGEgPSBFTVBUWV9PQkosIGlubGluZSA9IGZhbHNlLCBpc1RTID0gZmFsc2UsIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvciwgb25XYXJuID0gZGVmYXVsdE9uV2FybiwgY29tcGF0Q29uZmlnIH0pIHtcbiAgICBjb25zdCBuYW1lTWF0Y2ggPSBmaWxlbmFtZS5yZXBsYWNlKC9cXD8uKiQvLCAnJykubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgIHNlbGZOYW1lOiBuYW1lTWF0Y2ggJiYgY2FwaXRhbGl6ZShjYW1lbGl6ZSQxKG5hbWVNYXRjaFsxXSkpLFxuICAgICAgICBwcmVmaXhJZGVudGlmaWVycyxcbiAgICAgICAgaG9pc3RTdGF0aWMsXG4gICAgICAgIGNhY2hlSGFuZGxlcnMsXG4gICAgICAgIG5vZGVUcmFuc2Zvcm1zLFxuICAgICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zLFxuICAgICAgICB0cmFuc2Zvcm1Ib2lzdCxcbiAgICAgICAgaXNCdWlsdEluQ29tcG9uZW50LFxuICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXG4gICAgICAgIGV4cHJlc3Npb25QbHVnaW5zLFxuICAgICAgICBzY29wZUlkLFxuICAgICAgICBzbG90dGVkLFxuICAgICAgICBzc3IsXG4gICAgICAgIGluU1NSLFxuICAgICAgICBzc3JDc3NWYXJzLFxuICAgICAgICBiaW5kaW5nTWV0YWRhdGEsXG4gICAgICAgIGlubGluZSxcbiAgICAgICAgaXNUUyxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgb25XYXJuLFxuICAgICAgICBjb21wYXRDb25maWcsXG4gICAgICAgIC8vIHN0YXRlXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGhlbHBlcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgY29tcG9uZW50czogbmV3IFNldCgpLFxuICAgICAgICBkaXJlY3RpdmVzOiBuZXcgU2V0KCksXG4gICAgICAgIGhvaXN0czogW10sXG4gICAgICAgIGltcG9ydHM6IFtdLFxuICAgICAgICBjb25zdGFudENhY2hlOiBuZXcgTWFwKCksXG4gICAgICAgIHRlbXBzOiAwLFxuICAgICAgICBjYWNoZWQ6IDAsXG4gICAgICAgIGlkZW50aWZpZXJzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBzY29wZXM6IHtcbiAgICAgICAgICAgIHZGb3I6IDAsXG4gICAgICAgICAgICB2U2xvdDogMCxcbiAgICAgICAgICAgIHZQcmU6IDAsXG4gICAgICAgICAgICB2T25jZTogMFxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgIGN1cnJlbnROb2RlOiByb290LFxuICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICBpblZPbmNlOiBmYWxzZSxcbiAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICBoZWxwZXIobmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBjb250ZXh0LmhlbHBlcnMuZ2V0KG5hbWUpIHx8IDA7XG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcnMuc2V0KG5hbWUsIGNvdW50ICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlSGVscGVyKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gY29udGV4dC5oZWxwZXJzLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IGNvdW50IC0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXJzLnNldChuYW1lLCBjdXJyZW50Q291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGVscGVyU3RyaW5nKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgXyR7aGVscGVyTmFtZU1hcFtjb250ZXh0LmhlbHBlcihuYW1lKV19YDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGFjZU5vZGUobm9kZSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSBiZWluZyByZXBsYWNlZCBpcyBhbHJlYWR5IHJlbW92ZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSByb290IG5vZGUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5wYXJlbnQuY2hpbGRyZW5bY29udGV4dC5jaGlsZEluZGV4XSA9IGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNvbnRleHQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVtb3ZlIHJvb3Qgbm9kZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92YWxJbmRleCA9IG5vZGVcbiAgICAgICAgICAgICAgICA/IGxpc3QuaW5kZXhPZihub2RlKVxuICAgICAgICAgICAgICAgIDogY29udGV4dC5jdXJyZW50Tm9kZVxuICAgICAgICAgICAgICAgICAgICA/IGNvbnRleHQuY2hpbGRJbmRleFxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHJlbW92YWxJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vZGUgYmVpbmcgcmVtb3ZlZCBpcyBub3QgYSBjaGlsZCBvZiBjdXJyZW50IHBhcmVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IGNvbnRleHQuY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50IG5vZGUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2libGluZyBub2RlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5jaGlsZEluZGV4ID4gcmVtb3ZhbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hpbGRJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uTm9kZVJlbW92ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnBhcmVudC5jaGlsZHJlbi5zcGxpY2UocmVtb3ZhbEluZGV4LCAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlUmVtb3ZlZDogKCkgPT4geyB9LFxuICAgICAgICBhZGRJZGVudGlmaWVycyhleHApIHtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlSWRlbnRpZmllcnMoZXhwKSB7XG4gICAgICAgIH0sXG4gICAgICAgIGhvaXN0KGV4cCkge1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGV4cCkpXG4gICAgICAgICAgICAgICAgZXhwID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihleHApO1xuICAgICAgICAgICAgY29udGV4dC5ob2lzdHMucHVzaChleHApO1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9ob2lzdGVkXyR7Y29udGV4dC5ob2lzdHMubGVuZ3RofWAsIGZhbHNlLCBleHAubG9jLCAyIC8qIENvbnN0YW50VHlwZXMuQ0FOX0hPSVNUICovKTtcbiAgICAgICAgICAgIGlkZW50aWZpZXIuaG9pc3RlZCA9IGV4cDtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgICAgICB9LFxuICAgICAgICBjYWNoZShleHAsIGlzVk5vZGUgPSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhY2hlRXhwcmVzc2lvbihjb250ZXh0LmNhY2hlZCsrLCBleHAsIGlzVk5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB7XG4gICAgICAgIGNvbnRleHQuZmlsdGVycyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0ocm9vdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0KHJvb3QsIG9wdGlvbnMpO1xuICAgIHRyYXZlcnNlTm9kZShyb290LCBjb250ZXh0KTtcbiAgICBpZiAob3B0aW9ucy5ob2lzdFN0YXRpYykge1xuICAgICAgICBob2lzdFN0YXRpYyhyb290LCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnNzcikge1xuICAgICAgICBjcmVhdGVSb290Q29kZWdlbihyb290LCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gZmluYWxpemUgbWV0YSBpbmZvcm1hdGlvblxuICAgIHJvb3QuaGVscGVycyA9IG5ldyBTZXQoWy4uLmNvbnRleHQuaGVscGVycy5rZXlzKCldKTtcbiAgICByb290LmNvbXBvbmVudHMgPSBbLi4uY29udGV4dC5jb21wb25lbnRzXTtcbiAgICByb290LmRpcmVjdGl2ZXMgPSBbLi4uY29udGV4dC5kaXJlY3RpdmVzXTtcbiAgICByb290LmltcG9ydHMgPSBjb250ZXh0LmltcG9ydHM7XG4gICAgcm9vdC5ob2lzdHMgPSBjb250ZXh0LmhvaXN0cztcbiAgICByb290LnRlbXBzID0gY29udGV4dC50ZW1wcztcbiAgICByb290LmNhY2hlZCA9IGNvbnRleHQuY2FjaGVkO1xuICAgIHtcbiAgICAgICAgcm9vdC5maWx0ZXJzID0gWy4uLmNvbnRleHQuZmlsdGVyc107XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUm9vdENvZGVnZW4ocm9vdCwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgaGVscGVyIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHJvb3Q7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAvLyBpZiB0aGUgc2luZ2xlIGNoaWxkIGlzIGFuIGVsZW1lbnQsIHR1cm4gaXQgaW50byBhIGJsb2NrLlxuICAgICAgICBpZiAoaXNTaW5nbGVFbGVtZW50Um9vdChyb290LCBjaGlsZCkgJiYgY2hpbGQuY29kZWdlbk5vZGUpIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSBlbGVtZW50IHJvb3QgaXMgbmV2ZXIgaG9pc3RlZCBzbyBjb2RlZ2VuTm9kZSB3aWxsIG5ldmVyIGJlXG4gICAgICAgICAgICAvLyBTaW1wbGVFeHByZXNzaW9uTm9kZVxuICAgICAgICAgICAgY29uc3QgY29kZWdlbk5vZGUgPSBjaGlsZC5jb2RlZ2VuTm9kZTtcbiAgICAgICAgICAgIGlmIChjb2RlZ2VuTm9kZS50eXBlID09PSAxMyAvKiBOb2RlVHlwZXMuVk5PREVfQ0FMTCAqLykge1xuICAgICAgICAgICAgICAgIG1ha2VCbG9jayhjb2RlZ2VuTm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY29kZWdlbk5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyAtIHNpbmdsZSA8c2xvdC8+LCBJZk5vZGUsIEZvck5vZGU6IGFscmVhZHkgYmxvY2tzLlxuICAgICAgICAgICAgLy8gLSBzaW5nbGUgdGV4dCBub2RlOiBhbHdheXMgcGF0Y2hlZC5cbiAgICAgICAgICAgIC8vIHJvb3QgY29kZWdlbiBmYWxscyB0aHJvdWdoIHZpYSBnZW5Ob2RlKClcbiAgICAgICAgICAgIHJvb3QuY29kZWdlbk5vZGUgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHJvb3QgaGFzIG11bHRpcGxlIG5vZGVzIC0gcmV0dXJuIGEgZnJhZ21lbnQgYmxvY2suXG4gICAgICAgIGxldCBwYXRjaEZsYWcgPSA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqLztcbiAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL107XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBmcmFnbWVudCBhY3R1YWxseSBjb250YWlucyBhIHNpbmdsZSB2YWxpZCBjaGlsZCB3aXRoXG4gICAgICAgIC8vIHRoZSByZXN0IGJlaW5nIGNvbW1lbnRzXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovO1xuICAgICAgICAgICAgcGF0Y2hGbGFnVGV4dCArPSBgLCAke1BhdGNoRmxhZ05hbWVzWzIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqL119YDtcbiAgICAgICAgfVxuICAgICAgICByb290LmNvZGVnZW5Ob2RlID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIHVuZGVmaW5lZCwgcm9vdC5jaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGZhbHNlIC8qIGlzQ29tcG9uZW50ICovKTtcbiAgICB9XG4gICAgZWxzZSA7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUNoaWxkcmVuKHBhcmVudCwgY29udGV4dCkge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBub2RlUmVtb3ZlZCA9ICgpID0+IHtcbiAgICAgICAgaS0tO1xuICAgIH07XG4gICAgZm9yICg7IGkgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc1N0cmluZyhjaGlsZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29udGV4dC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGNvbnRleHQuY2hpbGRJbmRleCA9IGk7XG4gICAgICAgIGNvbnRleHQub25Ob2RlUmVtb3ZlZCA9IG5vZGVSZW1vdmVkO1xuICAgICAgICB0cmF2ZXJzZU5vZGUoY2hpbGQsIGNvbnRleHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlTm9kZShub2RlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgLy8gYXBwbHkgdHJhbnNmb3JtIHBsdWdpbnNcbiAgICBjb25zdCB7IG5vZGVUcmFuc2Zvcm1zIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGV4aXRGbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9uRXhpdCA9IG5vZGVUcmFuc2Zvcm1zW2ldKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBpZiAob25FeGl0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShvbkV4aXQpKSB7XG4gICAgICAgICAgICAgICAgZXhpdEZucy5wdXNoKC4uLm9uRXhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2gob25FeGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIHJlbW92ZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGhhdmUgYmVlbiByZXBsYWNlZFxuICAgICAgICAgICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovOlxuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnNzcikge1xuICAgICAgICAgICAgICAgIC8vIGluamVjdCBpbXBvcnQgZm9yIHRoZSBDb21tZW50IHN5bWJvbCwgd2hpY2ggaXMgbmVlZGVkIGZvciBjcmVhdGluZ1xuICAgICAgICAgICAgICAgIC8vIGNvbW1lbnQgbm9kZXMgd2l0aCBgY3JlYXRlVk5vZGVgXG4gICAgICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoQ1JFQVRFX0NPTU1FTlQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLzpcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdHJhdmVyc2UsIGJ1dCB3ZSBuZWVkIHRvIGluamVjdCB0b1N0cmluZyBoZWxwZXJcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmhlbHBlcihUT19ESVNQTEFZX1NUUklORyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZm9yIGNvbnRhaW5lciB0eXBlcywgZnVydGhlciB0cmF2ZXJzZSBkb3dud2FyZHNcbiAgICAgICAgY2FzZSA5IC8qIE5vZGVUeXBlcy5JRiAqLzpcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5icmFuY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlTm9kZShub2RlLmJyYW5jaGVzW2ldLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi86XG4gICAgICAgIGNhc2UgMTEgLyogTm9kZVR5cGVzLkZPUiAqLzpcbiAgICAgICAgY2FzZSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovOlxuICAgICAgICBjYXNlIDAgLyogTm9kZVR5cGVzLlJPT1QgKi86XG4gICAgICAgICAgICB0cmF2ZXJzZUNoaWxkcmVuKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIGV4aXQgdHJhbnNmb3Jtc1xuICAgIGNvbnRleHQuY3VycmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBpID0gZXhpdEZucy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBleGl0Rm5zW2ldKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybShuYW1lLCBmbikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBpc1N0cmluZyhuYW1lKVxuICAgICAgICA/IChuKSA9PiBuID09PSBuYW1lXG4gICAgICAgIDogKG4pID0+IG5hbWUudGVzdChuKTtcbiAgICByZXR1cm4gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gbm9kZTtcbiAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRyYW5zZm9ybXMgYXJlIG5vdCBjb25jZXJuZWQgd2l0aCBzbG90c1xuICAgICAgICAgICAgLy8gYXMgdGhleSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGluIHZTbG90LnRzXG4gICAgICAgICAgICBpZiAobm9kZS50YWdUeXBlID09PSAzIC8qIEVsZW1lbnRUeXBlcy5URU1QTEFURSAqLyAmJiBwcm9wcy5zb21lKGlzVlNsb3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhpdEZucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiYgbWF0Y2hlcyhwcm9wLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlcyBhcmUgcmVtb3ZlZCB0byBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3ZSByZW1vdmUgdGhlbSAqYmVmb3JlKiBhcHBseWluZyBzbyB0aGF0IGl0IGNhbiBmdXJ0aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYXZlcnNlIGl0c2VsZiBpbiBjYXNlIGl0IG1vdmVzIHRoZSBub2RlIGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FeGl0ID0gZm4obm9kZSwgcHJvcCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkV4aXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0Rm5zLnB1c2gob25FeGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhpdEZucztcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IFBVUkVfQU5OT1RBVElPTiA9IGAvKiNfX1BVUkVfXyovYDtcbmNvbnN0IGFsaWFzSGVscGVyID0gKHMpID0+IGAke2hlbHBlck5hbWVNYXBbc119OiBfJHtoZWxwZXJOYW1lTWFwW3NdfWA7XG5mdW5jdGlvbiBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIHsgbW9kZSA9ICdmdW5jdGlvbicsIHByZWZpeElkZW50aWZpZXJzID0gbW9kZSA9PT0gJ21vZHVsZScsIHNvdXJjZU1hcCA9IGZhbHNlLCBmaWxlbmFtZSA9IGB0ZW1wbGF0ZS52dWUuaHRtbGAsIHNjb3BlSWQgPSBudWxsLCBvcHRpbWl6ZUltcG9ydHMgPSBmYWxzZSwgcnVudGltZUdsb2JhbE5hbWUgPSBgVnVlYCwgcnVudGltZU1vZHVsZU5hbWUgPSBgdnVlYCwgc3NyUnVudGltZU1vZHVsZU5hbWUgPSAndnVlL3NlcnZlci1yZW5kZXJlcicsIHNzciA9IGZhbHNlLCBpc1RTID0gZmFsc2UsIGluU1NSID0gZmFsc2UgfSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG1vZGUsXG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzLFxuICAgICAgICBzb3VyY2VNYXAsXG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBzY29wZUlkLFxuICAgICAgICBvcHRpbWl6ZUltcG9ydHMsXG4gICAgICAgIHJ1bnRpbWVHbG9iYWxOYW1lLFxuICAgICAgICBydW50aW1lTW9kdWxlTmFtZSxcbiAgICAgICAgc3NyUnVudGltZU1vZHVsZU5hbWUsXG4gICAgICAgIHNzcixcbiAgICAgICAgaXNUUyxcbiAgICAgICAgaW5TU1IsXG4gICAgICAgIHNvdXJjZTogYXN0LmxvYy5zb3VyY2UsXG4gICAgICAgIGNvZGU6IGBgLFxuICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgIGxpbmU6IDEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgaW5kZW50TGV2ZWw6IDAsXG4gICAgICAgIHB1cmU6IGZhbHNlLFxuICAgICAgICBtYXA6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVscGVyKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGBfJHtoZWxwZXJOYW1lTWFwW2tleV19YDtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaChjb2RlLCBub2RlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmNvZGUgKz0gY29kZTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5kZW50KCkge1xuICAgICAgICAgICAgbmV3bGluZSgrK2NvbnRleHQuaW5kZW50TGV2ZWwpO1xuICAgICAgICB9LFxuICAgICAgICBkZWluZGVudCh3aXRob3V0TmV3TGluZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAod2l0aG91dE5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAtLWNvbnRleHQuaW5kZW50TGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdsaW5lKC0tY29udGV4dC5pbmRlbnRMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5ld2xpbmUoKSB7XG4gICAgICAgICAgICBuZXdsaW5lKGNvbnRleHQuaW5kZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXdsaW5lKG4pIHtcbiAgICAgICAgY29udGV4dC5wdXNoKCdcXG4nICsgYCAgYC5yZXBlYXQobikpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlKGFzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvZGVnZW5Db250ZXh0KGFzdCwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMub25Db250ZXh0Q3JlYXRlZClcbiAgICAgICAgb3B0aW9ucy5vbkNvbnRleHRDcmVhdGVkKGNvbnRleHQpO1xuICAgIGNvbnN0IHsgbW9kZSwgcHVzaCwgcHJlZml4SWRlbnRpZmllcnMsIGluZGVudCwgZGVpbmRlbnQsIG5ld2xpbmUsIHNjb3BlSWQsIHNzciB9ID0gY29udGV4dDtcbiAgICBjb25zdCBoZWxwZXJzID0gQXJyYXkuZnJvbShhc3QuaGVscGVycyk7XG4gICAgY29uc3QgaGFzSGVscGVycyA9IGhlbHBlcnMubGVuZ3RoID4gMDtcbiAgICBjb25zdCB1c2VXaXRoQmxvY2sgPSAhcHJlZml4SWRlbnRpZmllcnMgJiYgbW9kZSAhPT0gJ21vZHVsZSc7XG4gICAgY29uc3QgaXNTZXR1cElubGluZWQgPSAhdHJ1ZSA7XG4gICAgLy8gcHJlYW1ibGVzXG4gICAgLy8gaW4gc2V0dXAoKSBpbmxpbmUgbW9kZSwgdGhlIHByZWFtYmxlIGlzIGdlbmVyYXRlZCBpbiBhIHN1YiBjb250ZXh0XG4gICAgLy8gYW5kIHJldHVybmVkIHNlcGFyYXRlbHkuXG4gICAgY29uc3QgcHJlYW1ibGVDb250ZXh0ID0gaXNTZXR1cElubGluZWRcbiAgICAgICAgPyBjcmVhdGVDb2RlZ2VuQ29udGV4dChhc3QsIG9wdGlvbnMpXG4gICAgICAgIDogY29udGV4dDtcbiAgICB7XG4gICAgICAgIGdlbkZ1bmN0aW9uUHJlYW1ibGUoYXN0LCBwcmVhbWJsZUNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBlbnRlciByZW5kZXIgZnVuY3Rpb25cbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBzc3IgPyBgc3NyUmVuZGVyYCA6IGByZW5kZXJgO1xuICAgIGNvbnN0IGFyZ3MgPSBzc3IgPyBbJ19jdHgnLCAnX3B1c2gnLCAnX3BhcmVudCcsICdfYXR0cnMnXSA6IFsnX2N0eCcsICdfY2FjaGUnXTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhcmdzLmpvaW4oJywgJyk7XG4gICAge1xuICAgICAgICBwdXNoKGBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oJHtzaWduYXR1cmV9KSB7YCk7XG4gICAgfVxuICAgIGluZGVudCgpO1xuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcbiAgICAgICAgcHVzaChgd2l0aCAoX2N0eCkge2ApO1xuICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgLy8gZnVuY3Rpb24gbW9kZSBjb25zdCBkZWNsYXJhdGlvbnMgc2hvdWxkIGJlIGluc2lkZSB3aXRoIGJsb2NrXG4gICAgICAgIC8vIGFsc28gdGhleSBzaG91bGQgYmUgcmVuYW1lZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCB1c2VyIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKGhhc0hlbHBlcnMpIHtcbiAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHtoZWxwZXJzLm1hcChhbGlhc0hlbHBlcikuam9pbignLCAnKX0gfSA9IF9WdWVgKTtcbiAgICAgICAgICAgIHB1c2goYFxcbmApO1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGdlbmVyYXRlIGFzc2V0IHJlc29sdXRpb24gc3RhdGVtZW50c1xuICAgIGlmIChhc3QuY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5jb21wb25lbnRzLCAnY29tcG9uZW50JywgY29udGV4dCk7XG4gICAgICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGggfHwgYXN0LnRlbXBzID4gMCkge1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhc3QuZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgZ2VuQXNzZXRzKGFzdC5kaXJlY3RpdmVzLCAnZGlyZWN0aXZlJywgY29udGV4dCk7XG4gICAgICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XG4gICAgICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFzdC5maWx0ZXJzICYmIGFzdC5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgICAgIGdlbkFzc2V0cyhhc3QuZmlsdGVycywgJ2ZpbHRlcicsIGNvbnRleHQpO1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgfVxuICAgIGlmIChhc3QudGVtcHMgPiAwKSB7XG4gICAgICAgIHB1c2goYGxldCBgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudGVtcHM7IGkrKykge1xuICAgICAgICAgICAgcHVzaChgJHtpID4gMCA/IGAsIGAgOiBgYH1fdGVtcCR7aX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXN0LmNvbXBvbmVudHMubGVuZ3RoIHx8IGFzdC5kaXJlY3RpdmVzLmxlbmd0aCB8fCBhc3QudGVtcHMpIHtcbiAgICAgICAgcHVzaChgXFxuYCk7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICB9XG4gICAgLy8gZ2VuZXJhdGUgdGhlIFZOb2RlIHRyZWUgZXhwcmVzc2lvblxuICAgIGlmICghc3NyKSB7XG4gICAgICAgIHB1c2goYHJldHVybiBgKTtcbiAgICB9XG4gICAgaWYgKGFzdC5jb2RlZ2VuTm9kZSkge1xuICAgICAgICBnZW5Ob2RlKGFzdC5jb2RlZ2VuTm9kZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdXNoKGBudWxsYCk7XG4gICAgfVxuICAgIGlmICh1c2VXaXRoQmxvY2spIHtcbiAgICAgICAgZGVpbmRlbnQoKTtcbiAgICAgICAgcHVzaChgfWApO1xuICAgIH1cbiAgICBkZWluZGVudCgpO1xuICAgIHB1c2goYH1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3QsXG4gICAgICAgIGNvZGU6IGNvbnRleHQuY29kZSxcbiAgICAgICAgcHJlYW1ibGU6IGlzU2V0dXBJbmxpbmVkID8gcHJlYW1ibGVDb250ZXh0LmNvZGUgOiBgYCxcbiAgICAgICAgLy8gU291cmNlTWFwR2VuZXJhdG9yIGRvZXMgaGF2ZSB0b0pTT04oKSBtZXRob2QgYnV0IGl0J3Mgbm90IGluIHRoZSB0eXBlc1xuICAgICAgICBtYXA6IGNvbnRleHQubWFwID8gY29udGV4dC5tYXAudG9KU09OKCkgOiB1bmRlZmluZWRcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25QcmVhbWJsZShhc3QsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHNzciwgcHJlZml4SWRlbnRpZmllcnMsIHB1c2gsIG5ld2xpbmUsIHJ1bnRpbWVNb2R1bGVOYW1lLCBydW50aW1lR2xvYmFsTmFtZSwgc3NyUnVudGltZU1vZHVsZU5hbWUgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgVnVlQmluZGluZyA9IHJ1bnRpbWVHbG9iYWxOYW1lO1xuICAgIC8vIEdlbmVyYXRlIGNvbnN0IGRlY2xhcmF0aW9uIGZvciBoZWxwZXJzXG4gICAgLy8gSW4gcHJlZml4IG1vZGUsIHdlIHBsYWNlIHRoZSBjb25zdCBkZWNsYXJhdGlvbiBhdCB0b3Agc28gaXQncyBkb25lXG4gICAgLy8gb25seSBvbmNlOyBCdXQgaWYgd2Ugbm90IHByZWZpeGluZywgd2UgcGxhY2UgdGhlIGRlY2xhcmF0aW9uIGluc2lkZSB0aGVcbiAgICAvLyB3aXRoIGJsb2NrIHNvIGl0IGRvZXNuJ3QgaW5jdXIgdGhlIGBpbmAgY2hlY2sgY29zdCBmb3IgZXZlcnkgaGVscGVyIGFjY2Vzcy5cbiAgICBjb25zdCBoZWxwZXJzID0gQXJyYXkuZnJvbShhc3QuaGVscGVycyk7XG4gICAgaWYgKGhlbHBlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBcIndpdGhcIiBtb2RlLlxuICAgICAgICAgICAgLy8gc2F2ZSBWdWUgaW4gYSBzZXBhcmF0ZSB2YXJpYWJsZSB0byBhdm9pZCBjb2xsaXNpb25cbiAgICAgICAgICAgIHB1c2goYGNvbnN0IF9WdWUgPSAke1Z1ZUJpbmRpbmd9XFxuYCk7XG4gICAgICAgICAgICAvLyBpbiBcIndpdGhcIiBtb2RlLCBoZWxwZXJzIGFyZSBkZWNsYXJlZCBpbnNpZGUgdGhlIHdpdGggYmxvY2sgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGhhcyBjaGVjayBjb3N0LCBidXQgaG9pc3RzIGFyZSBsaWZ0ZWQgb3V0IG9mIHRoZSBmdW5jdGlvbiAtIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHByb3ZpZGUgdGhlIGhlbHBlciBoZXJlLlxuICAgICAgICAgICAgaWYgKGFzdC5ob2lzdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljSGVscGVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX1ZOT0RFLFxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfRUxFTUVOVF9WTk9ERSxcbiAgICAgICAgICAgICAgICAgICAgQ1JFQVRFX0NPTU1FTlQsXG4gICAgICAgICAgICAgICAgICAgIENSRUFURV9URVhULFxuICAgICAgICAgICAgICAgICAgICBDUkVBVEVfU1RBVElDXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGhlbHBlciA9PiBoZWxwZXJzLmluY2x1ZGVzKGhlbHBlcikpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoYWxpYXNIZWxwZXIpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIHB1c2goYGNvbnN0IHsgJHtzdGF0aWNIZWxwZXJzfSB9ID0gX1Z1ZVxcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdlbkhvaXN0cyhhc3QuaG9pc3RzLCBjb250ZXh0KTtcbiAgICBuZXdsaW5lKCk7XG4gICAgcHVzaChgcmV0dXJuIGApO1xufVxuZnVuY3Rpb24gZ2VuQXNzZXRzKGFzc2V0cywgdHlwZSwgeyBoZWxwZXIsIHB1c2gsIG5ld2xpbmUsIGlzVFMgfSkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gaGVscGVyKHR5cGUgPT09ICdmaWx0ZXInXG4gICAgICAgID8gUkVTT0xWRV9GSUxURVJcbiAgICAgICAgOiB0eXBlID09PSAnY29tcG9uZW50J1xuICAgICAgICAgICAgPyBSRVNPTFZFX0NPTVBPTkVOVFxuICAgICAgICAgICAgOiBSRVNPTFZFX0RJUkVDVElWRSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlkID0gYXNzZXRzW2ldO1xuICAgICAgICAvLyBwb3RlbnRpYWwgY29tcG9uZW50IGltcGxpY2l0IHNlbGYtcmVmZXJlbmNlIGluZmVycmVkIGZyb20gU0ZDIGZpbGVuYW1lXG4gICAgICAgIGNvbnN0IG1heWJlU2VsZlJlZmVyZW5jZSA9IGlkLmVuZHNXaXRoKCdfX3NlbGYnKTtcbiAgICAgICAgaWYgKG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgICAgICAgICAgaWQgPSBpZC5zbGljZSgwLCAtNik7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChgY29uc3QgJHt0b1ZhbGlkQXNzZXRJZChpZCwgdHlwZSl9ID0gJHtyZXNvbHZlcn0oJHtKU09OLnN0cmluZ2lmeShpZCl9JHttYXliZVNlbGZSZWZlcmVuY2UgPyBgLCB0cnVlYCA6IGBgfSkke2lzVFMgPyBgIWAgOiBgYH1gKTtcbiAgICAgICAgaWYgKGkgPCBhc3NldHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuSG9pc3RzKGhvaXN0cywgY29udGV4dCkge1xuICAgIGlmICghaG9pc3RzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQucHVyZSA9IHRydWU7XG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lLCBoZWxwZXIsIHNjb3BlSWQsIG1vZGUgfSA9IGNvbnRleHQ7XG4gICAgbmV3bGluZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9pc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGhvaXN0c1tpXTtcbiAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgcHVzaChgY29uc3QgX2hvaXN0ZWRfJHtpICsgMX0gPSAke2BgfWApO1xuICAgICAgICAgICAgZ2VuTm9kZShleHAsIGNvbnRleHQpO1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQucHVyZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNUZXh0KG4pIHtcbiAgICByZXR1cm4gKGlzU3RyaW5nKG4pIHx8XG4gICAgICAgIG4udHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcbiAgICAgICAgbi50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovIHx8XG4gICAgICAgIG4udHlwZSA9PT0gNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLyB8fFxuICAgICAgICBuLnR5cGUgPT09IDggLyogTm9kZVR5cGVzLkNPTVBPVU5EX0VYUFJFU1NJT04gKi8pO1xufVxuZnVuY3Rpb24gZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGVzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IG5vZGVzLmxlbmd0aCA+IDMgfHxcbiAgICAgICAgKCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpICYmIG5vZGVzLnNvbWUobiA9PiBpc0FycmF5KG4pIHx8ICFpc1RleHQobikpKTtcbiAgICBjb250ZXh0LnB1c2goYFtgKTtcbiAgICBtdWx0aWxpbmVzICYmIGNvbnRleHQuaW5kZW50KCk7XG4gICAgZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMpO1xuICAgIG11bHRpbGluZXMgJiYgY29udGV4dC5kZWluZGVudCgpO1xuICAgIGNvbnRleHQucHVzaChgXWApO1xufVxuZnVuY3Rpb24gZ2VuTm9kZUxpc3Qobm9kZXMsIGNvbnRleHQsIG11bHRpbGluZXMgPSBmYWxzZSwgY29tbWEgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBwdXNoLCBuZXdsaW5lIH0gPSBjb250ZXh0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIHB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuTm9kZShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IG5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmVzKSB7XG4gICAgICAgICAgICAgICAgY29tbWEgJiYgcHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1hICYmIHB1c2goJywgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgICBpZiAoaXNTdHJpbmcobm9kZSkpIHtcbiAgICAgICAgY29udGV4dC5wdXNoKG5vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChub2RlKSkge1xuICAgICAgICBjb250ZXh0LnB1c2goY29udGV4dC5oZWxwZXIobm9kZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLzpcbiAgICAgICAgY2FzZSA5IC8qIE5vZGVUeXBlcy5JRiAqLzpcbiAgICAgICAgY2FzZSAxMSAvKiBOb2RlVHlwZXMuRk9SICovOlxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgYXNzZXJ0KG5vZGUuY29kZWdlbk5vZGUgIT0gbnVsbCwgYENvZGVnZW4gbm9kZSBpcyBtaXNzaW5nIGZvciBlbGVtZW50L2lmL2ZvciBub2RlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYEFwcGx5IGFwcHJvcHJpYXRlIHRyYW5zZm9ybXMgZmlyc3QuYCk7XG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBOb2RlVHlwZXMuVEVYVCAqLzpcbiAgICAgICAgICAgIGdlblRleHQobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1IC8qIE5vZGVUeXBlcy5JTlRFUlBPTEFUSU9OICovOlxuICAgICAgICAgICAgZ2VuSW50ZXJwb2xhdGlvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyIC8qIE5vZGVUeXBlcy5URVhUX0NBTEwgKi86XG4gICAgICAgICAgICBnZW5Ob2RlKG5vZGUuY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogTm9kZVR5cGVzLkNPTU1FTlQgKi86XG4gICAgICAgICAgICBnZW5Db21tZW50KG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTMgLyogTm9kZVR5cGVzLlZOT0RFX0NBTEwgKi86XG4gICAgICAgICAgICBnZW5WTm9kZUNhbGwobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNCAvKiBOb2RlVHlwZXMuSlNfQ0FMTF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNSAvKiBOb2RlVHlwZXMuSlNfT0JKRUNUX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5PYmplY3RFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTcgLyogTm9kZVR5cGVzLkpTX0FSUkFZX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5BcnJheUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOCAvKiBOb2RlVHlwZXMuSlNfRlVOQ1RJT05fRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgIGdlbkZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgZ2VuQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjAgLyogTm9kZVR5cGVzLkpTX0NBQ0hFX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMSAvKiBOb2RlVHlwZXMuSlNfQkxPQ0tfU1RBVEVNRU5UICovOlxuICAgICAgICAgICAgZ2VuTm9kZUxpc3Qobm9kZS5ib2R5LCBjb250ZXh0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU1NSIG9ubHkgdHlwZXNcbiAgICAgICAgY2FzZSAyMiAvKiBOb2RlVHlwZXMuSlNfVEVNUExBVEVfTElURVJBTCAqLzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIzIC8qIE5vZGVUeXBlcy5KU19JRl9TVEFURU1FTlQgKi86XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNCAvKiBOb2RlVHlwZXMuSlNfQVNTSUdOTUVOVF9FWFBSRVNTSU9OICovOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjUgLyogTm9kZVR5cGVzLkpTX1NFUVVFTkNFX0VYUFJFU1NJT04gKi86XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNiAvKiBOb2RlVHlwZXMuSlNfUkVUVVJOX1NUQVRFTUVOVCAqLzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBjYXNlIDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi86XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGB1bmhhbmRsZWQgY29kZWdlbiBub2RlIHR5cGU6ICR7bm9kZS50eXBlfWApO1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBleGhhdXN0IGFsbCBwb3NzaWJsZSB0eXBlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aGF1c3RpdmVDaGVjaztcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZW5UZXh0KG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnB1c2goSlNPTi5zdHJpbmdpZnkobm9kZS5jb250ZW50KSwgbm9kZSk7XG59XG5mdW5jdGlvbiBnZW5FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGNvbnRlbnQsIGlzU3RhdGljIH0gPSBub2RlO1xuICAgIGNvbnRleHQucHVzaChpc1N0YXRpYyA/IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpIDogY29udGVudCwgbm9kZSk7XG59XG5mdW5jdGlvbiBnZW5JbnRlcnBvbGF0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcbiAgICBpZiAocHVyZSlcbiAgICAgICAgcHVzaChQVVJFX0FOTk9UQVRJT04pO1xuICAgIHB1c2goYCR7aGVscGVyKFRPX0RJU1BMQVlfU1RSSU5HKX0oYCk7XG4gICAgZ2VuTm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgIHB1c2goYClgKTtcbn1cbmZ1bmN0aW9uIGdlbkNvbXBvdW5kRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICAgICAgY29udGV4dC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbk5vZGUoY2hpbGQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuRXhwcmVzc2lvbkFzUHJvcGVydHlLZXkobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCB9ID0gY29udGV4dDtcbiAgICBpZiAobm9kZS50eXBlID09PSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgIHB1c2goYFtgKTtcbiAgICAgICAgZ2VuQ29tcG91bmRFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBwdXNoKGBdYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUuaXNTdGF0aWMpIHtcbiAgICAgICAgLy8gb25seSBxdW90ZSBrZXlzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBjb25zdCB0ZXh0ID0gaXNTaW1wbGVJZGVudGlmaWVyKG5vZGUuY29udGVudClcbiAgICAgICAgICAgID8gbm9kZS5jb250ZW50XG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCk7XG4gICAgICAgIHB1c2godGV4dCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdXNoKGBbJHtub2RlLmNvbnRlbnR9XWAsIG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbkNvbW1lbnQobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xuICAgIGlmIChwdXJlKSB7XG4gICAgICAgIHB1c2goUFVSRV9BTk5PVEFUSU9OKTtcbiAgICB9XG4gICAgcHVzaChgJHtoZWxwZXIoQ1JFQVRFX0NPTU1FTlQpfSgke0pTT04uc3RyaW5naWZ5KG5vZGUuY29udGVudCl9KWAsIG5vZGUpO1xufVxuZnVuY3Rpb24gZ2VuVk5vZGVDYWxsKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHB1c2gsIGhlbHBlciwgcHVyZSB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IHRhZywgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgZGlyZWN0aXZlcywgaXNCbG9jaywgZGlzYWJsZVRyYWNraW5nLCBpc0NvbXBvbmVudCB9ID0gbm9kZTtcbiAgICBpZiAoZGlyZWN0aXZlcykge1xuICAgICAgICBwdXNoKGhlbHBlcihXSVRIX0RJUkVDVElWRVMpICsgYChgKTtcbiAgICB9XG4gICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgcHVzaChgKCR7aGVscGVyKE9QRU5fQkxPQ0spfSgke2Rpc2FibGVUcmFja2luZyA/IGB0cnVlYCA6IGBgfSksIGApO1xuICAgIH1cbiAgICBpZiAocHVyZSkge1xuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XG4gICAgfVxuICAgIGNvbnN0IGNhbGxIZWxwZXIgPSBpc0Jsb2NrXG4gICAgICAgID8gZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudClcbiAgICAgICAgOiBnZXRWTm9kZUhlbHBlcihjb250ZXh0LmluU1NSLCBpc0NvbXBvbmVudCk7XG4gICAgcHVzaChoZWxwZXIoY2FsbEhlbHBlcikgKyBgKGAsIG5vZGUpO1xuICAgIGdlbk5vZGVMaXN0KGdlbk51bGxhYmxlQXJncyhbdGFnLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzXSksIGNvbnRleHQpO1xuICAgIHB1c2goYClgKTtcbiAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICBwdXNoKGApYCk7XG4gICAgfVxuICAgIGlmIChkaXJlY3RpdmVzKSB7XG4gICAgICAgIHB1c2goYCwgYCk7XG4gICAgICAgIGdlbk5vZGUoZGlyZWN0aXZlcywgY29udGV4dCk7XG4gICAgICAgIHB1c2goYClgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5OdWxsYWJsZUFyZ3MoYXJncykge1xuICAgIGxldCBpID0gYXJncy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYXJnc1tpXSAhPSBudWxsKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcmdzLnNsaWNlKDAsIGkgKyAxKS5tYXAoYXJnID0+IGFyZyB8fCBgbnVsbGApO1xufVxuLy8gSmF2YVNjcmlwdFxuZnVuY3Rpb24gZ2VuQ2FsbEV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBwdXJlIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGNhbGxlZSA9IGlzU3RyaW5nKG5vZGUuY2FsbGVlKSA/IG5vZGUuY2FsbGVlIDogaGVscGVyKG5vZGUuY2FsbGVlKTtcbiAgICBpZiAocHVyZSkge1xuICAgICAgICBwdXNoKFBVUkVfQU5OT1RBVElPTik7XG4gICAgfVxuICAgIHB1c2goY2FsbGVlICsgYChgLCBub2RlKTtcbiAgICBnZW5Ob2RlTGlzdChub2RlLmFyZ3VtZW50cywgY29udGV4dCk7XG4gICAgcHVzaChgKWApO1xufVxuZnVuY3Rpb24gZ2VuT2JqZWN0RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBwdXNoLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHsgcHJvcGVydGllcyB9ID0gbm9kZTtcbiAgICBpZiAoIXByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHB1c2goYHt9YCwgbm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbXVsdGlsaW5lcyA9IHByb3BlcnRpZXMubGVuZ3RoID4gMSB8fFxuICAgICAgICAoKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkgJiZcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc29tZShwID0+IHAudmFsdWUudHlwZSAhPT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pKTtcbiAgICBwdXNoKG11bHRpbGluZXMgPyBge2AgOiBgeyBgKTtcbiAgICBtdWx0aWxpbmVzICYmIGluZGVudCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIC8vIGtleVxuICAgICAgICBnZW5FeHByZXNzaW9uQXNQcm9wZXJ0eUtleShrZXksIGNvbnRleHQpO1xuICAgICAgICBwdXNoKGA6IGApO1xuICAgICAgICAvLyB2YWx1ZVxuICAgICAgICBnZW5Ob2RlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGkgPCBwcm9wZXJ0aWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIHdpbGwgb25seSByZWFjaCB0aGlzIGlmIGl0J3MgbXVsdGlsaW5lc1xuICAgICAgICAgICAgcHVzaChgLGApO1xuICAgICAgICAgICAgbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG11bHRpbGluZXMgJiYgZGVpbmRlbnQoKTtcbiAgICBwdXNoKG11bHRpbGluZXMgPyBgfWAgOiBgIH1gKTtcbn1cbmZ1bmN0aW9uIGdlbkFycmF5RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgZ2VuTm9kZUxpc3RBc0FycmF5KG5vZGUuZWxlbWVudHMsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2VuRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IHB1c2gsIGluZGVudCwgZGVpbmRlbnQgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgeyBwYXJhbXMsIHJldHVybnMsIGJvZHksIG5ld2xpbmUsIGlzU2xvdCB9ID0gbm9kZTtcbiAgICBpZiAoaXNTbG90KSB7XG4gICAgICAgIC8vIHdyYXAgc2xvdCBmdW5jdGlvbnMgd2l0aCBvd25lciBjb250ZXh0XG4gICAgICAgIHB1c2goYF8ke2hlbHBlck5hbWVNYXBbV0lUSF9DVFhdfShgKTtcbiAgICB9XG4gICAgcHVzaChgKGAsIG5vZGUpO1xuICAgIGlmIChpc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgZ2VuTm9kZUxpc3QocGFyYW1zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICAgIGdlbk5vZGUocGFyYW1zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcHVzaChgKSA9PiBgKTtcbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XG4gICAgICAgIHB1c2goYHtgKTtcbiAgICAgICAgaW5kZW50KCk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5zKSB7XG4gICAgICAgIGlmIChuZXdsaW5lKSB7XG4gICAgICAgICAgICBwdXNoKGByZXR1cm4gYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkocmV0dXJucykpIHtcbiAgICAgICAgICAgIGdlbk5vZGVMaXN0QXNBcnJheShyZXR1cm5zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbk5vZGUocmV0dXJucywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYm9keSkge1xuICAgICAgICBnZW5Ob2RlKGJvZHksIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAobmV3bGluZSB8fCBib2R5KSB7XG4gICAgICAgIGRlaW5kZW50KCk7XG4gICAgICAgIHB1c2goYH1gKTtcbiAgICB9XG4gICAgaWYgKGlzU2xvdCkge1xuICAgICAgICBpZiAobm9kZS5pc05vblNjb3BlZFNsb3QpIHtcbiAgICAgICAgICAgIHB1c2goYCwgdW5kZWZpbmVkLCB0cnVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaChgKWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbkNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyB0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIG5ld2xpbmU6IG5lZWROZXdsaW5lIH0gPSBub2RlO1xuICAgIGNvbnN0IHsgcHVzaCwgaW5kZW50LCBkZWluZGVudCwgbmV3bGluZSB9ID0gY29udGV4dDtcbiAgICBpZiAodGVzdC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBjb25zdCBuZWVkc1BhcmVucyA9ICFpc1NpbXBsZUlkZW50aWZpZXIodGVzdC5jb250ZW50KTtcbiAgICAgICAgbmVlZHNQYXJlbnMgJiYgcHVzaChgKGApO1xuICAgICAgICBnZW5FeHByZXNzaW9uKHRlc3QsIGNvbnRleHQpO1xuICAgICAgICBuZWVkc1BhcmVucyAmJiBwdXNoKGApYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdXNoKGAoYCk7XG4gICAgICAgIGdlbk5vZGUodGVzdCwgY29udGV4dCk7XG4gICAgICAgIHB1c2goYClgKTtcbiAgICB9XG4gICAgbmVlZE5ld2xpbmUgJiYgaW5kZW50KCk7XG4gICAgY29udGV4dC5pbmRlbnRMZXZlbCsrO1xuICAgIG5lZWROZXdsaW5lIHx8IHB1c2goYCBgKTtcbiAgICBwdXNoKGA/IGApO1xuICAgIGdlbk5vZGUoY29uc2VxdWVudCwgY29udGV4dCk7XG4gICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xuICAgIG5lZWROZXdsaW5lICYmIG5ld2xpbmUoKTtcbiAgICBuZWVkTmV3bGluZSB8fCBwdXNoKGAgYCk7XG4gICAgcHVzaChgOiBgKTtcbiAgICBjb25zdCBpc05lc3RlZCA9IGFsdGVybmF0ZS50eXBlID09PSAxOSAvKiBOb2RlVHlwZXMuSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLztcbiAgICBpZiAoIWlzTmVzdGVkKSB7XG4gICAgICAgIGNvbnRleHQuaW5kZW50TGV2ZWwrKztcbiAgICB9XG4gICAgZ2VuTm9kZShhbHRlcm5hdGUsIGNvbnRleHQpO1xuICAgIGlmICghaXNOZXN0ZWQpIHtcbiAgICAgICAgY29udGV4dC5pbmRlbnRMZXZlbC0tO1xuICAgIH1cbiAgICBuZWVkTmV3bGluZSAmJiBkZWluZGVudCh0cnVlIC8qIHdpdGhvdXQgbmV3bGluZSAqLyk7XG59XG5mdW5jdGlvbiBnZW5DYWNoZUV4cHJlc3Npb24obm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcHVzaCwgaGVscGVyLCBpbmRlbnQsIGRlaW5kZW50LCBuZXdsaW5lIH0gPSBjb250ZXh0O1xuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSB8fCAoYCk7XG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xuICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oLTEpLGApO1xuICAgICAgICBuZXdsaW5lKCk7XG4gICAgfVxuICAgIHB1c2goYF9jYWNoZVske25vZGUuaW5kZXh9XSA9IGApO1xuICAgIGdlbk5vZGUobm9kZS52YWx1ZSwgY29udGV4dCk7XG4gICAgaWYgKG5vZGUuaXNWTm9kZSkge1xuICAgICAgICBwdXNoKGAsYCk7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgcHVzaChgJHtoZWxwZXIoU0VUX0JMT0NLX1RSQUNLSU5HKX0oMSksYCk7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgcHVzaChgX2NhY2hlWyR7bm9kZS5pbmRleH1dYCk7XG4gICAgICAgIGRlaW5kZW50KCk7XG4gICAgfVxuICAgIHB1c2goYClgKTtcbn1cblxuZnVuY3Rpb24gd2Fsa0lkZW50aWZpZXJzKHJvb3QsIG9uSWRlbnRpZmllciwgaW5jbHVkZUFsbCA9IGZhbHNlLCBwYXJlbnRTdGFjayA9IFtdLCBrbm93bklkcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1JlZmVyZW5jZWRJZGVudGlmaWVyKGlkLCBwYXJlbnQsIHBhcmVudFN0YWNrKSB7XG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJbkRlc3RydWN0dXJlQXNzaWdubWVudChwYXJlbnQsIHBhcmVudFN0YWNrKSB7XG4gICAgaWYgKHBhcmVudCAmJlxuICAgICAgICAocGFyZW50LnR5cGUgPT09ICdPYmplY3RQcm9wZXJ0eScgfHwgcGFyZW50LnR5cGUgPT09ICdBcnJheVBhdHRlcm4nKSkge1xuICAgICAgICBsZXQgaSA9IHBhcmVudFN0YWNrLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHBhcmVudFN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocC50eXBlICE9PSAnT2JqZWN0UHJvcGVydHknICYmICFwLnR5cGUuZW5kc1dpdGgoJ1BhdHRlcm4nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHdhbGtGdW5jdGlvblBhcmFtcyhub2RlLCBvbklkZW50KSB7XG4gICAgZm9yIChjb25zdCBwIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZXh0cmFjdElkZW50aWZpZXJzKHApKSB7XG4gICAgICAgICAgICBvbklkZW50KGlkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHdhbGtCbG9ja0RlY2xhcmF0aW9ucyhibG9jaywgb25JZGVudCkge1xuICAgIGZvciAoY29uc3Qgc3RtdCBvZiBibG9jay5ib2R5KSB7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbCBvZiBzdG10LmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgZXh0cmFjdElkZW50aWZpZXJzKGRlY2wuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uSWRlbnQoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdG10LnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyB8fFxuICAgICAgICAgICAgc3RtdC50eXBlID09PSAnQ2xhc3NEZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmRlY2xhcmUgfHwgIXN0bXQuaWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBvbklkZW50KHN0bXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLCBub2RlcyA9IFtdKSB7XG4gICAgc3dpdGNoIChwYXJhbS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgICAgbm9kZXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTWVtYmVyRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBsZXQgb2JqZWN0ID0gcGFyYW07XG4gICAgICAgICAgICB3aGlsZSAob2JqZWN0LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5vYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnT2JqZWN0UGF0dGVybic6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcGFyYW0ucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLnR5cGUgPT09ICdSZXN0RWxlbWVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3AuYXJndW1lbnQsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RJZGVudGlmaWVycyhwcm9wLnZhbHVlLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FycmF5UGF0dGVybic6XG4gICAgICAgICAgICBwYXJhbS5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0SWRlbnRpZmllcnMoZWxlbWVudCwgbm9kZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUmVzdEVsZW1lbnQnOlxuICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmFyZ3VtZW50LCBub2Rlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXNzaWdubWVudFBhdHRlcm4nOlxuICAgICAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHBhcmFtLmxlZnQsIG5vZGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5jb25zdCBpc0Z1bmN0aW9uVHlwZSA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIC9GdW5jdGlvbig/OkV4cHJlc3Npb258RGVjbGFyYXRpb24pJHxNZXRob2QkLy50ZXN0KG5vZGUudHlwZSk7XG59O1xuY29uc3QgaXNTdGF0aWNQcm9wZXJ0eSA9IChub2RlKSA9PiBub2RlICYmXG4gICAgKG5vZGUudHlwZSA9PT0gJ09iamVjdFByb3BlcnR5JyB8fCBub2RlLnR5cGUgPT09ICdPYmplY3RNZXRob2QnKSAmJlxuICAgICFub2RlLmNvbXB1dGVkO1xuY29uc3QgaXNTdGF0aWNQcm9wZXJ0eUtleSA9IChub2RlLCBwYXJlbnQpID0+IGlzU3RhdGljUHJvcGVydHkocGFyZW50KSAmJiBwYXJlbnQua2V5ID09PSBub2RlO1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gJ3R5cGVvZicsICdpbnN0YW5jZW9mJywgYW5kICdpbicgYXJlIGFsbG93ZWRcbmNvbnN0IHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgK1xuICAgICgnYXJndW1lbnRzLGF3YWl0LGJyZWFrLGNhc2UsY2F0Y2gsY2xhc3MsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICtcbiAgICAgICAgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLGltcG9ydCxsZXQsbmV3LCcgK1xuICAgICAgICAncmV0dXJuLHN1cGVyLHN3aXRjaCx0aHJvdyx0cnksdmFyLHZvaWQsd2hpbGUsd2l0aCx5aWVsZCcpXG4gICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgIC5qb2luKCdcXFxcYnxcXFxcYicpICtcbiAgICAnXFxcXGInKTtcbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbmNvbnN0IHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcbi8qKlxuICogVmFsaWRhdGUgYSBub24tcHJlZml4ZWQgZXhwcmVzc2lvbi5cbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgd2hlbiB1c2luZyB0aGUgaW4tYnJvd3NlciBydW50aW1lIGNvbXBpbGVyIHNpbmNlIGl0XG4gKiBkb2Vzbid0IHByZWZpeCBleHByZXNzaW9ucy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcyA9IGZhbHNlLCBhc1Jhd1N0YXRlbWVudHMgPSBmYWxzZSkge1xuICAgIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcbiAgICAvLyBlbXB0eSBleHByZXNzaW9ucyBhcmUgdmFsaWRhdGVkIHBlci1kaXJlY3RpdmUgc2luY2Ugc29tZSBkaXJlY3RpdmVzXG4gICAgLy8gZG8gYWxsb3cgZW1wdHkgZXhwcmVzc2lvbnMuXG4gICAgaWYgKCFleHAudHJpbSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKGFzUmF3U3RhdGVtZW50c1xuICAgICAgICAgICAgPyBgICR7ZXhwfSBgXG4gICAgICAgICAgICA6IGByZXR1cm4gJHthc1BhcmFtcyA/IGAoJHtleHB9KSA9PiB7fWAgOiBgKCR7ZXhwfSlgfWApO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgICAgY29uc3Qga2V5d29yZE1hdGNoID0gZXhwXG4gICAgICAgICAgICAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJylcbiAgICAgICAgICAgIC5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICAgICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIke2tleXdvcmRNYXRjaFswXX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDUgLyogRXJyb3JDb2Rlcy5YX0lOVkFMSURfRVhQUkVTU0lPTiAqLywgbm9kZS5sb2MsIHVuZGVmaW5lZCwgbWVzc2FnZSkpO1xuICAgIH1cbn1cblxuY29uc3QgdHJhbnNmb3JtRXhwcmVzc2lvbiA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gNSAvKiBOb2RlVHlwZXMuSU5URVJQT0xBVElPTiAqLykge1xuICAgICAgICBub2RlLmNvbnRlbnQgPSBwcm9jZXNzRXhwcmVzc2lvbihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgLy8gaGFuZGxlIGRpcmVjdGl2ZXMgb24gZWxlbWVudFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IG5vZGUucHJvcHNbaV07XG4gICAgICAgICAgICAvLyBkbyBub3QgcHJvY2VzcyBmb3Igdi1vbiAmIHYtZm9yIHNpbmNlIHRoZXkgYXJlIHNwZWNpYWwgaGFuZGxlZFxuICAgICAgICAgICAgaWYgKGRpci50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiYgZGlyLm5hbWUgIT09ICdmb3InKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwID0gZGlyLmV4cDtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBkaXIuYXJnO1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwcm9jZXNzIGV4cCBpZiB0aGlzIGlzIHYtb246YXJnIC0gd2UgbmVlZCBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgLy8gZm9yIHdyYXBwaW5nIGlubGluZSBzdGF0ZW1lbnRzLlxuICAgICAgICAgICAgICAgIGlmIChleHAgJiZcbiAgICAgICAgICAgICAgICAgICAgZXhwLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovICYmXG4gICAgICAgICAgICAgICAgICAgICEoZGlyLm5hbWUgPT09ICdvbicgJiYgYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwID0gcHJvY2Vzc0V4cHJlc3Npb24oZXhwLCBjb250ZXh0LCBcbiAgICAgICAgICAgICAgICAgICAgLy8gc2xvdCBhcmdzIG11c3QgYmUgcHJvY2Vzc2VkIGFzIGZ1bmN0aW9uIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICBkaXIubmFtZSA9PT0gJ3Nsb3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFyZyAmJiBhcmcudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiYgIWFyZy5pc1N0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICBkaXIuYXJnID0gcHJvY2Vzc0V4cHJlc3Npb24oYXJnLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8gSW1wb3J0YW50OiBzaW5jZSB0aGlzIGZ1bmN0aW9uIHVzZXMgTm9kZS5qcyBvbmx5IGRlcGVuZGVuY2llcywgaXQgc2hvdWxkXG4vLyBhbHdheXMgYmUgdXNlZCB3aXRoIGEgbGVhZGluZyAhdHJ1ZSBjaGVjayBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gdHJlZS1zaGFrZW4gZnJvbSB0aGUgYnJvd3NlciBidWlsZC5cbmZ1bmN0aW9uIHByb2Nlc3NFeHByZXNzaW9uKG5vZGUsIGNvbnRleHQsIFxuLy8gc29tZSBleHByZXNzaW9ucyBsaWtlIHYtc2xvdCBwcm9wcyAmIHYtZm9yIGFsaWFzZXMgc2hvdWxkIGJlIHBhcnNlZCBhc1xuLy8gZnVuY3Rpb24gcGFyYW1zXG5hc1BhcmFtcyA9IGZhbHNlLCBcbi8vIHYtb24gaGFuZGxlciB2YWx1ZXMgbWF5IGNvbnRhaW4gbXVsdGlwbGUgc3RhdGVtZW50c1xuYXNSYXdTdGF0ZW1lbnRzID0gZmFsc2UsIGxvY2FsVmFycyA9IE9iamVjdC5jcmVhdGUoY29udGV4dC5pZGVudGlmaWVycykpIHtcbiAgICB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIHNpbXBsZSBpbi1icm93c2VyIHZhbGlkYXRpb24gKHNhbWUgbG9naWMgaW4gMi54KVxuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihub2RlLCBjb250ZXh0LCBhc1BhcmFtcywgYXNSYXdTdGF0ZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFeHByZXNzaW9uKGV4cCkge1xuICAgIGlmIChpc1N0cmluZyhleHApKSB7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICByZXR1cm4gZXhwLmNvbnRlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwLmNoaWxkcmVuXG4gICAgICAgICAgICAubWFwKHN0cmluZ2lmeUV4cHJlc3Npb24pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgfVxufVxuXG5jb25zdCB0cmFuc2Zvcm1JZiA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0oL14oaWZ8ZWxzZXxlbHNlLWlmKSQvLCAobm9kZSwgZGlyLCBjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIHByb2Nlc3NJZihub2RlLCBkaXIsIGNvbnRleHQsIChpZk5vZGUsIGJyYW5jaCwgaXNSb290KSA9PiB7XG4gICAgICAgIC8vICMxNTg3OiBXZSBuZWVkIHRvIGR5bmFtaWNhbGx5IGluY3JlbWVudCB0aGUga2V5IGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIG5vZGUncyBzaWJsaW5nIG5vZGVzLCBzaW5jZSBjaGFpbmVkIHYtaWYvZWxzZSBicmFuY2hlcyBhcmVcbiAgICAgICAgLy8gcmVuZGVyZWQgYXQgdGhlIHNhbWUgZGVwdGhcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBjb250ZXh0LnBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgbGV0IGkgPSBzaWJsaW5ncy5pbmRleE9mKGlmTm9kZSk7XG4gICAgICAgIGxldCBrZXkgPSAwO1xuICAgICAgICB3aGlsZSAoaS0tID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gOSAvKiBOb2RlVHlwZXMuSUYgKi8pIHtcbiAgICAgICAgICAgICAgICBrZXkgKz0gc2libGluZy5icmFuY2hlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhpdCBjYWxsYmFjay4gQ29tcGxldGUgdGhlIGNvZGVnZW5Ob2RlIHdoZW4gYWxsIGNoaWxkcmVuIGhhdmUgYmVlblxuICAgICAgICAvLyB0cmFuc2Zvcm1lZC5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICBpZk5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVDb2RlZ2VuTm9kZUZvckJyYW5jaChicmFuY2gsIGtleSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdGhpcyBicmFuY2gncyBjb2RlZ2VuIG5vZGUgdG8gdGhlIHYtaWYgcm9vdC5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRDb25kaXRpb24gPSBnZXRQYXJlbnRDb25kaXRpb24oaWZOb2RlLmNvZGVnZW5Ob2RlKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25kaXRpb24uYWx0ZXJuYXRlID0gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXkgKyBpZk5vZGUuYnJhbmNoZXMubGVuZ3RoIC0gMSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59KTtcbi8vIHRhcmdldC1hZ25vc3RpYyB0cmFuc2Zvcm0gdXNlZCBmb3IgYm90aCBDbGllbnQgYW5kIFNTUlxuZnVuY3Rpb24gcHJvY2Vzc0lmKG5vZGUsIGRpciwgY29udGV4dCwgcHJvY2Vzc0NvZGVnZW4pIHtcbiAgICBpZiAoZGlyLm5hbWUgIT09ICdlbHNlJyAmJlxuICAgICAgICAoIWRpci5leHAgfHwgIWRpci5leHAuY29udGVudC50cmltKCkpKSB7XG4gICAgICAgIGNvbnN0IGxvYyA9IGRpci5leHAgPyBkaXIuZXhwLmxvYyA6IG5vZGUubG9jO1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigyOCAvKiBFcnJvckNvZGVzLlhfVl9JRl9OT19FWFBSRVNTSU9OICovLCBkaXIubG9jKSk7XG4gICAgICAgIGRpci5leHAgPSBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGB0cnVlYCwgZmFsc2UsIGxvYyk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSAmJiBkaXIuZXhwKSB7XG4gICAgICAgIHZhbGlkYXRlQnJvd3NlckV4cHJlc3Npb24oZGlyLmV4cCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChkaXIubmFtZSA9PT0gJ2lmJykge1xuICAgICAgICBjb25zdCBicmFuY2ggPSBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpO1xuICAgICAgICBjb25zdCBpZk5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiA5IC8qIE5vZGVUeXBlcy5JRiAqLyxcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICBicmFuY2hlczogW2JyYW5jaF1cbiAgICAgICAgfTtcbiAgICAgICAgY29udGV4dC5yZXBsYWNlTm9kZShpZk5vZGUpO1xuICAgICAgICBpZiAocHJvY2Vzc0NvZGVnZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzQ29kZWdlbihpZk5vZGUsIGJyYW5jaCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgYWRqYWNlbnQgdi1pZlxuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGNvbnRleHQucGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBjb21tZW50cyA9IFtdO1xuICAgICAgICBsZXQgaSA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIHdoaWxlIChpLS0gPj0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcudHlwZSA9PT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZShzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY29tbWVudHMudW5zaGlmdChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgc2libGluZy50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovICYmXG4gICAgICAgICAgICAgICAgIXNpYmxpbmcuY29udGVudC50cmltKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVOb2RlKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy50eXBlID09PSA5IC8qIE5vZGVUeXBlcy5JRiAqLykge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHYtZWxzZSB3YXMgZm9sbG93ZWQgYnkgdi1lbHNlLWlmXG4gICAgICAgICAgICAgICAgaWYgKGRpci5uYW1lID09PSAnZWxzZS1pZicgJiZcbiAgICAgICAgICAgICAgICAgICAgc2libGluZy5icmFuY2hlc1tzaWJsaW5nLmJyYW5jaGVzLmxlbmd0aCAtIDFdLmNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIEVycm9yQ29kZXMuWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIG5vZGUubG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIG5vZGUgdG8gdGhlIGlmIG5vZGUncyBicmFuY2hlc1xuICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IGNyZWF0ZUlmQnJhbmNoKG5vZGUsIGRpcik7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gIzM2MTkgaWdub3JlIGNvbW1lbnRzIGlmIHRoZSB2LWlmIGlzIGRpcmVjdCBjaGlsZCBvZiA8dHJhbnNpdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgIShjb250ZXh0LnBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXJlbnQudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNCdWlsdEluVHlwZShjb250ZXh0LnBhcmVudC50YWcsICd0cmFuc2l0aW9uJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaC5jaGlsZHJlbiA9IFsuLi5jb21tZW50cywgLi4uYnJhbmNoLmNoaWxkcmVuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdXNlciBpcyBmb3JjaW5nIHNhbWUga2V5IG9uIGRpZmZlcmVudCBicmFuY2hlc1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYnJhbmNoLnVzZXJLZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMuZm9yRWFjaCgoeyB1c2VyS2V5IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lS2V5KHVzZXJLZXksIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMjkgLyogRXJyb3JDb2Rlcy5YX1ZfSUZfU0FNRV9LRVkgKi8sIGJyYW5jaC51c2VyS2V5LmxvYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpYmxpbmcuYnJhbmNoZXMucHVzaChicmFuY2gpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9IHByb2Nlc3NDb2RlZ2VuICYmIHByb2Nlc3NDb2RlZ2VuKHNpYmxpbmcsIGJyYW5jaCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBicmFuY2ggd2FzIHJlbW92ZWQsIGl0IHdpbGwgbm90IGJlIHRyYXZlcnNlZC5cbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gdHJhdmVyc2UgaGVyZS5cbiAgICAgICAgICAgICAgICB0cmF2ZXJzZU5vZGUoYnJhbmNoLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIG9uIGV4aXRcbiAgICAgICAgICAgICAgICBpZiAob25FeGl0KVxuICAgICAgICAgICAgICAgICAgICBvbkV4aXQoKTtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzZXQgY3VycmVudE5vZGUgYWZ0ZXIgdHJhdmVyc2FsIHRvIGluZGljYXRlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBub2RlIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgY29udGV4dC5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMCAvKiBFcnJvckNvZGVzLlhfVl9FTFNFX05PX0FESkFDRU5UX0lGICovLCBub2RlLmxvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVJZkJyYW5jaChub2RlLCBkaXIpIHtcbiAgICBjb25zdCBpc1RlbXBsYXRlSWYgPSBub2RlLnRhZ1R5cGUgPT09IDMgLyogRWxlbWVudFR5cGVzLlRFTVBMQVRFICovO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi8sXG4gICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgIGNvbmRpdGlvbjogZGlyLm5hbWUgPT09ICdlbHNlJyA/IHVuZGVmaW5lZCA6IGRpci5leHAsXG4gICAgICAgIGNoaWxkcmVuOiBpc1RlbXBsYXRlSWYgJiYgIWZpbmREaXIobm9kZSwgJ2ZvcicpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXSxcbiAgICAgICAgdXNlcktleTogZmluZFByb3Aobm9kZSwgYGtleWApLFxuICAgICAgICBpc1RlbXBsYXRlSWZcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ29kZWdlbk5vZGVGb3JCcmFuY2goYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCkge1xuICAgIGlmIChicmFuY2guY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24oYnJhbmNoLmNvbmRpdGlvbiwgY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSwgXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBwYXNzIGluIGFzQmxvY2s6IHRydWUgc28gdGhhdCB0aGUgY29tbWVudCBub2RlIGNhbGxcbiAgICAgICAgLy8gY2xvc2VzIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAgICBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfQ09NTUVOVCksIFtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/ICdcInYtaWZcIicgOiAnXCJcIicsXG4gICAgICAgICAgICAndHJ1ZSdcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkcmVuQ29kZWdlbk5vZGUoYnJhbmNoLCBrZXlJbmRleCwgY29udGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5Db2RlZ2VuTm9kZShicmFuY2gsIGtleUluZGV4LCBjb250ZXh0KSB7XG4gICAgY29uc3QgeyBoZWxwZXIgfSA9IGNvbnRleHQ7XG4gICAgY29uc3Qga2V5UHJvcGVydHkgPSBjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXlJbmRleH1gLCBmYWxzZSwgbG9jU3R1YiwgMiAvKiBDb25zdGFudFR5cGVzLkNBTl9IT0lTVCAqLykpO1xuICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGJyYW5jaDtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBmaXJzdENoaWxkLnR5cGUgIT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi87XG4gICAgaWYgKG5lZWRGcmFnbWVudFdyYXBwZXIpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBmaXJzdENoaWxkLnR5cGUgPT09IDExIC8qIE5vZGVUeXBlcy5GT1IgKi8pIHtcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGF3YXkgbmVzdGVkIGZyYWdtZW50cyB3aGVuIGNoaWxkIGlzIGEgRm9yTm9kZVxuICAgICAgICAgICAgY29uc3Qgdm5vZGVDYWxsID0gZmlyc3RDaGlsZC5jb2RlZ2VuTm9kZTtcbiAgICAgICAgICAgIGluamVjdFByb3Aodm5vZGVDYWxsLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGVDYWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZyA9IDY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovO1xuICAgICAgICAgICAgbGV0IHBhdGNoRmxhZ1RleHQgPSBQYXRjaEZsYWdOYW1lc1s2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL107XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZnJhZ21lbnQgYWN0dWFsbHkgY29udGFpbnMgYSBzaW5nbGUgdmFsaWQgY2hpbGQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIHJlc3QgYmVpbmcgY29tbWVudHNcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAhYnJhbmNoLmlzVGVtcGxhdGVJZiAmJlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmZpbHRlcihjID0+IGMudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqLztcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWdUZXh0ICs9IGAsICR7UGF0Y2hGbGFnTmFtZXNbMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlQ2FsbChjb250ZXh0LCBoZWxwZXIoRlJBR01FTlQpLCBjcmVhdGVPYmplY3RFeHByZXNzaW9uKFtrZXlQcm9wZXJ0eV0pLCBjaGlsZHJlbiwgcGF0Y2hGbGFnICsgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGAgLyogJHtwYXRjaEZsYWdUZXh0fSAqL2AgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCBmYWxzZSwgZmFsc2UgLyogaXNDb21wb25lbnQgKi8sIGJyYW5jaC5sb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZXQgPSBmaXJzdENoaWxkLmNvZGVnZW5Ob2RlO1xuICAgICAgICBjb25zdCB2bm9kZUNhbGwgPSBnZXRNZW1vZWRWTm9kZUNhbGwocmV0KTtcbiAgICAgICAgLy8gQ2hhbmdlIGNyZWF0ZVZOb2RlIHRvIGNyZWF0ZUJsb2NrLlxuICAgICAgICBpZiAodm5vZGVDYWxsLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICBtYWtlQmxvY2sodm5vZGVDYWxsLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmplY3QgYnJhbmNoIGtleVxuICAgICAgICBpbmplY3RQcm9wKHZub2RlQ2FsbCwga2V5UHJvcGVydHksIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZUtleShhLCBiKSB7XG4gICAgaWYgKCFhIHx8IGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovKSB7XG4gICAgICAgIGlmIChhLnZhbHVlLmNvbnRlbnQgIT09IGIudmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RpdmVcbiAgICAgICAgY29uc3QgZXhwID0gYS5leHA7XG4gICAgICAgIGNvbnN0IGJyYW5jaEV4cCA9IGIuZXhwO1xuICAgICAgICBpZiAoZXhwLnR5cGUgIT09IGJyYW5jaEV4cC50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cC50eXBlICE9PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyB8fFxuICAgICAgICAgICAgZXhwLmlzU3RhdGljICE9PSBicmFuY2hFeHAuaXNTdGF0aWMgfHxcbiAgICAgICAgICAgIGV4cC5jb250ZW50ICE9PSBicmFuY2hFeHAuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Q29uZGl0aW9uKG5vZGUpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAxOSAvKiBOb2RlVHlwZXMuSlNfQ09ORElUSU9OQUxfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLnR5cGUgPT09IDE5IC8qIE5vZGVUeXBlcy5KU19DT05ESVRJT05BTF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAyMCAvKiBOb2RlVHlwZXMuSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHRyYW5zZm9ybUZvciA9IGNyZWF0ZVN0cnVjdHVyYWxEaXJlY3RpdmVUcmFuc2Zvcm0oJ2ZvcicsIChub2RlLCBkaXIsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGhlbHBlciwgcmVtb3ZlSGVscGVyIH0gPSBjb250ZXh0O1xuICAgIHJldHVybiBwcm9jZXNzRm9yKG5vZGUsIGRpciwgY29udGV4dCwgZm9yTm9kZSA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbG9vcCByZW5kZXIgZnVuY3Rpb24gZXhwcmVzc2lvbiBub3csIGFuZCBhZGQgdGhlXG4gICAgICAgIC8vIGl0ZXJhdG9yIG9uIGV4aXQgYWZ0ZXIgYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiB0cmF2ZXJzZWRcbiAgICAgICAgY29uc3QgcmVuZGVyRXhwID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xuICAgICAgICAgICAgZm9yTm9kZS5zb3VyY2VcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGlzVGVtcGxhdGUgPSBpc1RlbXBsYXRlTm9kZShub2RlKTtcbiAgICAgICAgY29uc3QgbWVtbyA9IGZpbmREaXIobm9kZSwgJ21lbW8nKTtcbiAgICAgICAgY29uc3Qga2V5UHJvcCA9IGZpbmRQcm9wKG5vZGUsIGBrZXlgKTtcbiAgICAgICAgY29uc3Qga2V5RXhwID0ga2V5UHJvcCAmJlxuICAgICAgICAgICAgKGtleVByb3AudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGtleVByb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IGtleVByb3AuZXhwKTtcbiAgICAgICAgY29uc3Qga2V5UHJvcGVydHkgPSBrZXlQcm9wID8gY3JlYXRlT2JqZWN0UHJvcGVydHkoYGtleWAsIGtleUV4cCkgOiBudWxsO1xuICAgICAgICBjb25zdCBpc1N0YWJsZUZyYWdtZW50ID0gZm9yTm9kZS5zb3VyY2UudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcbiAgICAgICAgICAgIGZvck5vZGUuc291cmNlLmNvbnN0VHlwZSA+IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi87XG4gICAgICAgIGNvbnN0IGZyYWdtZW50RmxhZyA9IGlzU3RhYmxlRnJhZ21lbnRcbiAgICAgICAgICAgID8gNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi9cbiAgICAgICAgICAgIDoga2V5UHJvcFxuICAgICAgICAgICAgICAgID8gMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi9cbiAgICAgICAgICAgICAgICA6IDI1NiAvKiBQYXRjaEZsYWdzLlVOS0VZRURfRlJBR01FTlQgKi87XG4gICAgICAgIGZvck5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgaGVscGVyKEZSQUdNRU5UKSwgdW5kZWZpbmVkLCByZW5kZXJFeHAsIGZyYWdtZW50RmxhZyArXG4gICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYCAvKiAke1BhdGNoRmxhZ05hbWVzW2ZyYWdtZW50RmxhZ119ICovYCA6IGBgKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUgLyogaXNCbG9jayAqLywgIWlzU3RhYmxlRnJhZ21lbnQgLyogZGlzYWJsZVRyYWNraW5nICovLCBmYWxzZSAvKiBpc0NvbXBvbmVudCAqLywgbm9kZS5sb2MpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgLy8gZmluaXNoIHRoZSBjb2RlZ2VuIG5vdyB0aGF0IGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdHJhdmVyc2VkXG4gICAgICAgICAgICBsZXQgY2hpbGRCbG9jaztcbiAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IGZvck5vZGU7XG4gICAgICAgICAgICAvLyBjaGVjayA8dGVtcGxhdGUgdi1mb3I+IGtleSBwbGFjZW1lbnRcbiAgICAgICAgICAgIGlmICgoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8ICF0cnVlKSAmJiBpc1RlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zb21lKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBmaW5kUHJvcChjLCAna2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzMgLyogRXJyb3JDb2Rlcy5YX1ZfRk9SX1RFTVBMQVRFX0tFWV9QTEFDRU1FTlQgKi8sIGtleS5sb2MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmVlZEZyYWdtZW50V3JhcHBlciA9IGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBjaGlsZHJlblswXS50eXBlICE9PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovO1xuICAgICAgICAgICAgY29uc3Qgc2xvdE91dGxldCA9IGlzU2xvdE91dGxldChub2RlKVxuICAgICAgICAgICAgICAgID8gbm9kZVxuICAgICAgICAgICAgICAgIDogaXNUZW1wbGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBpc1Nsb3RPdXRsZXQobm9kZS5jaGlsZHJlblswXSlcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlLmNoaWxkcmVuWzBdIC8vIGFwaS1leHRyYWN0b3Igc29tZWhvdyBmYWlscyB0byBpbmZlciB0aGlzXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChzbG90T3V0bGV0KSB7XG4gICAgICAgICAgICAgICAgLy8gPHNsb3Qgdi1mb3I9XCIuLi5cIj4gb3IgPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+PHNsb3QvPjwvdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgY2hpbGRCbG9jayA9IHNsb3RPdXRsZXQuY29kZWdlbk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCIgOmtleT1cIi4uLlwiPjxzbG90Lz48L3RlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGluamVjdCB0aGUga2V5IHRvIHRoZSByZW5kZXJTbG90KCkgY2FsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb3BzIGZvciByZW5kZXJTbG90IGlzIHBhc3NlZCBhcyB0aGUgM3JkIGFyZ3VtZW50LlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RQcm9wKGNoaWxkQmxvY2ssIGtleVByb3BlcnR5LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkRnJhZ21lbnRXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gPHRlbXBsYXRlIHYtZm9yPVwiLi4uXCI+IHdpdGggdGV4dCBvciBtdWx0aS1lbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBnZW5lcmF0ZSBhIGZyYWdtZW50IGJsb2NrIGZvciBlYWNoIGxvb3BcbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrID0gY3JlYXRlVk5vZGVDYWxsKGNvbnRleHQsIGhlbHBlcihGUkFHTUVOVCksIGtleVByb3BlcnR5ID8gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihba2V5UHJvcGVydHldKSA6IHVuZGVmaW5lZCwgbm9kZS5jaGlsZHJlbiwgNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi8gK1xuICAgICAgICAgICAgICAgICAgICAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAgLyogJHtQYXRjaEZsYWdOYW1lc1s2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL119ICovYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgYCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGZhbHNlIC8qIGlzQ29tcG9uZW50ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBlbGVtZW50IHYtZm9yLiBEaXJlY3RseSB1c2UgdGhlIGNoaWxkJ3MgY29kZWdlbk5vZGVcbiAgICAgICAgICAgICAgICAvLyBidXQgbWFyayBpdCBhcyBhIGJsb2NrLlxuICAgICAgICAgICAgICAgIGNoaWxkQmxvY2sgPSBjaGlsZHJlblswXVxuICAgICAgICAgICAgICAgICAgICAuY29kZWdlbk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGUgJiYga2V5UHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0UHJvcChjaGlsZEJsb2NrLCBrZXlQcm9wZXJ0eSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2sgIT09ICFpc1N0YWJsZUZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEJsb2NrLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBmcm9tIGJsb2NrIHRvIHZub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoT1BFTl9CTE9DSyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVIZWxwZXIoZ2V0Vk5vZGVCbG9ja0hlbHBlcihjb250ZXh0LmluU1NSLCBjaGlsZEJsb2NrLmlzQ29tcG9uZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2l0Y2ggZnJvbSB2bm9kZSB0byBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZEJsb2NrLmlzQmxvY2sgPSAhaXNTdGFibGVGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCbG9jay5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihPUEVOX0JMT0NLKTtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlQmxvY2tIZWxwZXIoY29udGV4dC5pblNTUiwgY2hpbGRCbG9jay5pc0NvbXBvbmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKGdldFZOb2RlSGVscGVyKGNvbnRleHQuaW5TU1IsIGNoaWxkQmxvY2suaXNDb21wb25lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVtbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvb3AgPSBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24oY3JlYXRlRm9yTG9vcFBhcmFtcyhmb3JOb2RlLnBhcnNlUmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9jYWNoZWRgKVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICBsb29wLmJvZHkgPSBjcmVhdGVCbG9ja1N0YXRlbWVudChbXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYGNvbnN0IF9tZW1vID0gKGAsIG1lbW8uZXhwLCBgKWBdKSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpZiAoX2NhY2hlZGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oa2V5RXhwID8gW2AgJiYgX2NhY2hlZC5rZXkgPT09IGAsIGtleUV4cF0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBgICYmICR7Y29udGV4dC5oZWxwZXJTdHJpbmcoSVNfTUVNT19TQU1FKX0oX2NhY2hlZCwgX21lbW8pKSByZXR1cm4gX2NhY2hlZGBcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYGNvbnN0IF9pdGVtID0gYCwgY2hpbGRCbG9ja10pLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGBfaXRlbS5tZW1vID0gX21lbW9gKSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgcmV0dXJuIF9pdGVtYClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2gobG9vcCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgX2NhY2hlYCksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oU3RyaW5nKGNvbnRleHQuY2FjaGVkKyspKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJFeHAuYXJndW1lbnRzLnB1c2goY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKGNyZWF0ZUZvckxvb3BQYXJhbXMoZm9yTm9kZS5wYXJzZVJlc3VsdCksIGNoaWxkQmxvY2ssIHRydWUgLyogZm9yY2UgbmV3bGluZSAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufSk7XG4vLyB0YXJnZXQtYWdub3N0aWMgdHJhbnNmb3JtIHVzZWQgZm9yIGJvdGggQ2xpZW50IGFuZCBTU1JcbmZ1bmN0aW9uIHByb2Nlc3NGb3Iobm9kZSwgZGlyLCBjb250ZXh0LCBwcm9jZXNzQ29kZWdlbikge1xuICAgIGlmICghZGlyLmV4cCkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzMSAvKiBFcnJvckNvZGVzLlhfVl9GT1JfTk9fRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gcGFyc2VGb3JFeHByZXNzaW9uKFxuICAgIC8vIGNhbiBvbmx5IGJlIHNpbXBsZSBleHByZXNzaW9uIGJlY2F1c2UgdkZvciB0cmFuc2Zvcm0gaXMgYXBwbGllZFxuICAgIC8vIGJlZm9yZSBleHByZXNzaW9uIHRyYW5zZm9ybS5cbiAgICBkaXIuZXhwLCBjb250ZXh0KTtcbiAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMyIC8qIEVycm9yQ29kZXMuWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgZGlyLmxvYykpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgYWRkSWRlbnRpZmllcnMsIHJlbW92ZUlkZW50aWZpZXJzLCBzY29wZXMgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgeyBzb3VyY2UsIHZhbHVlLCBrZXksIGluZGV4IH0gPSBwYXJzZVJlc3VsdDtcbiAgICBjb25zdCBmb3JOb2RlID0ge1xuICAgICAgICB0eXBlOiAxMSAvKiBOb2RlVHlwZXMuRk9SICovLFxuICAgICAgICBsb2M6IGRpci5sb2MsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgdmFsdWVBbGlhczogdmFsdWUsXG4gICAgICAgIGtleUFsaWFzOiBrZXksXG4gICAgICAgIG9iamVjdEluZGV4QWxpYXM6IGluZGV4LFxuICAgICAgICBwYXJzZVJlc3VsdCxcbiAgICAgICAgY2hpbGRyZW46IGlzVGVtcGxhdGVOb2RlKG5vZGUpID8gbm9kZS5jaGlsZHJlbiA6IFtub2RlXVxuICAgIH07XG4gICAgY29udGV4dC5yZXBsYWNlTm9kZShmb3JOb2RlKTtcbiAgICAvLyBib29ra2VlcGluZ1xuICAgIHNjb3Blcy52Rm9yKys7XG4gICAgY29uc3Qgb25FeGl0ID0gcHJvY2Vzc0NvZGVnZW4gJiYgcHJvY2Vzc0NvZGVnZW4oZm9yTm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc2NvcGVzLnZGb3ItLTtcbiAgICAgICAgaWYgKG9uRXhpdClcbiAgICAgICAgICAgIG9uRXhpdCgpO1xuICAgIH07XG59XG5jb25zdCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xuLy8gVGhpcyByZWdleCBkb2Vzbid0IGNvdmVyIHRoZSBjYXNlIGlmIGtleSBvciBpbmRleCBhbGlhc2VzIGhhdmUgZGVzdHJ1Y3R1cmluZyxcbi8vIGJ1dCB0aG9zZSBkbyBub3QgbWFrZSBzZW5zZSBpbiB0aGUgZmlyc3QgcGxhY2UsIHNvIHRoaXMgd29ya3MgaW4gcHJhY3RpY2UuXG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihpbnB1dCwgY29udGV4dCkge1xuICAgIGNvbnN0IGxvYyA9IGlucHV0LmxvYztcbiAgICBjb25zdCBleHAgPSBpbnB1dC5jb250ZW50O1xuICAgIGNvbnN0IGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgWywgTEhTLCBSSFNdID0gaW5NYXRjaDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNvdXJjZTogY3JlYXRlQWxpYXNFeHByZXNzaW9uKGxvYywgUkhTLnRyaW0oKSwgZXhwLmluZGV4T2YoUkhTLCBMSFMubGVuZ3RoKSksXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGtleTogdW5kZWZpbmVkLFxuICAgICAgICBpbmRleDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcbiAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuc291cmNlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgbGV0IHZhbHVlQ29udGVudCA9IExIUy50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJykudHJpbSgpO1xuICAgIGNvbnN0IHRyaW1tZWRPZmZzZXQgPSBMSFMuaW5kZXhPZih2YWx1ZUNvbnRlbnQpO1xuICAgIGNvbnN0IGl0ZXJhdG9yTWF0Y2ggPSB2YWx1ZUNvbnRlbnQubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgICAgdmFsdWVDb250ZW50ID0gdmFsdWVDb250ZW50LnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICAgICAgY29uc3Qga2V5Q29udGVudCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICBsZXQga2V5T2Zmc2V0O1xuICAgICAgICBpZiAoa2V5Q29udGVudCkge1xuICAgICAgICAgICAga2V5T2Zmc2V0ID0gZXhwLmluZGV4T2Yoa2V5Q29udGVudCwgdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0LmtleSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIGtleUNvbnRlbnQsIGtleU9mZnNldCk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKHJlc3VsdC5rZXksIGNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleENvbnRlbnQgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChpbmRleENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaW5kZXggPSBjcmVhdGVBbGlhc0V4cHJlc3Npb24obG9jLCBpbmRleENvbnRlbnQsIGV4cC5pbmRleE9mKGluZGV4Q29udGVudCwgcmVzdWx0LmtleVxuICAgICAgICAgICAgICAgICAgICA/IGtleU9mZnNldCArIGtleUNvbnRlbnQubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIDogdHJpbW1lZE9mZnNldCArIHZhbHVlQ29udGVudC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQuaW5kZXgsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWVDb250ZW50KSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGNyZWF0ZUFsaWFzRXhwcmVzc2lvbihsb2MsIHZhbHVlQ29udGVudCwgdHJpbW1lZE9mZnNldCk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdHJ1ZSkge1xuICAgICAgICAgICAgdmFsaWRhdGVCcm93c2VyRXhwcmVzc2lvbihyZXN1bHQudmFsdWUsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVBbGlhc0V4cHJlc3Npb24ocmFuZ2UsIGNvbnRlbnQsIG9mZnNldCkge1xuICAgIHJldHVybiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKGNvbnRlbnQsIGZhbHNlLCBnZXRJbm5lclJhbmdlKHJhbmdlLCBvZmZzZXQsIGNvbnRlbnQubGVuZ3RoKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JMb29wUGFyYW1zKHsgdmFsdWUsIGtleSwgaW5kZXggfSwgbWVtb0FyZ3MgPSBbXSkge1xuICAgIHJldHVybiBjcmVhdGVQYXJhbXNMaXN0KFt2YWx1ZSwga2V5LCBpbmRleCwgLi4ubWVtb0FyZ3NdKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtc0xpc3QoYXJncykge1xuICAgIGxldCBpID0gYXJncy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYXJnc1tpXSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJnc1xuICAgICAgICAuc2xpY2UoMCwgaSArIDEpXG4gICAgICAgIC5tYXAoKGFyZywgaSkgPT4gYXJnIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYF9gLnJlcGVhdChpICsgMSksIGZhbHNlKSk7XG59XG5cbmNvbnN0IGRlZmF1bHRGYWxsYmFjayA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHVuZGVmaW5lZGAsIGZhbHNlKTtcbi8vIEEgTm9kZVRyYW5zZm9ybSB0aGF0OlxuLy8gMS4gVHJhY2tzIHNjb3BlIGlkZW50aWZpZXJzIGZvciBzY29wZWQgc2xvdHMgc28gdGhhdCB0aGV5IGRvbid0IGdldCBwcmVmaXhlZFxuLy8gICAgYnkgdHJhbnNmb3JtRXhwcmVzc2lvbi4gVGhpcyBpcyBvbmx5IGFwcGxpZWQgaW4gbm9uLWJyb3dzZXIgYnVpbGRzIHdpdGhcbi8vICAgIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfS5cbi8vIDIuIFRyYWNrIHYtc2xvdCBkZXB0aHMgc28gdGhhdCB3ZSBrbm93IGEgc2xvdCBpcyBpbnNpZGUgYW5vdGhlciBzbG90LlxuLy8gICAgTm90ZSB0aGUgZXhpdCBjYWxsYmFjayBpcyBleGVjdXRlZCBiZWZvcmUgYnVpbGRTbG90cygpIG9uIHRoZSBzYW1lIG5vZGUsXG4vLyAgICBzbyBvbmx5IG5lc3RlZCBzbG90cyBzZWUgcG9zaXRpdmUgbnVtYmVycy5cbmNvbnN0IHRyYWNrU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAobm9kZS50YWdUeXBlID09PSAxIC8qIEVsZW1lbnRUeXBlcy5DT01QT05FTlQgKi8gfHxcbiAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMyAvKiBFbGVtZW50VHlwZXMuVEVNUExBVEUgKi8pKSB7XG4gICAgICAgIC8vIFdlIGFyZSBvbmx5IGNoZWNraW5nIG5vbi1lbXB0eSB2LXNsb3QgaGVyZVxuICAgICAgICAvLyBzaW5jZSB3ZSBvbmx5IGNhcmUgYWJvdXQgc2xvdHMgdGhhdCBpbnRyb2R1Y2Ugc2NvcGUgdmFyaWFibGVzLlxuICAgICAgICBjb25zdCB2U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnKTtcbiAgICAgICAgaWYgKHZTbG90KSB7XG4gICAgICAgICAgICB2U2xvdC5leHA7XG4gICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdCsrO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNjb3Blcy52U2xvdC0tO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyBBIE5vZGVUcmFuc2Zvcm0gdGhhdCB0cmFja3Mgc2NvcGUgaWRlbnRpZmllcnMgZm9yIHNjb3BlZCBzbG90cyB3aXRoIHYtZm9yLlxuLy8gVGhpcyB0cmFuc2Zvcm0gaXMgb25seSBhcHBsaWVkIGluIG5vbi1icm93c2VyIGJ1aWxkcyB3aXRoIHsgcHJlZml4SWRlbnRpZmllcnM6IHRydWUgfVxuY29uc3QgdHJhY2tWRm9yU2xvdFNjb3BlcyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgbGV0IHZGb3I7XG4gICAgaWYgKGlzVGVtcGxhdGVOb2RlKG5vZGUpICYmXG4gICAgICAgIG5vZGUucHJvcHMuc29tZShpc1ZTbG90KSAmJlxuICAgICAgICAodkZvciA9IGZpbmREaXIobm9kZSwgJ2ZvcicpKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSAodkZvci5wYXJzZVJlc3VsdCA9IHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCkpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBrZXksIGluZGV4IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCB7IGFkZElkZW50aWZpZXJzLCByZW1vdmVJZGVudGlmaWVycyB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIHZhbHVlICYmIGFkZElkZW50aWZpZXJzKHZhbHVlKTtcbiAgICAgICAgICAgIGtleSAmJiBhZGRJZGVudGlmaWVycyhrZXkpO1xuICAgICAgICAgICAgaW5kZXggJiYgYWRkSWRlbnRpZmllcnMoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAmJiByZW1vdmVJZGVudGlmaWVycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAga2V5ICYmIHJlbW92ZUlkZW50aWZpZXJzKGtleSk7XG4gICAgICAgICAgICAgICAgaW5kZXggJiYgcmVtb3ZlSWRlbnRpZmllcnMoaW5kZXgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBidWlsZENsaWVudFNsb3RGbiA9IChwcm9wcywgY2hpbGRyZW4sIGxvYykgPT4gY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKHByb3BzLCBjaGlsZHJlbiwgZmFsc2UgLyogbmV3bGluZSAqLywgdHJ1ZSAvKiBpc1Nsb3QgKi8sIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuWzBdLmxvYyA6IGxvYyk7XG4vLyBJbnN0ZWFkIG9mIGJlaW5nIGEgRGlyZWN0aXZlVHJhbnNmb3JtLCB2LXNsb3QgcHJvY2Vzc2luZyBpcyBjYWxsZWQgZHVyaW5nXG4vLyB0cmFuc2Zvcm1FbGVtZW50IHRvIGJ1aWxkIHRoZSBzbG90cyBvYmplY3QgZm9yIGEgY29tcG9uZW50LlxuZnVuY3Rpb24gYnVpbGRTbG90cyhub2RlLCBjb250ZXh0LCBidWlsZFNsb3RGbiA9IGJ1aWxkQ2xpZW50U2xvdEZuKSB7XG4gICAgY29udGV4dC5oZWxwZXIoV0lUSF9DVFgpO1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGxvYyB9ID0gbm9kZTtcbiAgICBjb25zdCBzbG90c1Byb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAvLyBJZiB0aGUgc2xvdCBpcyBpbnNpZGUgYSB2LWZvciBvciBhbm90aGVyIHYtc2xvdCwgZm9yY2UgaXQgdG8gYmUgZHluYW1pY1xuICAgIC8vIHNpbmNlIGl0IGxpa2VseSB1c2VzIGEgc2NvcGUgdmFyaWFibGUuXG4gICAgbGV0IGhhc0R5bmFtaWNTbG90cyA9IGNvbnRleHQuc2NvcGVzLnZTbG90ID4gMCB8fCBjb250ZXh0LnNjb3Blcy52Rm9yID4gMDtcbiAgICAvLyAxLiBDaGVjayBmb3Igc2xvdCB3aXRoIHNsb3RQcm9wcyBvbiBjb21wb25lbnQgaXRzZWxmLlxuICAgIC8vICAgIDxDb21wIHYtc2xvdD1cInsgcHJvcCB9XCIvPlxuICAgIGNvbnN0IG9uQ29tcG9uZW50U2xvdCA9IGZpbmREaXIobm9kZSwgJ3Nsb3QnLCB0cnVlKTtcbiAgICBpZiAob25Db21wb25lbnRTbG90KSB7XG4gICAgICAgIGNvbnN0IHsgYXJnLCBleHAgfSA9IG9uQ29tcG9uZW50U2xvdDtcbiAgICAgICAgaWYgKGFyZyAmJiAhaXNTdGF0aWNFeHAoYXJnKSkge1xuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcgfHwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbignZGVmYXVsdCcsIHRydWUpLCBidWlsZFNsb3RGbihleHAsIGNoaWxkcmVuLCBsb2MpKSk7XG4gICAgfVxuICAgIC8vIDIuIEl0ZXJhdGUgdGhyb3VnaCBjaGlsZHJlbiBhbmQgY2hlY2sgZm9yIHRlbXBsYXRlIHNsb3RzXG4gICAgLy8gICAgPHRlbXBsYXRlIHYtc2xvdDpmb289XCJ7IHByb3AgfVwiPlxuICAgIGxldCBoYXNUZW1wbGF0ZVNsb3RzID0gZmFsc2U7XG4gICAgbGV0IGhhc05hbWVkRGVmYXVsdFNsb3QgPSBmYWxzZTtcbiAgICBjb25zdCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IHNlZW5TbG90TmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGNvbmRpdGlvbmFsQnJhbmNoSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2xvdEVsZW1lbnQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgbGV0IHNsb3REaXI7XG4gICAgICAgIGlmICghaXNUZW1wbGF0ZU5vZGUoc2xvdEVsZW1lbnQpIHx8XG4gICAgICAgICAgICAhKHNsb3REaXIgPSBmaW5kRGlyKHNsb3RFbGVtZW50LCAnc2xvdCcsIHRydWUpKSkge1xuICAgICAgICAgICAgLy8gbm90IGEgPHRlbXBsYXRlIHYtc2xvdD4sIHNraXAuXG4gICAgICAgICAgICBpZiAoc2xvdEVsZW1lbnQudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIGltcGxpY2l0RGVmYXVsdENoaWxkcmVuLnB1c2goc2xvdEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ29tcG9uZW50U2xvdCkge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBoYXMgb24tY29tcG9uZW50IHNsb3QgLSB0aGlzIGlzIGluY29ycmVjdCB1c2FnZS5cbiAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM3IC8qIEVycm9yQ29kZXMuWF9WX1NMT1RfTUlYRURfU0xPVF9VU0FHRSAqLywgc2xvdERpci5sb2MpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGhhc1RlbXBsYXRlU2xvdHMgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBzbG90Q2hpbGRyZW4sIGxvYzogc2xvdExvYyB9ID0gc2xvdEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHsgYXJnOiBzbG90TmFtZSA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYGRlZmF1bHRgLCB0cnVlKSwgZXhwOiBzbG90UHJvcHMsIGxvYzogZGlyTG9jIH0gPSBzbG90RGlyO1xuICAgICAgICAvLyBjaGVjayBpZiBuYW1lIGlzIGR5bmFtaWMuXG4gICAgICAgIGxldCBzdGF0aWNTbG90TmFtZTtcbiAgICAgICAgaWYgKGlzU3RhdGljRXhwKHNsb3ROYW1lKSkge1xuICAgICAgICAgICAgc3RhdGljU2xvdE5hbWUgPSBzbG90TmFtZSA/IHNsb3ROYW1lLmNvbnRlbnQgOiBgZGVmYXVsdGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNEeW5hbWljU2xvdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsb3RGdW5jdGlvbiA9IGJ1aWxkU2xvdEZuKHNsb3RQcm9wcywgc2xvdENoaWxkcmVuLCBzbG90TG9jKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBzbG90IGlzIGNvbmRpdGlvbmFsICh2LWlmL3YtZm9yKVxuICAgICAgICBsZXQgdklmO1xuICAgICAgICBsZXQgdkVsc2U7XG4gICAgICAgIGxldCB2Rm9yO1xuICAgICAgICBpZiAoKHZJZiA9IGZpbmREaXIoc2xvdEVsZW1lbnQsICdpZicpKSkge1xuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2SWYuZXhwLCBidWlsZER5bmFtaWNTbG90KHNsb3ROYW1lLCBzbG90RnVuY3Rpb24sIGNvbmRpdGlvbmFsQnJhbmNoSW5kZXgrKyksIGRlZmF1bHRGYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2RWxzZSA9IGZpbmREaXIoc2xvdEVsZW1lbnQsIC9eZWxzZSgtaWYpPyQvLCB0cnVlIC8qIGFsbG93RW1wdHkgKi8pKSkge1xuICAgICAgICAgICAgLy8gZmluZCBhZGphY2VudCB2LWlmXG4gICAgICAgICAgICBsZXQgaiA9IGk7XG4gICAgICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgICAgaWYgKHByZXYudHlwZSAhPT0gMyAvKiBOb2RlVHlwZXMuQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldiAmJiBpc1RlbXBsYXRlTm9kZShwcmV2KSAmJiBmaW5kRGlyKHByZXYsICdpZicpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIC8vIGF0dGFjaCB0aGlzIHNsb3QgdG8gcHJldmlvdXMgY29uZGl0aW9uYWxcbiAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uYWwgPSBkeW5hbWljU2xvdHNbZHluYW1pY1Nsb3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb25kaXRpb25hbC5hbHRlcm5hdGUudHlwZSA9PT0gMTkgLyogTm9kZVR5cGVzLkpTX0NPTkRJVElPTkFMX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5hbHRlcm5hdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbmFsLmFsdGVybmF0ZSA9IHZFbHNlLmV4cFxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbmRpdGlvbmFsRXhwcmVzc2lvbih2RWxzZS5leHAsIGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiwgY29uZGl0aW9uYWxCcmFuY2hJbmRleCsrKSwgZGVmYXVsdEZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICA6IGJ1aWxkRHluYW1pY1Nsb3Qoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbiwgY29uZGl0aW9uYWxCcmFuY2hJbmRleCsrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMwIC8qIEVycm9yQ29kZXMuWF9WX0VMU0VfTk9fQURKQUNFTlRfSUYgKi8sIHZFbHNlLmxvYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh2Rm9yID0gZmluZERpcihzbG90RWxlbWVudCwgJ2ZvcicpKSkge1xuICAgICAgICAgICAgaGFzRHluYW1pY1Nsb3RzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gdkZvci5wYXJzZVJlc3VsdCB8fFxuICAgICAgICAgICAgICAgIHBhcnNlRm9yRXhwcmVzc2lvbih2Rm9yLmV4cCwgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIGR5bmFtaWMgc2xvdHMgYXMgYW4gYXJyYXkgYW5kIGFkZCBpdCB0byB0aGUgY3JlYXRlU2xvdCgpXG4gICAgICAgICAgICAgICAgLy8gYXJncy4gVGhlIHJ1bnRpbWUga25vd3MgaG93IHRvIGhhbmRsZSBpdCBhcHByb3ByaWF0ZWx5LlxuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFTkRFUl9MSVNUKSwgW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihjcmVhdGVGb3JMb29wUGFyYW1zKHBhcnNlUmVzdWx0KSwgYnVpbGREeW5hbWljU2xvdChzbG90TmFtZSwgc2xvdEZ1bmN0aW9uKSwgdHJ1ZSAvKiBmb3JjZSBuZXdsaW5lICovKVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDMyIC8qIEVycm9yQ29kZXMuWF9WX0ZPUl9NQUxGT1JNRURfRVhQUkVTU0lPTiAqLywgdkZvci5sb2MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGR1cGxpY2F0ZSBzdGF0aWMgbmFtZXNcbiAgICAgICAgICAgIGlmIChzdGF0aWNTbG90TmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuU2xvdE5hbWVzLmhhcyhzdGF0aWNTbG90TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzggLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9EVVBMSUNBVEVfU0xPVF9OQU1FUyAqLywgZGlyTG9jKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWVuU2xvdE5hbWVzLmFkZChzdGF0aWNTbG90TmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1Nsb3ROYW1lID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTmFtZWREZWZhdWx0U2xvdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xvdHNQcm9wZXJ0aWVzLnB1c2goY3JlYXRlT2JqZWN0UHJvcGVydHkoc2xvdE5hbWUsIHNsb3RGdW5jdGlvbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb25Db21wb25lbnRTbG90KSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSA9IChwcm9wcywgY2hpbGRyZW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gYnVpbGRTbG90Rm4ocHJvcHMsIGNoaWxkcmVuLCBsb2MpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuY29tcGF0Q29uZmlnKSB7XG4gICAgICAgICAgICAgICAgZm4uaXNOb25TY29wZWRTbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYmplY3RQcm9wZXJ0eShgZGVmYXVsdGAsIGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFoYXNUZW1wbGF0ZVNsb3RzKSB7XG4gICAgICAgICAgICAvLyBpbXBsaWNpdCBkZWZhdWx0IHNsb3QgKG9uIGNvbXBvbmVudClcbiAgICAgICAgICAgIHNsb3RzUHJvcGVydGllcy5wdXNoKGJ1aWxkRGVmYXVsdFNsb3RQcm9wZXJ0eSh1bmRlZmluZWQsIGNoaWxkcmVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgICAgICAvLyAjMzc2NlxuICAgICAgICAgICAgLy8gd2l0aCB3aGl0ZXNwYWNlOiAncHJlc2VydmUnLCB3aGl0ZXNwYWNlcyBiZXR3ZWVuIHNsb3RzIHdpbGwgZW5kIHVwIGluXG4gICAgICAgICAgICAvLyBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi4gSWdub3JlIGlmIGFsbCBpbXBsaWNpdCBjaGlsZHJlbiBhcmUgd2hpdGVzcGFjZXMuXG4gICAgICAgICAgICBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbi5zb21lKG5vZGUgPT4gaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlKSkpIHtcbiAgICAgICAgICAgIC8vIGltcGxpY2l0IGRlZmF1bHQgc2xvdCAobWl4ZWQgd2l0aCBuYW1lZCBzbG90cylcbiAgICAgICAgICAgIGlmIChoYXNOYW1lZERlZmF1bHRTbG90KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoMzkgLyogRXJyb3JDb2Rlcy5YX1ZfU0xPVF9FWFRSQU5FT1VTX0RFRkFVTFRfU0xPVF9DSElMRFJFTiAqLywgaW1wbGljaXREZWZhdWx0Q2hpbGRyZW5bMF0ubG9jKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbG90c1Byb3BlcnRpZXMucHVzaChidWlsZERlZmF1bHRTbG90UHJvcGVydHkodW5kZWZpbmVkLCBpbXBsaWNpdERlZmF1bHRDaGlsZHJlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNsb3RGbGFnID0gaGFzRHluYW1pY1Nsb3RzXG4gICAgICAgID8gMiAvKiBTbG90RmxhZ3MuRFlOQU1JQyAqL1xuICAgICAgICA6IGhhc0ZvcndhcmRlZFNsb3RzKG5vZGUuY2hpbGRyZW4pXG4gICAgICAgICAgICA/IDMgLyogU2xvdEZsYWdzLkZPUldBUkRFRCAqL1xuICAgICAgICAgICAgOiAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi87XG4gICAgbGV0IHNsb3RzID0gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihzbG90c1Byb3BlcnRpZXMuY29uY2F0KGNyZWF0ZU9iamVjdFByb3BlcnR5KGBfYCwgXG4gICAgLy8gMiA9IGNvbXBpbGVkIGJ1dCBkeW5hbWljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiwgYnV0IG11c3QgcnVuIGRpZmZcbiAgICAvLyAxID0gY29tcGlsZWQgYW5kIHN0YXRpYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24gQU5EIGRpZmYgYXMgb3B0aW1pemVkXG4gICAgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihzbG90RmxhZyArICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7c2xvdEZsYWdzVGV4dFtzbG90RmxhZ119ICovYCA6IGBgKSwgZmFsc2UpKSksIGxvYyk7XG4gICAgaWYgKGR5bmFtaWNTbG90cy5sZW5ndGgpIHtcbiAgICAgICAgc2xvdHMgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihDUkVBVEVfU0xPVFMpLCBbXG4gICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgIGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkeW5hbWljU2xvdHMpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzbG90cyxcbiAgICAgICAgaGFzRHluYW1pY1Nsb3RzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY1Nsb3QobmFtZSwgZm4sIGluZGV4KSB7XG4gICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBuYW1lYCwgbmFtZSksXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGBmbmAsIGZuKVxuICAgIF07XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcHMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShga2V5YCwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihTdHJpbmcoaW5kZXgpLCB0cnVlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihwcm9wcyk7XG59XG5mdW5jdGlvbiBoYXNGb3J3YXJkZWRTbG90cyhjaGlsZHJlbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgc3dpdGNoIChjaGlsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi86XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnRhZ1R5cGUgPT09IDIgLyogRWxlbWVudFR5cGVzLlNMT1QgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgaGFzRm9yd2FyZGVkU2xvdHMoY2hpbGQuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOSAvKiBOb2RlVHlwZXMuSUYgKi86XG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmJyYW5jaGVzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwIC8qIE5vZGVUeXBlcy5JRl9CUkFOQ0ggKi86XG4gICAgICAgICAgICBjYXNlIDExIC8qIE5vZGVUeXBlcy5GT1IgKi86XG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZvcndhcmRlZFNsb3RzKGNoaWxkLmNoaWxkcmVuKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOb25XaGl0ZXNwYWNlQ29udGVudChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gMiAvKiBOb2RlVHlwZXMuVEVYVCAqLyAmJiBub2RlLnR5cGUgIT09IDEyIC8qIE5vZGVUeXBlcy5URVhUX0NBTEwgKi8pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi9cbiAgICAgICAgPyAhIW5vZGUuY29udGVudC50cmltKClcbiAgICAgICAgOiBpc05vbldoaXRlc3BhY2VDb250ZW50KG5vZGUuY29udGVudCk7XG59XG5cbi8vIHNvbWUgZGlyZWN0aXZlIHRyYW5zZm9ybXMgKGUuZy4gdi1tb2RlbCkgbWF5IHJldHVybiBhIHN5bWJvbCBmb3IgcnVudGltZVxuLy8gaW1wb3J0LCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkIG9mIGEgcmVzb2x2ZURpcmVjdGl2ZSBjYWxsLlxuY29uc3QgZGlyZWN0aXZlSW1wb3J0TWFwID0gbmV3IFdlYWtNYXAoKTtcbi8vIGdlbmVyYXRlIGEgSmF2YVNjcmlwdCBBU1QgZm9yIHRoaXMgZWxlbWVudCdzIGNvZGVnZW5cbmNvbnN0IHRyYW5zZm9ybUVsZW1lbnQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIC8vIHBlcmZvcm0gdGhlIHdvcmsgb24gZXhpdCwgYWZ0ZXIgYWxsIGNoaWxkIGV4cHJlc3Npb25zIGhhdmUgYmVlblxuICAgIC8vIHByb2Nlc3NlZCBhbmQgbWVyZ2VkLlxuICAgIHJldHVybiBmdW5jdGlvbiBwb3N0VHJhbnNmb3JtRWxlbWVudCgpIHtcbiAgICAgICAgbm9kZSA9IGNvbnRleHQuY3VycmVudE5vZGU7XG4gICAgICAgIGlmICghKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgKG5vZGUudGFnVHlwZSA9PT0gMCAvKiBFbGVtZW50VHlwZXMuRUxFTUVOVCAqLyB8fFxuICAgICAgICAgICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRhZywgcHJvcHMgfSA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGlzQ29tcG9uZW50ID0gbm9kZS50YWdUeXBlID09PSAxIC8qIEVsZW1lbnRUeXBlcy5DT01QT05FTlQgKi87XG4gICAgICAgIC8vIFRoZSBnb2FsIG9mIHRoZSB0cmFuc2Zvcm0gaXMgdG8gY3JlYXRlIGEgY29kZWdlbk5vZGUgaW1wbGVtZW50aW5nIHRoZVxuICAgICAgICAvLyBWTm9kZUNhbGwgaW50ZXJmYWNlLlxuICAgICAgICBsZXQgdm5vZGVUYWcgPSBpc0NvbXBvbmVudFxuICAgICAgICAgICAgPyByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0KVxuICAgICAgICAgICAgOiBgXCIke3RhZ31cImA7XG4gICAgICAgIGNvbnN0IGlzRHluYW1pY0NvbXBvbmVudCA9IGlzT2JqZWN0KHZub2RlVGFnKSAmJiB2bm9kZVRhZy5jYWxsZWUgPT09IFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQ7XG4gICAgICAgIGxldCB2bm9kZVByb3BzO1xuICAgICAgICBsZXQgdm5vZGVDaGlsZHJlbjtcbiAgICAgICAgbGV0IHZub2RlUGF0Y2hGbGFnO1xuICAgICAgICBsZXQgcGF0Y2hGbGFnID0gMDtcbiAgICAgICAgbGV0IHZub2RlRHluYW1pY1Byb3BzO1xuICAgICAgICBsZXQgZHluYW1pY1Byb3BOYW1lcztcbiAgICAgICAgbGV0IHZub2RlRGlyZWN0aXZlcztcbiAgICAgICAgbGV0IHNob3VsZFVzZUJsb2NrID0gXG4gICAgICAgIC8vIGR5bmFtaWMgY29tcG9uZW50IG1heSByZXNvbHZlIHRvIHBsYWluIGVsZW1lbnRzXG4gICAgICAgIGlzRHluYW1pY0NvbXBvbmVudCB8fFxuICAgICAgICAgICAgdm5vZGVUYWcgPT09IFRFTEVQT1JUIHx8XG4gICAgICAgICAgICB2bm9kZVRhZyA9PT0gU1VTUEVOU0UgfHxcbiAgICAgICAgICAgICghaXNDb21wb25lbnQgJiZcbiAgICAgICAgICAgICAgICAvLyA8c3ZnPiBhbmQgPGZvcmVpZ25PYmplY3Q+IG11c3QgYmUgZm9yY2VkIGludG8gYmxvY2tzIHNvIHRoYXQgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIGluc2lkZSBnZXQgcHJvcGVyIGlzU1ZHIGZsYWcgYXQgcnVudGltZS4gKCM2MzksICM2NDMpXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSB3ZWItc3BlY2lmaWMsIGJ1dCBzcGxpdHRpbmcgdGhlIGxvZ2ljIG91dCBvZiBjb3JlXG4gICAgICAgICAgICAgICAgLy8gbGVhZHMgdG8gdG9vIG11Y2ggdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cbiAgICAgICAgICAgICAgICAodGFnID09PSAnc3ZnJyB8fCB0YWcgPT09ICdmb3JlaWduT2JqZWN0JykpO1xuICAgICAgICAvLyBwcm9wc1xuICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHNCdWlsZFJlc3VsdCA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgdW5kZWZpbmVkLCBpc0NvbXBvbmVudCwgaXNEeW5hbWljQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHZub2RlUHJvcHMgPSBwcm9wc0J1aWxkUmVzdWx0LnByb3BzO1xuICAgICAgICAgICAgcGF0Y2hGbGFnID0gcHJvcHNCdWlsZFJlc3VsdC5wYXRjaEZsYWc7XG4gICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzID0gcHJvcHNCdWlsZFJlc3VsdC5keW5hbWljUHJvcE5hbWVzO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IHByb3BzQnVpbGRSZXN1bHQuZGlyZWN0aXZlcztcbiAgICAgICAgICAgIHZub2RlRGlyZWN0aXZlcyA9XG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlcyAmJiBkaXJlY3RpdmVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihkaXJlY3RpdmVzLm1hcChkaXIgPT4gYnVpbGREaXJlY3RpdmVBcmdzKGRpciwgY29udGV4dCkpKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChwcm9wc0J1aWxkUmVzdWx0LnNob3VsZFVzZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoaWxkcmVuXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh2bm9kZVRhZyA9PT0gS0VFUF9BTElWRSkge1xuICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIGEgYnVpbHQtaW4gY29tcG9uZW50LCB3ZSBjb21waWxlIEtlZXBBbGl2ZSB3aXRoIHJhdyBjaGlsZHJlblxuICAgICAgICAgICAgICAgIC8vIGluc3RlYWQgb2Ygc2xvdCBmdW5jdGlvbnMgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbnNpZGUgVHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIC8vIG9yIG90aGVyIFRyYW5zaXRpb24td3JhcHBpbmcgSE9Dcy5cbiAgICAgICAgICAgICAgICAvLyBUbyBlbnN1cmUgY29ycmVjdCB1cGRhdGVzIHdpdGggYmxvY2sgb3B0aW1pemF0aW9ucywgd2UgbmVlZCB0bzpcbiAgICAgICAgICAgICAgICAvLyAxLiBGb3JjZSBrZWVwLWFsaXZlIGludG8gYSBibG9jay4gVGhpcyBhdm9pZHMgaXRzIGNoaWxkcmVuIGJlaW5nXG4gICAgICAgICAgICAgICAgLy8gICAgY29sbGVjdGVkIGJ5IGEgcGFyZW50IGJsb2NrLlxuICAgICAgICAgICAgICAgIHNob3VsZFVzZUJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyAyLiBGb3JjZSBrZWVwLWFsaXZlIHRvIGFsd2F5cyBiZSB1cGRhdGVkLCBzaW5jZSBpdCB1c2VzIHJhdyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgfD0gMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi87XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDYgLyogRXJyb3JDb2Rlcy5YX0tFRVBfQUxJVkVfSU5WQUxJRF9DSElMRFJFTiAqLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubG9jLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEJ1aWxkQXNTbG90cyA9IGlzQ29tcG9uZW50ICYmXG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgaXMgbm90IGEgcmVhbCBjb21wb25lbnQgYW5kIGhhcyBkZWRpY2F0ZWQgcnVudGltZSBoYW5kbGluZ1xuICAgICAgICAgICAgICAgIHZub2RlVGFnICE9PSBURUxFUE9SVCAmJlxuICAgICAgICAgICAgICAgIC8vIGV4cGxhaW5lZCBhYm92ZS5cbiAgICAgICAgICAgICAgICB2bm9kZVRhZyAhPT0gS0VFUF9BTElWRTtcbiAgICAgICAgICAgIGlmIChzaG91bGRCdWlsZEFzU2xvdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNsb3RzLCBoYXNEeW5hbWljU2xvdHMgfSA9IGJ1aWxkU2xvdHMobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IHNsb3RzO1xuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljU2xvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnIHw9IDEwMjQgLyogUGF0Y2hGbGFncy5EWU5BTUlDX1NMT1RTICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHZub2RlVGFnICE9PSBURUxFUE9SVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gY2hpbGQudHlwZTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHluYW1pYyB0ZXh0IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1RleHRDaGlsZCA9IHR5cGUgPT09IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLztcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHluYW1pY1RleHRDaGlsZCAmJlxuICAgICAgICAgICAgICAgICAgICBnZXRDb25zdGFudFR5cGUoY2hpbGQsIGNvbnRleHQpID09PSAwIC8qIENvbnN0YW50VHlwZXMuTk9UX0NPTlNUQU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAxIC8qIFBhdGNoRmxhZ3MuVEVYVCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcGFzcyBkaXJlY3RseSBpZiB0aGUgb25seSBjaGlsZCBpcyBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgIC8vIChwbGFpbiAvIGludGVycG9sYXRpb24gLyBleHByZXNzaW9uKVxuICAgICAgICAgICAgICAgIGlmIChoYXNEeW5hbWljVGV4dENoaWxkIHx8IHR5cGUgPT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGVDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGF0Y2hGbGFnICYgZHluYW1pY1Byb3BOYW1lc1xuICAgICAgICBpZiAocGF0Y2hGbGFnICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBmbGFncyAobmVnYXRpdmUgYW5kIG11dHVhbGx5IGV4Y2x1c2l2ZSlcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbcGF0Y2hGbGFnXX0gKi9gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0d2lzZSBmbGFnc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnTmFtZXMgPSBPYmplY3Qua2V5cyhQYXRjaEZsYWdOYW1lcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihuID0+IG4gPiAwICYmIHBhdGNoRmxhZyAmIG4pXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKG4gPT4gUGF0Y2hGbGFnTmFtZXNbbl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihgLCBgKTtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBwYXRjaEZsYWcgKyBgIC8qICR7ZmxhZ05hbWVzfSAqL2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm5vZGVQYXRjaEZsYWcgPSBTdHJpbmcocGF0Y2hGbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeW5hbWljUHJvcE5hbWVzICYmIGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdm5vZGVEeW5hbWljUHJvcHMgPSBzdHJpbmdpZnlEeW5hbWljUHJvcE5hbWVzKGR5bmFtaWNQcm9wTmFtZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUuY29kZWdlbk5vZGUgPSBjcmVhdGVWTm9kZUNhbGwoY29udGV4dCwgdm5vZGVUYWcsIHZub2RlUHJvcHMsIHZub2RlQ2hpbGRyZW4sIHZub2RlUGF0Y2hGbGFnLCB2bm9kZUR5bmFtaWNQcm9wcywgdm5vZGVEaXJlY3RpdmVzLCAhIXNob3VsZFVzZUJsb2NrLCBmYWxzZSAvKiBkaXNhYmxlVHJhY2tpbmcgKi8sIGlzQ29tcG9uZW50LCBub2RlLmxvYyk7XG4gICAgfTtcbn07XG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50VHlwZShub2RlLCBjb250ZXh0LCBzc3IgPSBmYWxzZSkge1xuICAgIGxldCB7IHRhZyB9ID0gbm9kZTtcbiAgICAvLyAxLiBkeW5hbWljIGNvbXBvbmVudFxuICAgIGNvbnN0IGlzRXhwbGljaXREeW5hbWljID0gaXNDb21wb25lbnRUYWcodGFnKTtcbiAgICBjb25zdCBpc1Byb3AgPSBmaW5kUHJvcChub2RlLCAnaXMnKTtcbiAgICBpZiAoaXNQcm9wKSB7XG4gICAgICAgIGlmIChpc0V4cGxpY2l0RHluYW1pYyB8fFxuICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSB7XG4gICAgICAgICAgICBjb25zdCBleHAgPSBpc1Byb3AudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovXG4gICAgICAgICAgICAgICAgPyBpc1Byb3AudmFsdWUgJiYgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihpc1Byb3AudmFsdWUuY29udGVudCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IGlzUHJvcC5leHA7XG4gICAgICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXG4gICAgICAgICAgICAgICAgICAgIGV4cFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJvcC50eXBlID09PSA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8gJiZcbiAgICAgICAgICAgIGlzUHJvcC52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkge1xuICAgICAgICAgICAgLy8gPGJ1dHRvbiBpcz1cInZ1ZTp4eHhcIj5cbiAgICAgICAgICAgIC8vIGlmIG5vdCA8Y29tcG9uZW50Piwgb25seSBpcyB2YWx1ZSB0aGF0IHN0YXJ0cyB3aXRoIFwidnVlOlwiIHdpbGwgYmVcbiAgICAgICAgICAgIC8vIHRyZWF0ZWQgYXMgY29tcG9uZW50IGJ5IHRoZSBwYXJzZSBwaGFzZSBhbmQgcmVhY2ggaGVyZSwgdW5sZXNzIGl0J3NcbiAgICAgICAgICAgIC8vIGNvbXBhdCBtb2RlIHdoZXJlIGFsbCBpcyB2YWx1ZXMgYXJlIGNvbnNpZGVyZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgdGFnID0gaXNQcm9wLnZhbHVlLmNvbnRlbnQuc2xpY2UoNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMS41IHYtaXMgKFRPRE86IERlcHJlY2F0ZSlcbiAgICBjb25zdCBpc0RpciA9ICFpc0V4cGxpY2l0RHluYW1pYyAmJiBmaW5kRGlyKG5vZGUsICdpcycpO1xuICAgIGlmIChpc0RpciAmJiBpc0Rpci5leHApIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFJFU09MVkVfRFlOQU1JQ19DT01QT05FTlQpLCBbXG4gICAgICAgICAgICBpc0Rpci5leHBcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIC8vIDIuIGJ1aWx0LWluIGNvbXBvbmVudHMgKFRlbGVwb3J0LCBUcmFuc2l0aW9uLCBLZWVwQWxpdmUsIFN1c3BlbnNlLi4uKVxuICAgIGNvbnN0IGJ1aWx0SW4gPSBpc0NvcmVDb21wb25lbnQodGFnKSB8fCBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudCh0YWcpO1xuICAgIGlmIChidWlsdEluKSB7XG4gICAgICAgIC8vIGJ1aWx0LWlucyBhcmUgc2ltcGx5IGZhbGx0aHJvdWdocyAvIGhhdmUgc3BlY2lhbCBoYW5kbGluZyBkdXJpbmcgc3NyXG4gICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gaW1wb3J0IHRoZWlyIHJ1bnRpbWUgZXF1aXZhbGVudHNcbiAgICAgICAgaWYgKCFzc3IpXG4gICAgICAgICAgICBjb250ZXh0LmhlbHBlcihidWlsdEluKTtcbiAgICAgICAgcmV0dXJuIGJ1aWx0SW47XG4gICAgfVxuICAgIC8vIDUuIHVzZXIgY29tcG9uZW50IChyZXNvbHZlKVxuICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfQ09NUE9ORU5UKTtcbiAgICBjb250ZXh0LmNvbXBvbmVudHMuYWRkKHRhZyk7XG4gICAgcmV0dXJuIHRvVmFsaWRBc3NldElkKHRhZywgYGNvbXBvbmVudGApO1xufVxuZnVuY3Rpb24gYnVpbGRQcm9wcyhub2RlLCBjb250ZXh0LCBwcm9wcyA9IG5vZGUucHJvcHMsIGlzQ29tcG9uZW50LCBpc0R5bmFtaWNDb21wb25lbnQsIHNzciA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyB0YWcsIGxvYzogZWxlbWVudExvYywgY2hpbGRyZW4gfSA9IG5vZGU7XG4gICAgbGV0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBtZXJnZUFyZ3MgPSBbXTtcbiAgICBjb25zdCBydW50aW1lRGlyZWN0aXZlcyA9IFtdO1xuICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoID4gMDtcbiAgICBsZXQgc2hvdWxkVXNlQmxvY2sgPSBmYWxzZTtcbiAgICAvLyBwYXRjaEZsYWcgYW5hbHlzaXNcbiAgICBsZXQgcGF0Y2hGbGFnID0gMDtcbiAgICBsZXQgaGFzUmVmID0gZmFsc2U7XG4gICAgbGV0IGhhc0NsYXNzQmluZGluZyA9IGZhbHNlO1xuICAgIGxldCBoYXNTdHlsZUJpbmRpbmcgPSBmYWxzZTtcbiAgICBsZXQgaGFzSHlkcmF0aW9uRXZlbnRCaW5kaW5nID0gZmFsc2U7XG4gICAgbGV0IGhhc0R5bmFtaWNLZXlzID0gZmFsc2U7XG4gICAgbGV0IGhhc1Zub2RlSG9vayA9IGZhbHNlO1xuICAgIGNvbnN0IGR5bmFtaWNQcm9wTmFtZXMgPSBbXTtcbiAgICBjb25zdCBwdXNoTWVyZ2VBcmcgPSAoYXJnKSA9PiB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goY3JlYXRlT2JqZWN0RXhwcmVzc2lvbihkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpLCBlbGVtZW50TG9jKSk7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZylcbiAgICAgICAgICAgIG1lcmdlQXJncy5wdXNoKGFyZyk7XG4gICAgfTtcbiAgICBjb25zdCBhbmFseXplUGF0Y2hGbGFnID0gKHsga2V5LCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0ga2V5LmNvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBpc0V2ZW50SGFuZGxlciA9IGlzT24obmFtZSk7XG4gICAgICAgICAgICBpZiAoaXNFdmVudEhhbmRsZXIgJiZcbiAgICAgICAgICAgICAgICAoIWlzQ29tcG9uZW50IHx8IGlzRHluYW1pY0NvbXBvbmVudCkgJiZcbiAgICAgICAgICAgICAgICAvLyBvbWl0IHRoZSBmbGFnIGZvciBjbGljayBoYW5kbGVycyBiZWNhdXNlIGh5ZHJhdGlvbiBnaXZlcyBjbGlja1xuICAgICAgICAgICAgICAgIC8vIGRlZGljYXRlZCBmYXN0IHBhdGguXG4gICAgICAgICAgICAgICAgbmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25jbGljaycgJiZcbiAgICAgICAgICAgICAgICAvLyBvbWl0IHYtbW9kZWwgaGFuZGxlcnNcbiAgICAgICAgICAgICAgICBuYW1lICE9PSAnb25VcGRhdGU6bW9kZWxWYWx1ZScgJiZcbiAgICAgICAgICAgICAgICAvLyBvbWl0IG9uVm5vZGVYWFggaG9va3NcbiAgICAgICAgICAgICAgICAhaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVyICYmIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaGFzVm5vZGVIb29rID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAyMCAvKiBOb2RlVHlwZXMuSlNfQ0FDSEVfRVhQUkVTU0lPTiAqLyB8fFxuICAgICAgICAgICAgICAgICgodmFsdWUudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9PT0gOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uc3RhbnRUeXBlKHZhbHVlLCBjb250ZXh0KSA+IDApKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBpcyBhIGNhY2hlZCBoYW5kbGVyIG9yIGhhcyBjb25zdGFudCB2YWx1ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgaGFzQ2xhc3NCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICBoYXNTdHlsZUJpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPT0gJ2tleScgJiYgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmVhdCB0aGUgZHluYW1pYyBjbGFzcyBhbmQgc3R5bGUgYmluZGluZyBvZiB0aGUgY29tcG9uZW50IGFzIGR5bmFtaWMgcHJvcHNcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCAmJlxuICAgICAgICAgICAgICAgIChuYW1lID09PSAnY2xhc3MnIHx8IG5hbWUgPT09ICdzdHlsZScpICYmXG4gICAgICAgICAgICAgICAgIWR5bmFtaWNQcm9wTmFtZXMuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljUHJvcE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gc3RhdGljIGF0dHJpYnV0ZVxuICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIGlmIChwcm9wLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLykge1xuICAgICAgICAgICAgY29uc3QgeyBsb2MsIG5hbWUsIHZhbHVlIH0gPSBwcm9wO1xuICAgICAgICAgICAgbGV0IGlzU3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAncmVmJykge1xuICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChjcmVhdGVPYmplY3RQcm9wZXJ0eShjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCdyZWZfZm9yJywgdHJ1ZSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ3RydWUnKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgaXMgb24gPGNvbXBvbmVudD4sIG9yIGlzPVwidnVlOnh4eFwiXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lzJyAmJlxuICAgICAgICAgICAgICAgIChpc0NvbXBvbmVudFRhZyh0YWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZSAmJiB2YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoJ3Z1ZTonKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfSVNfT05fRUxFTUVOVCAqLywgY29udGV4dCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24obmFtZSwgdHJ1ZSwgZ2V0SW5uZXJSYW5nZShsb2MsIDAsIG5hbWUubGVuZ3RoKSksIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24odmFsdWUgPyB2YWx1ZS5jb250ZW50IDogJycsIGlzU3RhdGljLCB2YWx1ZSA/IHZhbHVlLmxvYyA6IGxvYykpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYXJnLCBleHAsIGxvYyB9ID0gcHJvcDtcbiAgICAgICAgICAgIGNvbnN0IGlzVkJpbmQgPSBuYW1lID09PSAnYmluZCc7XG4gICAgICAgICAgICBjb25zdCBpc1ZPbiA9IG5hbWUgPT09ICdvbic7XG4gICAgICAgICAgICAvLyBza2lwIHYtc2xvdCAtIGl0IGlzIGhhbmRsZWQgYnkgaXRzIGRlZGljYXRlZCB0cmFuc2Zvcm0uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0MCAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX01JU1BMQUNFRCAqLywgbG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2tpcCB2LW9uY2Uvdi1tZW1vIC0gdGhleSBhcmUgaGFuZGxlZCBieSBkZWRpY2F0ZWQgdHJhbnNmb3Jtcy5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnb25jZScgfHwgbmFtZSA9PT0gJ21lbW8nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIHYtaXMgYW5kIDppcyBvbiA8Y29tcG9uZW50PlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpcycgfHxcbiAgICAgICAgICAgICAgICAoaXNWQmluZCAmJlxuICAgICAgICAgICAgICAgICAgICBpc1N0YXRpY0FyZ09mKGFyZywgJ2lzJykgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29tcG9uZW50VGFnKHRhZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9JU19PTl9FTEVNRU5UXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0lTX09OX0VMRU1FTlQgKi8sIGNvbnRleHQpKSkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBza2lwIHYtb24gaW4gU1NSIGNvbXBpbGF0aW9uXG4gICAgICAgICAgICBpZiAoaXNWT24gJiYgc3NyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXG4gICAgICAgICAgICAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ2tleScpKSB8fFxuICAgICAgICAgICAgICAgIC8vIGlubGluZSBiZWZvcmUtdXBkYXRlIGhvb2tzIG5lZWQgdG8gZm9yY2UgYmxvY2sgc28gdGhhdCBpdCBpcyBpbnZva2VkXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgKGlzVk9uICYmIGhhc0NoaWxkcmVuICYmIGlzU3RhdGljQXJnT2YoYXJnLCAndnVlOmJlZm9yZS11cGRhdGUnKSkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRVc2VCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWQmluZCAmJiBpc1N0YXRpY0FyZ09mKGFyZywgJ3JlZicpICYmIGNvbnRleHQuc2NvcGVzLnZGb3IgPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ3JlZl9mb3InLCB0cnVlKSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbigndHJ1ZScpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHYtYmluZCBhbmQgdi1vbiB3aXRoIG5vIGFyZ3VtZW50XG4gICAgICAgICAgICBpZiAoIWFyZyAmJiAoaXNWQmluZCB8fCBpc1ZPbikpIHtcbiAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWQmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBtZXJnZSBlYXJseSBmb3IgY29tcGF0IGJ1aWxkIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoTWVyZ2VBcmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLnggdi1iaW5kIG9iamVjdCBvcmRlciBjb21wYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc092ZXJyaWRhYmxlS2V5cyA9IG1lcmdlQXJncy5zb21lKGFyZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcucHJvcGVydGllcy5zb21lKCh7IGtleSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSAhPT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFrZXkuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoa2V5LmNvbnRlbnQgIT09ICdjbGFzcycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5jb250ZW50ICE9PSAnc3R5bGUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNPbihrZXkuY29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3ZlcnJpZGFibGVLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX0JJTkRfT0JKRUNUX09SREVSXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVIgKi8sIGNvbnRleHQsIGxvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIiAvKiBDb21waWxlckRlcHJlY2F0aW9uVHlwZXMuQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUiAqLywgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnVuc2hpZnQoZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcmdzLnB1c2goZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtb249XCJvYmpcIiAtPiB0b0hhbmRsZXJzKG9iailcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hNZXJnZUFyZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBjb250ZXh0LmhlbHBlcihUT19IQU5ETEVSUyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBpc0NvbXBvbmVudCA/IFtleHBdIDogW2V4cCwgYHRydWVgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKGlzVkJpbmRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMzQgLyogRXJyb3JDb2Rlcy5YX1ZfQklORF9OT19FWFBSRVNTSU9OICovXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDM1IC8qIEVycm9yQ29kZXMuWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZVRyYW5zZm9ybSA9IGNvbnRleHQuZGlyZWN0aXZlVHJhbnNmb3Jtc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmVUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICAvLyBoYXMgYnVpbHQtaW4gZGlyZWN0aXZlIHRyYW5zZm9ybS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzLCBuZWVkUnVudGltZSB9ID0gZGlyZWN0aXZlVHJhbnNmb3JtKHByb3AsIG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICFzc3IgJiYgcHJvcHMuZm9yRWFjaChhbmFseXplUGF0Y2hGbGFnKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWT24gJiYgYXJnICYmICFpc1N0YXRpY0V4cChhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hNZXJnZUFyZyhjcmVhdGVPYmplY3RFeHByZXNzaW9uKHByb3BzLCBlbGVtZW50TG9jKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goLi4ucHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZURpcmVjdGl2ZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ltYm9sKG5lZWRSdW50aW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlSW1wb3J0TWFwLnNldChwcm9wLCBuZWVkUnVudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNCdWlsdEluRGlyZWN0aXZlKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gYnVpbHQtaW4gdHJhbnNmb3JtLCB0aGlzIGlzIGEgdXNlciBjdXN0b20gZGlyZWN0aXZlLlxuICAgICAgICAgICAgICAgIHJ1bnRpbWVEaXJlY3RpdmVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tIGRpcnMgbWF5IHVzZSBiZWZvcmVVcGRhdGUgc28gdGhleSBuZWVkIHRvIGZvcmNlIGJsb2Nrc1xuICAgICAgICAgICAgICAgIC8vIHRvIGVuc3VyZSBiZWZvcmUtdXBkYXRlIGdldHMgY2FsbGVkIGJlZm9yZSBjaGlsZHJlbiB1cGRhdGVcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXNlQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJvcHNFeHByZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgIC8vIGhhcyB2LWJpbmQ9XCJvYmplY3RcIiBvciB2LW9uPVwib2JqZWN0XCIsIHdyYXAgd2l0aCBtZXJnZVByb3BzXG4gICAgaWYgKG1lcmdlQXJncy5sZW5ndGgpIHtcbiAgICAgICAgLy8gY2xvc2UgdXAgYW55IG5vdC15ZXQtbWVyZ2VkIHByb3BzXG4gICAgICAgIHB1c2hNZXJnZUFyZygpO1xuICAgICAgICBpZiAobWVyZ2VBcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE1FUkdFX1BST1BTKSwgbWVyZ2VBcmdzLCBlbGVtZW50TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2LWJpbmQgd2l0aCBub3RoaW5nIGVsc2UgLSBubyBuZWVkIGZvciBhIG1lcmdlUHJvcHMgY2FsbFxuICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gbWVyZ2VBcmdzWzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGVkdXBlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSwgZWxlbWVudExvYyk7XG4gICAgfVxuICAgIC8vIHBhdGNoRmxhZyBhbmFseXNpc1xuICAgIGlmIChoYXNEeW5hbWljS2V5cykge1xuICAgICAgICBwYXRjaEZsYWcgfD0gMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGhhc0NsYXNzQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAyIC8qIFBhdGNoRmxhZ3MuQ0xBU1MgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0eWxlQmluZGluZyAmJiAhaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSA0IC8qIFBhdGNoRmxhZ3MuU1RZTEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR5bmFtaWNQcm9wTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRjaEZsYWcgfD0gOCAvKiBQYXRjaEZsYWdzLlBST1BTICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNIeWRyYXRpb25FdmVudEJpbmRpbmcpIHtcbiAgICAgICAgICAgIHBhdGNoRmxhZyB8PSAzMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2hvdWxkVXNlQmxvY2sgJiZcbiAgICAgICAgKHBhdGNoRmxhZyA9PT0gMCB8fCBwYXRjaEZsYWcgPT09IDMyIC8qIFBhdGNoRmxhZ3MuSFlEUkFURV9FVkVOVFMgKi8pICYmXG4gICAgICAgIChoYXNSZWYgfHwgaGFzVm5vZGVIb29rIHx8IHJ1bnRpbWVEaXJlY3RpdmVzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgIHBhdGNoRmxhZyB8PSA1MTIgLyogUGF0Y2hGbGFncy5ORUVEX1BBVENIICovO1xuICAgIH1cbiAgICAvLyBwcmUtbm9ybWFsaXplIHByb3BzLCBTU1IgaXMgc2tpcHBlZCBmb3Igbm93XG4gICAgaWYgKCFjb250ZXh0LmluU1NSICYmIHByb3BzRXhwcmVzc2lvbikge1xuICAgICAgICBzd2l0Y2ggKHByb3BzRXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE1IC8qIE5vZGVUeXBlcy5KU19PQkpFQ1RfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgICAgICAvLyBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIHYtYmluZCxcbiAgICAgICAgICAgICAgICAvLyBidXQgc3RpbGwgbmVlZCB0byBkZWFsIHdpdGggZHluYW1pYyBrZXkgYmluZGluZ1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc0tleUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlS2V5SW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzRHluYW1pY0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNFeHByZXNzaW9uLnByb3BlcnRpZXNbaV0ua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdGF0aWNFeHAoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5jb250ZW50ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NLZXlJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkuY29udGVudCA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlS2V5SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFrZXkuaXNIYW5kbGVyS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNEeW5hbWljS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc1Byb3AgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tjbGFzc0tleUluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVByb3AgPSBwcm9wc0V4cHJlc3Npb24ucHJvcGVydGllc1tzdHlsZUtleUluZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBubyBkeW5hbWljIGtleVxuICAgICAgICAgICAgICAgIGlmICghaGFzRHluYW1pY0tleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NQcm9wICYmICFpc1N0YXRpY0V4cChjbGFzc1Byb3AudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc1Byb3AudmFsdWUgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihOT1JNQUxJWkVfQ0xBU1MpLCBbY2xhc3NQcm9wLnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlUHJvcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0YXRpYyBzdHlsZSBpcyBjb21waWxlZCBpbnRvIGFuIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBgaGFzU3R5bGVCaW5kaW5nYCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhIGR5bmFtaWMgc3R5bGUgYmluZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKGhhc1N0eWxlQmluZGluZyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHlsZVByb3AudmFsdWUudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVQcm9wLnZhbHVlLmNvbnRlbnQudHJpbSgpWzBdID09PSBgW2ApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdi1iaW5kOnN0eWxlIGFuZCBzdHlsZSBib3RoIGV4aXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHYtYmluZDpzdHlsZSB3aXRoIHN0YXRpYyBsaXRlcmFsIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZS50eXBlID09PSAxNyAvKiBOb2RlVHlwZXMuSlNfQVJSQVlfRVhQUkVTU0lPTiAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUHJvcC52YWx1ZSA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9TVFlMRSksIFtzdHlsZVByb3AudmFsdWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pYyBrZXkgYmluZGluZywgd3JhcCB3aXRoIGBub3JtYWxpemVQcm9wc2BcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNFeHByZXNzaW9uID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoTk9STUFMSVpFX1BST1BTKSwgW3Byb3BzRXhwcmVzc2lvbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTQgLyogTm9kZVR5cGVzLkpTX0NBTExfRVhQUkVTU0lPTiAqLzpcbiAgICAgICAgICAgICAgICAvLyBtZXJnZVByb3BzIGNhbGwsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gc2luZ2xlIHYtYmluZFxuICAgICAgICAgICAgICAgIHByb3BzRXhwcmVzc2lvbiA9IGNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKE5PUk1BTElaRV9QUk9QUyksIFtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoR1VBUkRfUkVBQ1RJVkVfUFJPUFMpLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc0V4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogcHJvcHNFeHByZXNzaW9uLFxuICAgICAgICBkaXJlY3RpdmVzOiBydW50aW1lRGlyZWN0aXZlcyxcbiAgICAgICAgcGF0Y2hGbGFnLFxuICAgICAgICBkeW5hbWljUHJvcE5hbWVzLFxuICAgICAgICBzaG91bGRVc2VCbG9ja1xuICAgIH07XG59XG4vLyBEZWR1cGUgcHJvcHMgaW4gYW4gb2JqZWN0IGxpdGVyYWwuXG4vLyBMaXRlcmFsIGR1cGxpY2F0ZWQgYXR0cmlidXRlcyB3b3VsZCBoYXZlIGJlZW4gd2FybmVkIGR1cmluZyB0aGUgcGFyc2UgcGhhc2UsXG4vLyBob3dldmVyLCBpdCdzIHBvc3NpYmxlIHRvIGVuY291bnRlciBkdXBsaWNhdGVkIGBvblhYWGAgaGFuZGxlcnMgd2l0aCBkaWZmZXJlbnRcbi8vIG1vZGlmaWVycy4gV2UgYWxzbyBuZWVkIHRvIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBjbGFzcyAvIHN0eWxlIGF0dHJpYnV0ZXMuXG4vLyAtIG9uWFhYIGhhbmRsZXJzIC8gc3R5bGU6IG1lcmdlIGludG8gYXJyYXlcbi8vIC0gY2xhc3M6IG1lcmdlIGludG8gc2luZ2xlIGV4cHJlc3Npb24gd2l0aCBjb25jYXRlbmF0aW9uXG5mdW5jdGlvbiBkZWR1cGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBrbm93blByb3BzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlZHVwZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgIC8vIGR5bmFtaWMga2V5cyBhcmUgYWx3YXlzIGFsbG93ZWRcbiAgICAgICAgaWYgKHByb3Aua2V5LnR5cGUgPT09IDggLyogTm9kZVR5cGVzLkNPTVBPVU5EX0VYUFJFU1NJT04gKi8gfHwgIXByb3Aua2V5LmlzU3RhdGljKSB7XG4gICAgICAgICAgICBkZWR1cGVkLnB1c2gocHJvcCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gcHJvcC5rZXkuY29udGVudDtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBrbm93blByb3BzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJyB8fCBuYW1lID09PSAnY2xhc3MnIHx8IGlzT24obmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUFzQXJyYXkoZXhpc3RpbmcsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdW5leHBlY3RlZCBkdXBsaWNhdGUsIHNob3VsZCBoYXZlIGVtaXR0ZWQgZXJyb3IgZHVyaW5nIHBhcnNlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrbm93blByb3BzLnNldChuYW1lLCBwcm9wKTtcbiAgICAgICAgICAgIGRlZHVwZWQucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVkdXBlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlQXNBcnJheShleGlzdGluZywgaW5jb21pbmcpIHtcbiAgICBpZiAoZXhpc3RpbmcudmFsdWUudHlwZSA9PT0gMTcgLyogTm9kZVR5cGVzLkpTX0FSUkFZX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgZXhpc3RpbmcudmFsdWUuZWxlbWVudHMucHVzaChpbmNvbWluZy52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleGlzdGluZy52YWx1ZSA9IGNyZWF0ZUFycmF5RXhwcmVzc2lvbihbZXhpc3RpbmcudmFsdWUsIGluY29taW5nLnZhbHVlXSwgZXhpc3RpbmcubG9jKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERpcmVjdGl2ZUFyZ3MoZGlyLCBjb250ZXh0KSB7XG4gICAgY29uc3QgZGlyQXJncyA9IFtdO1xuICAgIGNvbnN0IHJ1bnRpbWUgPSBkaXJlY3RpdmVJbXBvcnRNYXAuZ2V0KGRpcik7XG4gICAgaWYgKHJ1bnRpbWUpIHtcbiAgICAgICAgLy8gYnVpbHQtaW4gZGlyZWN0aXZlIHdpdGggcnVudGltZVxuICAgICAgICBkaXJBcmdzLnB1c2goY29udGV4dC5oZWxwZXJTdHJpbmcocnVudGltZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gaW5qZWN0IHN0YXRlbWVudCBmb3IgcmVzb2x2aW5nIGRpcmVjdGl2ZVxuICAgICAgICAgICAgY29udGV4dC5oZWxwZXIoUkVTT0xWRV9ESVJFQ1RJVkUpO1xuICAgICAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzLmFkZChkaXIubmFtZSk7XG4gICAgICAgICAgICBkaXJBcmdzLnB1c2godG9WYWxpZEFzc2V0SWQoZGlyLm5hbWUsIGBkaXJlY3RpdmVgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBsb2MgfSA9IGRpcjtcbiAgICBpZiAoZGlyLmV4cClcbiAgICAgICAgZGlyQXJncy5wdXNoKGRpci5leHApO1xuICAgIGlmIChkaXIuYXJnKSB7XG4gICAgICAgIGlmICghZGlyLmV4cCkge1xuICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcbiAgICAgICAgfVxuICAgICAgICBkaXJBcmdzLnB1c2goZGlyLmFyZyk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzKS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFkaXIuYXJnKSB7XG4gICAgICAgICAgICBpZiAoIWRpci5leHApIHtcbiAgICAgICAgICAgICAgICBkaXJBcmdzLnB1c2goYHZvaWQgMGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlyQXJncy5wdXNoKGB2b2lkIDBgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cnVlRXhwcmVzc2lvbiA9IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHRydWVgLCBmYWxzZSwgbG9jKTtcbiAgICAgICAgZGlyQXJncy5wdXNoKGNyZWF0ZU9iamVjdEV4cHJlc3Npb24oZGlyLm1vZGlmaWVycy5tYXAobW9kaWZpZXIgPT4gY3JlYXRlT2JqZWN0UHJvcGVydHkobW9kaWZpZXIsIHRydWVFeHByZXNzaW9uKSksIGxvYykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQXJyYXlFeHByZXNzaW9uKGRpckFyZ3MsIGRpci5sb2MpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5RHluYW1pY1Byb3BOYW1lcyhwcm9wcykge1xuICAgIGxldCBwcm9wc05hbWVzU3RyaW5nID0gYFtgO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcHJvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHByb3BzTmFtZXNTdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkocHJvcHNbaV0pO1xuICAgICAgICBpZiAoaSA8IGwgLSAxKVxuICAgICAgICAgICAgcHJvcHNOYW1lc1N0cmluZyArPSAnLCAnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHNOYW1lc1N0cmluZyArIGBdYDtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9uZW50VGFnKHRhZykge1xuICAgIHJldHVybiB0YWcgPT09ICdjb21wb25lbnQnIHx8IHRhZyA9PT0gJ0NvbXBvbmVudCc7XG59XG5cbihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcbiAgICA6IHt9O1xuKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgICB9KTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xufSk7XG5cbmNvbnN0IHRyYW5zZm9ybVNsb3RPdXRsZXQgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChpc1Nsb3RPdXRsZXQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgbG9jIH0gPSBub2RlO1xuICAgICAgICBjb25zdCB7IHNsb3ROYW1lLCBzbG90UHJvcHMgfSA9IHByb2Nlc3NTbG90T3V0bGV0KG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBzbG90QXJncyA9IFtcbiAgICAgICAgICAgIGNvbnRleHQucHJlZml4SWRlbnRpZmllcnMgPyBgX2N0eC4kc2xvdHNgIDogYCRzbG90c2AsXG4gICAgICAgICAgICBzbG90TmFtZSxcbiAgICAgICAgICAgICd7fScsXG4gICAgICAgICAgICAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICd0cnVlJ1xuICAgICAgICBdO1xuICAgICAgICBsZXQgZXhwZWN0ZWRMZW4gPSAyO1xuICAgICAgICBpZiAoc2xvdFByb3BzKSB7XG4gICAgICAgICAgICBzbG90QXJnc1syXSA9IHNsb3RQcm9wcztcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBzbG90QXJnc1szXSA9IGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbihbXSwgY2hpbGRyZW4sIGZhbHNlLCBmYWxzZSwgbG9jKTtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5zY29wZUlkICYmICFjb250ZXh0LnNsb3R0ZWQpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuID0gNTtcbiAgICAgICAgfVxuICAgICAgICBzbG90QXJncy5zcGxpY2UoZXhwZWN0ZWRMZW4pOyAvLyByZW1vdmUgdW51c2VkIGFyZ3VtZW50c1xuICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoUkVOREVSX1NMT1QpLCBzbG90QXJncywgbG9jKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQobm9kZSwgY29udGV4dCkge1xuICAgIGxldCBzbG90TmFtZSA9IGBcImRlZmF1bHRcImA7XG4gICAgbGV0IHNsb3RQcm9wcyA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub25OYW1lUHJvcHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcCA9IG5vZGUucHJvcHNbaV07XG4gICAgICAgIGlmIChwLnR5cGUgPT09IDYgLyogTm9kZVR5cGVzLkFUVFJJQlVURSAqLykge1xuICAgICAgICAgICAgaWYgKHAudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnbmFtZScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xvdE5hbWUgPSBKU09OLnN0cmluZ2lmeShwLnZhbHVlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcC5uYW1lID0gY2FtZWxpemUocC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHAubmFtZSA9PT0gJ2JpbmQnICYmIGlzU3RhdGljQXJnT2YocC5hcmcsICduYW1lJykpIHtcbiAgICAgICAgICAgICAgICBpZiAocC5leHApXG4gICAgICAgICAgICAgICAgICAgIHNsb3ROYW1lID0gcC5leHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocC5uYW1lID09PSAnYmluZCcgJiYgcC5hcmcgJiYgaXNTdGF0aWNFeHAocC5hcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZShwLmFyZy5jb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9uTmFtZVByb3BzLnB1c2gocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vbk5hbWVQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGRpcmVjdGl2ZXMgfSA9IGJ1aWxkUHJvcHMobm9kZSwgY29udGV4dCwgbm9uTmFtZVByb3BzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBzbG90UHJvcHMgPSBwcm9wcztcbiAgICAgICAgaWYgKGRpcmVjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNiAvKiBFcnJvckNvZGVzLlhfVl9TTE9UX1VORVhQRUNURURfRElSRUNUSVZFX09OX1NMT1RfT1VUTEVUICovLCBkaXJlY3RpdmVzWzBdLmxvYykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNsb3ROYW1lLFxuICAgICAgICBzbG90UHJvcHNcbiAgICB9O1xufVxuXG5jb25zdCBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfChhc3luY1xccyopP1xcKFteKV0qP1xcKSlcXHMqKDpbXj1dKyk/PT58XlxccyooYXN5bmNcXHMrKT9mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcbmNvbnN0IHRyYW5zZm9ybU9uID0gKGRpciwgbm9kZSwgY29udGV4dCwgYXVnbWVudG9yKSA9PiB7XG4gICAgY29uc3QgeyBsb2MsIG1vZGlmaWVycywgYXJnIH0gPSBkaXI7XG4gICAgaWYgKCFkaXIuZXhwICYmICFtb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDM1IC8qIEVycm9yQ29kZXMuWF9WX09OX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgIH1cbiAgICBsZXQgZXZlbnROYW1lO1xuICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xuICAgICAgICAgICAgbGV0IHJhd05hbWUgPSBhcmcuY29udGVudDtcbiAgICAgICAgICAgIC8vIFRPRE8gZGVwcmVjYXRlIEB2bm9kZVhYWCB1c2FnZVxuICAgICAgICAgICAgaWYgKHJhd05hbWUuc3RhcnRzV2l0aCgndnVlOicpKSB7XG4gICAgICAgICAgICAgICAgcmF3TmFtZSA9IGB2bm9kZS0ke3Jhd05hbWUuc2xpY2UoNCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50U3RyaW5nID0gbm9kZS50YWdUeXBlICE9PSAwIC8qIEVsZW1lbnRUeXBlcy5FTEVNRU5UICovIHx8XG4gICAgICAgICAgICAgICAgcmF3TmFtZS5zdGFydHNXaXRoKCd2bm9kZScpIHx8XG4gICAgICAgICAgICAgICAgIS9bQS1aXS8udGVzdChyYXdOYW1lKVxuICAgICAgICAgICAgICAgID8gLy8gZm9yIG5vbi1lbGVtZW50IGFuZCB2bm9kZSBsaWZlY3ljbGUgZXZlbnQgbGlzdGVuZXJzLCBhdXRvIGNvbnZlcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgdG8gY2FtZWxDYXNlLiBTZWUgaXNzdWUgIzIyNDlcbiAgICAgICAgICAgICAgICAgICAgdG9IYW5kbGVyS2V5KGNhbWVsaXplJDEocmF3TmFtZSkpXG4gICAgICAgICAgICAgICAgOiAvLyBwcmVzZXJ2ZSBjYXNlIGZvciBwbGFpbiBlbGVtZW50IGxpc3RlbmVycyB0aGF0IGhhdmUgdXBwZXJjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldHRlcnMsIGFzIHRoZXNlIG1heSBiZSBjdXN0b20gZWxlbWVudHMnIGN1c3RvbSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgYG9uOiR7cmF3TmFtZX1gO1xuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudFN0cmluZywgdHJ1ZSwgYXJnLmxvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyAjMjM4OFxuICAgICAgICAgICAgZXZlbnROYW1lID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgICBgJHtjb250ZXh0LmhlbHBlclN0cmluZyhUT19IQU5ETEVSX0tFWSl9KGAsXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGApYFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGFscmVhZHkgYSBjb21wb3VuZCBleHByZXNzaW9uLlxuICAgICAgICBldmVudE5hbWUgPSBhcmc7XG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi51bnNoaWZ0KGAke2NvbnRleHQuaGVscGVyU3RyaW5nKFRPX0hBTkRMRVJfS0VZKX0oYCk7XG4gICAgICAgIGV2ZW50TmFtZS5jaGlsZHJlbi5wdXNoKGApYCk7XG4gICAgfVxuICAgIC8vIGhhbmRsZXIgcHJvY2Vzc2luZ1xuICAgIGxldCBleHAgPSBkaXIuZXhwO1xuICAgIGlmIChleHAgJiYgIWV4cC5jb250ZW50LnRyaW0oKSkge1xuICAgICAgICBleHAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBzaG91bGRDYWNoZSA9IGNvbnRleHQuY2FjaGVIYW5kbGVycyAmJiAhZXhwICYmICFjb250ZXh0LmluVk9uY2U7XG4gICAgaWYgKGV4cCkge1xuICAgICAgICBjb25zdCBpc01lbWJlckV4cCA9IGlzTWVtYmVyRXhwcmVzc2lvbihleHAuY29udGVudCk7XG4gICAgICAgIGNvbnN0IGlzSW5saW5lU3RhdGVtZW50ID0gIShpc01lbWJlckV4cCB8fCBmbkV4cFJFLnRlc3QoZXhwLmNvbnRlbnQpKTtcbiAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVTdGF0ZW1lbnRzID0gZXhwLmNvbnRlbnQuaW5jbHVkZXMoYDtgKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0cnVlKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUJyb3dzZXJFeHByZXNzaW9uKGV4cCwgY29udGV4dCwgZmFsc2UsIGhhc011bHRpcGxlU3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5saW5lU3RhdGVtZW50IHx8IChzaG91bGRDYWNoZSAmJiBpc01lbWJlckV4cCkpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgaW5saW5lIHN0YXRlbWVudCBpbiBhIGZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICAgICAgICAgIGV4cCA9IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXG4gICAgICAgICAgICAgICAgYCR7aXNJbmxpbmVTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgPyBgJGV2ZW50YFxuICAgICAgICAgICAgICAgICAgICA6IGAke2BgfSguLi5hcmdzKWB9ID0+ICR7aGFzTXVsdGlwbGVTdGF0ZW1lbnRzID8gYHtgIDogYChgfWAsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGhhc011bHRpcGxlU3RhdGVtZW50cyA/IGB9YCA6IGApYFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJldCA9IHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KGV2ZW50TmFtZSwgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCgpID0+IHt9YCwgZmFsc2UsIGxvYykpXG4gICAgICAgIF1cbiAgICB9O1xuICAgIC8vIGFwcGx5IGV4dGVuZGVkIGNvbXBpbGVyIGF1Z21lbnRvclxuICAgIGlmIChhdWdtZW50b3IpIHtcbiAgICAgICAgcmV0ID0gYXVnbWVudG9yKHJldCk7XG4gICAgfVxuICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICAvLyBjYWNoZSBoYW5kbGVycyBzbyB0aGF0IGl0J3MgYWx3YXlzIHRoZSBzYW1lIGhhbmRsZXIgYmVpbmcgcGFzc2VkIGRvd24uXG4gICAgICAgIC8vIHRoaXMgYXZvaWRzIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgd2hlbiB1c2VycyB1c2UgaW5saW5lIGhhbmRsZXJzIG9uXG4gICAgICAgIC8vIGNvbXBvbmVudHMuXG4gICAgICAgIHJldC5wcm9wc1swXS52YWx1ZSA9IGNvbnRleHQuY2FjaGUocmV0LnByb3BzWzBdLnZhbHVlKTtcbiAgICB9XG4gICAgLy8gbWFyayB0aGUga2V5IGFzIGhhbmRsZXIgZm9yIHByb3BzIG5vcm1hbGl6YXRpb24gY2hlY2tcbiAgICByZXQucHJvcHMuZm9yRWFjaChwID0+IChwLmtleS5pc0hhbmRsZXJLZXkgPSB0cnVlKSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8vIHYtYmluZCB3aXRob3V0IGFyZyBpcyBoYW5kbGVkIGRpcmVjdGx5IGluIC4vdHJhbnNmb3JtRWxlbWVudHMudHMgZHVlIHRvIGl0IGFmZmVjdGluZ1xuLy8gY29kZWdlbiBmb3IgdGhlIGVudGlyZSBwcm9wcyBvYmplY3QuIFRoaXMgdHJhbnNmb3JtIGhlcmUgaXMgb25seSBmb3Igdi1iaW5kXG4vLyAqd2l0aCogYXJncy5cbmNvbnN0IHRyYW5zZm9ybUJpbmQgPSAoZGlyLCBfbm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IHsgZXhwLCBtb2RpZmllcnMsIGxvYyB9ID0gZGlyO1xuICAgIGNvbnN0IGFyZyA9IGRpci5hcmc7XG4gICAgaWYgKGFyZy50eXBlICE9PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgKGApO1xuICAgICAgICBhcmcuY2hpbGRyZW4ucHVzaChgKSB8fCBcIlwiYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhcmcuaXNTdGF0aWMpIHtcbiAgICAgICAgYXJnLmNvbnRlbnQgPSBgJHthcmcuY29udGVudH0gfHwgXCJcImA7XG4gICAgfVxuICAgIC8vIC5zeW5jIGlzIHJlcGxhY2VkIGJ5IHYtbW9kZWw6YXJnXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSkge1xuICAgICAgICBpZiAoYXJnLnR5cGUgPT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICBpZiAoYXJnLmlzU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBjYW1lbGl6ZSQxKGFyZy5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfSgke2FyZy5jb250ZW50fSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXJnLmNoaWxkcmVuLnVuc2hpZnQoYCR7Y29udGV4dC5oZWxwZXJTdHJpbmcoQ0FNRUxJWkUpfShgKTtcbiAgICAgICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb250ZXh0LmluU1NSKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3Byb3AnKSkge1xuICAgICAgICAgICAgaW5qZWN0UHJlZml4KGFyZywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdhdHRyJykpIHtcbiAgICAgICAgICAgIGluamVjdFByZWZpeChhcmcsICdeJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFleHAgfHxcbiAgICAgICAgKGV4cC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyAmJiAhZXhwLmNvbnRlbnQudHJpbSgpKSkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcigzNCAvKiBFcnJvckNvZGVzLlhfVl9CSU5EX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShhcmcsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUsIGxvYykpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogW2NyZWF0ZU9iamVjdFByb3BlcnR5KGFyZywgZXhwKV1cbiAgICB9O1xufTtcbmNvbnN0IGluamVjdFByZWZpeCA9IChhcmcsIHByZWZpeCkgPT4ge1xuICAgIGlmIChhcmcudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgaWYgKGFyZy5pc1N0YXRpYykge1xuICAgICAgICAgICAgYXJnLmNvbnRlbnQgPSBwcmVmaXggKyBhcmcuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyZy5jb250ZW50ID0gYFxcYCR7cHJlZml4fVxcJHske2FyZy5jb250ZW50fX1cXGBgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmcuY2hpbGRyZW4udW5zaGlmdChgJyR7cHJlZml4fScgKyAoYCk7XG4gICAgICAgIGFyZy5jaGlsZHJlbi5wdXNoKGApYCk7XG4gICAgfVxufTtcblxuLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyBhbmQgZXhwcmVzc2lvbnMgaW50byBhIHNpbmdsZSBleHByZXNzaW9uXG4vLyBlLmcuIDxkaXY+YWJjIHt7IGQgfX0ge3sgZSB9fTwvZGl2PiBzaG91bGQgaGF2ZSBhIHNpbmdsZSBleHByZXNzaW9uIG5vZGUgYXMgY2hpbGQuXG5jb25zdCB0cmFuc2Zvcm1UZXh0ID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAwIC8qIE5vZGVUeXBlcy5ST09UICovIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyB8fFxuICAgICAgICBub2RlLnR5cGUgPT09IDExIC8qIE5vZGVUeXBlcy5GT1IgKi8gfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAxMCAvKiBOb2RlVHlwZXMuSUZfQlJBTkNIICovKSB7XG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIHRyYW5zZm9ybSBvbiBub2RlIGV4aXQgc28gdGhhdCBhbGwgZXhwcmVzc2lvbnMgaGF2ZSBhbHJlYWR5XG4gICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkLlxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgaGFzVGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dCQxKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RleHQkMShuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gY2hpbGRyZW5baV0gPSBjcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2NoaWxkXSwgY2hpbGQubG9jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlIGludG8gY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIuY2hpbGRyZW4ucHVzaChgICsgYCwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc1RleHQgfHxcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCB3aXRoIGEgc2luZ2xlIHRleHQgY2hpbGQsIGxlYXZlIGl0XG4gICAgICAgICAgICAgICAgLy8gYXMtaXMgc2luY2UgdGhlIHJ1bnRpbWUgaGFzIGRlZGljYXRlZCBmYXN0IHBhdGggZm9yIHRoaXMgYnkgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHRleHRDb250ZW50IG9mIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIGZvciBjb21wb25lbnQgcm9vdCBpdCdzIGFsd2F5cyBub3JtYWxpemVkIGFueXdheS5cbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIChub2RlLnR5cGUgPT09IDAgLyogTm9kZVR5cGVzLlJPT1QgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRWxlbWVudFR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAjMzc1NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBkaXJlY3RpdmVzIGNhbiBwb3RlbnRpYWxseSBhZGQgRE9NIGVsZW1lbnRzIGFyYml0cmFyaWx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYXZvaWQgc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudCBhdCBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgYWNjaWRlbnRhbGx5IG92ZXJ3cml0aW5nIHRoZSBET00gZWxlbWVudHMgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSB0aGUgdXNlciB0aHJvdWdoIGN1c3RvbSBkaXJlY3RpdmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFub2RlLnByb3BzLmZpbmQocCA9PiBwLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhY29udGV4dC5kaXJlY3RpdmVUcmFuc2Zvcm1zW3AubmFtZV0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY29tcGF0IG1vZGUsIDx0ZW1wbGF0ZT4gdGFncyB3aXRoIG5vIHNwZWNpYWwgZGlyZWN0aXZlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBmcmFnbWVudCBzbyBpdHMgY2hpbGRyZW4gbXVzdCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIHZub2Rlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKG5vZGUudGFnID09PSAndGVtcGxhdGUnKSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZS1jb252ZXJ0IHRleHQgbm9kZXMgaW50byBjcmVhdGVUZXh0Vk5vZGUodGV4dCkgY2FsbHMgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUgbm9ybWFsaXphdGlvbi5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHQkMShjaGlsZCkgfHwgY2hpbGQudHlwZSA9PT0gOCAvKiBOb2RlVHlwZXMuQ09NUE9VTkRfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsQXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVUZXh0Vk5vZGUgZGVmYXVsdHMgdG8gc2luZ2xlIHdoaXRlc3BhY2UsIHNvIGlmIGl0IGlzIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIHNwYWNlIHRoZSBjb2RlIGNvdWxkIGJlIGFuIGVtcHR5IGNhbGwgdG8gc2F2ZSBieXRlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IDIgLyogTm9kZVR5cGVzLlRFWFQgKi8gfHwgY2hpbGQuY29udGVudCAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQXJncy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGR5bmFtaWMgdGV4dCB3aXRoIGZsYWcgc28gaXQgZ2V0cyBwYXRjaGVkIGluc2lkZSBhIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5zc3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbnN0YW50VHlwZShjaGlsZCwgY29udGV4dCkgPT09IDAgLyogQ29uc3RhbnRUeXBlcy5OT1RfQ09OU1RBTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBcmdzLnB1c2goMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi8gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgIC8qICR7UGF0Y2hGbGFnTmFtZXNbMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi9dfSAqL2AgOiBgYCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMTIgLyogTm9kZVR5cGVzLlRFWFRfQ0FMTCAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiBjaGlsZC5sb2MsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlZ2VuTm9kZTogY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoQ1JFQVRFX1RFWFQpLCBjYWxsQXJncylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuY29uc3Qgc2VlbiQxID0gbmV3IFdlYWtTZXQoKTtcbmNvbnN0IHRyYW5zZm9ybU9uY2UgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8gJiYgZmluZERpcihub2RlLCAnb25jZScsIHRydWUpKSB7XG4gICAgICAgIGlmIChzZWVuJDEuaGFzKG5vZGUpIHx8IGNvbnRleHQuaW5WT25jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4kMS5hZGQobm9kZSk7XG4gICAgICAgIGNvbnRleHQuaW5WT25jZSA9IHRydWU7XG4gICAgICAgIGNvbnRleHQuaGVscGVyKFNFVF9CTE9DS19UUkFDS0lORyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0LmluVk9uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGN1ciA9IGNvbnRleHQuY3VycmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoY3VyLmNvZGVnZW5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgY3VyLmNvZGVnZW5Ob2RlID0gY29udGV4dC5jYWNoZShjdXIuY29kZWdlbk5vZGUsIHRydWUgLyogaXNWTm9kZSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuY29uc3QgdHJhbnNmb3JtTW9kZWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgY29uc3QgeyBleHAsIGFyZyB9ID0gZGlyO1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQxIC8qIEVycm9yQ29kZXMuWF9WX01PREVMX05PX0VYUFJFU1NJT04gKi8sIGRpci5sb2MpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XG4gICAgfVxuICAgIGNvbnN0IHJhd0V4cCA9IGV4cC5sb2Muc291cmNlO1xuICAgIGNvbnN0IGV4cFN0cmluZyA9IGV4cC50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLyA/IGV4cC5jb250ZW50IDogcmF3RXhwO1xuICAgIC8vIGltIFNGQyA8c2NyaXB0IHNldHVwPiBpbmxpbmUgbW9kZSwgdGhlIGV4cCBtYXkgaGF2ZSBiZWVuIHRyYW5zZm9ybWVkIGludG9cbiAgICAvLyBfdW5yZWYoZXhwKVxuICAgIGNvbnN0IGJpbmRpbmdUeXBlID0gY29udGV4dC5iaW5kaW5nTWV0YWRhdGFbcmF3RXhwXTtcbiAgICAvLyBjaGVjayBwcm9wc1xuICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gXCJwcm9wc1wiIC8qIEJpbmRpbmdUeXBlcy5QUk9QUyAqLyB8fFxuICAgICAgICBiaW5kaW5nVHlwZSA9PT0gXCJwcm9wcy1hbGlhc2VkXCIgLyogQmluZGluZ1R5cGVzLlBST1BTX0FMSUFTRUQgKi8pIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDQgLyogRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfT05fUFJPUFMgKi8sIGV4cC5sb2MpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZm9ybVByb3BzKCk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlUmVmID0gIXRydWUgIDtcbiAgICBpZiAoIWV4cFN0cmluZy50cmltKCkgfHxcbiAgICAgICAgKCFpc01lbWJlckV4cHJlc3Npb24oZXhwU3RyaW5nKSAmJiAhbWF5YmVSZWYpKSB7XG4gICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVDb21waWxlckVycm9yKDQyIC8qIEVycm9yQ29kZXMuWF9WX01PREVMX01BTEZPUk1FRF9FWFBSRVNTSU9OICovLCBleHAubG9jKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zvcm1Qcm9wcygpO1xuICAgIH1cbiAgICBjb25zdCBwcm9wTmFtZSA9IGFyZyA/IGFyZyA6IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJ21vZGVsVmFsdWUnLCB0cnVlKTtcbiAgICBjb25zdCBldmVudE5hbWUgPSBhcmdcbiAgICAgICAgPyBpc1N0YXRpY0V4cChhcmcpXG4gICAgICAgICAgICA/IGBvblVwZGF0ZToke2NhbWVsaXplJDEoYXJnLmNvbnRlbnQpfWBcbiAgICAgICAgICAgIDogY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFsnXCJvblVwZGF0ZTpcIiArICcsIGFyZ10pXG4gICAgICAgIDogYG9uVXBkYXRlOm1vZGVsVmFsdWVgO1xuICAgIGxldCBhc3NpZ25tZW50RXhwO1xuICAgIGNvbnN0IGV2ZW50QXJnID0gY29udGV4dC5pc1RTID8gYCgkZXZlbnQ6IGFueSlgIDogYCRldmVudGA7XG4gICAge1xuICAgICAgICBhc3NpZ25tZW50RXhwID0gY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uKFtcbiAgICAgICAgICAgIGAke2V2ZW50QXJnfSA9PiAoKGAsXG4gICAgICAgICAgICBleHAsXG4gICAgICAgICAgICBgKSA9ICRldmVudClgXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IFtcbiAgICAgICAgLy8gbW9kZWxWYWx1ZTogZm9vXG4gICAgICAgIGNyZWF0ZU9iamVjdFByb3BlcnR5KHByb3BOYW1lLCBkaXIuZXhwKSxcbiAgICAgICAgLy8gXCJvblVwZGF0ZTptb2RlbFZhbHVlXCI6ICRldmVudCA9PiAoZm9vID0gJGV2ZW50KVxuICAgICAgICBjcmVhdGVPYmplY3RQcm9wZXJ0eShldmVudE5hbWUsIGFzc2lnbm1lbnRFeHApXG4gICAgXTtcbiAgICAvLyBtb2RlbE1vZGlmaWVyczogeyBmb286IHRydWUsIFwiYmFyLWJhelwiOiB0cnVlIH1cbiAgICBpZiAoZGlyLm1vZGlmaWVycy5sZW5ndGggJiYgbm9kZS50YWdUeXBlID09PSAxIC8qIEVsZW1lbnRUeXBlcy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVyc1xuICAgICAgICAgICAgLm1hcChtID0+IChpc1NpbXBsZUlkZW50aWZpZXIobSkgPyBtIDogSlNPTi5zdHJpbmdpZnkobSkpICsgYDogdHJ1ZWApXG4gICAgICAgICAgICAuam9pbihgLCBgKTtcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYXJnXG4gICAgICAgICAgICA/IGlzU3RhdGljRXhwKGFyZylcbiAgICAgICAgICAgICAgICA/IGAke2FyZy5jb250ZW50fU1vZGlmaWVyc2BcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYXJnLCAnICsgXCJNb2RpZmllcnNcIiddKVxuICAgICAgICAgICAgOiBgbW9kZWxNb2RpZmllcnNgO1xuICAgICAgICBwcm9wcy5wdXNoKGNyZWF0ZU9iamVjdFByb3BlcnR5KG1vZGlmaWVyc0tleSwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgeyAke21vZGlmaWVyc30gfWAsIGZhbHNlLCBkaXIubG9jLCAyIC8qIENvbnN0YW50VHlwZXMuQ0FOX0hPSVNUICovKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlVHJhbnNmb3JtUHJvcHMocHJvcHMpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybVByb3BzKHByb3BzID0gW10pIHtcbiAgICByZXR1cm4geyBwcm9wcyB9O1xufVxuXG5jb25zdCB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuY29uc3QgdHJhbnNmb3JtRmlsdGVyID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAoIWlzQ29tcGF0RW5hYmxlZChcIkNPTVBJTEVSX0ZJTFRFUlwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9GSUxURVJTICovLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8pIHtcbiAgICAgICAgLy8gZmlsdGVyIHJld3JpdGUgaXMgYXBwbGllZCBiZWZvcmUgZXhwcmVzc2lvbiB0cmFuc2Zvcm0gc28gb25seVxuICAgICAgICAvLyBzaW1wbGUgZXhwcmVzc2lvbnMgYXJlIHBvc3NpYmxlIGF0IHRoaXMgc3RhZ2VcbiAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovICYmXG4gICAgICAgICAgICAgICAgcHJvcC5uYW1lICE9PSAnZm9yJyAmJlxuICAgICAgICAgICAgICAgIHByb3AuZXhwKSB7XG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihwcm9wLmV4cCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5mdW5jdGlvbiByZXdyaXRlRmlsdGVyKG5vZGUsIGNvbnRleHQpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSA0IC8qIE5vZGVUeXBlcy5TSU1QTEVfRVhQUkVTU0lPTiAqLykge1xuICAgICAgICBwYXJzZUZpbHRlcihub2RlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8pIHtcbiAgICAgICAgICAgICAgICBwYXJzZUZpbHRlcihjaGlsZCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50eXBlID09PSA4IC8qIE5vZGVUeXBlcy5DT01QT1VORF9FWFBSRVNTSU9OICovKSB7XG4gICAgICAgICAgICAgICAgcmV3cml0ZUZpbHRlcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IDUgLyogTm9kZVR5cGVzLklOVEVSUE9MQVRJT04gKi8pIHtcbiAgICAgICAgICAgICAgICByZXdyaXRlRmlsdGVyKGNoaWxkLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VGaWx0ZXIobm9kZSwgY29udGV4dCkge1xuICAgIGNvbnN0IGV4cCA9IG5vZGUuY29udGVudDtcbiAgICBsZXQgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICBsZXQgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBpblJlZ2V4ID0gZmFsc2U7XG4gICAgbGV0IGN1cmx5ID0gMDtcbiAgICBsZXQgc3F1YXJlID0gMDtcbiAgICBsZXQgcGFyZW4gPSAwO1xuICAgIGxldCBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmV2ID0gYztcbiAgICAgICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NWMpXG4gICAgICAgICAgICAgICAgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1YylcbiAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NWMpXG4gICAgICAgICAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NWMpXG4gICAgICAgICAgICAgICAgaW5SZWdleCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IDB4N2MgJiYgLy8gcGlwZVxuICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdjICYmXG4gICAgICAgICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N2MgJiZcbiAgICAgICAgICAgICFjdXJseSAmJlxuICAgICAgICAgICAgIXNxdWFyZSAmJlxuICAgICAgICAgICAgIXBhcmVuKSB7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAweDIyOlxuICAgICAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBcIlxuICAgICAgICAgICAgICAgIGNhc2UgMHgyNzpcbiAgICAgICAgICAgICAgICAgICAgaW5TaW5nbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gJ1xuICAgICAgICAgICAgICAgIGNhc2UgMHg2MDpcbiAgICAgICAgICAgICAgICAgICAgaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBgXG4gICAgICAgICAgICAgICAgY2FzZSAweDI4OlxuICAgICAgICAgICAgICAgICAgICBwYXJlbisrO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gKFxuICAgICAgICAgICAgICAgIGNhc2UgMHgyOTpcbiAgICAgICAgICAgICAgICAgICAgcGFyZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIClcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWI6XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZSsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gW1xuICAgICAgICAgICAgICAgIGNhc2UgMHg1ZDpcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBdXG4gICAgICAgICAgICAgICAgY2FzZSAweDdiOlxuICAgICAgICAgICAgICAgICAgICBjdXJseSsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8ge1xuICAgICAgICAgICAgICAgIGNhc2UgMHg3ZDpcbiAgICAgICAgICAgICAgICAgICAgY3VybHktLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAweDJmKSB7XG4gICAgICAgICAgICAgICAgLy8gL1xuICAgICAgICAgICAgICAgIGxldCBqID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICE9PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XG4gICAgICAgIGZpbHRlcnMucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKFwiQ09NUElMRVJfRklMVEVSXCIgLyogQ29tcGlsZXJEZXByZWNhdGlvblR5cGVzLkNPTVBJTEVSX0ZJTFRFUlMgKi8sIGNvbnRleHQsIG5vZGUubG9jKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuY29udGVudCA9IGV4cHJlc3Npb247XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlciwgY29udGV4dCkge1xuICAgIGNvbnRleHQuaGVscGVyKFJFU09MVkVfRklMVEVSKTtcbiAgICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgY29udGV4dC5maWx0ZXJzLmFkZChmaWx0ZXIpO1xuICAgICAgICByZXR1cm4gYCR7dG9WYWxpZEFzc2V0SWQoZmlsdGVyLCAnZmlsdGVyJyl9KCR7ZXhwfSlgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgICAgIGNvbnRleHQuZmlsdGVycy5hZGQobmFtZSk7XG4gICAgICAgIHJldHVybiBgJHt0b1ZhbGlkQXNzZXRJZChuYW1lLCAnZmlsdGVyJyl9KCR7ZXhwfSR7YXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3N9YDtcbiAgICB9XG59XG5cbmNvbnN0IHNlZW4gPSBuZXcgV2Vha1NldCgpO1xuY29uc3QgdHJhbnNmb3JtTWVtbyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLykge1xuICAgICAgICBjb25zdCBkaXIgPSBmaW5kRGlyKG5vZGUsICdtZW1vJyk7XG4gICAgICAgIGlmICghZGlyIHx8IHNlZW4uaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQobm9kZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlZ2VuTm9kZSA9IG5vZGUuY29kZWdlbk5vZGUgfHxcbiAgICAgICAgICAgICAgICBjb250ZXh0LmN1cnJlbnROb2RlLmNvZGVnZW5Ob2RlO1xuICAgICAgICAgICAgaWYgKGNvZGVnZW5Ob2RlICYmIGNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzIC8qIE5vZGVUeXBlcy5WTk9ERV9DQUxMICovKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uLWNvbXBvbmVudCBzdWIgdHJlZSBzaG91bGQgYmUgdHVybmVkIGludG8gYSBibG9ja1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ1R5cGUgIT09IDEgLyogRWxlbWVudFR5cGVzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBtYWtlQmxvY2soY29kZWdlbk5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLmNvZGVnZW5Ob2RlID0gY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoV0lUSF9NRU1PKSwgW1xuICAgICAgICAgICAgICAgICAgICBkaXIuZXhwLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGdW5jdGlvbkV4cHJlc3Npb24odW5kZWZpbmVkLCBjb2RlZ2VuTm9kZSksXG4gICAgICAgICAgICAgICAgICAgIGBfY2FjaGVgLFxuICAgICAgICAgICAgICAgICAgICBTdHJpbmcoY29udGV4dC5jYWNoZWQrKylcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KHByZWZpeElkZW50aWZpZXJzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgW1xuICAgICAgICAgICAgdHJhbnNmb3JtT25jZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybUlmLFxuICAgICAgICAgICAgdHJhbnNmb3JtTWVtbyxcbiAgICAgICAgICAgIHRyYW5zZm9ybUZvcixcbiAgICAgICAgICAgIC4uLihbdHJhbnNmb3JtRmlsdGVyXSApLFxuICAgICAgICAgICAgLi4uKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICA/IFt0cmFuc2Zvcm1FeHByZXNzaW9uXVxuICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybVNsb3RPdXRsZXQsXG4gICAgICAgICAgICB0cmFuc2Zvcm1FbGVtZW50LFxuICAgICAgICAgICAgdHJhY2tTbG90U2NvcGVzLFxuICAgICAgICAgICAgdHJhbnNmb3JtVGV4dFxuICAgICAgICBdLFxuICAgICAgICB7XG4gICAgICAgICAgICBvbjogdHJhbnNmb3JtT24sXG4gICAgICAgICAgICBiaW5kOiB0cmFuc2Zvcm1CaW5kLFxuICAgICAgICAgICAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsXG4gICAgICAgIH1cbiAgICBdO1xufVxuLy8gd2UgbmFtZSBpdCBgYmFzZUNvbXBpbGVgIHNvIHRoYXQgaGlnaGVyIG9yZGVyIGNvbXBpbGVycyBsaWtlXG4vLyBAdnVlL2NvbXBpbGVyLWRvbSBjYW4gZXhwb3J0IGBjb21waWxlYCB3aGlsZSByZS1leHBvcnRpbmcgZXZlcnl0aGluZyBlbHNlLlxuZnVuY3Rpb24gYmFzZUNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9uRXJyb3IgPSBvcHRpb25zLm9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XG4gICAgY29uc3QgaXNNb2R1bGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnbW9kdWxlJztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLnByZWZpeElkZW50aWZpZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDcgLyogRXJyb3JDb2Rlcy5YX1BSRUZJWF9JRF9OT1RfU1VQUE9SVEVEICovKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNb2R1bGVNb2RlKSB7XG4gICAgICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNDggLyogRXJyb3JDb2Rlcy5YX01PRFVMRV9NT0RFX05PVF9TVVBQT1JURUQgKi8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcmVmaXhJZGVudGlmaWVycyA9ICF0cnVlIDtcbiAgICBpZiAob3B0aW9ucy5jYWNoZUhhbmRsZXJzKSB7XG4gICAgICAgIG9uRXJyb3IoY3JlYXRlQ29tcGlsZXJFcnJvcig0OSAvKiBFcnJvckNvZGVzLlhfQ0FDSEVfSEFORExFUl9OT1RfU1VQUE9SVEVEICovKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNjb3BlSWQgJiYgIWlzTW9kdWxlTW9kZSkge1xuICAgICAgICBvbkVycm9yKGNyZWF0ZUNvbXBpbGVyRXJyb3IoNTAgLyogRXJyb3JDb2Rlcy5YX1NDT1BFX0lEX05PVF9TVVBQT1JURUQgKi8pKTtcbiAgICB9XG4gICAgY29uc3QgYXN0ID0gaXNTdHJpbmcodGVtcGxhdGUpID8gYmFzZVBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSA6IHRlbXBsYXRlO1xuICAgIGNvbnN0IFtub2RlVHJhbnNmb3JtcywgZGlyZWN0aXZlVHJhbnNmb3Jtc10gPSBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0KCk7XG4gICAgdHJhbnNmb3JtKGFzdCwgZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHByZWZpeElkZW50aWZpZXJzLFxuICAgICAgICBub2RlVHJhbnNmb3JtczogW1xuICAgICAgICAgICAgLi4ubm9kZVRyYW5zZm9ybXMsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXSkgLy8gdXNlciB0cmFuc2Zvcm1zXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGV4dGVuZCh7fSwgZGlyZWN0aXZlVHJhbnNmb3Jtcywgb3B0aW9ucy5kaXJlY3RpdmVUcmFuc2Zvcm1zIHx8IHt9IC8vIHVzZXIgdHJhbnNmb3Jtc1xuICAgICAgICApXG4gICAgfSkpO1xuICAgIHJldHVybiBnZW5lcmF0ZShhc3QsIGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBwcmVmaXhJZGVudGlmaWVyc1xuICAgIH0pKTtcbn1cblxuY29uc3Qgbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSA9ICgpID0+ICh7IHByb3BzOiBbXSB9KTtcblxuZXhwb3J0IHsgQkFTRV9UUkFOU0lUSU9OLCBDQU1FTElaRSwgQ0FQSVRBTElaRSwgQ1JFQVRFX0JMT0NLLCBDUkVBVEVfQ09NTUVOVCwgQ1JFQVRFX0VMRU1FTlRfQkxPQ0ssIENSRUFURV9FTEVNRU5UX1ZOT0RFLCBDUkVBVEVfU0xPVFMsIENSRUFURV9TVEFUSUMsIENSRUFURV9URVhULCBDUkVBVEVfVk5PREUsIEZSQUdNRU5ULCBHVUFSRF9SRUFDVElWRV9QUk9QUywgSVNfTUVNT19TQU1FLCBJU19SRUYsIEtFRVBfQUxJVkUsIE1FUkdFX1BST1BTLCBOT1JNQUxJWkVfQ0xBU1MsIE5PUk1BTElaRV9QUk9QUywgTk9STUFMSVpFX1NUWUxFLCBPUEVOX0JMT0NLLCBQT1BfU0NPUEVfSUQsIFBVU0hfU0NPUEVfSUQsIFJFTkRFUl9MSVNULCBSRU5ERVJfU0xPVCwgUkVTT0xWRV9DT01QT05FTlQsIFJFU09MVkVfRElSRUNUSVZFLCBSRVNPTFZFX0RZTkFNSUNfQ09NUE9ORU5ULCBSRVNPTFZFX0ZJTFRFUiwgU0VUX0JMT0NLX1RSQUNLSU5HLCBTVVNQRU5TRSwgVEVMRVBPUlQsIFRPX0RJU1BMQVlfU1RSSU5HLCBUT19IQU5ETEVSUywgVE9fSEFORExFUl9LRVksIFVOUkVGLCBXSVRIX0NUWCwgV0lUSF9ESVJFQ1RJVkVTLCBXSVRIX01FTU8sIGFkdmFuY2VQb3NpdGlvbldpdGhDbG9uZSwgYWR2YW5jZVBvc2l0aW9uV2l0aE11dGF0aW9uLCBhc3NlcnQsIGJhc2VDb21waWxlLCBiYXNlUGFyc2UsIGJ1aWxkRGlyZWN0aXZlQXJncywgYnVpbGRQcm9wcywgYnVpbGRTbG90cywgY2hlY2tDb21wYXRFbmFibGVkLCBjcmVhdGVBcnJheUV4cHJlc3Npb24sIGNyZWF0ZUFzc2lnbm1lbnRFeHByZXNzaW9uLCBjcmVhdGVCbG9ja1N0YXRlbWVudCwgY3JlYXRlQ2FjaGVFeHByZXNzaW9uLCBjcmVhdGVDYWxsRXhwcmVzc2lvbiwgY3JlYXRlQ29tcGlsZXJFcnJvciwgY3JlYXRlQ29tcG91bmRFeHByZXNzaW9uLCBjcmVhdGVDb25kaXRpb25hbEV4cHJlc3Npb24sIGNyZWF0ZUZvckxvb3BQYXJhbXMsIGNyZWF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiwgY3JlYXRlSWZTdGF0ZW1lbnQsIGNyZWF0ZUludGVycG9sYXRpb24sIGNyZWF0ZU9iamVjdEV4cHJlc3Npb24sIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBjcmVhdGVSZXR1cm5TdGF0ZW1lbnQsIGNyZWF0ZVJvb3QsIGNyZWF0ZVNlcXVlbmNlRXhwcmVzc2lvbiwgY3JlYXRlU2ltcGxlRXhwcmVzc2lvbiwgY3JlYXRlU3RydWN0dXJhbERpcmVjdGl2ZVRyYW5zZm9ybSwgY3JlYXRlVGVtcGxhdGVMaXRlcmFsLCBjcmVhdGVUcmFuc2Zvcm1Db250ZXh0LCBjcmVhdGVWTm9kZUNhbGwsIGV4dHJhY3RJZGVudGlmaWVycywgZmluZERpciwgZmluZFByb3AsIGdlbmVyYXRlLCBnZXRCYXNlVHJhbnNmb3JtUHJlc2V0LCBnZXRDb25zdGFudFR5cGUsIGdldElubmVyUmFuZ2UsIGdldE1lbW9lZFZOb2RlQ2FsbCwgZ2V0Vk5vZGVCbG9ja0hlbHBlciwgZ2V0Vk5vZGVIZWxwZXIsIGhhc0R5bmFtaWNLZXlWQmluZCwgaGFzU2NvcGVSZWYsIGhlbHBlck5hbWVNYXAsIGluamVjdFByb3AsIGlzQnVpbHRJblR5cGUsIGlzQ29yZUNvbXBvbmVudCwgaXNGdW5jdGlvblR5cGUsIGlzSW5EZXN0cnVjdHVyZUFzc2lnbm1lbnQsIGlzTWVtYmVyRXhwcmVzc2lvbiwgaXNNZW1iZXJFeHByZXNzaW9uQnJvd3NlciwgaXNNZW1iZXJFeHByZXNzaW9uTm9kZSwgaXNSZWZlcmVuY2VkSWRlbnRpZmllciwgaXNTaW1wbGVJZGVudGlmaWVyLCBpc1Nsb3RPdXRsZXQsIGlzU3RhdGljQXJnT2YsIGlzU3RhdGljRXhwLCBpc1N0YXRpY1Byb3BlcnR5LCBpc1N0YXRpY1Byb3BlcnR5S2V5LCBpc1RlbXBsYXRlTm9kZSwgaXNUZXh0JDEgYXMgaXNUZXh0LCBpc1ZTbG90LCBsb2NTdHViLCBtYWtlQmxvY2ssIG5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sIHByb2Nlc3NFeHByZXNzaW9uLCBwcm9jZXNzRm9yLCBwcm9jZXNzSWYsIHByb2Nlc3NTbG90T3V0bGV0LCByZWdpc3RlclJ1bnRpbWVIZWxwZXJzLCByZXNvbHZlQ29tcG9uZW50VHlwZSwgc3RyaW5naWZ5RXhwcmVzc2lvbiwgdG9WYWxpZEFzc2V0SWQsIHRyYWNrU2xvdFNjb3BlcywgdHJhY2tWRm9yU2xvdFNjb3BlcywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1CaW5kLCB0cmFuc2Zvcm1FbGVtZW50LCB0cmFuc2Zvcm1FeHByZXNzaW9uLCB0cmFuc2Zvcm1Nb2RlbCwgdHJhbnNmb3JtT24sIHRyYXZlcnNlTm9kZSwgd2Fsa0Jsb2NrRGVjbGFyYXRpb25zLCB3YWxrRnVuY3Rpb25QYXJhbXMsIHdhbGtJZGVudGlmaWVycywgd2FybkRlcHJlY2F0aW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/compiler-core/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@vue/compiler-core/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_ARR\": () => (/* binding */ EMPTY_ARR),\n/* harmony export */   \"EMPTY_OBJ\": () => (/* binding */ EMPTY_OBJ),\n/* harmony export */   \"NO\": () => (/* binding */ NO),\n/* harmony export */   \"NOOP\": () => (/* binding */ NOOP),\n/* harmony export */   \"PatchFlagNames\": () => (/* binding */ PatchFlagNames),\n/* harmony export */   \"camelize\": () => (/* binding */ camelize),\n/* harmony export */   \"capitalize\": () => (/* binding */ capitalize),\n/* harmony export */   \"def\": () => (/* binding */ def),\n/* harmony export */   \"escapeHtml\": () => (/* binding */ escapeHtml),\n/* harmony export */   \"escapeHtmlComment\": () => (/* binding */ escapeHtmlComment),\n/* harmony export */   \"extend\": () => (/* binding */ extend),\n/* harmony export */   \"genPropsAccessExp\": () => (/* binding */ genPropsAccessExp),\n/* harmony export */   \"generateCodeFrame\": () => (/* binding */ generateCodeFrame),\n/* harmony export */   \"getGlobalThis\": () => (/* binding */ getGlobalThis),\n/* harmony export */   \"hasChanged\": () => (/* binding */ hasChanged),\n/* harmony export */   \"hasOwn\": () => (/* binding */ hasOwn),\n/* harmony export */   \"hyphenate\": () => (/* binding */ hyphenate),\n/* harmony export */   \"includeBooleanAttr\": () => (/* binding */ includeBooleanAttr),\n/* harmony export */   \"invokeArrayFns\": () => (/* binding */ invokeArrayFns),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"isBooleanAttr\": () => (/* binding */ isBooleanAttr),\n/* harmony export */   \"isBuiltInDirective\": () => (/* binding */ isBuiltInDirective),\n/* harmony export */   \"isDate\": () => (/* binding */ isDate),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isGloballyWhitelisted\": () => (/* binding */ isGloballyWhitelisted),\n/* harmony export */   \"isHTMLTag\": () => (/* binding */ isHTMLTag),\n/* harmony export */   \"isIntegerKey\": () => (/* binding */ isIntegerKey),\n/* harmony export */   \"isKnownHtmlAttr\": () => (/* binding */ isKnownHtmlAttr),\n/* harmony export */   \"isKnownSvgAttr\": () => (/* binding */ isKnownSvgAttr),\n/* harmony export */   \"isMap\": () => (/* binding */ isMap),\n/* harmony export */   \"isModelListener\": () => (/* binding */ isModelListener),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isOn\": () => (/* binding */ isOn),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"isRegExp\": () => (/* binding */ isRegExp),\n/* harmony export */   \"isReservedProp\": () => (/* binding */ isReservedProp),\n/* harmony export */   \"isSSRSafeAttrName\": () => (/* binding */ isSSRSafeAttrName),\n/* harmony export */   \"isSVGTag\": () => (/* binding */ isSVGTag),\n/* harmony export */   \"isSet\": () => (/* binding */ isSet),\n/* harmony export */   \"isSpecialBooleanAttr\": () => (/* binding */ isSpecialBooleanAttr),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"isSymbol\": () => (/* binding */ isSymbol),\n/* harmony export */   \"isVoidTag\": () => (/* binding */ isVoidTag),\n/* harmony export */   \"looseEqual\": () => (/* binding */ looseEqual),\n/* harmony export */   \"looseIndexOf\": () => (/* binding */ looseIndexOf),\n/* harmony export */   \"looseToNumber\": () => (/* binding */ looseToNumber),\n/* harmony export */   \"makeMap\": () => (/* binding */ makeMap),\n/* harmony export */   \"normalizeClass\": () => (/* binding */ normalizeClass),\n/* harmony export */   \"normalizeProps\": () => (/* binding */ normalizeProps),\n/* harmony export */   \"normalizeStyle\": () => (/* binding */ normalizeStyle),\n/* harmony export */   \"objectToString\": () => (/* binding */ objectToString),\n/* harmony export */   \"parseStringStyle\": () => (/* binding */ parseStringStyle),\n/* harmony export */   \"propsToAttrMap\": () => (/* binding */ propsToAttrMap),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"slotFlagsText\": () => (/* binding */ slotFlagsText),\n/* harmony export */   \"stringifyStyle\": () => (/* binding */ stringifyStyle),\n/* harmony export */   \"toDisplayString\": () => (/* binding */ toDisplayString),\n/* harmony export */   \"toHandlerKey\": () => (/* binding */ toHandlerKey),\n/* harmony export */   \"toNumber\": () => (/* binding */ toNumber),\n/* harmony export */   \"toRawType\": () => (/* binding */ toRawType),\n/* harmony export */   \"toTypeString\": () => (/* binding */ toTypeString)\n/* harmony export */ });\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    // Split the content into individual lines but capture the newline sequence\n    // that separated each line. This is important because the actual sequence is\n    // needed to properly take into account the full line length for offset\n    // comparison\n    let lines = source.split(/(\\r?\\n)/);\n    // Separate the lines and newline sequences into separate arrays for easier referencing\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n    lines = lines.filter((_, idx) => idx % 2 === 0);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count +=\n            lines[i].length +\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - (lineLength + newLineSeqLength));\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + newLineSeqLength;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\nfunction normalizeStyle(value) {\n    if (isArray(value)) {\n        const res = {};\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            const normalized = isString(item)\n                ? parseStringStyle(item)\n                : normalizeStyle(item);\n            if (normalized) {\n                for (const key in normalized) {\n                    res[key] = normalized[key];\n                }\n            }\n        }\n        return res;\n    }\n    else if (isString(value)) {\n        return value;\n    }\n    else if (isObject(value)) {\n        return value;\n    }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n    const ret = {};\n    cssText\n        .replace(styleCommentRE, '')\n        .split(listDelimiterRE)\n        .forEach(item => {\n        if (item) {\n            const tmp = item.split(propertyDelimiterRE);\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return ret;\n}\nfunction stringifyStyle(styles) {\n    let ret = '';\n    if (!styles || isString(styles)) {\n        return ret;\n    }\n    for (const key in styles) {\n        const value = styles[key];\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n        if (isString(value) || typeof value === 'number') {\n            // only render valid values\n            ret += `${normalizedKey}:${value};`;\n        }\n    }\n    return ret;\n}\nfunction normalizeClass(value) {\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value)) {\n        for (const name in value) {\n            if (value[name]) {\n                res += name + ' ';\n            }\n        }\n    }\n    return res.trim();\n}\nfunction normalizeProps(props) {\n    if (!props)\n        return null;\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n        props.class = normalizeClass(klass);\n    }\n    if (style) {\n        props.style = normalizeStyle(style);\n    }\n    return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n    'option,output,progress,select,textarea,details,dialog,menu,' +\n    'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n    'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n    return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n        return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n        console.error(`unsafe attribute name: ${name}`);\n    }\n    return (attrValidationCache[name] = !isUnsafe);\n}\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`);\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n    const str = '' + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n        return str;\n    }\n    let html = '';\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34: // \"\n                escaped = '&quot;';\n                break;\n            case 38: // &\n                escaped = '&amp;';\n                break;\n            case 39: // '\n                escaped = '&#39;';\n                break;\n            case 60: // <\n                escaped = '&lt;';\n                break;\n            case 62: // >\n                escaped = '&gt;';\n                break;\n            default:\n                continue;\n        }\n        if (lastIndex !== index) {\n            html += str.slice(lastIndex, index);\n        }\n        lastIndex = index + 1;\n        html += escaped;\n    }\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n    return src.replace(commentStripRE, '');\n}\n\nfunction looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n        equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n}\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isSymbol(a);\n    bValidType = isSymbol(b);\n    if (aValidType || bValidType) {\n        return a === b;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n        /* istanbul ignore if: this if will probably never be called */\n        if (!aValidType || !bValidType) {\n            return false;\n        }\n        const aKeysCount = Object.keys(a).length;\n        const bKeysCount = Object.keys(b).length;\n        if (aKeysCount !== bKeysCount) {\n            return false;\n        }\n        for (const key in a) {\n            const aHasKey = a.hasOwnProperty(key);\n            const bHasKey = b.hasOwnProperty(key);\n            if ((aHasKey && !bHasKey) ||\n                (!aHasKey && bHasKey) ||\n                !looseEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n    }\n    return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n    return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = (val) => {\n    return isString(val)\n        ? val\n        : val == null\n            ? ''\n            : isArray(val) ||\n                (isObject(val) &&\n                    (val.toString === objectToString || !isFunction(val.toString)))\n                ? JSON.stringify(val, replacer, 2)\n                : String(val);\n};\nconst replacer = (_key, val) => {\n    // can't use isRef here since @vue/shared has no deps\n    if (val && val.__v_isRef) {\n        return replacer(_key, val.value);\n    }\n    else if (isMap(val)) {\n        return {\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                entries[`${key} =>`] = val;\n                return entries;\n            }, {})\n        };\n    }\n    else if (isSet(val)) {\n        return {\n            [`Set(${val.size})`]: [...val.values()]\n        };\n    }\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n        return String(val);\n    }\n    return val;\n};\n\nconst EMPTY_OBJ = ( true)\n    ? Object.freeze({})\n    : 0;\nconst EMPTY_ARR = ( true) ? Object.freeze([]) : 0;\nconst NOOP = () => { };\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === '[object Map]';\nconst isSet = (val) => toTypeString(val) === '[object Set]';\nconst isDate = (val) => toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\nconst isFunction = (val) => typeof val === 'function';\nconst isString = (val) => typeof val === 'string';\nconst isSymbol = (val) => typeof val === 'symbol';\nconst isObject = (val) => val !== null && typeof val === 'object';\nconst isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\nconst isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\nconst def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = (val) => {\n    const n = isString(val) ? Number(val) : NaN;\n    return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof __webpack_require__.g !== 'undefined'\n                            ? __webpack_require__.g\n                            : {}));\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n    return identRE.test(name)\n        ? `__props.${name}`\n        : `__props[${JSON.stringify(name)}]`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1jb3JlL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLEVBQUUsaURBQWlELEtBQUssU0FBUztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsR0FBRyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsS0FBcUM7QUFDeEQsc0JBQXNCO0FBQ3RCLE1BQU0sQ0FBRTtBQUNSLG1CQUFtQixLQUFxQyx3QkFBd0IsQ0FBRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQU07QUFDdkMsOEJBQThCLHFCQUFNO0FBQ3BDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRXV6QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWNvcmUvbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzPzIzMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICogSU1QT1JUQU5UOiBhbGwgY2FsbHMgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHByZWZpeGVkIHdpdGhcbiAqIFxcL1xcKiNcXF9cXF9QVVJFXFxfXFxfXFwqXFwvXG4gKiBTbyB0aGF0IHJvbGx1cCBjYW4gdHJlZS1zaGFrZSB0aGVtIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyB2YWwgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogdmFsID0+ICEhbWFwW3ZhbF07XG59XG5cbi8qKlxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcbiAqL1xuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gICAgWzEgLyogUGF0Y2hGbGFncy5URVhUICovXTogYFRFWFRgLFxuICAgIFsyIC8qIFBhdGNoRmxhZ3MuQ0xBU1MgKi9dOiBgQ0xBU1NgLFxuICAgIFs0IC8qIFBhdGNoRmxhZ3MuU1RZTEUgKi9dOiBgU1RZTEVgLFxuICAgIFs4IC8qIFBhdGNoRmxhZ3MuUFJPUFMgKi9dOiBgUFJPUFNgLFxuICAgIFsxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi9dOiBgRlVMTF9QUk9QU2AsXG4gICAgWzMyIC8qIFBhdGNoRmxhZ3MuSFlEUkFURV9FVkVOVFMgKi9dOiBgSFlEUkFURV9FVkVOVFNgLFxuICAgIFs2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL106IGBTVEFCTEVfRlJBR01FTlRgLFxuICAgIFsxMjggLyogUGF0Y2hGbGFncy5LRVlFRF9GUkFHTUVOVCAqL106IGBLRVlFRF9GUkFHTUVOVGAsXG4gICAgWzI1NiAvKiBQYXRjaEZsYWdzLlVOS0VZRURfRlJBR01FTlQgKi9dOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gICAgWzUxMiAvKiBQYXRjaEZsYWdzLk5FRURfUEFUQ0ggKi9dOiBgTkVFRF9QQVRDSGAsXG4gICAgWzEwMjQgLyogUGF0Y2hGbGFncy5EWU5BTUlDX1NMT1RTICovXTogYERZTkFNSUNfU0xPVFNgLFxuICAgIFsyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi9dOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICAgIFstMSAvKiBQYXRjaEZsYWdzLkhPSVNURUQgKi9dOiBgSE9JU1RFRGAsXG4gICAgWy0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqL106IGBCQUlMYFxufTtcblxuLyoqXG4gKiBEZXYgb25seVxuICovXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xuICAgIFsxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi9dOiAnU1RBQkxFJyxcbiAgICBbMiAvKiBTbG90RmxhZ3MuRFlOQU1JQyAqL106ICdEWU5BTUlDJyxcbiAgICBbMyAvKiBTbG90RmxhZ3MuRk9SV0FSREVEICovXTogJ0ZPUldBUkRFRCdcbn07XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksJyArXG4gICAgJ2RlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksJyArXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgLy8gU3BsaXQgdGhlIGNvbnRlbnQgaW50byBpbmRpdmlkdWFsIGxpbmVzIGJ1dCBjYXB0dXJlIHRoZSBuZXdsaW5lIHNlcXVlbmNlXG4gICAgLy8gdGhhdCBzZXBhcmF0ZWQgZWFjaCBsaW5lLiBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBhY3R1YWwgc2VxdWVuY2UgaXNcbiAgICAvLyBuZWVkZWQgdG8gcHJvcGVybHkgdGFrZSBpbnRvIGFjY291bnQgdGhlIGZ1bGwgbGluZSBsZW5ndGggZm9yIG9mZnNldFxuICAgIC8vIGNvbXBhcmlzb25cbiAgICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICAgIC8vIFNlcGFyYXRlIHRoZSBsaW5lcyBhbmQgbmV3bGluZSBzZXF1ZW5jZXMgaW50byBzZXBhcmF0ZSBhcnJheXMgZm9yIGVhc2llciByZWZlcmVuY2luZ1xuICAgIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50ICs9XG4gICAgICAgICAgICBsaW5lc1tpXS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICgobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCkgfHwgMCk7XG4gICAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSAobmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heCgxLCBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJyAnLnJlcGVhdChwYWQpICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSlcbiAgICAgICAgICAgICAgICA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSlcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooW15dKykvO1xuY29uc3Qgc3R5bGVDb21tZW50UkUgPSAvXFwvXFwqLio/XFwqXFwvL2dzO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgY3NzVGV4dFxuICAgICAgICAucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgJycpXG4gICAgICAgIC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpXG4gICAgICAgIC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcbiAgICAgICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgICBsZXQgcmV0ID0gJyc7XG4gICAgaWYgKCFzdHlsZXMgfHwgaXNTdHJpbmcoc3R5bGVzKSkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gb25seSByZW5kZXIgdmFsaWQgdmFsdWVzXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cblxuLy8gVGhlc2UgdGFnIGNvbmZpZ3MgYXJlIHNoYXJlZCBiZXR3ZWVuIGNvbXBpbGVyLWRvbSBhbmQgcnVudGltZS1kb20sIHNvIHRoZXlcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXG4gICAgJ2hlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sJyArXG4gICAgJ2ZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLCcgK1xuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCwnICtcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcbiAgICAnY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLCcgK1xuICAgICd0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsJyArXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXG4gICAgJ3N1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnRcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcbiAgICAnZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlciwnICtcbiAgICAnZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCwnICtcbiAgICAnZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUiwnICtcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcbiAgICAnZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlciwnICtcbiAgICAnZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLCcgK1xuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsJyArXG4gICAgJ3RleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlldyc7XG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xuLyoqXG4gKiBDb21waWxlciBvbmx5LlxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxuICovXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbi8qKlxuICogQ29tcGlsZXIgb25seS5cbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cbiAqL1xuY29uc3QgaXNTVkdUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuLyoqXG4gKiBDb21waWxlciBvbmx5LlxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxuICovXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuLyoqXG4gKiBPbiB0aGUgY2xpZW50IHdlIG9ubHkgbmVlZCB0byBvZmZlciBzcGVjaWFsIGNhc2VzIGZvciBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdFxuICogaGF2ZSBkaWZmZXJlbnQgbmFtZXMgZnJvbSB0aGVpciBjb3JyZXNwb25kaW5nIGRvbSBwcm9wZXJ0aWVzOlxuICogLSBpdGVtc2NvcGUgLT4gTi9BXG4gKiAtIGFsbG93ZnVsbHNjcmVlbiAtPiBhbGxvd0Z1bGxzY3JlZW5cbiAqIC0gZm9ybW5vdmFsaWRhdGUgLT4gZm9ybU5vVmFsaWRhdGVcbiAqIC0gaXNtYXAgLT4gaXNNYXBcbiAqIC0gbm9tb2R1bGUgLT4gbm9Nb2R1bGVcbiAqIC0gbm92YWxpZGF0ZSAtPiBub1ZhbGlkYXRlXG4gKiAtIHJlYWRvbmx5IC0+IHJlYWRPbmx5XG4gKi9cbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuLyoqXG4gKiBUaGUgZnVsbCBsaXN0IGlzIG5lZWRlZCBkdXJpbmcgU1NSIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgaW5pdGlhbCBtYXJrdXAuXG4gKi9cbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyArXG4gICAgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4sYCArXG4gICAgYGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsYCArXG4gICAgYGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcbi8qKlxuICogQm9vbGVhbiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IG9yICcnLlxuICogZS5nLiBgPHNlbGVjdCBtdWx0aXBsZT5gIGNvbXBpbGVzIHRvIGB7IG11bHRpcGxlOiAnJyB9YFxuICovXG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gJyc7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gICAgfVxuICAgIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xuICAgIGlmIChpc1Vuc2FmZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIChhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlKTtcbn1cbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG59O1xuLyoqXG4gKiBLbm93biBhdHRyaWJ1dGVzLCB0aGlzIGlzIHVzZWQgZm9yIHN0cmluZ2lmaWNhdGlvbiBvZiBydW50aW1lIHN0YXRpYyBub2Rlc1xuICogc28gdGhhdCB3ZSBkb24ndCBzdHJpbmdpZnkgYmluZGluZ3MgdGhhdCBjYW5ub3QgYmUgc2V0IGZyb20gSFRNTC5cbiAqIERvbid0IGFsc28gZm9yZ2V0IHRvIGFsbG93IGBkYXRhLSpgIGFuZCBgYXJpYS0qYCFcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlc1xuICovXG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxgICtcbiAgICBgYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYCArXG4gICAgYGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGAgK1xuICAgIGBjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsYCArXG4gICAgYGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGAgK1xuICAgIGBkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sYCArXG4gICAgYGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsYCArXG4gICAgYGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGludGVncml0eSxgICtcbiAgICBgaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LGAgK1xuICAgIGBtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLGAgK1xuICAgIGBvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHksYCArXG4gICAgYHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsYCArXG4gICAgYHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxgICtcbiAgICBgc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsYCArXG4gICAgYHZhbHVlLHdpZHRoLHdyYXBgKTtcbi8qKlxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZVxuICovXG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxgICtcbiAgICBgYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYCArXG4gICAgYGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGAgK1xuICAgIGBjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGAgK1xuICAgIGBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsYCArXG4gICAgYGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxgICtcbiAgICBgZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsYCArXG4gICAgYGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksYCArXG4gICAgYGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksYCArXG4gICAgYGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGAgK1xuICAgIGBmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxgICtcbiAgICBgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixgICtcbiAgICBgZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGAgK1xuICAgIGBob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGAgK1xuICAgIGBrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGAgK1xuICAgIGBsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxgICtcbiAgICBgbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsYCArXG4gICAgYG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsYCArXG4gICAgYG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLGAgK1xuICAgIGBvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxgICtcbiAgICBgcGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcsYCArXG4gICAgYHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLGAgK1xuICAgIGBwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwsYCArXG4gICAgYHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLGAgK1xuICAgIGByZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxgICtcbiAgICBgc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxgICtcbiAgICBgc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LGAgK1xuICAgIGBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2UsYCArXG4gICAgYHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLGAgK1xuICAgIGBzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLGAgK1xuICAgIGBzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLGAgK1xuICAgIGB0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbixgICtcbiAgICBgdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSxgICtcbiAgICBgdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLGAgK1xuICAgIGB2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCxgICtcbiAgICBgdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLGAgK1xuICAgIGB3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSxgICtcbiAgICBgeGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWw6YmFzZSx4bWw6bGFuZyxgICtcbiAgICBgeG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgICBjb25zdCBzdHIgPSAnJyArIHN0cmluZztcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGxldCBodG1sID0gJyc7XG4gICAgbGV0IGVzY2FwZWQ7XG4gICAgbGV0IGluZGV4O1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICAgICAgICBjYXNlIDM0OiAvLyBcIlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJnF1b3Q7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6IC8vICZcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZhbXA7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzk6IC8vICdcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyYjMzk7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjA6IC8vIDxcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZsdDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MjogLy8gPlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmd0Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTIvc3ludGF4Lmh0bWwjY29tbWVudHNcbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsICcnKTtcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG4gICAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRoaXMgaWYgd2lsbCBwcm9iYWJseSBuZXZlciBiZSBjYWxsZWQgKi9cbiAgICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcbiAgICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgIGlmICgoYUhhc0tleSAmJiAhYkhhc0tleSkgfHxcbiAgICAgICAgICAgICAgICAoIWFIYXNLZXkgJiYgYkhhc0tleSkgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoaXRlbSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xufVxuXG4vKipcbiAqIEZvciBjb252ZXJ0aW5nIHt7IGludGVycG9sYXRpb24gfX0gdmFsdWVzIHRvIGRpc3BsYXllZCBzdHJpbmdzLlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogdmFsID09IG51bGxcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogaXNBcnJheSh2YWwpIHx8XG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KHZhbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkpXG4gICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxuICAgICAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XG59O1xuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XG4gICAgLy8gY2FuJ3QgdXNlIGlzUmVmIGhlcmUgc2luY2UgQHZ1ZS9zaGFyZWQgaGFzIG5vIGRlcHNcbiAgICBpZiAodmFsICYmIHZhbC5fX3ZfaXNSZWYpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKChlbnRyaWVzLCBba2V5LCB2YWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbmNvbnN0IEVNUFRZX09CSiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcbiAgICA6IHt9O1xuY29uc3QgRU1QVFlfQVJSID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XG5jb25zdCBvblJFID0gL15vblteYS16XS87XG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnb25VcGRhdGU6Jyk7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG59O1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBTZXRdJztcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG5jb25zdCBpc1JlZ0V4cCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBSZWdFeHBdJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcbiAgICBrZXkgIT09ICdOYU4nICYmXG4gICAga2V5WzBdICE9PSAnLScgJiZcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbicsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksJyArXG4gICAgJ29uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCwnICtcbiAgICAnb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCwnICtcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCxtZW1vJyk7XG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiAoKHN0cikgPT4ge1xuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XG4gICAgfSk7XG59O1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcbn0pO1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKTtcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCBhcmcpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0oYXJnKTtcbiAgICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZVxuICAgIH0pO1xufTtcbi8qKlxuICogXCIxMjMtZm9vXCIgd2lsbCBiZSBwYXJzZWQgdG8gMTIzXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHRoZSAubnVtYmVyIG1vZGlmaWVyIGluIHYtbW9kZWxcbiAqL1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuLyoqXG4gKiBPbmx5IGNvbmVyY2VzIG51bWJlci1saWtlIHN0cmluZ3NcbiAqIFwiMTIzLWZvb1wiIHdpbGwgYmUgcmV0dXJuZWQgYXMtaXNcbiAqL1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmxldCBfZ2xvYmFsVGhpcztcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxuICAgICAgICAoX2dsb2JhbFRoaXMgPVxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gd2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgICByZXR1cm4gaWRlbnRSRS50ZXN0KG5hbWUpXG4gICAgICAgID8gYF9fcHJvcHMuJHtuYW1lfWBcbiAgICAgICAgOiBgX19wcm9wc1ske0pTT04uc3RyaW5naWZ5KG5hbWUpfV1gO1xufVxuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbG9vc2VUb051bWJlciwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/compiler-core/node_modules/@vue/shared/dist/shared.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BASE_TRANSITION\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.BASE_TRANSITION),\n/* harmony export */   \"CAMELIZE\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAMELIZE),\n/* harmony export */   \"CAPITALIZE\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CAPITALIZE),\n/* harmony export */   \"CREATE_BLOCK\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_BLOCK),\n/* harmony export */   \"CREATE_COMMENT\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_COMMENT),\n/* harmony export */   \"CREATE_ELEMENT_BLOCK\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_BLOCK),\n/* harmony export */   \"CREATE_ELEMENT_VNODE\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_ELEMENT_VNODE),\n/* harmony export */   \"CREATE_SLOTS\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_SLOTS),\n/* harmony export */   \"CREATE_STATIC\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_STATIC),\n/* harmony export */   \"CREATE_TEXT\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_TEXT),\n/* harmony export */   \"CREATE_VNODE\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.CREATE_VNODE),\n/* harmony export */   \"DOMDirectiveTransforms\": () => (/* binding */ DOMDirectiveTransforms),\n/* harmony export */   \"DOMNodeTransforms\": () => (/* binding */ DOMNodeTransforms),\n/* harmony export */   \"FRAGMENT\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.FRAGMENT),\n/* harmony export */   \"GUARD_REACTIVE_PROPS\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.GUARD_REACTIVE_PROPS),\n/* harmony export */   \"IS_MEMO_SAME\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_MEMO_SAME),\n/* harmony export */   \"IS_REF\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.IS_REF),\n/* harmony export */   \"KEEP_ALIVE\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.KEEP_ALIVE),\n/* harmony export */   \"MERGE_PROPS\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.MERGE_PROPS),\n/* harmony export */   \"NORMALIZE_CLASS\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_CLASS),\n/* harmony export */   \"NORMALIZE_PROPS\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_PROPS),\n/* harmony export */   \"NORMALIZE_STYLE\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.NORMALIZE_STYLE),\n/* harmony export */   \"OPEN_BLOCK\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.OPEN_BLOCK),\n/* harmony export */   \"POP_SCOPE_ID\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.POP_SCOPE_ID),\n/* harmony export */   \"PUSH_SCOPE_ID\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.PUSH_SCOPE_ID),\n/* harmony export */   \"RENDER_LIST\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_LIST),\n/* harmony export */   \"RENDER_SLOT\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RENDER_SLOT),\n/* harmony export */   \"RESOLVE_COMPONENT\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_COMPONENT),\n/* harmony export */   \"RESOLVE_DIRECTIVE\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DIRECTIVE),\n/* harmony export */   \"RESOLVE_DYNAMIC_COMPONENT\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_DYNAMIC_COMPONENT),\n/* harmony export */   \"RESOLVE_FILTER\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.RESOLVE_FILTER),\n/* harmony export */   \"SET_BLOCK_TRACKING\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SET_BLOCK_TRACKING),\n/* harmony export */   \"SUSPENSE\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.SUSPENSE),\n/* harmony export */   \"TELEPORT\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TELEPORT),\n/* harmony export */   \"TO_DISPLAY_STRING\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING),\n/* harmony export */   \"TO_HANDLERS\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLERS),\n/* harmony export */   \"TO_HANDLER_KEY\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_HANDLER_KEY),\n/* harmony export */   \"TRANSITION\": () => (/* binding */ TRANSITION),\n/* harmony export */   \"TRANSITION_GROUP\": () => (/* binding */ TRANSITION_GROUP),\n/* harmony export */   \"UNREF\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.UNREF),\n/* harmony export */   \"V_MODEL_CHECKBOX\": () => (/* binding */ V_MODEL_CHECKBOX),\n/* harmony export */   \"V_MODEL_DYNAMIC\": () => (/* binding */ V_MODEL_DYNAMIC),\n/* harmony export */   \"V_MODEL_RADIO\": () => (/* binding */ V_MODEL_RADIO),\n/* harmony export */   \"V_MODEL_SELECT\": () => (/* binding */ V_MODEL_SELECT),\n/* harmony export */   \"V_MODEL_TEXT\": () => (/* binding */ V_MODEL_TEXT),\n/* harmony export */   \"V_ON_WITH_KEYS\": () => (/* binding */ V_ON_WITH_KEYS),\n/* harmony export */   \"V_ON_WITH_MODIFIERS\": () => (/* binding */ V_ON_WITH_MODIFIERS),\n/* harmony export */   \"V_SHOW\": () => (/* binding */ V_SHOW),\n/* harmony export */   \"WITH_CTX\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_CTX),\n/* harmony export */   \"WITH_DIRECTIVES\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_DIRECTIVES),\n/* harmony export */   \"WITH_MEMO\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.WITH_MEMO),\n/* harmony export */   \"advancePositionWithClone\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithClone),\n/* harmony export */   \"advancePositionWithMutation\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.advancePositionWithMutation),\n/* harmony export */   \"assert\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.assert),\n/* harmony export */   \"baseCompile\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile),\n/* harmony export */   \"baseParse\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse),\n/* harmony export */   \"buildDirectiveArgs\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildDirectiveArgs),\n/* harmony export */   \"buildProps\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildProps),\n/* harmony export */   \"buildSlots\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.buildSlots),\n/* harmony export */   \"checkCompatEnabled\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled),\n/* harmony export */   \"compile\": () => (/* binding */ compile),\n/* harmony export */   \"createArrayExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createArrayExpression),\n/* harmony export */   \"createAssignmentExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createAssignmentExpression),\n/* harmony export */   \"createBlockStatement\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createBlockStatement),\n/* harmony export */   \"createCacheExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCacheExpression),\n/* harmony export */   \"createCallExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression),\n/* harmony export */   \"createCompilerError\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError),\n/* harmony export */   \"createCompoundExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression),\n/* harmony export */   \"createConditionalExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createConditionalExpression),\n/* harmony export */   \"createDOMCompilerError\": () => (/* binding */ createDOMCompilerError),\n/* harmony export */   \"createForLoopParams\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createForLoopParams),\n/* harmony export */   \"createFunctionExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createFunctionExpression),\n/* harmony export */   \"createIfStatement\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createIfStatement),\n/* harmony export */   \"createInterpolation\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolation),\n/* harmony export */   \"createObjectExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectExpression),\n/* harmony export */   \"createObjectProperty\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty),\n/* harmony export */   \"createReturnStatement\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createReturnStatement),\n/* harmony export */   \"createRoot\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createRoot),\n/* harmony export */   \"createSequenceExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSequenceExpression),\n/* harmony export */   \"createSimpleExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression),\n/* harmony export */   \"createStructuralDirectiveTransform\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createStructuralDirectiveTransform),\n/* harmony export */   \"createTemplateLiteral\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTemplateLiteral),\n/* harmony export */   \"createTransformContext\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createTransformContext),\n/* harmony export */   \"createVNodeCall\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createVNodeCall),\n/* harmony export */   \"extractIdentifiers\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.extractIdentifiers),\n/* harmony export */   \"findDir\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findDir),\n/* harmony export */   \"findProp\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp),\n/* harmony export */   \"generate\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generate),\n/* harmony export */   \"generateCodeFrame\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.generateCodeFrame),\n/* harmony export */   \"getBaseTransformPreset\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getBaseTransformPreset),\n/* harmony export */   \"getConstantType\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType),\n/* harmony export */   \"getInnerRange\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getInnerRange),\n/* harmony export */   \"getMemoedVNodeCall\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getMemoedVNodeCall),\n/* harmony export */   \"getVNodeBlockHelper\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeBlockHelper),\n/* harmony export */   \"getVNodeHelper\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getVNodeHelper),\n/* harmony export */   \"hasDynamicKeyVBind\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind),\n/* harmony export */   \"hasScopeRef\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasScopeRef),\n/* harmony export */   \"helperNameMap\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.helperNameMap),\n/* harmony export */   \"injectProp\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.injectProp),\n/* harmony export */   \"isBuiltInType\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType),\n/* harmony export */   \"isCoreComponent\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isCoreComponent),\n/* harmony export */   \"isFunctionType\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isFunctionType),\n/* harmony export */   \"isInDestructureAssignment\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isInDestructureAssignment),\n/* harmony export */   \"isMemberExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpression),\n/* harmony export */   \"isMemberExpressionBrowser\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionBrowser),\n/* harmony export */   \"isMemberExpressionNode\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isMemberExpressionNode),\n/* harmony export */   \"isReferencedIdentifier\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isReferencedIdentifier),\n/* harmony export */   \"isSimpleIdentifier\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSimpleIdentifier),\n/* harmony export */   \"isSlotOutlet\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isSlotOutlet),\n/* harmony export */   \"isStaticArgOf\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticArgOf),\n/* harmony export */   \"isStaticExp\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp),\n/* harmony export */   \"isStaticProperty\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticProperty),\n/* harmony export */   \"isStaticPropertyKey\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticPropertyKey),\n/* harmony export */   \"isTemplateNode\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isTemplateNode),\n/* harmony export */   \"isText\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isText),\n/* harmony export */   \"isVSlot\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isVSlot),\n/* harmony export */   \"locStub\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.locStub),\n/* harmony export */   \"makeBlock\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.makeBlock),\n/* harmony export */   \"noopDirectiveTransform\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"parserOptions\": () => (/* binding */ parserOptions),\n/* harmony export */   \"processExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processExpression),\n/* harmony export */   \"processFor\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processFor),\n/* harmony export */   \"processIf\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processIf),\n/* harmony export */   \"processSlotOutlet\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.processSlotOutlet),\n/* harmony export */   \"registerRuntimeHelpers\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers),\n/* harmony export */   \"resolveComponentType\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponentType),\n/* harmony export */   \"stringifyExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.stringifyExpression),\n/* harmony export */   \"toValidAssetId\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.toValidAssetId),\n/* harmony export */   \"trackSlotScopes\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackSlotScopes),\n/* harmony export */   \"trackVForSlotScopes\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.trackVForSlotScopes),\n/* harmony export */   \"transform\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transform),\n/* harmony export */   \"transformBind\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformBind),\n/* harmony export */   \"transformElement\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformElement),\n/* harmony export */   \"transformExpression\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformExpression),\n/* harmony export */   \"transformModel\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel),\n/* harmony export */   \"transformOn\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn),\n/* harmony export */   \"transformStyle\": () => (/* binding */ transformStyle),\n/* harmony export */   \"traverseNode\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.traverseNode),\n/* harmony export */   \"walkBlockDeclarations\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkBlockDeclarations),\n/* harmony export */   \"walkFunctionParams\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkFunctionParams),\n/* harmony export */   \"walkIdentifiers\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.walkIdentifiers),\n/* harmony export */   \"warnDeprecation\": () => (/* reexport safe */ _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.warnDeprecation)\n/* harmony export */ });\n/* harmony import */ var _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/compiler-core */ \"./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js\");\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/compiler-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\n\n\nconst V_MODEL_RADIO = Symbol(( true) ? `vModelRadio` : 0);\nconst V_MODEL_CHECKBOX = Symbol(( true) ? `vModelCheckbox` : 0);\nconst V_MODEL_TEXT = Symbol(( true) ? `vModelText` : 0);\nconst V_MODEL_SELECT = Symbol(( true) ? `vModelSelect` : 0);\nconst V_MODEL_DYNAMIC = Symbol(( true) ? `vModelDynamic` : 0);\nconst V_ON_WITH_MODIFIERS = Symbol(( true) ? `vOnModifiersGuard` : 0);\nconst V_ON_WITH_KEYS = Symbol(( true) ? `vOnKeysGuard` : 0);\nconst V_SHOW = Symbol(( true) ? `vShow` : 0);\nconst TRANSITION = Symbol(( true) ? `Transition` : 0);\nconst TRANSITION_GROUP = Symbol(( true) ? `TransitionGroup` : 0);\n(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeHelpers)({\n    [V_MODEL_RADIO]: `vModelRadio`,\n    [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n    [V_MODEL_TEXT]: `vModelText`,\n    [V_MODEL_SELECT]: `vModelSelect`,\n    [V_MODEL_DYNAMIC]: `vModelDynamic`,\n    [V_ON_WITH_MODIFIERS]: `withModifiers`,\n    [V_ON_WITH_KEYS]: `withKeys`,\n    [V_SHOW]: `vShow`,\n    [TRANSITION]: `Transition`,\n    [TRANSITION_GROUP]: `TransitionGroup`\n});\n\n/* eslint-disable no-restricted-globals */\nlet decoder;\nfunction decodeHtmlBrowser(raw, asAttr = false) {\n    if (!decoder) {\n        decoder = document.createElement('div');\n    }\n    if (asAttr) {\n        decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`;\n        return decoder.children[0].getAttribute('foo');\n    }\n    else {\n        decoder.innerHTML = raw;\n        return decoder.textContent;\n    }\n}\n\nconst isRawTextContainer = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('style,iframe,script,noscript', true);\nconst parserOptions = {\n    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.isVoidTag,\n    isNativeTag: tag => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),\n    isPreTag: tag => tag === 'pre',\n    decodeEntities: decodeHtmlBrowser ,\n    isBuiltInComponent: (tag) => {\n        if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `Transition`)) {\n            return TRANSITION;\n        }\n        else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isBuiltInType)(tag, `TransitionGroup`)) {\n            return TRANSITION_GROUP;\n        }\n    },\n    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n    getNamespace(tag, parent) {\n        let ns = parent ? parent.ns : 0 /* DOMNamespaces.HTML */;\n        if (parent && ns === 2 /* DOMNamespaces.MATH_ML */) {\n            if (parent.tag === 'annotation-xml') {\n                if (tag === 'svg') {\n                    return 1 /* DOMNamespaces.SVG */;\n                }\n                if (parent.props.some(a => a.type === 6 /* NodeTypes.ATTRIBUTE */ &&\n                    a.name === 'encoding' &&\n                    a.value != null &&\n                    (a.value.content === 'text/html' ||\n                        a.value.content === 'application/xhtml+xml'))) {\n                    ns = 0 /* DOMNamespaces.HTML */;\n                }\n            }\n            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&\n                tag !== 'mglyph' &&\n                tag !== 'malignmark') {\n                ns = 0 /* DOMNamespaces.HTML */;\n            }\n        }\n        else if (parent && ns === 1 /* DOMNamespaces.SVG */) {\n            if (parent.tag === 'foreignObject' ||\n                parent.tag === 'desc' ||\n                parent.tag === 'title') {\n                ns = 0 /* DOMNamespaces.HTML */;\n            }\n        }\n        if (ns === 0 /* DOMNamespaces.HTML */) {\n            if (tag === 'svg') {\n                return 1 /* DOMNamespaces.SVG */;\n            }\n            if (tag === 'math') {\n                return 2 /* DOMNamespaces.MATH_ML */;\n            }\n        }\n        return ns;\n    },\n    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n    getTextMode({ tag, ns }) {\n        if (ns === 0 /* DOMNamespaces.HTML */) {\n            if (tag === 'textarea' || tag === 'title') {\n                return 1 /* TextModes.RCDATA */;\n            }\n            if (isRawTextContainer(tag)) {\n                return 2 /* TextModes.RAWTEXT */;\n            }\n        }\n        return 0 /* TextModes.DATA */;\n    }\n};\n\n// Parse inline CSS strings for static style attributes into an object.\n// This is a NodeTransform since it works on the static `style` attribute and\n// converts it into a dynamic equivalent:\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\n// It is then processed by `transformElement` and included in the generated\n// props.\nconst transformStyle = node => {\n    if (node.type === 1 /* NodeTypes.ELEMENT */) {\n        node.props.forEach((p, i) => {\n            if (p.type === 6 /* NodeTypes.ATTRIBUTE */ && p.name === 'style' && p.value) {\n                // replace p with an expression node\n                node.props[i] = {\n                    type: 7 /* NodeTypes.DIRECTIVE */,\n                    name: `bind`,\n                    arg: (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`style`, true, p.loc),\n                    exp: parseInlineCSS(p.value.content, p.loc),\n                    modifiers: [],\n                    loc: p.loc\n                };\n            }\n        });\n    }\n};\nconst parseInlineCSS = (cssText, loc) => {\n    const normalized = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.parseStringStyle)(cssText);\n    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(JSON.stringify(normalized), false, loc, 3 /* ConstantTypes.CAN_STRINGIFY */);\n};\n\nfunction createDOMCompilerError(code, loc) {\n    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompilerError)(code, loc,  true ? DOMErrorMessages : 0);\n}\nconst DOMErrorMessages = {\n    [51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\n    [52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\n    [53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\n    [54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\n    [55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n    [56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\n    [57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n    [58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\n    [59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\n    [60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\n    [61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\n};\n\nconst transformVHtml = (dir, node, context) => {\n    const { exp, loc } = dir;\n    if (!exp) {\n        context.onError(createDOMCompilerError(51 /* DOMErrorCodes.X_V_HTML_NO_EXPRESSION */, loc));\n    }\n    if (node.children.length) {\n        context.onError(createDOMCompilerError(52 /* DOMErrorCodes.X_V_HTML_WITH_CHILDREN */, loc));\n        node.children.length = 0;\n    }\n    return {\n        props: [\n            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`innerHTML`, true, loc), exp || (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))\n        ]\n    };\n};\n\nconst transformVText = (dir, node, context) => {\n    const { exp, loc } = dir;\n    if (!exp) {\n        context.onError(createDOMCompilerError(53 /* DOMErrorCodes.X_V_TEXT_NO_EXPRESSION */, loc));\n    }\n    if (node.children.length) {\n        context.onError(createDOMCompilerError(54 /* DOMErrorCodes.X_V_TEXT_WITH_CHILDREN */, loc));\n        node.children.length = 0;\n    }\n    return {\n        props: [\n            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`textContent`, true), exp\n                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.getConstantType)(exp, context) > 0\n                    ? exp\n                    : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helperString(_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.TO_DISPLAY_STRING), [exp], loc)\n                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)('', true))\n        ]\n    };\n};\n\nconst transformModel = (dir, node, context) => {\n    const baseResult = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformModel)(dir, node, context);\n    // base transform has errors OR component v-model (only need props)\n    if (!baseResult.props.length || node.tagType === 1 /* ElementTypes.COMPONENT */) {\n        return baseResult;\n    }\n    if (dir.arg) {\n        context.onError(createDOMCompilerError(56 /* DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\n    }\n    function checkDuplicatedValue() {\n        const value = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, 'value');\n        if (value) {\n            context.onError(createDOMCompilerError(58 /* DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\n        }\n    }\n    const { tag } = node;\n    const isCustomElement = context.isCustomElement(tag);\n    if (tag === 'input' ||\n        tag === 'textarea' ||\n        tag === 'select' ||\n        isCustomElement) {\n        let directiveToUse = V_MODEL_TEXT;\n        let isInvalidType = false;\n        if (tag === 'input' || isCustomElement) {\n            const type = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.findProp)(node, `type`);\n            if (type) {\n                if (type.type === 7 /* NodeTypes.DIRECTIVE */) {\n                    // :type=\"foo\"\n                    directiveToUse = V_MODEL_DYNAMIC;\n                }\n                else if (type.value) {\n                    switch (type.value.content) {\n                        case 'radio':\n                            directiveToUse = V_MODEL_RADIO;\n                            break;\n                        case 'checkbox':\n                            directiveToUse = V_MODEL_CHECKBOX;\n                            break;\n                        case 'file':\n                            isInvalidType = true;\n                            context.onError(createDOMCompilerError(57 /* DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\n                            break;\n                        default:\n                            // text type\n                            ( true) && checkDuplicatedValue();\n                            break;\n                    }\n                }\n            }\n            else if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.hasDynamicKeyVBind)(node)) {\n                // element has bindings with dynamic keys, which can possibly contain\n                // \"type\".\n                directiveToUse = V_MODEL_DYNAMIC;\n            }\n            else {\n                // text type\n                ( true) && checkDuplicatedValue();\n            }\n        }\n        else if (tag === 'select') {\n            directiveToUse = V_MODEL_SELECT;\n        }\n        else {\n            // textarea\n            ( true) && checkDuplicatedValue();\n        }\n        // inject runtime directive\n        // by returning the helper symbol via needRuntime\n        // the import will replaced a resolveDirective call.\n        if (!isInvalidType) {\n            baseResult.needRuntime = context.helper(directiveToUse);\n        }\n    }\n    else {\n        context.onError(createDOMCompilerError(55 /* DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\n    }\n    // native vmodel doesn't need the `modelValue` props since they are also\n    // passed to the runtime as `binding.value`. removing it reduces code size.\n    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* NodeTypes.SIMPLE_EXPRESSION */ &&\n        p.key.content === 'modelValue'));\n    return baseResult;\n};\n\nconst isEventOptionModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`passive,once,capture`);\nconst isNonKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(\n// event propagation management\n`stop,prevent,self,` +\n    // system modifiers + exact\n    `ctrl,shift,alt,meta,exact,` +\n    // mouse\n    `middle`);\n// left & right could be mouse or key modifiers based on event type\nconst maybeKeyModifier = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('left,right');\nconst isKeyboardEvent = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)(`onkeyup,onkeydown,onkeypress`, true);\nconst resolveModifiers = (key, modifiers, context, loc) => {\n    const keyModifiers = [];\n    const nonKeyModifiers = [];\n    const eventOptionModifiers = [];\n    for (let i = 0; i < modifiers.length; i++) {\n        const modifier = modifiers[i];\n        if (modifier === 'native' &&\n            (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.checkCompatEnabled)(\"COMPILER_V_ON_NATIVE\" /* CompilerDeprecationTypes.COMPILER_V_ON_NATIVE */, context, loc)) {\n            eventOptionModifiers.push(modifier);\n        }\n        else if (isEventOptionModifier(modifier)) {\n            // eventOptionModifiers: modifiers for addEventListener() options,\n            // e.g. .passive & .capture\n            eventOptionModifiers.push(modifier);\n        }\n        else {\n            // runtimeModifiers: modifiers that needs runtime guards\n            if (maybeKeyModifier(modifier)) {\n                if ((0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)) {\n                    if (isKeyboardEvent(key.content)) {\n                        keyModifiers.push(modifier);\n                    }\n                    else {\n                        nonKeyModifiers.push(modifier);\n                    }\n                }\n                else {\n                    keyModifiers.push(modifier);\n                    nonKeyModifiers.push(modifier);\n                }\n            }\n            else {\n                if (isNonKeyModifier(modifier)) {\n                    nonKeyModifiers.push(modifier);\n                }\n                else {\n                    keyModifiers.push(modifier);\n                }\n            }\n        }\n    }\n    return {\n        keyModifiers,\n        nonKeyModifiers,\n        eventOptionModifiers\n    };\n};\nconst transformClick = (key, event) => {\n    const isStaticClick = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) && key.content.toLowerCase() === 'onclick';\n    return isStaticClick\n        ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(event, true)\n        : key.type !== 4 /* NodeTypes.SIMPLE_EXPRESSION */\n            ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([\n                `(`,\n                key,\n                `) === \"onClick\" ? \"${event}\" : (`,\n                key,\n                `)`\n            ])\n            : key;\n};\nconst transformOn = (dir, node, context) => {\n    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.transformOn)(dir, node, context, baseResult => {\n        const { modifiers } = dir;\n        if (!modifiers.length)\n            return baseResult;\n        let { key, value: handlerExp } = baseResult.props[0];\n        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);\n        // normalize click.right and click.middle since they don't actually fire\n        if (nonKeyModifiers.includes('right')) {\n            key = transformClick(key, `onContextmenu`);\n        }\n        if (nonKeyModifiers.includes('middle')) {\n            key = transformClick(key, `onMouseup`);\n        }\n        if (nonKeyModifiers.length) {\n            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_MODIFIERS), [\n                handlerExp,\n                JSON.stringify(nonKeyModifiers)\n            ]);\n        }\n        if (keyModifiers.length &&\n            // if event name is dynamic, always wrap with keys guard\n            (!(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key) || isKeyboardEvent(key.content))) {\n            handlerExp = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCallExpression)(context.helper(V_ON_WITH_KEYS), [\n                handlerExp,\n                JSON.stringify(keyModifiers)\n            ]);\n        }\n        if (eventOptionModifiers.length) {\n            const modifierPostfix = eventOptionModifiers.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join('');\n            key = (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.isStaticExp)(key)\n                ? (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createSimpleExpression)(`${key.content}${modifierPostfix}`, true)\n                : (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createCompoundExpression)([`(`, key, `) + \"${modifierPostfix}\"`]);\n        }\n        return {\n            props: [(0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.createObjectProperty)(key, handlerExp)]\n        };\n    });\n};\n\nconst transformShow = (dir, node, context) => {\n    const { exp, loc } = dir;\n    if (!exp) {\n        context.onError(createDOMCompilerError(59 /* DOMErrorCodes.X_V_SHOW_NO_EXPRESSION */, loc));\n    }\n    return {\n        props: [],\n        needRuntime: context.helper(V_SHOW)\n    };\n};\n\nconst transformTransition = (node, context) => {\n    if (node.type === 1 /* NodeTypes.ELEMENT */ &&\n        node.tagType === 1 /* ElementTypes.COMPONENT */) {\n        const component = context.isBuiltInComponent(node.tag);\n        if (component === TRANSITION) {\n            return () => {\n                if (!node.children.length) {\n                    return;\n                }\n                // warn multiple transition children\n                if (hasMultipleChildren(node)) {\n                    context.onError(createDOMCompilerError(60 /* DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN */, {\n                        start: node.children[0].loc.start,\n                        end: node.children[node.children.length - 1].loc.end,\n                        source: ''\n                    }));\n                }\n                // check if it's s single child w/ v-show\n                // if yes, inject \"persisted: true\" to the transition props\n                const child = node.children[0];\n                if (child.type === 1 /* NodeTypes.ELEMENT */) {\n                    for (const p of child.props) {\n                        if (p.type === 7 /* NodeTypes.DIRECTIVE */ && p.name === 'show') {\n                            node.props.push({\n                                type: 6 /* NodeTypes.ATTRIBUTE */,\n                                name: 'persisted',\n                                value: undefined,\n                                loc: node.loc\n                            });\n                        }\n                    }\n                }\n            };\n        }\n    }\n};\nfunction hasMultipleChildren(node) {\n    // #1352 filter out potential comment nodes.\n    const children = (node.children = node.children.filter(c => c.type !== 3 /* NodeTypes.COMMENT */ &&\n        !(c.type === 2 /* NodeTypes.TEXT */ && !c.content.trim())));\n    const child = children[0];\n    return (children.length !== 1 ||\n        child.type === 11 /* NodeTypes.FOR */ ||\n        (child.type === 9 /* NodeTypes.IF */ && child.branches.some(hasMultipleChildren)));\n}\n\nconst ignoreSideEffectTags = (node, context) => {\n    if (node.type === 1 /* NodeTypes.ELEMENT */ &&\n        node.tagType === 0 /* ElementTypes.ELEMENT */ &&\n        (node.tag === 'script' || node.tag === 'style')) {\n        context.onError(createDOMCompilerError(61 /* DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\n        context.removeNode();\n    }\n};\n\nconst DOMNodeTransforms = [\n    transformStyle,\n    ...(( true) ? [transformTransition] : 0)\n];\nconst DOMDirectiveTransforms = {\n    cloak: _vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.noopDirectiveTransform,\n    html: transformVHtml,\n    text: transformVText,\n    model: transformModel,\n    on: transformOn,\n    show: transformShow\n};\nfunction compile(template, options = {}) {\n    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options, {\n        nodeTransforms: [\n            // ignore <script> and <tag>\n            // this is not put inside DOMNodeTransforms because that list is used\n            // by compiler-ssr to generate vnode fallback branches\n            ignoreSideEffectTags,\n            ...DOMNodeTransforms,\n            ...(options.nodeTransforms || [])\n        ],\n        directiveTransforms: (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\n        transformHoist: null \n    }));\n}\nfunction parse(template, options = {}) {\n    return (0,_vue_compiler_core__WEBPACK_IMPORTED_MODULE_0__.baseParse)(template, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, parserOptions, options));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1kb20vZGlzdC9jb21waWxlci1kb20uZXNtLWJ1bmRsZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtWjtBQUNoWDtBQUN5RTs7QUFFNUcsOEJBQThCLEtBQXFDLG9CQUFvQixDQUFFO0FBQ3pGLGlDQUFpQyxLQUFxQyx1QkFBdUIsQ0FBRTtBQUMvRiw2QkFBNkIsS0FBcUMsbUJBQW1CLENBQUU7QUFDdkYsK0JBQStCLEtBQXFDLHFCQUFxQixDQUFFO0FBQzNGLGdDQUFnQyxLQUFxQyxzQkFBc0IsQ0FBRTtBQUM3RixvQ0FBb0MsS0FBcUMsMEJBQTBCLENBQUU7QUFDckcsK0JBQStCLEtBQXFDLHFCQUFxQixDQUFFO0FBQzNGLHVCQUF1QixLQUFxQyxjQUFjLENBQUU7QUFDNUUsMkJBQTJCLEtBQXFDLG1CQUFtQixDQUFFO0FBQ3JGLGlDQUFpQyxLQUFxQyx3QkFBd0IsQ0FBRTtBQUNoRywwRUFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QixHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxvREFBTztBQUNoRDtBQUNBLGFBQWE7QUFDYix3QkFBd0Isc0RBQVMsU0FBUyxxREFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFhO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUIsaUVBQWE7QUFDOUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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LFNBQVMsS0FBcUMsNEJBQTRCLENBQUU7QUFDNUU7QUFDQTtBQUNBLFdBQVcsc0VBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxXQUFXLCtEQUFXLFdBQVcsbURBQU0sR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1EQUFNLEdBQUcsMkRBQTJEO0FBQ2pHO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUNBQXFDO0FBQ3JDLFdBQVcsNkRBQVMsV0FBVyxtREFBTSxHQUFHO0FBQ3hDOztBQUV1UiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBpbGVyLWRvbS9kaXN0L2NvbXBpbGVyLWRvbS5lc20tYnVuZGxlci5qcz81YmY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlZ2lzdGVyUnVudGltZUhlbHBlcnMsIGlzQnVpbHRJblR5cGUsIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24sIGNyZWF0ZUNvbXBpbGVyRXJyb3IsIGNyZWF0ZU9iamVjdFByb3BlcnR5LCBnZXRDb25zdGFudFR5cGUsIGNyZWF0ZUNhbGxFeHByZXNzaW9uLCBUT19ESVNQTEFZX1NUUklORywgdHJhbnNmb3JtTW9kZWwgYXMgdHJhbnNmb3JtTW9kZWwkMSwgZmluZFByb3AsIGhhc0R5bmFtaWNLZXlWQmluZCwgdHJhbnNmb3JtT24gYXMgdHJhbnNmb3JtT24kMSwgaXNTdGF0aWNFeHAsIGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbiwgY2hlY2tDb21wYXRFbmFibGVkLCBub29wRGlyZWN0aXZlVHJhbnNmb3JtLCBiYXNlQ29tcGlsZSwgYmFzZVBhcnNlIH0gZnJvbSAnQHZ1ZS9jb21waWxlci1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B2dWUvY29tcGlsZXItY29yZSc7XG5pbXBvcnQgeyBpc1ZvaWRUYWcsIGlzSFRNTFRhZywgaXNTVkdUYWcsIG1ha2VNYXAsIHBhcnNlU3RyaW5nU3R5bGUsIGNhcGl0YWxpemUsIGV4dGVuZCB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3QgVl9NT0RFTF9SQURJTyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsUmFkaW9gIDogYGApO1xuY29uc3QgVl9NT0RFTF9DSEVDS0JPWCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgdk1vZGVsQ2hlY2tib3hgIDogYGApO1xuY29uc3QgVl9NT0RFTF9URVhUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxUZXh0YCA6IGBgKTtcbmNvbnN0IFZfTU9ERUxfU0VMRUNUID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxTZWxlY3RgIDogYGApO1xuY29uc3QgVl9NT0RFTF9EWU5BTUlDID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2TW9kZWxEeW5hbWljYCA6IGBgKTtcbmNvbnN0IFZfT05fV0lUSF9NT0RJRklFUlMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYHZPbk1vZGlmaWVyc0d1YXJkYCA6IGBgKTtcbmNvbnN0IFZfT05fV0lUSF9LRVlTID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2T25LZXlzR3VhcmRgIDogYGApO1xuY29uc3QgVl9TSE9XID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGB2U2hvd2AgOiBgYCk7XG5jb25zdCBUUkFOU0lUSU9OID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBUcmFuc2l0aW9uYCA6IGBgKTtcbmNvbnN0IFRSQU5TSVRJT05fR1JPVVAgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gYFRyYW5zaXRpb25Hcm91cGAgOiBgYCk7XG5yZWdpc3RlclJ1bnRpbWVIZWxwZXJzKHtcbiAgICBbVl9NT0RFTF9SQURJT106IGB2TW9kZWxSYWRpb2AsXG4gICAgW1ZfTU9ERUxfQ0hFQ0tCT1hdOiBgdk1vZGVsQ2hlY2tib3hgLFxuICAgIFtWX01PREVMX1RFWFRdOiBgdk1vZGVsVGV4dGAsXG4gICAgW1ZfTU9ERUxfU0VMRUNUXTogYHZNb2RlbFNlbGVjdGAsXG4gICAgW1ZfTU9ERUxfRFlOQU1JQ106IGB2TW9kZWxEeW5hbWljYCxcbiAgICBbVl9PTl9XSVRIX01PRElGSUVSU106IGB3aXRoTW9kaWZpZXJzYCxcbiAgICBbVl9PTl9XSVRIX0tFWVNdOiBgd2l0aEtleXNgLFxuICAgIFtWX1NIT1ddOiBgdlNob3dgLFxuICAgIFtUUkFOU0lUSU9OXTogYFRyYW5zaXRpb25gLFxuICAgIFtUUkFOU0lUSU9OX0dST1VQXTogYFRyYW5zaXRpb25Hcm91cGBcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmxldCBkZWNvZGVyO1xuZnVuY3Rpb24gZGVjb2RlSHRtbEJyb3dzZXIocmF3LCBhc0F0dHIgPSBmYWxzZSkge1xuICAgIGlmICghZGVjb2Rlcikge1xuICAgICAgICBkZWNvZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIGlmIChhc0F0dHIpIHtcbiAgICAgICAgZGVjb2Rlci5pbm5lckhUTUwgPSBgPGRpdiBmb289XCIke3Jhdy5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyl9XCI+YDtcbiAgICAgICAgcmV0dXJuIGRlY29kZXIuY2hpbGRyZW5bMF0uZ2V0QXR0cmlidXRlKCdmb28nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gcmF3O1xuICAgICAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudDtcbiAgICB9XG59XG5cbmNvbnN0IGlzUmF3VGV4dENvbnRhaW5lciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnc3R5bGUsaWZyYW1lLHNjcmlwdCxub3NjcmlwdCcsIHRydWUpO1xuY29uc3QgcGFyc2VyT3B0aW9ucyA9IHtcbiAgICBpc1ZvaWRUYWcsXG4gICAgaXNOYXRpdmVUYWc6IHRhZyA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpLFxuICAgIGlzUHJlVGFnOiB0YWcgPT4gdGFnID09PSAncHJlJyxcbiAgICBkZWNvZGVFbnRpdGllczogZGVjb2RlSHRtbEJyb3dzZXIgLFxuICAgIGlzQnVpbHRJbkNvbXBvbmVudDogKHRhZykgPT4ge1xuICAgICAgICBpZiAoaXNCdWlsdEluVHlwZSh0YWcsIGBUcmFuc2l0aW9uYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQnVpbHRJblR5cGUodGFnLCBgVHJhbnNpdGlvbkdyb3VwYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBUUkFOU0lUSU9OX0dST1VQO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjdHJlZS1jb25zdHJ1Y3Rpb24tZGlzcGF0Y2hlclxuICAgIGdldE5hbWVzcGFjZSh0YWcsIHBhcmVudCkge1xuICAgICAgICBsZXQgbnMgPSBwYXJlbnQgPyBwYXJlbnQubnMgOiAwIC8qIERPTU5hbWVzcGFjZXMuSFRNTCAqLztcbiAgICAgICAgaWYgKHBhcmVudCAmJiBucyA9PT0gMiAvKiBET01OYW1lc3BhY2VzLk1BVEhfTUwgKi8pIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudGFnID09PSAnYW5ub3RhdGlvbi14bWwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogRE9NTmFtZXNwYWNlcy5TVkcgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQucHJvcHMuc29tZShhID0+IGEudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovICYmXG4gICAgICAgICAgICAgICAgICAgIGEubmFtZSA9PT0gJ2VuY29kaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICBhLnZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgKGEudmFsdWUuY29udGVudCA9PT0gJ3RleHQvaHRtbCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEudmFsdWUuY29udGVudCA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcpKSkge1xuICAgICAgICAgICAgICAgICAgICBucyA9IDAgLyogRE9NTmFtZXNwYWNlcy5IVE1MICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9ebSg/Oltpb25zXXx0ZXh0KSQvLnRlc3QocGFyZW50LnRhZykgJiZcbiAgICAgICAgICAgICAgICB0YWcgIT09ICdtZ2x5cGgnICYmXG4gICAgICAgICAgICAgICAgdGFnICE9PSAnbWFsaWdubWFyaycpIHtcbiAgICAgICAgICAgICAgICBucyA9IDAgLyogRE9NTmFtZXNwYWNlcy5IVE1MICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCAmJiBucyA9PT0gMSAvKiBET01OYW1lc3BhY2VzLlNWRyAqLykge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50YWcgPT09ICdmb3JlaWduT2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC50YWcgPT09ICdkZXNjJyB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC50YWcgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICBucyA9IDAgLyogRE9NTmFtZXNwYWNlcy5IVE1MICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChucyA9PT0gMCAvKiBET01OYW1lc3BhY2VzLkhUTUwgKi8pIHtcbiAgICAgICAgICAgIGlmICh0YWcgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogRE9NTmFtZXNwYWNlcy5TVkcgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBET01OYW1lc3BhY2VzLk1BVEhfTUwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5zO1xuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3BhcnNpbmctaHRtbC1mcmFnbWVudHNcbiAgICBnZXRUZXh0TW9kZSh7IHRhZywgbnMgfSkge1xuICAgICAgICBpZiAobnMgPT09IDAgLyogRE9NTmFtZXNwYWNlcy5IVE1MICovKSB7XG4gICAgICAgICAgICBpZiAodGFnID09PSAndGV4dGFyZWEnIHx8IHRhZyA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFRleHRNb2Rlcy5SQ0RBVEEgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNSYXdUZXh0Q29udGFpbmVyKHRhZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBUZXh0TW9kZXMuUkFXVEVYVCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBUZXh0TW9kZXMuREFUQSAqLztcbiAgICB9XG59O1xuXG4vLyBQYXJzZSBpbmxpbmUgQ1NTIHN0cmluZ3MgZm9yIHN0YXRpYyBzdHlsZSBhdHRyaWJ1dGVzIGludG8gYW4gb2JqZWN0LlxuLy8gVGhpcyBpcyBhIE5vZGVUcmFuc2Zvcm0gc2luY2UgaXQgd29ya3Mgb24gdGhlIHN0YXRpYyBgc3R5bGVgIGF0dHJpYnV0ZSBhbmRcbi8vIGNvbnZlcnRzIGl0IGludG8gYSBkeW5hbWljIGVxdWl2YWxlbnQ6XG4vLyBzdHlsZT1cImNvbG9yOiByZWRcIiAtPiA6c3R5bGU9J3sgXCJjb2xvclwiOiBcInJlZFwiIH0nXG4vLyBJdCBpcyB0aGVuIHByb2Nlc3NlZCBieSBgdHJhbnNmb3JtRWxlbWVudGAgYW5kIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWRcbi8vIHByb3BzLlxuY29uc3QgdHJhbnNmb3JtU3R5bGUgPSBub2RlID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovKSB7XG4gICAgICAgIG5vZGUucHJvcHMuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKHAudHlwZSA9PT0gNiAvKiBOb2RlVHlwZXMuQVRUUklCVVRFICovICYmIHAubmFtZSA9PT0gJ3N0eWxlJyAmJiBwLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwIHdpdGggYW4gZXhwcmVzc2lvbiBub2RlXG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogNyAvKiBOb2RlVHlwZXMuRElSRUNUSVZFICovLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgYmluZGAsXG4gICAgICAgICAgICAgICAgICAgIGFyZzogY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgc3R5bGVgLCB0cnVlLCBwLmxvYyksXG4gICAgICAgICAgICAgICAgICAgIGV4cDogcGFyc2VJbmxpbmVDU1MocC52YWx1ZS5jb250ZW50LCBwLmxvYyksXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICAgICAgICAgICAgICAgIGxvYzogcC5sb2NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuY29uc3QgcGFyc2VJbmxpbmVDU1MgPSAoY3NzVGV4dCwgbG9jKSA9PiB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCk7XG4gICAgcmV0dXJuIGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCksIGZhbHNlLCBsb2MsIDMgLyogQ29uc3RhbnRUeXBlcy5DQU5fU1RSSU5HSUZZICovKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgIXRydWUgPyBET01FcnJvck1lc3NhZ2VzIDogdW5kZWZpbmVkKTtcbn1cbmNvbnN0IERPTUVycm9yTWVzc2FnZXMgPSB7XG4gICAgWzUxIC8qIERPTUVycm9yQ29kZXMuWF9WX0hUTUxfTk9fRVhQUkVTU0lPTiAqL106IGB2LWh0bWwgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gICAgWzUyIC8qIERPTUVycm9yQ29kZXMuWF9WX0hUTUxfV0lUSF9DSElMRFJFTiAqL106IGB2LWh0bWwgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXG4gICAgWzUzIC8qIERPTUVycm9yQ29kZXMuWF9WX1RFWFRfTk9fRVhQUkVTU0lPTiAqL106IGB2LXRleHQgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gICAgWzU0IC8qIERPTUVycm9yQ29kZXMuWF9WX1RFWFRfV0lUSF9DSElMRFJFTiAqL106IGB2LXRleHQgd2lsbCBvdmVycmlkZSBlbGVtZW50IGNoaWxkcmVuLmAsXG4gICAgWzU1IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX09OX0lOVkFMSURfRUxFTUVOVCAqL106IGB2LW1vZGVsIGNhbiBvbmx5IGJlIHVzZWQgb24gPGlucHV0PiwgPHRleHRhcmVhPiBhbmQgPHNlbGVjdD4gZWxlbWVudHMuYCxcbiAgICBbNTYgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfQVJHX09OX0VMRU1FTlQgKi9dOiBgdi1tb2RlbCBhcmd1bWVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIHBsYWluIGVsZW1lbnRzLmAsXG4gICAgWzU3IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqL106IGB2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIGZpbGUgaW5wdXRzIHNpbmNlIHRoZXkgYXJlIHJlYWQtb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5gLFxuICAgIFs1OCAvKiBET01FcnJvckNvZGVzLlhfVl9NT0RFTF9VTk5FQ0VTU0FSWV9WQUxVRSAqL106IGBVbm5lY2Vzc2FyeSB2YWx1ZSBiaW5kaW5nIHVzZWQgYWxvbmdzaWRlIHYtbW9kZWwuIEl0IHdpbGwgaW50ZXJmZXJlIHdpdGggdi1tb2RlbCdzIGJlaGF2aW9yLmAsXG4gICAgWzU5IC8qIERPTUVycm9yQ29kZXMuWF9WX1NIT1dfTk9fRVhQUkVTU0lPTiAqL106IGB2LXNob3cgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gICAgWzYwIC8qIERPTUVycm9yQ29kZXMuWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU4gKi9dOiBgPFRyYW5zaXRpb24+IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudCBvciBjb21wb25lbnQuYCxcbiAgICBbNjEgLyogRE9NRXJyb3JDb2Rlcy5YX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHICovXTogYFRhZ3Mgd2l0aCBzaWRlIGVmZmVjdCAoPHNjcmlwdD4gYW5kIDxzdHlsZT4pIGFyZSBpZ25vcmVkIGluIGNsaWVudCBjb21wb25lbnQgdGVtcGxhdGVzLmBcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVZIdG1sID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcbiAgICBpZiAoIWV4cCkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MSAvKiBET01FcnJvckNvZGVzLlhfVl9IVE1MX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTIgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfSFRNTF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgaW5uZXJIVE1MYCwgdHJ1ZSwgbG9jKSwgZXhwIHx8IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oJycsIHRydWUpKVxuICAgICAgICBdXG4gICAgfTtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVZUZXh0ID0gKGRpciwgbm9kZSwgY29udGV4dCkgPT4ge1xuICAgIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcbiAgICBpZiAoIWV4cCkge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1MyAvKiBET01FcnJvckNvZGVzLlhfVl9URVhUX05PX0VYUFJFU1NJT04gKi8sIGxvYykpO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTQgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfVEVYVF9XSVRIX0NISUxEUkVOICovLCBsb2MpKTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgICAgY3JlYXRlT2JqZWN0UHJvcGVydHkoY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdGV4dENvbnRlbnRgLCB0cnVlKSwgZXhwXG4gICAgICAgICAgICAgICAgPyBnZXRDb25zdGFudFR5cGUoZXhwLCBjb250ZXh0KSA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBleHBcbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlclN0cmluZyhUT19ESVNQTEFZX1NUUklORyksIFtleHBdLCBsb2MpXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVTaW1wbGVFeHByZXNzaW9uKCcnLCB0cnVlKSlcbiAgICAgICAgXVxuICAgIH07XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCBiYXNlUmVzdWx0ID0gdHJhbnNmb3JtTW9kZWwkMShkaXIsIG5vZGUsIGNvbnRleHQpO1xuICAgIC8vIGJhc2UgdHJhbnNmb3JtIGhhcyBlcnJvcnMgT1IgY29tcG9uZW50IHYtbW9kZWwgKG9ubHkgbmVlZCBwcm9wcylcbiAgICBpZiAoIWJhc2VSZXN1bHQucHJvcHMubGVuZ3RoIHx8IG5vZGUudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovKSB7XG4gICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZGlyLmFyZykge1xuICAgICAgICBjb250ZXh0Lm9uRXJyb3IoY3JlYXRlRE9NQ29tcGlsZXJFcnJvcig1NiAvKiBET01FcnJvckNvZGVzLlhfVl9NT0RFTF9BUkdfT05fRUxFTUVOVCAqLywgZGlyLmFyZy5sb2MpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVkVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmluZFByb3Aobm9kZSwgJ3ZhbHVlJyk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTggLyogRE9NRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUUgKi8sIHZhbHVlLmxvYykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgdGFnIH0gPSBub2RlO1xuICAgIGNvbnN0IGlzQ3VzdG9tRWxlbWVudCA9IGNvbnRleHQuaXNDdXN0b21FbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fFxuICAgICAgICB0YWcgPT09ICd0ZXh0YXJlYScgfHxcbiAgICAgICAgdGFnID09PSAnc2VsZWN0JyB8fFxuICAgICAgICBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgbGV0IGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9URVhUO1xuICAgICAgICBsZXQgaXNJbnZhbGlkVHlwZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGFnID09PSAnaW5wdXQnIHx8IGlzQ3VzdG9tRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGZpbmRQcm9wKG5vZGUsIGB0eXBlYCk7XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLnR5cGUgPT09IDcgLyogTm9kZVR5cGVzLkRJUkVDVElWRSAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyA6dHlwZT1cImZvb1wiXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9EWU5BTUlDO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZS52YWx1ZS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1JBRElPO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9DSEVDS0JPWDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzSW52YWxpZFR5cGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQub25FcnJvcihjcmVhdGVET01Db21waWxlckVycm9yKDU3IC8qIERPTUVycm9yQ29kZXMuWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVCAqLywgZGlyLmxvYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0R5bmFtaWNLZXlWQmluZChub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaGFzIGJpbmRpbmdzIHdpdGggZHluYW1pYyBrZXlzLCB3aGljaCBjYW4gcG9zc2libHkgY29udGFpblxuICAgICAgICAgICAgICAgIC8vIFwidHlwZVwiLlxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9EWU5BTUlDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGV4dCB0eXBlXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrRHVwbGljYXRlZFZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX1NFTEVDVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRleHRhcmVhXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbmplY3QgcnVudGltZSBkaXJlY3RpdmVcbiAgICAgICAgLy8gYnkgcmV0dXJuaW5nIHRoZSBoZWxwZXIgc3ltYm9sIHZpYSBuZWVkUnVudGltZVxuICAgICAgICAvLyB0aGUgaW1wb3J0IHdpbGwgcmVwbGFjZWQgYSByZXNvbHZlRGlyZWN0aXZlIGNhbGwuXG4gICAgICAgIGlmICghaXNJbnZhbGlkVHlwZSkge1xuICAgICAgICAgICAgYmFzZVJlc3VsdC5uZWVkUnVudGltZSA9IGNvbnRleHQuaGVscGVyKGRpcmVjdGl2ZVRvVXNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTUgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UICovLCBkaXIubG9jKSk7XG4gICAgfVxuICAgIC8vIG5hdGl2ZSB2bW9kZWwgZG9lc24ndCBuZWVkIHRoZSBgbW9kZWxWYWx1ZWAgcHJvcHMgc2luY2UgdGhleSBhcmUgYWxzb1xuICAgIC8vIHBhc3NlZCB0byB0aGUgcnVudGltZSBhcyBgYmluZGluZy52YWx1ZWAuIHJlbW92aW5nIGl0IHJlZHVjZXMgY29kZSBzaXplLlxuICAgIGJhc2VSZXN1bHQucHJvcHMgPSBiYXNlUmVzdWx0LnByb3BzLmZpbHRlcihwID0+ICEocC5rZXkudHlwZSA9PT0gNCAvKiBOb2RlVHlwZXMuU0lNUExFX0VYUFJFU1NJT04gKi8gJiZcbiAgICAgICAgcC5rZXkuY29udGVudCA9PT0gJ21vZGVsVmFsdWUnKSk7XG4gICAgcmV0dXJuIGJhc2VSZXN1bHQ7XG59O1xuXG5jb25zdCBpc0V2ZW50T3B0aW9uTW9kaWZpZXIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHBhc3NpdmUsb25jZSxjYXB0dXJlYCk7XG5jb25zdCBpc05vbktleU1vZGlmaWVyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxuLy8gZXZlbnQgcHJvcGFnYXRpb24gbWFuYWdlbWVudFxuYHN0b3AscHJldmVudCxzZWxmLGAgK1xuICAgIC8vIHN5c3RlbSBtb2RpZmllcnMgKyBleGFjdFxuICAgIGBjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0LGAgK1xuICAgIC8vIG1vdXNlXG4gICAgYG1pZGRsZWApO1xuLy8gbGVmdCAmIHJpZ2h0IGNvdWxkIGJlIG1vdXNlIG9yIGtleSBtb2RpZmllcnMgYmFzZWQgb24gZXZlbnQgdHlwZVxuY29uc3QgbWF5YmVLZXlNb2RpZmllciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnbGVmdCxyaWdodCcpO1xuY29uc3QgaXNLZXlib2FyZEV2ZW50ID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBvbmtleXVwLG9ua2V5ZG93bixvbmtleXByZXNzYCwgdHJ1ZSk7XG5jb25zdCByZXNvbHZlTW9kaWZpZXJzID0gKGtleSwgbW9kaWZpZXJzLCBjb250ZXh0LCBsb2MpID0+IHtcbiAgICBjb25zdCBrZXlNb2RpZmllcnMgPSBbXTtcbiAgICBjb25zdCBub25LZXlNb2RpZmllcnMgPSBbXTtcbiAgICBjb25zdCBldmVudE9wdGlvbk1vZGlmaWVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyID0gbW9kaWZpZXJzW2ldO1xuICAgICAgICBpZiAobW9kaWZpZXIgPT09ICduYXRpdmUnICYmXG4gICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QSUxFUl9WX09OX05BVElWRVwiIC8qIENvbXBpbGVyRGVwcmVjYXRpb25UeXBlcy5DT01QSUxFUl9WX09OX05BVElWRSAqLywgY29udGV4dCwgbG9jKSkge1xuICAgICAgICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudE9wdGlvbk1vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICAgICAgLy8gZXZlbnRPcHRpb25Nb2RpZmllcnM6IG1vZGlmaWVycyBmb3IgYWRkRXZlbnRMaXN0ZW5lcigpIG9wdGlvbnMsXG4gICAgICAgICAgICAvLyBlLmcuIC5wYXNzaXZlICYgLmNhcHR1cmVcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcnVudGltZU1vZGlmaWVyczogbW9kaWZpZXJzIHRoYXQgbmVlZHMgcnVudGltZSBndWFyZHNcbiAgICAgICAgICAgIGlmIChtYXliZUtleU1vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpY0V4cChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc05vbktleU1vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBub25LZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleU1vZGlmaWVycyxcbiAgICAgICAgbm9uS2V5TW9kaWZpZXJzLFxuICAgICAgICBldmVudE9wdGlvbk1vZGlmaWVyc1xuICAgIH07XG59O1xuY29uc3QgdHJhbnNmb3JtQ2xpY2sgPSAoa2V5LCBldmVudCkgPT4ge1xuICAgIGNvbnN0IGlzU3RhdGljQ2xpY2sgPSBpc1N0YXRpY0V4cChrZXkpICYmIGtleS5jb250ZW50LnRvTG93ZXJDYXNlKCkgPT09ICdvbmNsaWNrJztcbiAgICByZXR1cm4gaXNTdGF0aWNDbGlja1xuICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oZXZlbnQsIHRydWUpXG4gICAgICAgIDoga2V5LnR5cGUgIT09IDQgLyogTm9kZVR5cGVzLlNJTVBMRV9FWFBSRVNTSU9OICovXG4gICAgICAgICAgICA/IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbXG4gICAgICAgICAgICAgICAgYChgLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBgKSA9PT0gXCJvbkNsaWNrXCIgPyBcIiR7ZXZlbnR9XCIgOiAoYCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgYClgXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgOiBrZXk7XG59O1xuY29uc3QgdHJhbnNmb3JtT24gPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybU9uJDEoZGlyLCBub2RlLCBjb250ZXh0LCBiYXNlUmVzdWx0ID0+IHtcbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGRpcjtcbiAgICAgICAgaWYgKCFtb2RpZmllcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2VSZXN1bHQ7XG4gICAgICAgIGxldCB7IGtleSwgdmFsdWU6IGhhbmRsZXJFeHAgfSA9IGJhc2VSZXN1bHQucHJvcHNbMF07XG4gICAgICAgIGNvbnN0IHsga2V5TW9kaWZpZXJzLCBub25LZXlNb2RpZmllcnMsIGV2ZW50T3B0aW9uTW9kaWZpZXJzIH0gPSByZXNvbHZlTW9kaWZpZXJzKGtleSwgbW9kaWZpZXJzLCBjb250ZXh0LCBkaXIubG9jKTtcbiAgICAgICAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gICAgICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoJ3JpZ2h0JykpIHtcbiAgICAgICAgICAgIGtleSA9IHRyYW5zZm9ybUNsaWNrKGtleSwgYG9uQ29udGV4dG1lbnVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdtaWRkbGUnKSkge1xuICAgICAgICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Nb3VzZXVwYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vbktleU1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfTU9ESUZJRVJTKSwgW1xuICAgICAgICAgICAgICAgIGhhbmRsZXJFeHAsXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9uS2V5TW9kaWZpZXJzKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggJiZcbiAgICAgICAgICAgIC8vIGlmIGV2ZW50IG5hbWUgaXMgZHluYW1pYywgYWx3YXlzIHdyYXAgd2l0aCBrZXlzIGd1YXJkXG4gICAgICAgICAgICAoIWlzU3RhdGljRXhwKGtleSkgfHwgaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50KSkpIHtcbiAgICAgICAgICAgIGhhbmRsZXJFeHAgPSBjcmVhdGVDYWxsRXhwcmVzc2lvbihjb250ZXh0LmhlbHBlcihWX09OX1dJVEhfS0VZUyksIFtcbiAgICAgICAgICAgICAgICBoYW5kbGVyRXhwLFxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGtleU1vZGlmaWVycylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE9wdGlvbk1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyUG9zdGZpeCA9IGV2ZW50T3B0aW9uTW9kaWZpZXJzLm1hcChjYXBpdGFsaXplKS5qb2luKCcnKTtcbiAgICAgICAgICAgIGtleSA9IGlzU3RhdGljRXhwKGtleSlcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYCR7a2V5LmNvbnRlbnR9JHttb2RpZmllclBvc3RmaXh9YCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUNvbXBvdW5kRXhwcmVzc2lvbihbYChgLCBrZXksIGApICsgXCIke21vZGlmaWVyUG9zdGZpeH1cImBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvcHM6IFtjcmVhdGVPYmplY3RQcm9wZXJ0eShrZXksIGhhbmRsZXJFeHApXVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuY29uc3QgdHJhbnNmb3JtU2hvdyA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBjb25zdCB7IGV4cCwgbG9jIH0gPSBkaXI7XG4gICAgaWYgKCFleHApIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNTkgLyogRE9NRXJyb3JDb2Rlcy5YX1ZfU0hPV19OT19FWFBSRVNTSU9OICovLCBsb2MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IFtdLFxuICAgICAgICBuZWVkUnVudGltZTogY29udGV4dC5oZWxwZXIoVl9TSE9XKVxuICAgIH07XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1UcmFuc2l0aW9uID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxIC8qIE5vZGVUeXBlcy5FTEVNRU5UICovICYmXG4gICAgICAgIG5vZGUudGFnVHlwZSA9PT0gMSAvKiBFbGVtZW50VHlwZXMuQ09NUE9ORU5UICovKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbnRleHQuaXNCdWlsdEluQ29tcG9uZW50KG5vZGUudGFnKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudCA9PT0gVFJBTlNJVElPTikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2FybiBtdWx0aXBsZSB0cmFuc2l0aW9uIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYgKGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNjAgLyogRE9NRXJyb3JDb2Rlcy5YX1RSQU5TSVRJT05fSU5WQUxJRF9DSElMRFJFTiAqLywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubG9jLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdCdzIHMgc2luZ2xlIGNoaWxkIHcvIHYtc2hvd1xuICAgICAgICAgICAgICAgIC8vIGlmIHllcywgaW5qZWN0IFwicGVyc2lzdGVkOiB0cnVlXCIgdG8gdGhlIHRyYW5zaXRpb24gcHJvcHNcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEgLyogTm9kZVR5cGVzLkVMRU1FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIGNoaWxkLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09PSA3IC8qIE5vZGVUeXBlcy5ESVJFQ1RJVkUgKi8gJiYgcC5uYW1lID09PSAnc2hvdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnByb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiA2IC8qIE5vZGVUeXBlcy5BVFRSSUJVVEUgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdwZXJzaXN0ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IG5vZGUubG9jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkge1xuICAgIC8vICMxMzUyIGZpbHRlciBvdXQgcG90ZW50aWFsIGNvbW1lbnQgbm9kZXMuXG4gICAgY29uc3QgY2hpbGRyZW4gPSAobm9kZS5jaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4uZmlsdGVyKGMgPT4gYy50eXBlICE9PSAzIC8qIE5vZGVUeXBlcy5DT01NRU5UICovICYmXG4gICAgICAgICEoYy50eXBlID09PSAyIC8qIE5vZGVUeXBlcy5URVhUICovICYmICFjLmNvbnRlbnQudHJpbSgpKSkpO1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIChjaGlsZHJlbi5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gMTEgLyogTm9kZVR5cGVzLkZPUiAqLyB8fFxuICAgICAgICAoY2hpbGQudHlwZSA9PT0gOSAvKiBOb2RlVHlwZXMuSUYgKi8gJiYgY2hpbGQuYnJhbmNoZXMuc29tZShoYXNNdWx0aXBsZUNoaWxkcmVuKSkpO1xufVxuXG5jb25zdCBpZ25vcmVTaWRlRWZmZWN0VGFncyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSAvKiBOb2RlVHlwZXMuRUxFTUVOVCAqLyAmJlxuICAgICAgICBub2RlLnRhZ1R5cGUgPT09IDAgLyogRWxlbWVudFR5cGVzLkVMRU1FTlQgKi8gJiZcbiAgICAgICAgKG5vZGUudGFnID09PSAnc2NyaXB0JyB8fCBub2RlLnRhZyA9PT0gJ3N0eWxlJykpIHtcbiAgICAgICAgY29udGV4dC5vbkVycm9yKGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNjEgLyogRE9NRXJyb3JDb2Rlcy5YX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHICovLCBub2RlLmxvYykpO1xuICAgICAgICBjb250ZXh0LnJlbW92ZU5vZGUoKTtcbiAgICB9XG59O1xuXG5jb25zdCBET01Ob2RlVHJhbnNmb3JtcyA9IFtcbiAgICB0cmFuc2Zvcm1TdHlsZSxcbiAgICAuLi4oKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gW3RyYW5zZm9ybVRyYW5zaXRpb25dIDogW10pXG5dO1xuY29uc3QgRE9NRGlyZWN0aXZlVHJhbnNmb3JtcyA9IHtcbiAgICBjbG9hazogbm9vcERpcmVjdGl2ZVRyYW5zZm9ybSxcbiAgICBodG1sOiB0cmFuc2Zvcm1WSHRtbCxcbiAgICB0ZXh0OiB0cmFuc2Zvcm1WVGV4dCxcbiAgICBtb2RlbDogdHJhbnNmb3JtTW9kZWwsXG4gICAgb246IHRyYW5zZm9ybU9uLFxuICAgIHNob3c6IHRyYW5zZm9ybVNob3dcbn07XG5mdW5jdGlvbiBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucywge1xuICAgICAgICBub2RlVHJhbnNmb3JtczogW1xuICAgICAgICAgICAgLy8gaWdub3JlIDxzY3JpcHQ+IGFuZCA8dGFnPlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgcHV0IGluc2lkZSBET01Ob2RlVHJhbnNmb3JtcyBiZWNhdXNlIHRoYXQgbGlzdCBpcyB1c2VkXG4gICAgICAgICAgICAvLyBieSBjb21waWxlci1zc3IgdG8gZ2VuZXJhdGUgdm5vZGUgZmFsbGJhY2sgYnJhbmNoZXNcbiAgICAgICAgICAgIGlnbm9yZVNpZGVFZmZlY3RUYWdzLFxuICAgICAgICAgICAgLi4uRE9NTm9kZVRyYW5zZm9ybXMsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5ub2RlVHJhbnNmb3JtcyB8fCBbXSlcbiAgICAgICAgXSxcbiAgICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogZXh0ZW5kKHt9LCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zLCBvcHRpb25zLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge30pLFxuICAgICAgICB0cmFuc2Zvcm1Ib2lzdDogbnVsbCBcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBwYXJzZSh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGJhc2VQYXJzZSh0ZW1wbGF0ZSwgZXh0ZW5kKHt9LCBwYXJzZXJPcHRpb25zLCBvcHRpb25zKSk7XG59XG5cbmV4cG9ydCB7IERPTURpcmVjdGl2ZVRyYW5zZm9ybXMsIERPTU5vZGVUcmFuc2Zvcm1zLCBUUkFOU0lUSU9OLCBUUkFOU0lUSU9OX0dST1VQLCBWX01PREVMX0NIRUNLQk9YLCBWX01PREVMX0RZTkFNSUMsIFZfTU9ERUxfUkFESU8sIFZfTU9ERUxfU0VMRUNULCBWX01PREVMX1RFWFQsIFZfT05fV0lUSF9LRVlTLCBWX09OX1dJVEhfTU9ESUZJRVJTLCBWX1NIT1csIGNvbXBpbGUsIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IsIHBhcnNlLCBwYXJzZXJPcHRpb25zLCB0cmFuc2Zvcm1TdHlsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/compiler-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@vue/compiler-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_ARR\": () => (/* binding */ EMPTY_ARR),\n/* harmony export */   \"EMPTY_OBJ\": () => (/* binding */ EMPTY_OBJ),\n/* harmony export */   \"NO\": () => (/* binding */ NO),\n/* harmony export */   \"NOOP\": () => (/* binding */ NOOP),\n/* harmony export */   \"PatchFlagNames\": () => (/* binding */ PatchFlagNames),\n/* harmony export */   \"camelize\": () => (/* binding */ camelize),\n/* harmony export */   \"capitalize\": () => (/* binding */ capitalize),\n/* harmony export */   \"def\": () => (/* binding */ def),\n/* harmony export */   \"escapeHtml\": () => (/* binding */ escapeHtml),\n/* harmony export */   \"escapeHtmlComment\": () => (/* binding */ escapeHtmlComment),\n/* harmony export */   \"extend\": () => (/* binding */ extend),\n/* harmony export */   \"genPropsAccessExp\": () => (/* binding */ genPropsAccessExp),\n/* harmony export */   \"generateCodeFrame\": () => (/* binding */ generateCodeFrame),\n/* harmony export */   \"getGlobalThis\": () => (/* binding */ getGlobalThis),\n/* harmony export */   \"hasChanged\": () => (/* binding */ hasChanged),\n/* harmony export */   \"hasOwn\": () => (/* binding */ hasOwn),\n/* harmony export */   \"hyphenate\": () => (/* binding */ hyphenate),\n/* harmony export */   \"includeBooleanAttr\": () => (/* binding */ includeBooleanAttr),\n/* harmony export */   \"invokeArrayFns\": () => (/* binding */ invokeArrayFns),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"isBooleanAttr\": () => (/* binding */ isBooleanAttr),\n/* harmony export */   \"isBuiltInDirective\": () => (/* binding */ isBuiltInDirective),\n/* harmony export */   \"isDate\": () => (/* binding */ isDate),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isGloballyWhitelisted\": () => (/* binding */ isGloballyWhitelisted),\n/* harmony export */   \"isHTMLTag\": () => (/* binding */ isHTMLTag),\n/* harmony export */   \"isIntegerKey\": () => (/* binding */ isIntegerKey),\n/* harmony export */   \"isKnownHtmlAttr\": () => (/* binding */ isKnownHtmlAttr),\n/* harmony export */   \"isKnownSvgAttr\": () => (/* binding */ isKnownSvgAttr),\n/* harmony export */   \"isMap\": () => (/* binding */ isMap),\n/* harmony export */   \"isModelListener\": () => (/* binding */ isModelListener),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isOn\": () => (/* binding */ isOn),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"isRegExp\": () => (/* binding */ isRegExp),\n/* harmony export */   \"isReservedProp\": () => (/* binding */ isReservedProp),\n/* harmony export */   \"isSSRSafeAttrName\": () => (/* binding */ isSSRSafeAttrName),\n/* harmony export */   \"isSVGTag\": () => (/* binding */ isSVGTag),\n/* harmony export */   \"isSet\": () => (/* binding */ isSet),\n/* harmony export */   \"isSpecialBooleanAttr\": () => (/* binding */ isSpecialBooleanAttr),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"isSymbol\": () => (/* binding */ isSymbol),\n/* harmony export */   \"isVoidTag\": () => (/* binding */ isVoidTag),\n/* harmony export */   \"looseEqual\": () => (/* binding */ looseEqual),\n/* harmony export */   \"looseIndexOf\": () => (/* binding */ looseIndexOf),\n/* harmony export */   \"looseToNumber\": () => (/* binding */ looseToNumber),\n/* harmony export */   \"makeMap\": () => (/* binding */ makeMap),\n/* harmony export */   \"normalizeClass\": () => (/* binding */ normalizeClass),\n/* harmony export */   \"normalizeProps\": () => (/* binding */ normalizeProps),\n/* harmony export */   \"normalizeStyle\": () => (/* binding */ normalizeStyle),\n/* harmony export */   \"objectToString\": () => (/* binding */ objectToString),\n/* harmony export */   \"parseStringStyle\": () => (/* binding */ parseStringStyle),\n/* harmony export */   \"propsToAttrMap\": () => (/* binding */ propsToAttrMap),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"slotFlagsText\": () => (/* binding */ slotFlagsText),\n/* harmony export */   \"stringifyStyle\": () => (/* binding */ stringifyStyle),\n/* harmony export */   \"toDisplayString\": () => (/* binding */ toDisplayString),\n/* harmony export */   \"toHandlerKey\": () => (/* binding */ toHandlerKey),\n/* harmony export */   \"toNumber\": () => (/* binding */ toNumber),\n/* harmony export */   \"toRawType\": () => (/* binding */ toRawType),\n/* harmony export */   \"toTypeString\": () => (/* binding */ toTypeString)\n/* harmony export */ });\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    // Split the content into individual lines but capture the newline sequence\n    // that separated each line. This is important because the actual sequence is\n    // needed to properly take into account the full line length for offset\n    // comparison\n    let lines = source.split(/(\\r?\\n)/);\n    // Separate the lines and newline sequences into separate arrays for easier referencing\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n    lines = lines.filter((_, idx) => idx % 2 === 0);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count +=\n            lines[i].length +\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - (lineLength + newLineSeqLength));\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + newLineSeqLength;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\nfunction normalizeStyle(value) {\n    if (isArray(value)) {\n        const res = {};\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            const normalized = isString(item)\n                ? parseStringStyle(item)\n                : normalizeStyle(item);\n            if (normalized) {\n                for (const key in normalized) {\n                    res[key] = normalized[key];\n                }\n            }\n        }\n        return res;\n    }\n    else if (isString(value)) {\n        return value;\n    }\n    else if (isObject(value)) {\n        return value;\n    }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n    const ret = {};\n    cssText\n        .replace(styleCommentRE, '')\n        .split(listDelimiterRE)\n        .forEach(item => {\n        if (item) {\n            const tmp = item.split(propertyDelimiterRE);\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return ret;\n}\nfunction stringifyStyle(styles) {\n    let ret = '';\n    if (!styles || isString(styles)) {\n        return ret;\n    }\n    for (const key in styles) {\n        const value = styles[key];\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n        if (isString(value) || typeof value === 'number') {\n            // only render valid values\n            ret += `${normalizedKey}:${value};`;\n        }\n    }\n    return ret;\n}\nfunction normalizeClass(value) {\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value)) {\n        for (const name in value) {\n            if (value[name]) {\n                res += name + ' ';\n            }\n        }\n    }\n    return res.trim();\n}\nfunction normalizeProps(props) {\n    if (!props)\n        return null;\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n        props.class = normalizeClass(klass);\n    }\n    if (style) {\n        props.style = normalizeStyle(style);\n    }\n    return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n    'option,output,progress,select,textarea,details,dialog,menu,' +\n    'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n    'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n    return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n        return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n        console.error(`unsafe attribute name: ${name}`);\n    }\n    return (attrValidationCache[name] = !isUnsafe);\n}\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`);\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n    const str = '' + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n        return str;\n    }\n    let html = '';\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34: // \"\n                escaped = '&quot;';\n                break;\n            case 38: // &\n                escaped = '&amp;';\n                break;\n            case 39: // '\n                escaped = '&#39;';\n                break;\n            case 60: // <\n                escaped = '&lt;';\n                break;\n            case 62: // >\n                escaped = '&gt;';\n                break;\n            default:\n                continue;\n        }\n        if (lastIndex !== index) {\n            html += str.slice(lastIndex, index);\n        }\n        lastIndex = index + 1;\n        html += escaped;\n    }\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n    return src.replace(commentStripRE, '');\n}\n\nfunction looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n        equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n}\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isSymbol(a);\n    bValidType = isSymbol(b);\n    if (aValidType || bValidType) {\n        return a === b;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n        /* istanbul ignore if: this if will probably never be called */\n        if (!aValidType || !bValidType) {\n            return false;\n        }\n        const aKeysCount = Object.keys(a).length;\n        const bKeysCount = Object.keys(b).length;\n        if (aKeysCount !== bKeysCount) {\n            return false;\n        }\n        for (const key in a) {\n            const aHasKey = a.hasOwnProperty(key);\n            const bHasKey = b.hasOwnProperty(key);\n            if ((aHasKey && !bHasKey) ||\n                (!aHasKey && bHasKey) ||\n                !looseEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n    }\n    return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n    return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = (val) => {\n    return isString(val)\n        ? val\n        : val == null\n            ? ''\n            : isArray(val) ||\n                (isObject(val) &&\n                    (val.toString === objectToString || !isFunction(val.toString)))\n                ? JSON.stringify(val, replacer, 2)\n                : String(val);\n};\nconst replacer = (_key, val) => {\n    // can't use isRef here since @vue/shared has no deps\n    if (val && val.__v_isRef) {\n        return replacer(_key, val.value);\n    }\n    else if (isMap(val)) {\n        return {\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                entries[`${key} =>`] = val;\n                return entries;\n            }, {})\n        };\n    }\n    else if (isSet(val)) {\n        return {\n            [`Set(${val.size})`]: [...val.values()]\n        };\n    }\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n        return String(val);\n    }\n    return val;\n};\n\nconst EMPTY_OBJ = ( true)\n    ? Object.freeze({})\n    : 0;\nconst EMPTY_ARR = ( true) ? Object.freeze([]) : 0;\nconst NOOP = () => { };\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === '[object Map]';\nconst isSet = (val) => toTypeString(val) === '[object Set]';\nconst isDate = (val) => toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\nconst isFunction = (val) => typeof val === 'function';\nconst isString = (val) => typeof val === 'string';\nconst isSymbol = (val) => typeof val === 'symbol';\nconst isObject = (val) => val !== null && typeof val === 'object';\nconst isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\nconst isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\nconst def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = (val) => {\n    const n = isString(val) ? Number(val) : NaN;\n    return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof __webpack_require__.g !== 'undefined'\n                            ? __webpack_require__.g\n                            : {}));\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n    return identRE.test(name)\n        ? `__props.${name}`\n        : `__props[${JSON.stringify(name)}]`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1kb20vbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssRUFBRSxpREFBaUQsS0FBSyxTQUFTO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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cUJBQXFCLHFCQUFxQjtBQUMxQzs7QUFFdXpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvY29tcGlsZXItZG9tL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcz8zMzQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqIElNUE9SVEFOVDogYWxsIGNhbGxzIG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBwcmVmaXhlZCB3aXRoXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xufVxuXG4vKipcbiAqIGRldiBvbmx5IGZsYWcgLT4gbmFtZSBtYXBwaW5nXG4gKi9cbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICAgIFsxIC8qIFBhdGNoRmxhZ3MuVEVYVCAqL106IGBURVhUYCxcbiAgICBbMiAvKiBQYXRjaEZsYWdzLkNMQVNTICovXTogYENMQVNTYCxcbiAgICBbNCAvKiBQYXRjaEZsYWdzLlNUWUxFICovXTogYFNUWUxFYCxcbiAgICBbOCAvKiBQYXRjaEZsYWdzLlBST1BTICovXTogYFBST1BTYCxcbiAgICBbMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxuICAgIFszMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcbiAgICBbNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgICBbMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxuICAgIFsyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxuICAgIFs1MTIgLyogUGF0Y2hGbGFncy5ORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxuICAgIFsxMDI0IC8qIFBhdGNoRmxhZ3MuRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcbiAgICBbMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgICBbLTEgLyogUGF0Y2hGbGFncy5IT0lTVEVEICovXTogYEhPSVNURURgLFxuICAgIFstMiAvKiBQYXRjaEZsYWdzLkJBSUwgKi9dOiBgQkFJTGBcbn07XG5cbi8qKlxuICogRGV2IG9ubHlcbiAqL1xuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgICBbMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovXTogJ1NUQUJMRScsXG4gICAgWzIgLyogU2xvdEZsYWdzLkRZTkFNSUMgKi9dOiAnRFlOQU1JQycsXG4gICAgWzMgLyogU2xvdEZsYWdzLkZPUldBUkRFRCAqL106ICdGT1JXQVJERUQnXG59O1xuXG5jb25zdCBHTE9CQUxTX1dISVRFX0xJU1RFRCA9ICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLCcgK1xuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xuICAgICdPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCc7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICAgIC8vIFNwbGl0IHRoZSBjb250ZW50IGludG8gaW5kaXZpZHVhbCBsaW5lcyBidXQgY2FwdHVyZSB0aGUgbmV3bGluZSBzZXF1ZW5jZVxuICAgIC8vIHRoYXQgc2VwYXJhdGVkIGVhY2ggbGluZS4gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgYWN0dWFsIHNlcXVlbmNlIGlzXG4gICAgLy8gbmVlZGVkIHRvIHByb3Blcmx5IHRha2UgaW50byBhY2NvdW50IHRoZSBmdWxsIGxpbmUgbGVuZ3RoIGZvciBvZmZzZXRcbiAgICAvLyBjb21wYXJpc29uXG4gICAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgICAvLyBTZXBhcmF0ZSB0aGUgbGluZXMgYW5kIG5ld2xpbmUgc2VxdWVuY2VzIGludG8gc2VwYXJhdGUgYXJyYXlzIGZvciBlYXNpZXIgcmVmZXJlbmNpbmdcbiAgICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICAgIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb3VudCArPVxuICAgICAgICAgICAgbGluZXNbaV0ubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAoKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGgpIHx8IDApO1xuICAgICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtsaW5lfSR7JyAnLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gKG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGgpIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgICAgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKi4qP1xcKlxcLy9ncztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGNzc1RleHRcbiAgICAgICAgLnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsICcnKVxuICAgICAgICAuc3BsaXQobGlzdERlbGltaXRlclJFKVxuICAgICAgICAuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gICAgbGV0IHJldCA9ICcnO1xuICAgIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xuICAgICAgICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmVzID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBuYW1lICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcbmNvbnN0IEhUTUxfVEFHUyA9ICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLCcgK1xuICAgICdoZWFkZXIsaGdyb3VwLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcbiAgICAnZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXG4gICAgJ3RpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsJyArXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xuICAgICdvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LCcgK1xuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290Jztcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XG5jb25zdCBTVkdfVEFHUyA9ICdzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsJyArXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXG4gICAgJ2ZlRGlzdGFudExpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXG4gICAgJ2ZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsJyArXG4gICAgJ2ZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsJyArXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcbiAgICAnbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLCcgK1xuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLCcgK1xuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xuY29uc3QgVk9JRF9UQUdTID0gJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJztcbi8qKlxuICogQ29tcGlsZXIgb25seS5cbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cbiAqL1xuY29uc3QgaXNIVE1MVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG4vKipcbiAqIENvbXBpbGVyIG9ubHkuXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXG4gKi9cbmNvbnN0IGlzU1ZHVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFNWR19UQUdTKTtcbi8qKlxuICogQ29tcGlsZXIgb25seS5cbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cbiAqL1xuY29uc3QgaXNWb2lkVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbi8qKlxuICogT24gdGhlIGNsaWVudCB3ZSBvbmx5IG5lZWQgdG8gb2ZmZXIgc3BlY2lhbCBjYXNlcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXRcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcbiAqIC0gaXRlbXNjb3BlIC0+IE4vQVxuICogLSBhbGxvd2Z1bGxzY3JlZW4gLT4gYWxsb3dGdWxsc2NyZWVuXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXG4gKiAtIGlzbWFwIC0+IGlzTWFwXG4gKiAtIG5vbW9kdWxlIC0+IG5vTW9kdWxlXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxuICogLSByZWFkb25seSAtPiByZWFkT25seVxuICovXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbi8qKlxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxuICovXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgK1xuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xuICAgIGBsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGAgK1xuICAgIGBjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XG4vKipcbiAqIEJvb2xlYW4gYXR0cmlidXRlcyBzaG91bGQgYmUgaW5jbHVkZWQgaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBvciAnJy5cbiAqIGUuZy4gYDxzZWxlY3QgbXVsdGlwbGU+YCBjb21waWxlcyB0byBgeyBtdWx0aXBsZTogJycgfWBcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09ICcnO1xufVxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICAgIH1cbiAgICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgICBpZiAoaXNVbnNhZmUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiAoYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZSk7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xufTtcbi8qKlxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcbiAqIHNvIHRoYXQgd2UgZG9uJ3Qgc3RyaW5naWZ5IGJpbmRpbmdzIHRoYXQgY2Fubm90IGJlIHNldCBmcm9tIEhUTUwuXG4gKiBEb24ndCBhbHNvIGZvcmdldCB0byBhbGxvdyBgZGF0YS0qYCBhbmQgYGFyaWEtKmAhXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcbiAqL1xuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYCArXG4gICAgYGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGAgK1xuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcbiAgICBgY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGAgK1xuICAgIGBjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxgICtcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xuICAgIGBmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGAgK1xuICAgIGBoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbnRlZ3JpdHksYCArXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcbiAgICBgbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxgICtcbiAgICBgb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LGAgK1xuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xuICAgIGBzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsYCArXG4gICAgYHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLGAgK1xuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XG4vKipcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGVcbiAqL1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYCArXG4gICAgYGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGAgK1xuICAgIGBiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxgICtcbiAgICBgY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixgICtcbiAgICBgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGAgK1xuICAgIGBjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsYCArXG4gICAgYGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGAgK1xuICAgIGBkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGAgK1xuICAgIGBmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGAgK1xuICAgIGBmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxgICtcbiAgICBgZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsYCArXG4gICAgYGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsYCArXG4gICAgYGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxgICtcbiAgICBgaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxgICtcbiAgICBgazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxgICtcbiAgICBgbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsYCArXG4gICAgYG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLGAgK1xuICAgIGBtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLGAgK1xuICAgIGBuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixgICtcbiAgICBgb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgsYCArXG4gICAgYHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLGAgK1xuICAgIGBwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxgICtcbiAgICBgcHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLGAgK1xuICAgIGByZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxgICtcbiAgICBgcmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsYCArXG4gICAgYHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsYCArXG4gICAgYHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxgICtcbiAgICBgc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLGAgK1xuICAgIGBzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixgICtcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxgICtcbiAgICBgc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcixgICtcbiAgICBgdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sYCArXG4gICAgYHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksYCArXG4gICAgYHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyxgICtcbiAgICBgdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsYCArXG4gICAgYHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyxgICtcbiAgICBgd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUsYCArXG4gICAgYHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcsYCArXG4gICAgYHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYCk7XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XG4gICAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBlc2NhcGVkO1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAmXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OiAvLyAnXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYwOiAvLyA8XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XG4gICAgfVxuICAgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUyL3N5bnRheC5odG1sI2NvbW1lbnRzXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGl0ZW0gPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuLyoqXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHZhbCA9PSBudWxsXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IGlzQXJyYXkodmFsKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwpICYmXG4gICAgICAgICAgICAgICAgICAgICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpKVxuICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMilcbiAgICAgICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICAgIC8vIGNhbid0IHVzZSBpc1JlZiBoZXJlIHNpbmNlIEB2dWUvc2hhcmVkIGhhcyBubyBkZXBzXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICAgICAgfSwge30pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXG4gICAgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJ29uVXBkYXRlOicpO1xuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE1hcF0nO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgICAvLyBleHRyYWN0IFwiUmF3VHlwZVwiIGZyb20gc3RyaW5ncyBsaWtlIFwiW29iamVjdCBSYXdUeXBlXVwiXG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmXG4gICAga2V5ICE9PSAnTmFOJyAmJlxuICAgIGtleVswXSAhPT0gJy0nICYmXG4gICAgJycgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXG4vLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4nLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LCcgK1xuICAgICdvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsJyArXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXG4gICAgJ29uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWQnKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtbycpO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKChzdHIpID0+IHtcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICAgIH0pO1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XG59KTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCk7XG4vLyBjb21wYXJlIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZCwgYWNjb3VudGluZyBmb3IgTmFOLlxuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+ICFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKTtcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldKGFyZyk7XG4gICAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICB9KTtcbn07XG4vKipcbiAqIFwiMTIzLWZvb1wiIHdpbGwgYmUgcGFyc2VkIHRvIDEyM1xuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgLm51bWJlciBtb2RpZmllciBpbiB2LW1vZGVsXG4gKi9cbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbi8qKlxuICogT25seSBjb25lcmNlcyBudW1iZXItbGlrZSBzdHJpbmdzXG4gKiBcIjEyMy1mb29cIiB3aWxsIGJlIHJldHVybmVkIGFzLWlzXG4gKi9cbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICAgIHJldHVybiAoX2dsb2JhbFRoaXMgfHxcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gICAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKVxuICAgICAgICA/IGBfX3Byb3BzLiR7bmFtZX1gXG4gICAgICAgIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vue/compiler-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTransition\": () => (/* binding */ BaseTransition),\n/* harmony export */   \"Comment\": () => (/* binding */ Comment),\n/* harmony export */   \"EffectScope\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope),\n/* harmony export */   \"Fragment\": () => (/* binding */ Fragment),\n/* harmony export */   \"KeepAlive\": () => (/* binding */ KeepAlive),\n/* harmony export */   \"ReactiveEffect\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),\n/* harmony export */   \"Static\": () => (/* binding */ Static),\n/* harmony export */   \"Suspense\": () => (/* binding */ Suspense),\n/* harmony export */   \"Teleport\": () => (/* binding */ Teleport),\n/* harmony export */   \"Text\": () => (/* binding */ Text),\n/* harmony export */   \"assertNumber\": () => (/* binding */ assertNumber),\n/* harmony export */   \"callWithAsyncErrorHandling\": () => (/* binding */ callWithAsyncErrorHandling),\n/* harmony export */   \"callWithErrorHandling\": () => (/* binding */ callWithErrorHandling),\n/* harmony export */   \"camelize\": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize),\n/* harmony export */   \"capitalize\": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize),\n/* harmony export */   \"cloneVNode\": () => (/* binding */ cloneVNode),\n/* harmony export */   \"compatUtils\": () => (/* binding */ compatUtils),\n/* harmony export */   \"computed\": () => (/* binding */ computed),\n/* harmony export */   \"createBlock\": () => (/* binding */ createBlock),\n/* harmony export */   \"createCommentVNode\": () => (/* binding */ createCommentVNode),\n/* harmony export */   \"createElementBlock\": () => (/* binding */ createElementBlock),\n/* harmony export */   \"createElementVNode\": () => (/* binding */ createBaseVNode),\n/* harmony export */   \"createHydrationRenderer\": () => (/* binding */ createHydrationRenderer),\n/* harmony export */   \"createPropsRestProxy\": () => (/* binding */ createPropsRestProxy),\n/* harmony export */   \"createRenderer\": () => (/* binding */ createRenderer),\n/* harmony export */   \"createSlots\": () => (/* binding */ createSlots),\n/* harmony export */   \"createStaticVNode\": () => (/* binding */ createStaticVNode),\n/* harmony export */   \"createTextVNode\": () => (/* binding */ createTextVNode),\n/* harmony export */   \"createVNode\": () => (/* binding */ createVNode),\n/* harmony export */   \"customRef\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.customRef),\n/* harmony export */   \"defineAsyncComponent\": () => (/* binding */ defineAsyncComponent),\n/* harmony export */   \"defineComponent\": () => (/* binding */ defineComponent),\n/* harmony export */   \"defineEmits\": () => (/* binding */ defineEmits),\n/* harmony export */   \"defineExpose\": () => (/* binding */ defineExpose),\n/* harmony export */   \"defineProps\": () => (/* binding */ defineProps),\n/* harmony export */   \"devtools\": () => (/* binding */ devtools),\n/* harmony export */   \"effect\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effect),\n/* harmony export */   \"effectScope\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.effectScope),\n/* harmony export */   \"getCurrentInstance\": () => (/* binding */ getCurrentInstance),\n/* harmony export */   \"getCurrentScope\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),\n/* harmony export */   \"getTransitionRawChildren\": () => (/* binding */ getTransitionRawChildren),\n/* harmony export */   \"guardReactiveProps\": () => (/* binding */ guardReactiveProps),\n/* harmony export */   \"h\": () => (/* binding */ h),\n/* harmony export */   \"handleError\": () => (/* binding */ handleError),\n/* harmony export */   \"initCustomFormatter\": () => (/* binding */ initCustomFormatter),\n/* harmony export */   \"inject\": () => (/* binding */ inject),\n/* harmony export */   \"isMemoSame\": () => (/* binding */ isMemoSame),\n/* harmony export */   \"isProxy\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy),\n/* harmony export */   \"isReactive\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive),\n/* harmony export */   \"isReadonly\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly),\n/* harmony export */   \"isRef\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef),\n/* harmony export */   \"isRuntimeOnly\": () => (/* binding */ isRuntimeOnly),\n/* harmony export */   \"isShallow\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow),\n/* harmony export */   \"isVNode\": () => (/* binding */ isVNode),\n/* harmony export */   \"markRaw\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw),\n/* harmony export */   \"mergeDefaults\": () => (/* binding */ mergeDefaults),\n/* harmony export */   \"mergeProps\": () => (/* binding */ mergeProps),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"normalizeClass\": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass),\n/* harmony export */   \"normalizeProps\": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeProps),\n/* harmony export */   \"normalizeStyle\": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle),\n/* harmony export */   \"onActivated\": () => (/* binding */ onActivated),\n/* harmony export */   \"onBeforeMount\": () => (/* binding */ onBeforeMount),\n/* harmony export */   \"onBeforeUnmount\": () => (/* binding */ onBeforeUnmount),\n/* harmony export */   \"onBeforeUpdate\": () => (/* binding */ onBeforeUpdate),\n/* harmony export */   \"onDeactivated\": () => (/* binding */ onDeactivated),\n/* harmony export */   \"onErrorCaptured\": () => (/* binding */ onErrorCaptured),\n/* harmony export */   \"onMounted\": () => (/* binding */ onMounted),\n/* harmony export */   \"onRenderTracked\": () => (/* binding */ onRenderTracked),\n/* harmony export */   \"onRenderTriggered\": () => (/* binding */ onRenderTriggered),\n/* harmony export */   \"onScopeDispose\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),\n/* harmony export */   \"onServerPrefetch\": () => (/* binding */ onServerPrefetch),\n/* harmony export */   \"onUnmounted\": () => (/* binding */ onUnmounted),\n/* harmony export */   \"onUpdated\": () => (/* binding */ onUpdated),\n/* harmony export */   \"openBlock\": () => (/* binding */ openBlock),\n/* harmony export */   \"popScopeId\": () => (/* binding */ popScopeId),\n/* harmony export */   \"provide\": () => (/* binding */ provide),\n/* harmony export */   \"proxyRefs\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),\n/* harmony export */   \"pushScopeId\": () => (/* binding */ pushScopeId),\n/* harmony export */   \"queuePostFlushCb\": () => (/* binding */ queuePostFlushCb),\n/* harmony export */   \"reactive\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive),\n/* harmony export */   \"readonly\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.readonly),\n/* harmony export */   \"ref\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref),\n/* harmony export */   \"registerRuntimeCompiler\": () => (/* binding */ registerRuntimeCompiler),\n/* harmony export */   \"renderList\": () => (/* binding */ renderList),\n/* harmony export */   \"renderSlot\": () => (/* binding */ renderSlot),\n/* harmony export */   \"resolveComponent\": () => (/* binding */ resolveComponent),\n/* harmony export */   \"resolveDirective\": () => (/* binding */ resolveDirective),\n/* harmony export */   \"resolveDynamicComponent\": () => (/* binding */ resolveDynamicComponent),\n/* harmony export */   \"resolveFilter\": () => (/* binding */ resolveFilter),\n/* harmony export */   \"resolveTransitionHooks\": () => (/* binding */ resolveTransitionHooks),\n/* harmony export */   \"setBlockTracking\": () => (/* binding */ setBlockTracking),\n/* harmony export */   \"setDevtoolsHook\": () => (/* binding */ setDevtoolsHook),\n/* harmony export */   \"setTransitionHooks\": () => (/* binding */ setTransitionHooks),\n/* harmony export */   \"shallowReactive\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),\n/* harmony export */   \"shallowReadonly\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),\n/* harmony export */   \"shallowRef\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowRef),\n/* harmony export */   \"ssrContextKey\": () => (/* binding */ ssrContextKey),\n/* harmony export */   \"ssrUtils\": () => (/* binding */ ssrUtils),\n/* harmony export */   \"stop\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.stop),\n/* harmony export */   \"toDisplayString\": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString),\n/* harmony export */   \"toHandlerKey\": () => (/* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey),\n/* harmony export */   \"toHandlers\": () => (/* binding */ toHandlers),\n/* harmony export */   \"toRaw\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw),\n/* harmony export */   \"toRef\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRef),\n/* harmony export */   \"toRefs\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRefs),\n/* harmony export */   \"transformVNodeArgs\": () => (/* binding */ transformVNodeArgs),\n/* harmony export */   \"triggerRef\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.triggerRef),\n/* harmony export */   \"unref\": () => (/* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.unref),\n/* harmony export */   \"useAttrs\": () => (/* binding */ useAttrs),\n/* harmony export */   \"useSSRContext\": () => (/* binding */ useSSRContext),\n/* harmony export */   \"useSlots\": () => (/* binding */ useSlots),\n/* harmony export */   \"useTransitionState\": () => (/* binding */ useTransitionState),\n/* harmony export */   \"version\": () => (/* binding */ version),\n/* harmony export */   \"warn\": () => (/* binding */ warn),\n/* harmony export */   \"watch\": () => (/* binding */ watch),\n/* harmony export */   \"watchEffect\": () => (/* binding */ watchEffect),\n/* harmony export */   \"watchPostEffect\": () => (/* binding */ watchPostEffect),\n/* harmony export */   \"watchSyncEffect\": () => (/* binding */ watchSyncEffect),\n/* harmony export */   \"withAsyncContext\": () => (/* binding */ withAsyncContext),\n/* harmony export */   \"withCtx\": () => (/* binding */ withCtx),\n/* harmony export */   \"withDefaults\": () => (/* binding */ withDefaults),\n/* harmony export */   \"withDirectives\": () => (/* binding */ withDirectives),\n/* harmony export */   \"withMemo\": () => (/* binding */ withMemo),\n/* harmony export */   \"withScopeId\": () => (/* binding */ withScopeId)\n/* harmony export */ });\n/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/reactivity */ \"./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\n\n\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n    stack.push(vnode);\n}\nfunction popWarningContext() {\n    stack.pop();\n}\nfunction warn(msg, ...args) {\n    if (false)\n        {}\n    // avoid props formatting or warn handler tracking deps that might be mutated\n    // during patch, leading to infinite recursion.\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n    const instance = stack.length ? stack[stack.length - 1].component : null;\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\n    const trace = getComponentTrace();\n    if (appWarnHandler) {\n        callWithErrorHandling(appWarnHandler, instance, 11 /* ErrorCodes.APP_WARN_HANDLER */, [\n            msg + args.join(''),\n            instance && instance.proxy,\n            trace\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\n                .join('\\n'),\n            trace\n        ]);\n    }\n    else {\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n        /* istanbul ignore if */\n        if (trace.length &&\n            // avoid spamming console during tests\n            !false) {\n            warnArgs.push(`\\n`, ...formatTrace(trace));\n        }\n        console.warn(...warnArgs);\n    }\n    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n}\nfunction getComponentTrace() {\n    let currentVNode = stack[stack.length - 1];\n    if (!currentVNode) {\n        return [];\n    }\n    // we can't just use the stack because it will be incomplete during updates\n    // that did not start from the root. Re-construct the parent chain using\n    // instance parent pointers.\n    const normalizedStack = [];\n    while (currentVNode) {\n        const last = normalizedStack[0];\n        if (last && last.vnode === currentVNode) {\n            last.recurseCount++;\n        }\n        else {\n            normalizedStack.push({\n                vnode: currentVNode,\n                recurseCount: 0\n            });\n        }\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\n        currentVNode = parentInstance && parentInstance.vnode;\n    }\n    return normalizedStack;\n}\n/* istanbul ignore next */\nfunction formatTrace(trace) {\n    const logs = [];\n    trace.forEach((entry, i) => {\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\n    });\n    return logs;\n}\nfunction formatTraceEntry({ vnode, recurseCount }) {\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n    const close = `>` + postfix;\n    return vnode.props\n        ? [open, ...formatProps(vnode.props), close]\n        : [open + close];\n}\n/* istanbul ignore next */\nfunction formatProps(props) {\n    const res = [];\n    const keys = Object.keys(props);\n    keys.slice(0, 3).forEach(key => {\n        res.push(...formatProp(key, props[key]));\n    });\n    if (keys.length > 3) {\n        res.push(` ...`);\n    }\n    return res;\n}\n/* istanbul ignore next */\nfunction formatProp(key, value, raw) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {\n        value = JSON.stringify(value);\n        return raw ? value : [`${key}=${value}`];\n    }\n    else if (typeof value === 'number' ||\n        typeof value === 'boolean' ||\n        value == null) {\n        return raw ? value : [`${key}=${value}`];\n    }\n    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {\n        value = formatProp(key, (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value.value), true);\n        return raw ? value : [`${key}=Ref<`, value, `>`];\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n    }\n    else {\n        value = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(value);\n        return raw ? value : [`${key}=`, value];\n    }\n}\n/**\n * @internal\n */\nfunction assertNumber(val, type) {\n    if (false)\n        {}\n    if (val === undefined) {\n        return;\n    }\n    else if (typeof val !== 'number') {\n        warn(`${type} is not a valid number - ` + `got ${JSON.stringify(val)}.`);\n    }\n    else if (isNaN(val)) {\n        warn(`${type} is NaN - ` + 'the duration expression might be incorrect.');\n    }\n}\n\nconst ErrorTypeStrings = {\n    [\"sp\" /* LifecycleHooks.SERVER_PREFETCH */]: 'serverPrefetch hook',\n    [\"bc\" /* LifecycleHooks.BEFORE_CREATE */]: 'beforeCreate hook',\n    [\"c\" /* LifecycleHooks.CREATED */]: 'created hook',\n    [\"bm\" /* LifecycleHooks.BEFORE_MOUNT */]: 'beforeMount hook',\n    [\"m\" /* LifecycleHooks.MOUNTED */]: 'mounted hook',\n    [\"bu\" /* LifecycleHooks.BEFORE_UPDATE */]: 'beforeUpdate hook',\n    [\"u\" /* LifecycleHooks.UPDATED */]: 'updated',\n    [\"bum\" /* LifecycleHooks.BEFORE_UNMOUNT */]: 'beforeUnmount hook',\n    [\"um\" /* LifecycleHooks.UNMOUNTED */]: 'unmounted hook',\n    [\"a\" /* LifecycleHooks.ACTIVATED */]: 'activated hook',\n    [\"da\" /* LifecycleHooks.DEACTIVATED */]: 'deactivated hook',\n    [\"ec\" /* LifecycleHooks.ERROR_CAPTURED */]: 'errorCaptured hook',\n    [\"rtc\" /* LifecycleHooks.RENDER_TRACKED */]: 'renderTracked hook',\n    [\"rtg\" /* LifecycleHooks.RENDER_TRIGGERED */]: 'renderTriggered hook',\n    [0 /* ErrorCodes.SETUP_FUNCTION */]: 'setup function',\n    [1 /* ErrorCodes.RENDER_FUNCTION */]: 'render function',\n    [2 /* ErrorCodes.WATCH_GETTER */]: 'watcher getter',\n    [3 /* ErrorCodes.WATCH_CALLBACK */]: 'watcher callback',\n    [4 /* ErrorCodes.WATCH_CLEANUP */]: 'watcher cleanup function',\n    [5 /* ErrorCodes.NATIVE_EVENT_HANDLER */]: 'native event handler',\n    [6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */]: 'component event handler',\n    [7 /* ErrorCodes.VNODE_HOOK */]: 'vnode hook',\n    [8 /* ErrorCodes.DIRECTIVE_HOOK */]: 'directive hook',\n    [9 /* ErrorCodes.TRANSITION_HOOK */]: 'transition hook',\n    [10 /* ErrorCodes.APP_ERROR_HANDLER */]: 'app errorHandler',\n    [11 /* ErrorCodes.APP_WARN_HANDLER */]: 'app warnHandler',\n    [12 /* ErrorCodes.FUNCTION_REF */]: 'ref function',\n    [13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */]: 'async component loader',\n    [14 /* ErrorCodes.SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n    let res;\n    try {\n        res = args ? fn(...args) : fn();\n    }\n    catch (err) {\n        handleError(err, instance, type);\n    }\n    return res;\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {\n        const res = callWithErrorHandling(fn, instance, type, args);\n        if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(res)) {\n            res.catch(err => {\n                handleError(err, instance, type);\n            });\n        }\n        return res;\n    }\n    const values = [];\n    for (let i = 0; i < fn.length; i++) {\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n    }\n    return values;\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n    const contextVNode = instance ? instance.vnode : null;\n    if (instance) {\n        let cur = instance.parent;\n        // the exposed instance is the render proxy to keep it consistent with 2.x\n        const exposedInstance = instance.proxy;\n        // in production the hook receives only the error code\n        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;\n        while (cur) {\n            const errorCapturedHooks = cur.ec;\n            if (errorCapturedHooks) {\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n                        return;\n                    }\n                }\n            }\n            cur = cur.parent;\n        }\n        // app-level handling\n        const appErrorHandler = instance.appContext.config.errorHandler;\n        if (appErrorHandler) {\n            callWithErrorHandling(appErrorHandler, null, 10 /* ErrorCodes.APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\n            return;\n        }\n    }\n    logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n    if ((true)) {\n        const info = ErrorTypeStrings[type];\n        if (contextVNode) {\n            pushWarningContext(contextVNode);\n        }\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n        if (contextVNode) {\n            popWarningContext();\n        }\n        // crash in dev by default so it's more noticeable\n        if (throwInDev) {\n            throw err;\n        }\n        else {\n            console.error(err);\n        }\n    }\n    else {}\n}\n\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n    const p = currentFlushPromise || resolvedPromise;\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\n// #2768\n// Use binary-search to find a suitable position in the queue,\n// so that the queue maintains the increasing order of job's id,\n// which can prevent the job from being skipped and also can avoid repeated patching.\nfunction findInsertionIndex(id) {\n    // the start index should be `flushIndex + 1`\n    let start = flushIndex + 1;\n    let end = queue.length;\n    while (start < end) {\n        const middle = (start + end) >>> 1;\n        const middleJobId = getId(queue[middle]);\n        middleJobId < id ? (start = middle + 1) : (end = middle);\n    }\n    return start;\n}\nfunction queueJob(job) {\n    // the dedupe search uses the startIndex argument of Array.includes()\n    // by default the search index includes the current job that is being run\n    // so it cannot recursively trigger itself again.\n    // if the job is a watch() callback, the search will start with a +1 index to\n    // allow it recursively trigger itself - it is the user's responsibility to\n    // ensure it doesn't end up in an infinite loop.\n    if (!queue.length ||\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {\n        if (job.id == null) {\n            queue.push(job);\n        }\n        else {\n            queue.splice(findInsertionIndex(job.id), 0, job);\n        }\n        queueFlush();\n    }\n}\nfunction queueFlush() {\n    if (!isFlushing && !isFlushPending) {\n        isFlushPending = true;\n        currentFlushPromise = resolvedPromise.then(flushJobs);\n    }\n}\nfunction invalidateJob(job) {\n    const i = queue.indexOf(job);\n    if (i > flushIndex) {\n        queue.splice(i, 1);\n    }\n}\nfunction queuePostFlushCb(cb) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(cb)) {\n        if (!activePostFlushCbs ||\n            !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {\n            pendingPostFlushCbs.push(cb);\n        }\n    }\n    else {\n        // if cb is an array, it is a component lifecycle hook which can only be\n        // triggered by a job, which is already deduped in the main queue, so\n        // we can skip duplicate check here to improve perf\n        pendingPostFlushCbs.push(...cb);\n    }\n    queueFlush();\n}\nfunction flushPreFlushCbs(seen, \n// if currently flushing, skip the current job itself\ni = isFlushing ? flushIndex + 1 : 0) {\n    if ((true)) {\n        seen = seen || new Map();\n    }\n    for (; i < queue.length; i++) {\n        const cb = queue[i];\n        if (cb && cb.pre) {\n            if (( true) && checkRecursiveUpdates(seen, cb)) {\n                continue;\n            }\n            queue.splice(i, 1);\n            i--;\n            cb();\n        }\n    }\n}\nfunction flushPostFlushCbs(seen) {\n    if (pendingPostFlushCbs.length) {\n        const deduped = [...new Set(pendingPostFlushCbs)];\n        pendingPostFlushCbs.length = 0;\n        // #1947 already has active queue, nested flushPostFlushCbs call\n        if (activePostFlushCbs) {\n            activePostFlushCbs.push(...deduped);\n            return;\n        }\n        activePostFlushCbs = deduped;\n        if ((true)) {\n            seen = seen || new Map();\n        }\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n            if (( true) &&\n                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {\n                continue;\n            }\n            activePostFlushCbs[postFlushIndex]();\n        }\n        activePostFlushCbs = null;\n        postFlushIndex = 0;\n    }\n}\nconst getId = (job) => job.id == null ? Infinity : job.id;\nconst comparator = (a, b) => {\n    const diff = getId(a) - getId(b);\n    if (diff === 0) {\n        if (a.pre && !b.pre)\n            return -1;\n        if (b.pre && !a.pre)\n            return 1;\n    }\n    return diff;\n};\nfunction flushJobs(seen) {\n    isFlushPending = false;\n    isFlushing = true;\n    if ((true)) {\n        seen = seen || new Map();\n    }\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child so its render effect will have smaller\n    //    priority number)\n    // 2. If a component is unmounted during a parent component's update,\n    //    its update can be skipped.\n    queue.sort(comparator);\n    // conditional usage of checkRecursiveUpdate must be determined out of\n    // try ... catch block since Rollup by default de-optimizes treeshaking\n    // inside try-catch. This can leave all warning code unshaked. Although\n    // they would get eventually shaken by a minifier like terser, some minifiers\n    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\n    const check = ( true)\n        ? (job) => checkRecursiveUpdates(seen, job)\n        : 0;\n    try {\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n            const job = queue[flushIndex];\n            if (job && job.active !== false) {\n                if (( true) && check(job)) {\n                    continue;\n                }\n                // console.log(`running:`, job.id)\n                callWithErrorHandling(job, null, 14 /* ErrorCodes.SCHEDULER */);\n            }\n        }\n    }\n    finally {\n        flushIndex = 0;\n        queue.length = 0;\n        flushPostFlushCbs(seen);\n        isFlushing = false;\n        currentFlushPromise = null;\n        // some postFlushCb queued jobs!\n        // keep flushing until it drains.\n        if (queue.length || pendingPostFlushCbs.length) {\n            flushJobs(seen);\n        }\n    }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n    if (!seen.has(fn)) {\n        seen.set(fn, 1);\n    }\n    else {\n        const count = seen.get(fn);\n        if (count > RECURSION_LIMIT) {\n            const instance = fn.ownerInstance;\n            const componentName = instance && getComponentName(instance.type);\n            warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +\n                `This means you have a reactive effect that is mutating its own ` +\n                `dependencies and thus recursively triggering itself. Possible sources ` +\n                `include component template, render function, updated hook or ` +\n                `watcher source function.`);\n            return true;\n        }\n        else {\n            seen.set(fn, count + 1);\n        }\n    }\n}\n\n/* eslint-disable no-restricted-globals */\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = new Set();\n// Expose the HMR runtime on the global object\n// This makes it entirely tree-shakable without polluting the exports and makes\n// it easier to be used in toolings like vue-loader\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\n// to be set so that its instances can be registered / removed.\nif ((true)) {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_HMR_RUNTIME__ = {\n        createRecord: tryWrap(createRecord),\n        rerender: tryWrap(rerender),\n        reload: tryWrap(reload)\n    };\n}\nconst map = new Map();\nfunction registerHMR(instance) {\n    const id = instance.type.__hmrId;\n    let record = map.get(id);\n    if (!record) {\n        createRecord(id, instance.type);\n        record = map.get(id);\n    }\n    record.instances.add(instance);\n}\nfunction unregisterHMR(instance) {\n    map.get(instance.type.__hmrId).instances.delete(instance);\n}\nfunction createRecord(id, initialDef) {\n    if (map.has(id)) {\n        return false;\n    }\n    map.set(id, {\n        initialDef: normalizeClassComponent(initialDef),\n        instances: new Set()\n    });\n    return true;\n}\nfunction normalizeClassComponent(component) {\n    return isClassComponent(component) ? component.__vccOpts : component;\n}\nfunction rerender(id, newRender) {\n    const record = map.get(id);\n    if (!record) {\n        return;\n    }\n    // update initial record (for not-yet-rendered component)\n    record.initialDef.render = newRender;\n    [...record.instances].forEach(instance => {\n        if (newRender) {\n            instance.render = newRender;\n            normalizeClassComponent(instance.type).render = newRender;\n        }\n        instance.renderCache = [];\n        // this flag forces child components with slot content to update\n        isHmrUpdating = true;\n        instance.update();\n        isHmrUpdating = false;\n    });\n}\nfunction reload(id, newComp) {\n    const record = map.get(id);\n    if (!record)\n        return;\n    newComp = normalizeClassComponent(newComp);\n    // update initial def (for not-yet-rendered components)\n    updateComponentDef(record.initialDef, newComp);\n    // create a snapshot which avoids the set being mutated during updates\n    const instances = [...record.instances];\n    for (const instance of instances) {\n        const oldComp = normalizeClassComponent(instance.type);\n        if (!hmrDirtyComponents.has(oldComp)) {\n            // 1. Update existing comp definition to match new one\n            if (oldComp !== record.initialDef) {\n                updateComponentDef(oldComp, newComp);\n            }\n            // 2. mark definition dirty. This forces the renderer to replace the\n            // component on patch.\n            hmrDirtyComponents.add(oldComp);\n        }\n        // 3. invalidate options resolution cache\n        instance.appContext.optionsCache.delete(instance.type);\n        // 4. actually update\n        if (instance.ceReload) {\n            // custom element\n            hmrDirtyComponents.add(oldComp);\n            instance.ceReload(newComp.styles);\n            hmrDirtyComponents.delete(oldComp);\n        }\n        else if (instance.parent) {\n            // 4. Force the parent instance to re-render. This will cause all updated\n            // components to be unmounted and re-mounted. Queue the update so that we\n            // don't end up forcing the same parent to re-render multiple times.\n            queueJob(instance.parent.update);\n        }\n        else if (instance.appContext.reload) {\n            // root instance mounted via createApp() has a reload method\n            instance.appContext.reload();\n        }\n        else if (typeof window !== 'undefined') {\n            // root instance inside tree created via raw render(). Force reload.\n            window.location.reload();\n        }\n        else {\n            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');\n        }\n    }\n    // 5. make sure to cleanup dirty hmr components after update\n    queuePostFlushCb(() => {\n        for (const instance of instances) {\n            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));\n        }\n    });\n}\nfunction updateComponentDef(oldComp, newComp) {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(oldComp, newComp);\n    for (const key in oldComp) {\n        if (key !== '__file' && !(key in newComp)) {\n            delete oldComp[key];\n        }\n    }\n}\nfunction tryWrap(fn) {\n    return (id, arg) => {\n        try {\n            return fn(id, arg);\n        }\n        catch (e) {\n            console.error(e);\n            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +\n                `Full reload required.`);\n        }\n    };\n}\n\nlet devtools;\nlet buffer = [];\nlet devtoolsNotInstalled = false;\nfunction emit$1(event, ...args) {\n    if (devtools) {\n        devtools.emit(event, ...args);\n    }\n    else if (!devtoolsNotInstalled) {\n        buffer.push({ event, args });\n    }\n}\nfunction setDevtoolsHook(hook, target) {\n    var _a, _b;\n    devtools = hook;\n    if (devtools) {\n        devtools.enabled = true;\n        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));\n        buffer = [];\n    }\n    else if (\n    // handle late devtools injection - only do this if we are in an actual\n    // browser environment to avoid the timer handle stalling test runner exit\n    // (#4815)\n    typeof window !== 'undefined' &&\n        // some envs mock window but not fully\n        window.HTMLElement &&\n        // also exclude jsdom\n        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {\n        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =\n            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);\n        replay.push((newHook) => {\n            setDevtoolsHook(newHook, target);\n        });\n        // clear buffer after 3s - the user probably doesn't have devtools installed\n        // at all, and keeping the buffer will cause memory leaks (#4738)\n        setTimeout(() => {\n            if (!devtools) {\n                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n                devtoolsNotInstalled = true;\n                buffer = [];\n            }\n        }, 3000);\n    }\n    else {\n        // non-browser env, assume not installed\n        devtoolsNotInstalled = true;\n        buffer = [];\n    }\n}\nfunction devtoolsInitApp(app, version) {\n    emit$1(\"app:init\" /* DevtoolsHooks.APP_INIT */, app, version, {\n        Fragment,\n        Text,\n        Comment,\n        Static\n    });\n}\nfunction devtoolsUnmountApp(app) {\n    emit$1(\"app:unmount\" /* DevtoolsHooks.APP_UNMOUNT */, app);\n}\nconst devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(\"component:added\" /* DevtoolsHooks.COMPONENT_ADDED */);\nconst devtoolsComponentUpdated = \n/*#__PURE__*/ createDevtoolsComponentHook(\"component:updated\" /* DevtoolsHooks.COMPONENT_UPDATED */);\nconst _devtoolsComponentRemoved = /*#__PURE__*/ createDevtoolsComponentHook(\"component:removed\" /* DevtoolsHooks.COMPONENT_REMOVED */);\nconst devtoolsComponentRemoved = (component) => {\n    if (devtools &&\n        typeof devtools.cleanupBuffer === 'function' &&\n        // remove the component if it wasn't buffered\n        !devtools.cleanupBuffer(component)) {\n        _devtoolsComponentRemoved(component);\n    }\n};\nfunction createDevtoolsComponentHook(hook) {\n    return (component) => {\n        emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);\n    };\n}\nconst devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook(\"perf:start\" /* DevtoolsHooks.PERFORMANCE_START */);\nconst devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook(\"perf:end\" /* DevtoolsHooks.PERFORMANCE_END */);\nfunction createDevtoolsPerformanceHook(hook) {\n    return (component, type, time) => {\n        emit$1(hook, component.appContext.app, component.uid, component, type, time);\n    };\n}\nfunction devtoolsComponentEmit(component, event, params) {\n    emit$1(\"component:emit\" /* DevtoolsHooks.COMPONENT_EMIT */, component.appContext.app, component, event, params);\n}\n\nfunction emit(instance, event, ...rawArgs) {\n    if (instance.isUnmounted)\n        return;\n    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    if ((true)) {\n        const { emitsOptions, propsOptions: [propsOptions] } = instance;\n        if (emitsOptions) {\n            if (!(event in emitsOptions) &&\n                !(false )) {\n                if (!propsOptions || !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event) in propsOptions)) {\n                    warn(`Component emitted event \"${event}\" but it is neither declared in ` +\n                        `the emits option nor as an \"${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event)}\" prop.`);\n                }\n            }\n            else {\n                const validator = emitsOptions[event];\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(validator)) {\n                    const isValid = validator(...rawArgs);\n                    if (!isValid) {\n                        warn(`Invalid event arguments: event validation failed for event \"${event}\".`);\n                    }\n                }\n            }\n        }\n    }\n    let args = rawArgs;\n    const isModelListener = event.startsWith('update:');\n    // for v-model update:xxx events, apply modifiers on args\n    const modelArg = isModelListener && event.slice(7);\n    if (modelArg && modelArg in props) {\n        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;\n        const { number, trim } = props[modifiersKey] || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n        if (trim) {\n            args = rawArgs.map(a => ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(a) ? a.trim() : a));\n        }\n        if (number) {\n            args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber);\n        }\n    }\n    if (true) {\n        devtoolsComponentEmit(instance, event, args);\n    }\n    if ((true)) {\n        const lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && props[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(lowerCaseEvent)]) {\n            warn(`Event \"${lowerCaseEvent}\" is emitted in component ` +\n                `${formatComponentName(instance, instance.type)} but the handler is registered for \"${event}\". ` +\n                `Note that HTML attributes are case-insensitive and you cannot use ` +\n                `v-on to listen to camelCase events when using in-DOM templates. ` +\n                `You should probably use \"${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)}\" instead of \"${event}\".`);\n        }\n    }\n    let handlerName;\n    let handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(event))] ||\n        // also try camelCase event handler (#2249)\n        props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(event)))];\n    // for v-model update:xxx events, also trigger kebab-case equivalent\n    // for props passed via kebab-case\n    if (!handler && isModelListener) {\n        handler = props[(handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event)))];\n    }\n    if (handler) {\n        callWithAsyncErrorHandling(handler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);\n    }\n    const onceHandler = props[handlerName + `Once`];\n    if (onceHandler) {\n        if (!instance.emitted) {\n            instance.emitted = {};\n        }\n        else if (instance.emitted[handlerName]) {\n            return;\n        }\n        instance.emitted[handlerName] = true;\n        callWithAsyncErrorHandling(onceHandler, instance, 6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */, args);\n    }\n}\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n    const cache = appContext.emitsCache;\n    const cached = cache.get(comp);\n    if (cached !== undefined) {\n        return cached;\n    }\n    const raw = comp.emits;\n    let normalized = {};\n    // apply mixin/extends props\n    let hasExtends = false;\n    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\n        const extendEmits = (raw) => {\n            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);\n            if (normalizedFromExtend) {\n                hasExtends = true;\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, normalizedFromExtend);\n            }\n        };\n        if (!asMixin && appContext.mixins.length) {\n            appContext.mixins.forEach(extendEmits);\n        }\n        if (comp.extends) {\n            extendEmits(comp.extends);\n        }\n        if (comp.mixins) {\n            comp.mixins.forEach(extendEmits);\n        }\n    }\n    if (!raw && !hasExtends) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {\n            cache.set(comp, null);\n        }\n        return null;\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\n        raw.forEach(key => (normalized[key] = null));\n    }\n    else {\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, raw);\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {\n        cache.set(comp, normalized);\n    }\n    return normalized;\n}\n// Check if an incoming prop key is a declared emit event listener.\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\n// both considered matched listeners.\nfunction isEmitListener(options, key) {\n    if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n        return false;\n    }\n    key = key.slice(2).replace(/Once$/, '');\n    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key[0].toLowerCase() + key.slice(1)) ||\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) ||\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, key));\n}\n\n/**\n * mark the current rendering instance for asset resolution (e.g.\n * resolveComponent, resolveDirective) during render\n */\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\n/**\n * Note: rendering calls maybe nested. The function returns the parent rendering\n * instance if present, which should be restored after the render is done:\n *\n * ```js\n * const prev = setCurrentRenderingInstance(i)\n * // ...render\n * setCurrentRenderingInstance(prev)\n * ```\n */\nfunction setCurrentRenderingInstance(instance) {\n    const prev = currentRenderingInstance;\n    currentRenderingInstance = instance;\n    currentScopeId = (instance && instance.type.__scopeId) || null;\n    return prev;\n}\n/**\n * Set scope id when creating hoisted vnodes.\n * @private compiler helper\n */\nfunction pushScopeId(id) {\n    currentScopeId = id;\n}\n/**\n * Technically we no longer need this after 3.0.8 but we need to keep the same\n * API for backwards compat w/ code generated by compilers.\n * @private\n */\nfunction popScopeId() {\n    currentScopeId = null;\n}\n/**\n * Only for backwards compat\n * @private\n */\nconst withScopeId = (_id) => withCtx;\n/**\n * Wrap a slot function to memoize current rendering instance\n * @private compiler helper\n */\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only\n) {\n    if (!ctx)\n        return fn;\n    // already normalized\n    if (fn._n) {\n        return fn;\n    }\n    const renderFnWithContext = (...args) => {\n        // If a user calls a compiled slot inside a template expression (#1745), it\n        // can mess up block tracking, so by default we disable block tracking and\n        // force bail out when invoking a compiled slot (indicated by the ._d flag).\n        // This isn't necessary if rendering a compiled `<slot>`, so we flip the\n        // ._d flag off when invoking the wrapped fn inside `renderSlot`.\n        if (renderFnWithContext._d) {\n            setBlockTracking(-1);\n        }\n        const prevInstance = setCurrentRenderingInstance(ctx);\n        let res;\n        try {\n            res = fn(...args);\n        }\n        finally {\n            setCurrentRenderingInstance(prevInstance);\n            if (renderFnWithContext._d) {\n                setBlockTracking(1);\n            }\n        }\n        if (true) {\n            devtoolsComponentUpdated(ctx);\n        }\n        return res;\n    };\n    // mark normalized to avoid duplicated wrapping\n    renderFnWithContext._n = true;\n    // mark this as compiled by default\n    // this is used in vnode.ts -> normalizeChildren() to set the slot\n    // rendering flag.\n    renderFnWithContext._c = true;\n    // disable block tracking by default\n    renderFnWithContext._d = true;\n    return renderFnWithContext;\n}\n\n/**\n * dev only flag to track whether $attrs was used during render.\n * If $attrs was used during render then the warning for failed attrs\n * fallthrough can be suppressed.\n */\nlet accessedAttrs = false;\nfunction markAttrsAccessed() {\n    accessedAttrs = true;\n}\nfunction renderComponentRoot(instance) {\n    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;\n    let result;\n    let fallthroughAttrs;\n    const prev = setCurrentRenderingInstance(instance);\n    if ((true)) {\n        accessedAttrs = false;\n    }\n    try {\n        if (vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */) {\n            // withProxy is a proxy with a different `has` trap only for\n            // runtime-compiled render functions using `with` block.\n            const proxyToUse = withProxy || proxy;\n            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\n            fallthroughAttrs = attrs;\n        }\n        else {\n            // functional\n            const render = Component;\n            // in dev, mark attrs accessed if optional props (attrs === props)\n            if (( true) && attrs === props) {\n                markAttrsAccessed();\n            }\n            result = normalizeVNode(render.length > 1\n                ? render(props, ( true)\n                    ? {\n                        get attrs() {\n                            markAttrsAccessed();\n                            return attrs;\n                        },\n                        slots,\n                        emit\n                    }\n                    : 0)\n                : render(props, null /* we know it doesn't need it */));\n            fallthroughAttrs = Component.props\n                ? attrs\n                : getFunctionalFallthrough(attrs);\n        }\n    }\n    catch (err) {\n        blockStack.length = 0;\n        handleError(err, instance, 1 /* ErrorCodes.RENDER_FUNCTION */);\n        result = createVNode(Comment);\n    }\n    // attr merging\n    // in dev mode, comments are preserved, and it's possible for a template\n    // to have comments along side the root element which makes it a fragment\n    let root = result;\n    let setRoot = undefined;\n    if (( true) &&\n        result.patchFlag > 0 &&\n        result.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */) {\n        [root, setRoot] = getChildRoot(result);\n    }\n    if (fallthroughAttrs && inheritAttrs !== false) {\n        const keys = Object.keys(fallthroughAttrs);\n        const { shapeFlag } = root;\n        if (keys.length) {\n            if (shapeFlag & (1 /* ShapeFlags.ELEMENT */ | 6 /* ShapeFlags.COMPONENT */)) {\n                if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)) {\n                    // If a v-model listener (onUpdate:xxx) has a corresponding declared\n                    // prop, it indicates this component expects to handle v-model and\n                    // it should not fallthrough.\n                    // related: #1543, #1643, #1989\n                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\n                }\n                root = cloneVNode(root, fallthroughAttrs);\n            }\n            else if (( true) && !accessedAttrs && root.type !== Comment) {\n                const allAttrs = Object.keys(attrs);\n                const eventAttrs = [];\n                const extraAttrs = [];\n                for (let i = 0, l = allAttrs.length; i < l; i++) {\n                    const key = allAttrs[i];\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n                        // ignore v-model handlers when they fail to fallthrough\n                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {\n                            // remove `on`, lowercase first letter to reflect event casing\n                            // accurately\n                            eventAttrs.push(key[2].toLowerCase() + key.slice(3));\n                        }\n                    }\n                    else {\n                        extraAttrs.push(key);\n                    }\n                }\n                if (extraAttrs.length) {\n                    warn(`Extraneous non-props attributes (` +\n                        `${extraAttrs.join(', ')}) ` +\n                        `were passed to component but could not be automatically inherited ` +\n                        `because component renders fragment or text root nodes.`);\n                }\n                if (eventAttrs.length) {\n                    warn(`Extraneous non-emits event listeners (` +\n                        `${eventAttrs.join(', ')}) ` +\n                        `were passed to component but could not be automatically inherited ` +\n                        `because component renders fragment or text root nodes. ` +\n                        `If the listener is intended to be a component custom event listener only, ` +\n                        `declare it using the \"emits\" option.`);\n                }\n            }\n        }\n    }\n    // inherit directives\n    if (vnode.dirs) {\n        if (( true) && !isElementRoot(root)) {\n            warn(`Runtime directive used on component with non-element root node. ` +\n                `The directives will not function as intended.`);\n        }\n        // clone before mutating since the root may be a hoisted vnode\n        root = cloneVNode(root);\n        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n    }\n    // inherit transition data\n    if (vnode.transition) {\n        if (( true) && !isElementRoot(root)) {\n            warn(`Component inside <Transition> renders non-element root node ` +\n                `that cannot be animated.`);\n        }\n        root.transition = vnode.transition;\n    }\n    if (( true) && setRoot) {\n        setRoot(root);\n    }\n    else {\n        result = root;\n    }\n    setCurrentRenderingInstance(prev);\n    return result;\n}\n/**\n * dev only\n * In dev mode, template root level comments are rendered, which turns the\n * template into a fragment root, but we need to locate the single element\n * root for attrs and scope id processing.\n */\nconst getChildRoot = (vnode) => {\n    const rawChildren = vnode.children;\n    const dynamicChildren = vnode.dynamicChildren;\n    const childRoot = filterSingleRoot(rawChildren);\n    if (!childRoot) {\n        return [vnode, undefined];\n    }\n    const index = rawChildren.indexOf(childRoot);\n    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n    const setRoot = (updatedRoot) => {\n        rawChildren[index] = updatedRoot;\n        if (dynamicChildren) {\n            if (dynamicIndex > -1) {\n                dynamicChildren[dynamicIndex] = updatedRoot;\n            }\n            else if (updatedRoot.patchFlag > 0) {\n                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n            }\n        }\n    };\n    return [normalizeVNode(childRoot), setRoot];\n};\nfunction filterSingleRoot(children) {\n    let singleRoot;\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (isVNode(child)) {\n            // ignore user comment\n            if (child.type !== Comment || child.children === 'v-if') {\n                if (singleRoot) {\n                    // has more than 1 non-comment child, return now\n                    return;\n                }\n                else {\n                    singleRoot = child;\n                }\n            }\n        }\n        else {\n            return;\n        }\n    }\n    return singleRoot;\n}\nconst getFunctionalFallthrough = (attrs) => {\n    let res;\n    for (const key in attrs) {\n        if (key === 'class' || key === 'style' || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n            (res || (res = {}))[key] = attrs[key];\n        }\n    }\n    return res;\n};\nconst filterModelListeners = (attrs, props) => {\n    const res = {};\n    for (const key in attrs) {\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key) || !(key.slice(9) in props)) {\n            res[key] = attrs[key];\n        }\n    }\n    return res;\n};\nconst isElementRoot = (vnode) => {\n    return (vnode.shapeFlag & (6 /* ShapeFlags.COMPONENT */ | 1 /* ShapeFlags.ELEMENT */) ||\n        vnode.type === Comment // potential v-if branch switch\n    );\n};\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n    const { props: prevProps, children: prevChildren, component } = prevVNode;\n    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\n    const emits = component.emitsOptions;\n    // Parent component's render function was hot-updated. Since this may have\n    // caused the child component's slots content to have changed, we need to\n    // force the child to update as well.\n    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {\n        return true;\n    }\n    // force child update for runtime directive or transition on component vnode.\n    if (nextVNode.dirs || nextVNode.transition) {\n        return true;\n    }\n    if (optimized && patchFlag >= 0) {\n        if (patchFlag & 1024 /* PatchFlags.DYNAMIC_SLOTS */) {\n            // slot content that references values that might have changed,\n            // e.g. in a v-for\n            return true;\n        }\n        if (patchFlag & 16 /* PatchFlags.FULL_PROPS */) {\n            if (!prevProps) {\n                return !!nextProps;\n            }\n            // presence of this flag indicates props are always non-null\n            return hasPropsChanged(prevProps, nextProps, emits);\n        }\n        else if (patchFlag & 8 /* PatchFlags.PROPS */) {\n            const dynamicProps = nextVNode.dynamicProps;\n            for (let i = 0; i < dynamicProps.length; i++) {\n                const key = dynamicProps[i];\n                if (nextProps[key] !== prevProps[key] &&\n                    !isEmitListener(emits, key)) {\n                    return true;\n                }\n            }\n        }\n    }\n    else {\n        // this path is only taken by manually written render functions\n        // so presence of any children leads to a forced update\n        if (prevChildren || nextChildren) {\n            if (!nextChildren || !nextChildren.$stable) {\n                return true;\n            }\n        }\n        if (prevProps === nextProps) {\n            return false;\n        }\n        if (!prevProps) {\n            return !!nextProps;\n        }\n        if (!nextProps) {\n            return true;\n        }\n        return hasPropsChanged(prevProps, nextProps, emits);\n    }\n    return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n    const nextKeys = Object.keys(nextProps);\n    if (nextKeys.length !== Object.keys(prevProps).length) {\n        return true;\n    }\n    for (let i = 0; i < nextKeys.length; i++) {\n        const key = nextKeys[i];\n        if (nextProps[key] !== prevProps[key] &&\n            !isEmitListener(emitsOptions, key)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction updateHOCHostEl({ vnode, parent }, el // HostNode\n) {\n    while (parent && parent.subTree === vnode) {\n        (vnode = parent.vnode).el = el;\n        parent = parent.parent;\n    }\n}\n\nconst isSuspense = (type) => type.__isSuspense;\n// Suspense exposes a component-like API, and is treated like a component\n// in the compiler, but internally it's a special built-in type that hooks\n// directly into the renderer.\nconst SuspenseImpl = {\n    name: 'Suspense',\n    // In order to make Suspense tree-shakable, we need to avoid importing it\n    // directly in the renderer. The renderer checks for the __isSuspense flag\n    // on a vnode's type and calls the `process` method, passing in renderer\n    // internals.\n    __isSuspense: true,\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, \n    // platform-specific impl passed from renderer\n    rendererInternals) {\n        if (n1 == null) {\n            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);\n        }\n        else {\n            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);\n        }\n    },\n    hydrate: hydrateSuspense,\n    create: createSuspenseBoundary,\n    normalize: normalizeSuspenseChildren\n};\n// Force-casted public typing for h and TSX props inference\nconst Suspense = (SuspenseImpl\n    );\nfunction triggerEvent(vnode, name) {\n    const eventListener = vnode.props && vnode.props[name];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(eventListener)) {\n        eventListener();\n    }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\n    const { p: patch, o: { createElement } } = rendererInternals;\n    const hiddenContainer = createElement('div');\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));\n    // start mounting the content subtree in an off-dom container\n    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);\n    // now check if we have encountered any async deps\n    if (suspense.deps > 0) {\n        // has async\n        // invoke @fallback event\n        triggerEvent(vnode, 'onPending');\n        triggerEvent(vnode, 'onFallback');\n        // mount the fallback tree\n        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n        isSVG, slotScopeIds);\n        setActiveBranch(suspense, vnode.ssFallback);\n    }\n    else {\n        // Suspense has no async deps. Just resolve.\n        suspense.resolve();\n    }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\n    const suspense = (n2.suspense = n1.suspense);\n    suspense.vnode = n2;\n    n2.el = n1.el;\n    const newBranch = n2.ssContent;\n    const newFallback = n2.ssFallback;\n    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\n    if (pendingBranch) {\n        suspense.pendingBranch = newBranch;\n        if (isSameVNodeType(newBranch, pendingBranch)) {\n            // same root type but content may have changed.\n            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n            if (suspense.deps <= 0) {\n                suspense.resolve();\n            }\n            else if (isInFallback) {\n                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n                isSVG, slotScopeIds, optimized);\n                setActiveBranch(suspense, newFallback);\n            }\n        }\n        else {\n            // toggled before pending tree is resolved\n            suspense.pendingId++;\n            if (isHydrating) {\n                // if toggled before hydration is finished, the current DOM tree is\n                // no longer valid. set it as the active branch so it will be unmounted\n                // when resolved\n                suspense.isHydrating = false;\n                suspense.activeBranch = pendingBranch;\n            }\n            else {\n                unmount(pendingBranch, parentComponent, suspense);\n            }\n            // increment pending ID. this is used to invalidate async callbacks\n            // reset suspense state\n            suspense.deps = 0;\n            // discard effects from pending branch\n            suspense.effects.length = 0;\n            // discard previous container\n            suspense.hiddenContainer = createElement('div');\n            if (isInFallback) {\n                // already in fallback state\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n                if (suspense.deps <= 0) {\n                    suspense.resolve();\n                }\n                else {\n                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n                    isSVG, slotScopeIds, optimized);\n                    setActiveBranch(suspense, newFallback);\n                }\n            }\n            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n                // toggled \"back\" to current active branch\n                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n                // force resolve\n                suspense.resolve(true);\n            }\n            else {\n                // switched to a 3rd branch\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n                if (suspense.deps <= 0) {\n                    suspense.resolve();\n                }\n            }\n        }\n    }\n    else {\n        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n            // root did not change, just normal patch\n            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n            setActiveBranch(suspense, newBranch);\n        }\n        else {\n            // root node toggled\n            // invoke @pending event\n            triggerEvent(n2, 'onPending');\n            // mount pending branch in off-dom container\n            suspense.pendingBranch = newBranch;\n            suspense.pendingId++;\n            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\n            if (suspense.deps <= 0) {\n                // incoming branch has no async deps, resolve now.\n                suspense.resolve();\n            }\n            else {\n                const { timeout, pendingId } = suspense;\n                if (timeout > 0) {\n                    setTimeout(() => {\n                        if (suspense.pendingId === pendingId) {\n                            suspense.fallback(newFallback);\n                        }\n                    }, timeout);\n                }\n                else if (timeout === 0) {\n                    suspense.fallback(newFallback);\n                }\n            }\n        }\n    }\n}\nlet hasWarned = false;\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\n    /* istanbul ignore if */\n    if ( true && !hasWarned) {\n        hasWarned = true;\n        // @ts-ignore `console.info` cannot be null error\n        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);\n    }\n    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\n    const timeout = vnode.props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(vnode.props.timeout) : undefined;\n    if ((true)) {\n        assertNumber(timeout, `Suspense timeout`);\n    }\n    const suspense = {\n        vnode,\n        parent,\n        parentComponent,\n        isSVG,\n        container,\n        hiddenContainer,\n        anchor,\n        deps: 0,\n        pendingId: 0,\n        timeout: typeof timeout === 'number' ? timeout : -1,\n        activeBranch: null,\n        pendingBranch: null,\n        isInFallback: true,\n        isHydrating,\n        isUnmounted: false,\n        effects: [],\n        resolve(resume = false) {\n            if ((true)) {\n                if (!resume && !suspense.pendingBranch) {\n                    throw new Error(`suspense.resolve() is called without a pending branch.`);\n                }\n                if (suspense.isUnmounted) {\n                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);\n                }\n            }\n            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\n            if (suspense.isHydrating) {\n                suspense.isHydrating = false;\n            }\n            else if (!resume) {\n                const delayEnter = activeBranch &&\n                    pendingBranch.transition &&\n                    pendingBranch.transition.mode === 'out-in';\n                if (delayEnter) {\n                    activeBranch.transition.afterLeave = () => {\n                        if (pendingId === suspense.pendingId) {\n                            move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);\n                        }\n                    };\n                }\n                // this is initial anchor on mount\n                let { anchor } = suspense;\n                // unmount current active tree\n                if (activeBranch) {\n                    // if the fallback tree was mounted, it may have been moved\n                    // as part of a parent suspense. get the latest anchor for insertion\n                    anchor = next(activeBranch);\n                    unmount(activeBranch, parentComponent, suspense, true);\n                }\n                if (!delayEnter) {\n                    // move content from off-dom container to actual container\n                    move(pendingBranch, container, anchor, 0 /* MoveType.ENTER */);\n                }\n            }\n            setActiveBranch(suspense, pendingBranch);\n            suspense.pendingBranch = null;\n            suspense.isInFallback = false;\n            // flush buffered effects\n            // check if there is a pending parent suspense\n            let parent = suspense.parent;\n            let hasUnresolvedAncestor = false;\n            while (parent) {\n                if (parent.pendingBranch) {\n                    // found a pending parent suspense, merge buffered post jobs\n                    // into that parent\n                    parent.effects.push(...effects);\n                    hasUnresolvedAncestor = true;\n                    break;\n                }\n                parent = parent.parent;\n            }\n            // no pending parent suspense, flush all jobs\n            if (!hasUnresolvedAncestor) {\n                queuePostFlushCb(effects);\n            }\n            suspense.effects = [];\n            // invoke @resolve event\n            triggerEvent(vnode, 'onResolve');\n        },\n        fallback(fallbackVNode) {\n            if (!suspense.pendingBranch) {\n                return;\n            }\n            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;\n            // invoke @fallback event\n            triggerEvent(vnode, 'onFallback');\n            const anchor = next(activeBranch);\n            const mountFallback = () => {\n                if (!suspense.isInFallback) {\n                    return;\n                }\n                // mount the fallback tree\n                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\n                isSVG, slotScopeIds, optimized);\n                setActiveBranch(suspense, fallbackVNode);\n            };\n            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\n            if (delayEnter) {\n                activeBranch.transition.afterLeave = mountFallback;\n            }\n            suspense.isInFallback = true;\n            // unmount current active branch\n            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\n            true // shouldRemove\n            );\n            if (!delayEnter) {\n                mountFallback();\n            }\n        },\n        move(container, anchor, type) {\n            suspense.activeBranch &&\n                move(suspense.activeBranch, container, anchor, type);\n            suspense.container = container;\n        },\n        next() {\n            return suspense.activeBranch && next(suspense.activeBranch);\n        },\n        registerDep(instance, setupRenderEffect) {\n            const isInPendingSuspense = !!suspense.pendingBranch;\n            if (isInPendingSuspense) {\n                suspense.deps++;\n            }\n            const hydratedEl = instance.vnode.el;\n            instance\n                .asyncDep.catch(err => {\n                handleError(err, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);\n            })\n                .then(asyncSetupResult => {\n                // retry when the setup() promise resolves.\n                // component may have been unmounted before resolve.\n                if (instance.isUnmounted ||\n                    suspense.isUnmounted ||\n                    suspense.pendingId !== instance.suspenseId) {\n                    return;\n                }\n                // retry from this component\n                instance.asyncResolved = true;\n                const { vnode } = instance;\n                if ((true)) {\n                    pushWarningContext(vnode);\n                }\n                handleSetupResult(instance, asyncSetupResult, false);\n                if (hydratedEl) {\n                    // vnode may have been replaced if an update happened before the\n                    // async dep is resolved.\n                    vnode.el = hydratedEl;\n                }\n                const placeholder = !hydratedEl && instance.subTree.el;\n                setupRenderEffect(instance, vnode, \n                // component may have been moved before resolve.\n                // if this is not a hydration, instance.subTree will be the comment\n                // placeholder.\n                parentNode(hydratedEl || instance.subTree.el), \n                // anchor will not be used if this is hydration, so only need to\n                // consider the comment placeholder case.\n                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\n                if (placeholder) {\n                    remove(placeholder);\n                }\n                updateHOCHostEl(instance, vnode.el);\n                if ((true)) {\n                    popWarningContext();\n                }\n                // only decrease deps count if suspense is not already resolved\n                if (isInPendingSuspense && --suspense.deps === 0) {\n                    suspense.resolve();\n                }\n            });\n        },\n        unmount(parentSuspense, doRemove) {\n            suspense.isUnmounted = true;\n            if (suspense.activeBranch) {\n                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\n            }\n            if (suspense.pendingBranch) {\n                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\n            }\n        }\n    };\n    return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n    /* eslint-disable no-restricted-globals */\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));\n    // there are two possible scenarios for server-rendered suspense:\n    // - success: ssr content should be fully resolved\n    // - failure: ssr content should be the fallback branch.\n    // however, on the client we don't really know if it has failed or not\n    // attempt to hydrate the DOM assuming it has succeeded, but we still\n    // need to construct a suspense boundary first\n    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);\n    if (suspense.deps === 0) {\n        suspense.resolve();\n    }\n    return result;\n    /* eslint-enable no-restricted-globals */\n}\nfunction normalizeSuspenseChildren(vnode) {\n    const { shapeFlag, children } = vnode;\n    const isSlotChildren = shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */;\n    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);\n    vnode.ssFallback = isSlotChildren\n        ? normalizeSuspenseSlot(children.fallback)\n        : createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n    let block;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {\n        const trackBlock = isBlockTreeEnabled && s._c;\n        if (trackBlock) {\n            // disableTracking: false\n            // allow block tracking for compiled slots\n            // (see ./componentRenderContext.ts)\n            s._d = false;\n            openBlock();\n        }\n        s = s();\n        if (trackBlock) {\n            s._d = true;\n            block = currentBlock;\n            closeBlock();\n        }\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(s)) {\n        const singleChild = filterSingleRoot(s);\n        if (( true) && !singleChild) {\n            warn(`<Suspense> slots expect a single root node.`);\n        }\n        s = singleChild;\n    }\n    s = normalizeVNode(s);\n    if (block && !s.dynamicChildren) {\n        s.dynamicChildren = block.filter(c => c !== s);\n    }\n    return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n    if (suspense && suspense.pendingBranch) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn)) {\n            suspense.effects.push(...fn);\n        }\n        else {\n            suspense.effects.push(fn);\n        }\n    }\n    else {\n        queuePostFlushCb(fn);\n    }\n}\nfunction setActiveBranch(suspense, branch) {\n    suspense.activeBranch = branch;\n    const { vnode, parentComponent } = suspense;\n    const el = (vnode.el = branch.el);\n    // in case suspense is the root node of a component,\n    // recursively update the HOC el\n    if (parentComponent && parentComponent.subTree === vnode) {\n        parentComponent.vnode.el = el;\n        updateHOCHostEl(parentComponent, el);\n    }\n}\n\nfunction provide(key, value) {\n    if (!currentInstance) {\n        if ((true)) {\n            warn(`provide() can only be used inside setup().`);\n        }\n    }\n    else {\n        let provides = currentInstance.provides;\n        // by default an instance inherits its parent's provides object\n        // but when it needs to provide values of its own, it creates its\n        // own provides object using parent provides object as prototype.\n        // this way in `inject` we can simply look up injections from direct\n        // parent and let the prototype chain do the work.\n        const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n        if (parentProvides === provides) {\n            provides = currentInstance.provides = Object.create(parentProvides);\n        }\n        // TS doesn't allow symbol as index type\n        provides[key] = value;\n    }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n    // fallback to `currentRenderingInstance` so that this can be called in\n    // a functional component\n    const instance = currentInstance || currentRenderingInstance;\n    if (instance) {\n        // #2400\n        // to support `app.use` plugins,\n        // fallback to appContext's `provides` if the instance is at root\n        const provides = instance.parent == null\n            ? instance.vnode.appContext && instance.vnode.appContext.provides\n            : instance.parent.provides;\n        if (provides && key in provides) {\n            // TS doesn't allow symbol as index type\n            return provides[key];\n        }\n        else if (arguments.length > 1) {\n            return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)\n                ? defaultValue.call(instance.proxy)\n                : defaultValue;\n        }\n        else if ((true)) {\n            warn(`injection \"${String(key)}\" not found.`);\n        }\n    }\n    else if ((true)) {\n        warn(`inject() can only be used inside setup() or functional components.`);\n    }\n}\n\n// Simple effect.\nfunction watchEffect(effect, options) {\n    return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n    return doWatch(effect, null, ( true) ? Object.assign(Object.assign({}, options), { flush: 'post' }) : 0);\n}\nfunction watchSyncEffect(effect, options) {\n    return doWatch(effect, null, ( true) ? Object.assign(Object.assign({}, options), { flush: 'sync' }) : 0);\n}\n// initial value for watchers to trigger on undefined initial values\nconst INITIAL_WATCHER_VALUE = {};\n// implementation\nfunction watch(source, cb, options) {\n    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb)) {\n        warn(`\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\n            `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\n            `supports \\`watch(source, cb, options?) signature.`);\n    }\n    return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n    if (( true) && !cb) {\n        if (immediate !== undefined) {\n            warn(`watch() \"immediate\" option is only respected when using the ` +\n                `watch(source, callback, options?) signature.`);\n        }\n        if (deep !== undefined) {\n            warn(`watch() \"deep\" option is only respected when using the ` +\n                `watch(source, callback, options?) signature.`);\n        }\n    }\n    const warnInvalidSource = (s) => {\n        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +\n            `a reactive object, or an array of these types.`);\n    };\n    const instance = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;\n    // const instance = currentInstance\n    let getter;\n    let forceTrigger = false;\n    let isMultiSource = false;\n    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(source)) {\n        getter = () => source.value;\n        forceTrigger = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(source);\n    }\n    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(source)) {\n        getter = () => source;\n        deep = true;\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source)) {\n        isMultiSource = true;\n        forceTrigger = source.some(s => (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isShallow)(s));\n        getter = () => source.map(s => {\n            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(s)) {\n                return s.value;\n            }\n            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(s)) {\n                return traverse(s);\n            }\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) {\n                return callWithErrorHandling(s, instance, 2 /* ErrorCodes.WATCH_GETTER */);\n            }\n            else {\n                ( true) && warnInvalidSource(s);\n            }\n        });\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {\n        if (cb) {\n            // getter with cb\n            getter = () => callWithErrorHandling(source, instance, 2 /* ErrorCodes.WATCH_GETTER */);\n        }\n        else {\n            // no cb -> simple effect\n            getter = () => {\n                if (instance && instance.isUnmounted) {\n                    return;\n                }\n                if (cleanup) {\n                    cleanup();\n                }\n                return callWithAsyncErrorHandling(source, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [onCleanup]);\n            };\n        }\n    }\n    else {\n        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n        ( true) && warnInvalidSource(source);\n    }\n    if (cb && deep) {\n        const baseGetter = getter;\n        getter = () => traverse(baseGetter());\n    }\n    let cleanup;\n    let onCleanup = (fn) => {\n        cleanup = effect.onStop = () => {\n            callWithErrorHandling(fn, instance, 4 /* ErrorCodes.WATCH_CLEANUP */);\n        };\n    };\n    // in SSR there is no need to setup an actual effect, and it should be noop\n    // unless it's eager or sync flush\n    let ssrCleanup;\n    if (isInSSRComponentSetup) {\n        // we will also not call the invalidate callback (+ runner is not set up)\n        onCleanup = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n        if (!cb) {\n            getter();\n        }\n        else if (immediate) {\n            callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [\n                getter(),\n                isMultiSource ? [] : undefined,\n                onCleanup\n            ]);\n        }\n        if (flush === 'sync') {\n            const ctx = useSSRContext();\n            ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n        }\n        else {\n            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n        }\n    }\n    let oldValue = isMultiSource\n        ? new Array(source.length).fill(INITIAL_WATCHER_VALUE)\n        : INITIAL_WATCHER_VALUE;\n    const job = () => {\n        if (!effect.active) {\n            return;\n        }\n        if (cb) {\n            // watch(source, cb)\n            const newValue = effect.run();\n            if (deep ||\n                forceTrigger ||\n                (isMultiSource\n                    ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(v, oldValue[i]))\n                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(newValue, oldValue)) ||\n                (false  )) {\n                // cleanup before running cb again\n                if (cleanup) {\n                    cleanup();\n                }\n                callWithAsyncErrorHandling(cb, instance, 3 /* ErrorCodes.WATCH_CALLBACK */, [\n                    newValue,\n                    // pass undefined as the old value when it's changed for the first time\n                    oldValue === INITIAL_WATCHER_VALUE\n                        ? undefined\n                        : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE\n                            ? []\n                            : oldValue,\n                    onCleanup\n                ]);\n                oldValue = newValue;\n            }\n        }\n        else {\n            // watchEffect\n            effect.run();\n        }\n    };\n    // important: mark the job as a watcher callback so that scheduler knows\n    // it is allowed to self-trigger (#1727)\n    job.allowRecurse = !!cb;\n    let scheduler;\n    if (flush === 'sync') {\n        scheduler = job; // the scheduler function gets called directly\n    }\n    else if (flush === 'post') {\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n    }\n    else {\n        // default: 'pre'\n        job.pre = true;\n        if (instance)\n            job.id = instance.uid;\n        scheduler = () => queueJob(job);\n    }\n    const effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(getter, scheduler);\n    if ((true)) {\n        effect.onTrack = onTrack;\n        effect.onTrigger = onTrigger;\n    }\n    // initial run\n    if (cb) {\n        if (immediate) {\n            job();\n        }\n        else {\n            oldValue = effect.run();\n        }\n    }\n    else if (flush === 'post') {\n        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);\n    }\n    else {\n        effect.run();\n    }\n    const unwatch = () => {\n        effect.stop();\n        if (instance && instance.scope) {\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(instance.scope.effects, effect);\n        }\n    };\n    if (ssrCleanup)\n        ssrCleanup.push(unwatch);\n    return unwatch;\n}\n// this.$watch\nfunction instanceWatch(source, value, options) {\n    const publicThis = this.proxy;\n    const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)\n        ? source.includes('.')\n            ? createPathGetter(publicThis, source)\n            : () => publicThis[source]\n        : source.bind(publicThis, publicThis);\n    let cb;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\n        cb = value;\n    }\n    else {\n        cb = value.handler;\n        options = value;\n    }\n    const cur = currentInstance;\n    setCurrentInstance(this);\n    const res = doWatch(getter, cb.bind(publicThis), options);\n    if (cur) {\n        setCurrentInstance(cur);\n    }\n    else {\n        unsetCurrentInstance();\n    }\n    return res;\n}\nfunction createPathGetter(ctx, path) {\n    const segments = path.split('.');\n    return () => {\n        let cur = ctx;\n        for (let i = 0; i < segments.length && cur; i++) {\n            cur = cur[segments[i]];\n        }\n        return cur;\n    };\n}\nfunction traverse(value, seen) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) || value[\"__v_skip\" /* ReactiveFlags.SKIP */]) {\n        return value;\n    }\n    seen = seen || new Set();\n    if (seen.has(value)) {\n        return value;\n    }\n    seen.add(value);\n    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(value)) {\n        traverse(value.value, seen);\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n        for (let i = 0; i < value.length; i++) {\n            traverse(value[i], seen);\n        }\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isMap)(value)) {\n        value.forEach((v) => {\n            traverse(v, seen);\n        });\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(value)) {\n        for (const key in value) {\n            traverse(value[key], seen);\n        }\n    }\n    return value;\n}\n\nfunction useTransitionState() {\n    const state = {\n        isMounted: false,\n        isLeaving: false,\n        isUnmounting: false,\n        leavingVNodes: new Map()\n    };\n    onMounted(() => {\n        state.isMounted = true;\n    });\n    onBeforeUnmount(() => {\n        state.isUnmounting = true;\n    });\n    return state;\n}\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionImpl = {\n    name: `BaseTransition`,\n    props: {\n        mode: String,\n        appear: Boolean,\n        persisted: Boolean,\n        // enter\n        onBeforeEnter: TransitionHookValidator,\n        onEnter: TransitionHookValidator,\n        onAfterEnter: TransitionHookValidator,\n        onEnterCancelled: TransitionHookValidator,\n        // leave\n        onBeforeLeave: TransitionHookValidator,\n        onLeave: TransitionHookValidator,\n        onAfterLeave: TransitionHookValidator,\n        onLeaveCancelled: TransitionHookValidator,\n        // appear\n        onBeforeAppear: TransitionHookValidator,\n        onAppear: TransitionHookValidator,\n        onAfterAppear: TransitionHookValidator,\n        onAppearCancelled: TransitionHookValidator\n    },\n    setup(props, { slots }) {\n        const instance = getCurrentInstance();\n        const state = useTransitionState();\n        let prevTransitionKey;\n        return () => {\n            const children = slots.default && getTransitionRawChildren(slots.default(), true);\n            if (!children || !children.length) {\n                return;\n            }\n            let child = children[0];\n            if (children.length > 1) {\n                let hasFound = false;\n                // locate first non-comment child\n                for (const c of children) {\n                    if (c.type !== Comment) {\n                        if (( true) && hasFound) {\n                            // warn more than one non-comment child\n                            warn('<transition> can only be used on a single element or component. ' +\n                                'Use <transition-group> for lists.');\n                            break;\n                        }\n                        child = c;\n                        hasFound = true;\n                        if (false)\n                            {}\n                    }\n                }\n            }\n            // there's no need to track reactivity for these props so use the raw\n            // props for a bit better perf\n            const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n            const { mode } = rawProps;\n            // check mode\n            if (( true) &&\n                mode &&\n                mode !== 'in-out' &&\n                mode !== 'out-in' &&\n                mode !== 'default') {\n                warn(`invalid <transition> mode: ${mode}`);\n            }\n            if (state.isLeaving) {\n                return emptyPlaceholder(child);\n            }\n            // in the case of <transition><keep-alive/></transition>, we need to\n            // compare the type of the kept-alive children.\n            const innerChild = getKeepAliveChild(child);\n            if (!innerChild) {\n                return emptyPlaceholder(child);\n            }\n            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\n            setTransitionHooks(innerChild, enterHooks);\n            const oldChild = instance.subTree;\n            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n            let transitionKeyChanged = false;\n            const { getTransitionKey } = innerChild.type;\n            if (getTransitionKey) {\n                const key = getTransitionKey();\n                if (prevTransitionKey === undefined) {\n                    prevTransitionKey = key;\n                }\n                else if (key !== prevTransitionKey) {\n                    prevTransitionKey = key;\n                    transitionKeyChanged = true;\n                }\n            }\n            // handle mode\n            if (oldInnerChild &&\n                oldInnerChild.type !== Comment &&\n                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\n                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\n                // update old tree's hooks in case of dynamic transition\n                setTransitionHooks(oldInnerChild, leavingHooks);\n                // switching between different views\n                if (mode === 'out-in') {\n                    state.isLeaving = true;\n                    // return placeholder node and queue update when leave finishes\n                    leavingHooks.afterLeave = () => {\n                        state.isLeaving = false;\n                        // #6835\n                        // it also needs to be updated when active is undefined\n                        if (instance.update.active !== false) {\n                            instance.update();\n                        }\n                    };\n                    return emptyPlaceholder(child);\n                }\n                else if (mode === 'in-out' && innerChild.type !== Comment) {\n                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\n                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n                        // early removal callback\n                        el._leaveCb = () => {\n                            earlyRemove();\n                            el._leaveCb = undefined;\n                            delete enterHooks.delayedLeave;\n                        };\n                        enterHooks.delayedLeave = delayedLeave;\n                    };\n                }\n            }\n            return child;\n        };\n    }\n};\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\nconst BaseTransition = BaseTransitionImpl;\nfunction getLeavingNodesForType(state, vnode) {\n    const { leavingVNodes } = state;\n    let leavingVNodesCache = leavingVNodes.get(vnode.type);\n    if (!leavingVNodesCache) {\n        leavingVNodesCache = Object.create(null);\n        leavingVNodes.set(vnode.type, leavingVNodesCache);\n    }\n    return leavingVNodesCache;\n}\n// The transition hooks are attached to the vnode as vnode.transition\n// and will be called at appropriate timing in the renderer.\nfunction resolveTransitionHooks(vnode, props, state, instance) {\n    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\n    const key = String(vnode.key);\n    const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n    const callHook = (hook, args) => {\n        hook &&\n            callWithAsyncErrorHandling(hook, instance, 9 /* ErrorCodes.TRANSITION_HOOK */, args);\n    };\n    const callAsyncHook = (hook, args) => {\n        const done = args[1];\n        callHook(hook, args);\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\n            if (hook.every(hook => hook.length <= 1))\n                done();\n        }\n        else if (hook.length <= 1) {\n            done();\n        }\n    };\n    const hooks = {\n        mode,\n        persisted,\n        beforeEnter(el) {\n            let hook = onBeforeEnter;\n            if (!state.isMounted) {\n                if (appear) {\n                    hook = onBeforeAppear || onBeforeEnter;\n                }\n                else {\n                    return;\n                }\n            }\n            // for same element (v-show)\n            if (el._leaveCb) {\n                el._leaveCb(true /* cancelled */);\n            }\n            // for toggled element with same key (v-if)\n            const leavingVNode = leavingVNodesCache[key];\n            if (leavingVNode &&\n                isSameVNodeType(vnode, leavingVNode) &&\n                leavingVNode.el._leaveCb) {\n                // force early removal (not cancelled)\n                leavingVNode.el._leaveCb();\n            }\n            callHook(hook, [el]);\n        },\n        enter(el) {\n            let hook = onEnter;\n            let afterHook = onAfterEnter;\n            let cancelHook = onEnterCancelled;\n            if (!state.isMounted) {\n                if (appear) {\n                    hook = onAppear || onEnter;\n                    afterHook = onAfterAppear || onAfterEnter;\n                    cancelHook = onAppearCancelled || onEnterCancelled;\n                }\n                else {\n                    return;\n                }\n            }\n            let called = false;\n            const done = (el._enterCb = (cancelled) => {\n                if (called)\n                    return;\n                called = true;\n                if (cancelled) {\n                    callHook(cancelHook, [el]);\n                }\n                else {\n                    callHook(afterHook, [el]);\n                }\n                if (hooks.delayedLeave) {\n                    hooks.delayedLeave();\n                }\n                el._enterCb = undefined;\n            });\n            if (hook) {\n                callAsyncHook(hook, [el, done]);\n            }\n            else {\n                done();\n            }\n        },\n        leave(el, remove) {\n            const key = String(vnode.key);\n            if (el._enterCb) {\n                el._enterCb(true /* cancelled */);\n            }\n            if (state.isUnmounting) {\n                return remove();\n            }\n            callHook(onBeforeLeave, [el]);\n            let called = false;\n            const done = (el._leaveCb = (cancelled) => {\n                if (called)\n                    return;\n                called = true;\n                remove();\n                if (cancelled) {\n                    callHook(onLeaveCancelled, [el]);\n                }\n                else {\n                    callHook(onAfterLeave, [el]);\n                }\n                el._leaveCb = undefined;\n                if (leavingVNodesCache[key] === vnode) {\n                    delete leavingVNodesCache[key];\n                }\n            });\n            leavingVNodesCache[key] = vnode;\n            if (onLeave) {\n                callAsyncHook(onLeave, [el, done]);\n            }\n            else {\n                done();\n            }\n        },\n        clone(vnode) {\n            return resolveTransitionHooks(vnode, props, state, instance);\n        }\n    };\n    return hooks;\n}\n// the placeholder really only handles one special case: KeepAlive\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\n// placeholder with empty content to avoid the KeepAlive instance from being\n// unmounted.\nfunction emptyPlaceholder(vnode) {\n    if (isKeepAlive(vnode)) {\n        vnode = cloneVNode(vnode);\n        vnode.children = null;\n        return vnode;\n    }\n}\nfunction getKeepAliveChild(vnode) {\n    return isKeepAlive(vnode)\n        ? vnode.children\n            ? vnode.children[0]\n            : undefined\n        : vnode;\n}\nfunction setTransitionHooks(vnode, hooks) {\n    if (vnode.shapeFlag & 6 /* ShapeFlags.COMPONENT */ && vnode.component) {\n        setTransitionHooks(vnode.component.subTree, hooks);\n    }\n    else if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n        vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n    }\n    else {\n        vnode.transition = hooks;\n    }\n}\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\n    let ret = [];\n    let keyedFragmentCount = 0;\n    for (let i = 0; i < children.length; i++) {\n        let child = children[i];\n        // #5360 inherit parent key in case of <template v-for>\n        const key = parentKey == null\n            ? child.key\n            : String(parentKey) + String(child.key != null ? child.key : i);\n        // handle fragment children case, e.g. v-for\n        if (child.type === Fragment) {\n            if (child.patchFlag & 128 /* PatchFlags.KEYED_FRAGMENT */)\n                keyedFragmentCount++;\n            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));\n        }\n        // comment placeholders should be skipped, e.g. v-if\n        else if (keepComment || child.type !== Comment) {\n            ret.push(key != null ? cloneVNode(child, { key }) : child);\n        }\n    }\n    // #1126 if a transition children list contains multiple sub fragments, these\n    // fragments will be merged into a flat children array. Since each v-for\n    // fragment may contain different static bindings inside, we need to de-op\n    // these children to force full diffs to ensure correct behavior.\n    if (keyedFragmentCount > 1) {\n        for (let i = 0; i < ret.length; i++) {\n            ret[i].patchFlag = -2 /* PatchFlags.BAIL */;\n        }\n    }\n    return ret;\n}\n\n// implementation, close to no-op\nfunction defineComponent(options) {\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options) ? { setup: options, name: options.name } : options;\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\nfunction defineAsyncComponent(source) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(source)) {\n        source = { loader: source };\n    }\n    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\n    suspensible = true, onError: userOnError } = source;\n    let pendingRequest = null;\n    let resolvedComp;\n    let retries = 0;\n    const retry = () => {\n        retries++;\n        pendingRequest = null;\n        return load();\n    };\n    const load = () => {\n        let thisRequest;\n        return (pendingRequest ||\n            (thisRequest = pendingRequest =\n                loader()\n                    .catch(err => {\n                    err = err instanceof Error ? err : new Error(String(err));\n                    if (userOnError) {\n                        return new Promise((resolve, reject) => {\n                            const userRetry = () => resolve(retry());\n                            const userFail = () => reject(err);\n                            userOnError(err, userRetry, userFail, retries + 1);\n                        });\n                    }\n                    else {\n                        throw err;\n                    }\n                })\n                    .then((comp) => {\n                    if (thisRequest !== pendingRequest && pendingRequest) {\n                        return pendingRequest;\n                    }\n                    if (( true) && !comp) {\n                        warn(`Async component loader resolved to undefined. ` +\n                            `If you are using retry(), make sure to return its return value.`);\n                    }\n                    // interop module default\n                    if (comp &&\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\n                        comp = comp.default;\n                    }\n                    if (( true) && comp && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\n                        throw new Error(`Invalid async component load result: ${comp}`);\n                    }\n                    resolvedComp = comp;\n                    return comp;\n                })));\n    };\n    return defineComponent({\n        name: 'AsyncComponentWrapper',\n        __asyncLoader: load,\n        get __asyncResolved() {\n            return resolvedComp;\n        },\n        setup() {\n            const instance = currentInstance;\n            // already resolved\n            if (resolvedComp) {\n                return () => createInnerComp(resolvedComp, instance);\n            }\n            const onError = (err) => {\n                pendingRequest = null;\n                handleError(err, instance, 13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\n            };\n            // suspense-controlled or SSR.\n            if ((suspensible && instance.suspense) ||\n                (isInSSRComponentSetup)) {\n                return load()\n                    .then(comp => {\n                    return () => createInnerComp(comp, instance);\n                })\n                    .catch(err => {\n                    onError(err);\n                    return () => errorComponent\n                        ? createVNode(errorComponent, {\n                            error: err\n                        })\n                        : null;\n                });\n            }\n            const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(false);\n            const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)();\n            const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ref)(!!delay);\n            if (delay) {\n                setTimeout(() => {\n                    delayed.value = false;\n                }, delay);\n            }\n            if (timeout != null) {\n                setTimeout(() => {\n                    if (!loaded.value && !error.value) {\n                        const err = new Error(`Async component timed out after ${timeout}ms.`);\n                        onError(err);\n                        error.value = err;\n                    }\n                }, timeout);\n            }\n            load()\n                .then(() => {\n                loaded.value = true;\n                if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n                    // parent is keep-alive, force update so the loaded component's\n                    // name is taken into account\n                    queueJob(instance.parent.update);\n                }\n            })\n                .catch(err => {\n                onError(err);\n                error.value = err;\n            });\n            return () => {\n                if (loaded.value && resolvedComp) {\n                    return createInnerComp(resolvedComp, instance);\n                }\n                else if (error.value && errorComponent) {\n                    return createVNode(errorComponent, {\n                        error: error.value\n                    });\n                }\n                else if (loadingComponent && !delayed.value) {\n                    return createVNode(loadingComponent);\n                }\n            };\n        }\n    });\n}\nfunction createInnerComp(comp, parent) {\n    const { ref, props, children, ce } = parent.vnode;\n    const vnode = createVNode(comp, props, children);\n    // ensure inner component inherits the async wrapper's ref owner\n    vnode.ref = ref;\n    // pass the custom element callback on to the inner comp\n    // and remove it from the async wrapper\n    vnode.ce = ce;\n    delete parent.vnode.ce;\n    return vnode;\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n    name: `KeepAlive`,\n    // Marker for special handling inside the renderer. We are not using a ===\n    // check directly on KeepAlive in the renderer, because importing it directly\n    // would prevent it from being tree-shaken.\n    __isKeepAlive: true,\n    props: {\n        include: [String, RegExp, Array],\n        exclude: [String, RegExp, Array],\n        max: [String, Number]\n    },\n    setup(props, { slots }) {\n        const instance = getCurrentInstance();\n        // KeepAlive communicates with the instantiated renderer via the\n        // ctx where the renderer passes in its internals,\n        // and the KeepAlive instance exposes activate/deactivate implementations.\n        // The whole point of this is to avoid importing KeepAlive directly in the\n        // renderer to facilitate tree-shaking.\n        const sharedContext = instance.ctx;\n        // if the internal renderer is not registered, it indicates that this is server-side rendering,\n        // for KeepAlive, we just need to render its children\n        if (!sharedContext.renderer) {\n            return () => {\n                const children = slots.default && slots.default();\n                return children && children.length === 1 ? children[0] : children;\n            };\n        }\n        const cache = new Map();\n        const keys = new Set();\n        let current = null;\n        if (true) {\n            instance.__v_cache = cache;\n        }\n        const parentSuspense = instance.suspense;\n        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\n        const storageContainer = createElement('div');\n        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n            const instance = vnode.component;\n            move(vnode, container, anchor, 0 /* MoveType.ENTER */, parentSuspense);\n            // in case props have changed\n            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);\n            queuePostRenderEffect(() => {\n                instance.isDeactivated = false;\n                if (instance.a) {\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.a);\n                }\n                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n                if (vnodeHook) {\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\n                }\n            }, parentSuspense);\n            if (true) {\n                // Update components tree\n                devtoolsComponentAdded(instance);\n            }\n        };\n        sharedContext.deactivate = (vnode) => {\n            const instance = vnode.component;\n            move(vnode, storageContainer, null, 1 /* MoveType.LEAVE */, parentSuspense);\n            queuePostRenderEffect(() => {\n                if (instance.da) {\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.da);\n                }\n                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n                if (vnodeHook) {\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\n                }\n                instance.isDeactivated = true;\n            }, parentSuspense);\n            if (true) {\n                // Update components tree\n                devtoolsComponentAdded(instance);\n            }\n        };\n        function unmount(vnode) {\n            // reset the shapeFlag so it can be properly unmounted\n            resetShapeFlag(vnode);\n            _unmount(vnode, instance, parentSuspense, true);\n        }\n        function pruneCache(filter) {\n            cache.forEach((vnode, key) => {\n                const name = getComponentName(vnode.type);\n                if (name && (!filter || !filter(name))) {\n                    pruneCacheEntry(key);\n                }\n            });\n        }\n        function pruneCacheEntry(key) {\n            const cached = cache.get(key);\n            if (!current || !isSameVNodeType(cached, current)) {\n                unmount(cached);\n            }\n            else if (current) {\n                // current active instance should no longer be kept-alive.\n                // we can't unmount it now but it might be later, so reset its flag now.\n                resetShapeFlag(current);\n            }\n            cache.delete(key);\n            keys.delete(key);\n        }\n        // prune cache on include/exclude prop change\n        watch(() => [props.include, props.exclude], ([include, exclude]) => {\n            include && pruneCache(name => matches(include, name));\n            exclude && pruneCache(name => !matches(exclude, name));\n        }, \n        // prune post-render after `current` has been updated\n        { flush: 'post', deep: true });\n        // cache sub tree after render\n        let pendingCacheKey = null;\n        const cacheSubtree = () => {\n            // fix #1621, the pendingCacheKey could be 0\n            if (pendingCacheKey != null) {\n                cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n            }\n        };\n        onMounted(cacheSubtree);\n        onUpdated(cacheSubtree);\n        onBeforeUnmount(() => {\n            cache.forEach(cached => {\n                const { subTree, suspense } = instance;\n                const vnode = getInnerChild(subTree);\n                if (cached.type === vnode.type && cached.key === vnode.key) {\n                    // current instance will be unmounted as part of keep-alive's unmount\n                    resetShapeFlag(vnode);\n                    // but invoke its deactivated hook here\n                    const da = vnode.component.da;\n                    da && queuePostRenderEffect(da, suspense);\n                    return;\n                }\n                unmount(cached);\n            });\n        });\n        return () => {\n            pendingCacheKey = null;\n            if (!slots.default) {\n                return null;\n            }\n            const children = slots.default();\n            const rawVNode = children[0];\n            if (children.length > 1) {\n                if ((true)) {\n                    warn(`KeepAlive should contain exactly one component child.`);\n                }\n                current = null;\n                return children;\n            }\n            else if (!isVNode(rawVNode) ||\n                (!(rawVNode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */) &&\n                    !(rawVNode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */))) {\n                current = null;\n                return rawVNode;\n            }\n            let vnode = getInnerChild(rawVNode);\n            const comp = vnode.type;\n            // for async components, name check should be based in its loaded\n            // inner component if available\n            const name = getComponentName(isAsyncWrapper(vnode)\n                ? vnode.type.__asyncResolved || {}\n                : comp);\n            const { include, exclude, max } = props;\n            if ((include && (!name || !matches(include, name))) ||\n                (exclude && name && matches(exclude, name))) {\n                current = vnode;\n                return rawVNode;\n            }\n            const key = vnode.key == null ? comp : vnode.key;\n            const cachedVNode = cache.get(key);\n            // clone vnode if it's reused because we are going to mutate it\n            if (vnode.el) {\n                vnode = cloneVNode(vnode);\n                if (rawVNode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n                    rawVNode.ssContent = vnode;\n                }\n            }\n            // #1513 it's possible for the returned vnode to be cloned due to attr\n            // fallthrough or scopeId, so the vnode here may not be the final vnode\n            // that is mounted. Instead of caching it directly, we store the pending\n            // key and cache `instance.subTree` (the normalized vnode) in\n            // beforeMount/beforeUpdate hooks.\n            pendingCacheKey = key;\n            if (cachedVNode) {\n                // copy over mounted state\n                vnode.el = cachedVNode.el;\n                vnode.component = cachedVNode.component;\n                if (vnode.transition) {\n                    // recursively update transition hooks on subTree\n                    setTransitionHooks(vnode, vnode.transition);\n                }\n                // avoid vnode being mounted as fresh\n                vnode.shapeFlag |= 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;\n                // make this key the freshest\n                keys.delete(key);\n                keys.add(key);\n            }\n            else {\n                keys.add(key);\n                // prune oldest entry\n                if (max && keys.size > parseInt(max, 10)) {\n                    pruneCacheEntry(keys.values().next().value);\n                }\n            }\n            // avoid vnode being unmounted\n            vnode.shapeFlag |= 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;\n            current = vnode;\n            return isSuspense(rawVNode.type) ? rawVNode : vnode;\n        };\n    }\n};\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\nconst KeepAlive = KeepAliveImpl;\nfunction matches(pattern, name) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(pattern)) {\n        return pattern.some((p) => matches(p, name));\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(pattern)) {\n        return pattern.split(',').includes(name);\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(pattern)) {\n        return pattern.test(name);\n    }\n    /* istanbul ignore next */\n    return false;\n}\nfunction onActivated(hook, target) {\n    registerKeepAliveHook(hook, \"a\" /* LifecycleHooks.ACTIVATED */, target);\n}\nfunction onDeactivated(hook, target) {\n    registerKeepAliveHook(hook, \"da\" /* LifecycleHooks.DEACTIVATED */, target);\n}\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n    // cache the deactivate branch check wrapper for injected hooks so the same\n    // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\n    // deactivation check\".\n    const wrappedHook = hook.__wdc ||\n        (hook.__wdc = () => {\n            // only fire the hook if the target instance is NOT in a deactivated branch.\n            let current = target;\n            while (current) {\n                if (current.isDeactivated) {\n                    return;\n                }\n                current = current.parent;\n            }\n            return hook();\n        });\n    injectHook(type, wrappedHook, target);\n    // In addition to registering it on the target instance, we walk up the parent\n    // chain and register it on all ancestor instances that are keep-alive roots.\n    // This avoids the need to walk the entire component tree when invoking these\n    // hooks, and more importantly, avoids the need to track child components in\n    // arrays.\n    if (target) {\n        let current = target.parent;\n        while (current && current.parent) {\n            if (isKeepAlive(current.parent.vnode)) {\n                injectToKeepAliveRoot(wrappedHook, type, target, current);\n            }\n            current = current.parent;\n        }\n    }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n    // injectHook wraps the original for error handling, so make sure to remove\n    // the wrapped version.\n    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\n    onUnmounted(() => {\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(keepAliveRoot[type], injected);\n    }, target);\n}\nfunction resetShapeFlag(vnode) {\n    // bitwise operations to remove keep alive flags\n    vnode.shapeFlag &= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;\n    vnode.shapeFlag &= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;\n}\nfunction getInnerChild(vnode) {\n    return vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */ ? vnode.ssContent : vnode;\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n    if (target) {\n        const hooks = target[type] || (target[type] = []);\n        // cache the error handling wrapper for injected hooks so the same hook\n        // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\n        // handling\".\n        const wrappedHook = hook.__weh ||\n            (hook.__weh = (...args) => {\n                if (target.isUnmounted) {\n                    return;\n                }\n                // disable tracking inside all lifecycle hooks\n                // since they can potentially be called inside effects.\n                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n                // Set currentInstance during hook invocation.\n                // This assumes the hook does not synchronously trigger other hooks, which\n                // can only be false when the user does something really funky.\n                setCurrentInstance(target);\n                const res = callWithAsyncErrorHandling(hook, target, type, args);\n                unsetCurrentInstance();\n                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n                return res;\n            });\n        if (prepend) {\n            hooks.unshift(wrappedHook);\n        }\n        else {\n            hooks.push(wrappedHook);\n        }\n        return wrappedHook;\n    }\n    else if ((true)) {\n        const apiName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(ErrorTypeStrings[type].replace(/ hook$/, ''));\n        warn(`${apiName} is called when there is no active component instance to be ` +\n            `associated with. ` +\n            `Lifecycle injection APIs can only be used during execution of setup().` +\n            (` If you are using async setup(), make sure to register lifecycle ` +\n                    `hooks before the first await statement.`\n                ));\n    }\n}\nconst createHook = (lifecycle) => (hook, target = currentInstance) => \n// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n(!isInSSRComponentSetup || lifecycle === \"sp\" /* LifecycleHooks.SERVER_PREFETCH */) &&\n    injectHook(lifecycle, (...args) => hook(...args), target);\nconst onBeforeMount = createHook(\"bm\" /* LifecycleHooks.BEFORE_MOUNT */);\nconst onMounted = createHook(\"m\" /* LifecycleHooks.MOUNTED */);\nconst onBeforeUpdate = createHook(\"bu\" /* LifecycleHooks.BEFORE_UPDATE */);\nconst onUpdated = createHook(\"u\" /* LifecycleHooks.UPDATED */);\nconst onBeforeUnmount = createHook(\"bum\" /* LifecycleHooks.BEFORE_UNMOUNT */);\nconst onUnmounted = createHook(\"um\" /* LifecycleHooks.UNMOUNTED */);\nconst onServerPrefetch = createHook(\"sp\" /* LifecycleHooks.SERVER_PREFETCH */);\nconst onRenderTriggered = createHook(\"rtg\" /* LifecycleHooks.RENDER_TRIGGERED */);\nconst onRenderTracked = createHook(\"rtc\" /* LifecycleHooks.RENDER_TRACKED */);\nfunction onErrorCaptured(hook, target = currentInstance) {\n    injectHook(\"ec\" /* LifecycleHooks.ERROR_CAPTURED */, hook, target);\n}\n\n/**\nRuntime helper for applying directives to a vnode. Example usage:\n\nconst comp = resolveComponent('comp')\nconst foo = resolveDirective('foo')\nconst bar = resolveDirective('bar')\n\nreturn withDirectives(h(comp), [\n  [foo, this.x],\n  [bar, this.y]\n])\n*/\nfunction validateDirectiveName(name) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isBuiltInDirective)(name)) {\n        warn('Do not use built-in directive ids as custom directive id: ' + name);\n    }\n}\n/**\n * Adds directives to a VNode.\n */\nfunction withDirectives(vnode, directives) {\n    const internalInstance = currentRenderingInstance;\n    if (internalInstance === null) {\n        ( true) && warn(`withDirectives can only be used inside render functions.`);\n        return vnode;\n    }\n    const instance = getExposeProxy(internalInstance) ||\n        internalInstance.proxy;\n    const bindings = vnode.dirs || (vnode.dirs = []);\n    for (let i = 0; i < directives.length; i++) {\n        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ] = directives[i];\n        if (dir) {\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dir)) {\n                dir = {\n                    mounted: dir,\n                    updated: dir\n                };\n            }\n            if (dir.deep) {\n                traverse(value);\n            }\n            bindings.push({\n                dir,\n                instance,\n                value,\n                oldValue: void 0,\n                arg,\n                modifiers\n            });\n        }\n    }\n    return vnode;\n}\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n    const bindings = vnode.dirs;\n    const oldBindings = prevVNode && prevVNode.dirs;\n    for (let i = 0; i < bindings.length; i++) {\n        const binding = bindings[i];\n        if (oldBindings) {\n            binding.oldValue = oldBindings[i].value;\n        }\n        let hook = binding.dir[name];\n        if (hook) {\n            // disable tracking inside all lifecycle hooks\n            // since they can potentially be called inside effects.\n            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n            callWithAsyncErrorHandling(hook, instance, 8 /* ErrorCodes.DIRECTIVE_HOOK */, [\n                vnode.el,\n                binding,\n                vnode,\n                prevVNode\n            ]);\n            (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n        }\n    }\n}\n\nconst COMPONENTS = 'components';\nconst DIRECTIVES = 'directives';\n/**\n * @private\n */\nfunction resolveComponent(name, maybeSelfReference) {\n    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nconst NULL_DYNAMIC_COMPONENT = Symbol();\n/**\n * @private\n */\nfunction resolveDynamicComponent(component) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(component)) {\n        return resolveAsset(COMPONENTS, component, false) || component;\n    }\n    else {\n        // invalid types will fallthrough to createVNode and raise warning\n        return (component || NULL_DYNAMIC_COMPONENT);\n    }\n}\n/**\n * @private\n */\nfunction resolveDirective(name) {\n    return resolveAsset(DIRECTIVES, name);\n}\n// implementation\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\n    const instance = currentRenderingInstance || currentInstance;\n    if (instance) {\n        const Component = instance.type;\n        // explicit self name has highest priority\n        if (type === COMPONENTS) {\n            const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);\n            if (selfName &&\n                (selfName === name ||\n                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name) ||\n                    selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)))) {\n                return Component;\n            }\n        }\n        const res = \n        // local registration\n        // check instance[type] first which is resolved for options API\n        resolve(instance[type] || Component[type], name) ||\n            // global registration\n            resolve(instance.appContext[type], name);\n        if (!res && maybeSelfReference) {\n            // fallback to implicit self-reference\n            return Component;\n        }\n        if (( true) && warnMissing && !res) {\n            const extra = type === COMPONENTS\n                ? `\\nIf this is a native custom element, make sure to exclude it from ` +\n                    `component resolution via compilerOptions.isCustomElement.`\n                : ``;\n            warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);\n        }\n        return res;\n    }\n    else if ((true)) {\n        warn(`resolve${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(type.slice(0, -1))} ` +\n            `can only be used in render() or setup().`);\n    }\n}\nfunction resolve(registry, name) {\n    return (registry &&\n        (registry[name] ||\n            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name)] ||\n            registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(name))]));\n}\n\n/**\n * Actual implementation\n */\nfunction renderList(source, renderItem, cache, index) {\n    let ret;\n    const cached = (cache && cache[index]);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(source) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(source)) {\n        ret = new Array(source.length);\n        for (let i = 0, l = source.length; i < l; i++) {\n            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);\n        }\n    }\n    else if (typeof source === 'number') {\n        if (( true) && !Number.isInteger(source)) {\n            warn(`The v-for range expect an integer value but got ${source}.`);\n        }\n        ret = new Array(source);\n        for (let i = 0; i < source; i++) {\n            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);\n        }\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(source)) {\n        if (source[Symbol.iterator]) {\n            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));\n        }\n        else {\n            const keys = Object.keys(source);\n            ret = new Array(keys.length);\n            for (let i = 0, l = keys.length; i < l; i++) {\n                const key = keys[i];\n                ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n            }\n        }\n    }\n    else {\n        ret = [];\n    }\n    if (cache) {\n        cache[index] = ret;\n    }\n    return ret;\n}\n\n/**\n * Compiler runtime helper for creating dynamic slots object\n * @private\n */\nfunction createSlots(slots, dynamicSlots) {\n    for (let i = 0; i < dynamicSlots.length; i++) {\n        const slot = dynamicSlots[i];\n        // array of dynamic slot generated by <template v-for=\"...\" #[...]>\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(slot)) {\n            for (let j = 0; j < slot.length; j++) {\n                slots[slot[j].name] = slot[j].fn;\n            }\n        }\n        else if (slot) {\n            // conditional single slot generated by <template v-if=\"...\" #foo>\n            slots[slot.name] = slot.key\n                ? (...args) => {\n                    const res = slot.fn(...args);\n                    // attach branch key so each conditional branch is considered a\n                    // different fragment\n                    if (res)\n                        res.key = slot.key;\n                    return res;\n                }\n                : slot.fn;\n        }\n    }\n    return slots;\n}\n\n/**\n * Compiler runtime helper for rendering `<slot/>`\n * @private\n */\nfunction renderSlot(slots, name, props = {}, \n// this is not a user-facing function, so the fallback is always generated by\n// the compiler and guaranteed to be a function returning an array\nfallback, noSlotted) {\n    if (currentRenderingInstance.isCE ||\n        (currentRenderingInstance.parent &&\n            isAsyncWrapper(currentRenderingInstance.parent) &&\n            currentRenderingInstance.parent.isCE)) {\n        if (name !== 'default')\n            props.name = name;\n        return createVNode('slot', props, fallback && fallback());\n    }\n    let slot = slots[name];\n    if (( true) && slot && slot.length > 1) {\n        warn(`SSR-optimized slot function detected in a non-SSR-optimized render ` +\n            `function. You need to mark this component with $dynamic-slots in the ` +\n            `parent template.`);\n        slot = () => [];\n    }\n    // a compiled slot disables block tracking by default to avoid manual\n    // invocation interfering with template-based block tracking, but in\n    // `renderSlot` we can be sure that it's template-based so we can force\n    // enable it.\n    if (slot && slot._c) {\n        slot._d = false;\n    }\n    openBlock();\n    const validSlotContent = slot && ensureValidVNode(slot(props));\n    const rendered = createBlock(Fragment, {\n        key: props.key ||\n            // slot content array of a dynamic conditional slot may have a branch\n            // key attached in the `createSlots` helper, respect that\n            (validSlotContent && validSlotContent.key) ||\n            `_${name}`\n    }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* SlotFlags.STABLE */\n        ? 64 /* PatchFlags.STABLE_FRAGMENT */\n        : -2 /* PatchFlags.BAIL */);\n    if (!noSlotted && rendered.scopeId) {\n        rendered.slotScopeIds = [rendered.scopeId + '-s'];\n    }\n    if (slot && slot._c) {\n        slot._d = true;\n    }\n    return rendered;\n}\nfunction ensureValidVNode(vnodes) {\n    return vnodes.some(child => {\n        if (!isVNode(child))\n            return true;\n        if (child.type === Comment)\n            return false;\n        if (child.type === Fragment &&\n            !ensureValidVNode(child.children))\n            return false;\n        return true;\n    })\n        ? vnodes\n        : null;\n}\n\n/**\n * For prefixing keys in v-on=\"obj\" with \"on\"\n * @private\n */\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n    const ret = {};\n    if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {\n        warn(`v-on with no argument expects an object value.`);\n        return ret;\n    }\n    for (const key in obj) {\n        ret[preserveCaseIfNecessary && /[A-Z]/.test(key)\n            ? `on:${key}`\n            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toHandlerKey)(key)] = obj[key];\n    }\n    return ret;\n}\n\n/**\n * #2437 In Vue 3, functional components do not have a public instance proxy but\n * they exist in the internal parent chain. For code that relies on traversing\n * public $parent chains, skip functional ones and go to the parent instead.\n */\nconst getPublicInstance = (i) => {\n    if (!i)\n        return null;\n    if (isStatefulComponent(i))\n        return getExposeProxy(i) || i.proxy;\n    return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap = \n// Move PURE marker to new line to workaround compiler discarding it\n// due to type annotation\n/*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), {\n    $: i => i,\n    $el: i => i.vnode.el,\n    $data: i => i.data,\n    $props: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.props) : 0),\n    $attrs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.attrs) : 0),\n    $slots: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.slots) : 0),\n    $refs: i => (( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(i.refs) : 0),\n    $parent: i => getPublicInstance(i.parent),\n    $root: i => getPublicInstance(i.root),\n    $emit: i => i.emit,\n    $options: i => ( true ? resolveMergedOptions(i) : 0),\n    $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),\n    $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),\n    $watch: i => ( true ? instanceWatch.bind(i) : 0)\n});\nconst isReservedPrefix = (key) => key === '_' || key === '$';\nconst hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(state, key);\nconst PublicInstanceProxyHandlers = {\n    get({ _: instance }, key) {\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\n        // for internal formatters to know that this is a Vue instance\n        if (( true) && key === '__isVue') {\n            return true;\n        }\n        // data / props / ctx\n        // This getter gets called for every property access on the render context\n        // during render and is a major hotspot. The most expensive part of this\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\n        // access on a plain object, so we use an accessCache object (with null\n        // prototype) to memoize what access type a key corresponds to.\n        let normalizedProps;\n        if (key[0] !== '$') {\n            const n = accessCache[key];\n            if (n !== undefined) {\n                switch (n) {\n                    case 1 /* AccessTypes.SETUP */:\n                        return setupState[key];\n                    case 2 /* AccessTypes.DATA */:\n                        return data[key];\n                    case 4 /* AccessTypes.CONTEXT */:\n                        return ctx[key];\n                    case 3 /* AccessTypes.PROPS */:\n                        return props[key];\n                    // default: just fallthrough\n                }\n            }\n            else if (hasSetupBinding(setupState, key)) {\n                accessCache[key] = 1 /* AccessTypes.SETUP */;\n                return setupState[key];\n            }\n            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\n                accessCache[key] = 2 /* AccessTypes.DATA */;\n                return data[key];\n            }\n            else if (\n            // only cache other properties when instance has declared (thus stable)\n            // props\n            (normalizedProps = instance.propsOptions[0]) &&\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) {\n                accessCache[key] = 3 /* AccessTypes.PROPS */;\n                return props[key];\n            }\n            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {\n                accessCache[key] = 4 /* AccessTypes.CONTEXT */;\n                return ctx[key];\n            }\n            else if ( false || shouldCacheAccess) {\n                accessCache[key] = 0 /* AccessTypes.OTHER */;\n            }\n        }\n        const publicGetter = publicPropertiesMap[key];\n        let cssModule, globalProperties;\n        // public $xxx properties\n        if (publicGetter) {\n            if (key === '$attrs') {\n                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, \"get\" /* TrackOpTypes.GET */, key);\n                ( true) && markAttrsAccessed();\n            }\n            return publicGetter(instance);\n        }\n        else if (\n        // css module (injected by vue-loader)\n        (cssModule = type.__cssModules) &&\n            (cssModule = cssModule[key])) {\n            return cssModule;\n        }\n        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key)) {\n            // user may set custom properties to `this` that start with `$`\n            accessCache[key] = 4 /* AccessTypes.CONTEXT */;\n            return ctx[key];\n        }\n        else if (\n        // global properties\n        ((globalProperties = appContext.config.globalProperties),\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(globalProperties, key))) {\n            {\n                return globalProperties[key];\n            }\n        }\n        else if (( true) &&\n            currentRenderingInstance &&\n            (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) ||\n                // #1091 avoid internal isRef/isVNode checks on component instance leading\n                // to infinite warning loop\n                key.indexOf('__v') !== 0)) {\n            if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && isReservedPrefix(key[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\n                warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +\n                    `character (\"$\" or \"_\") and is not proxied on the render context.`);\n            }\n            else if (instance === currentRenderingInstance) {\n                warn(`Property ${JSON.stringify(key)} was accessed during render ` +\n                    `but is not defined on instance.`);\n            }\n        }\n    },\n    set({ _: instance }, key, value) {\n        const { data, setupState, ctx } = instance;\n        if (hasSetupBinding(setupState, key)) {\n            setupState[key] = value;\n            return true;\n        }\n        else if (( true) &&\n            setupState.__isScriptSetup &&\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, key)) {\n            warn(`Cannot mutate <script setup> binding \"${key}\" from Options API.`);\n            return false;\n        }\n        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) {\n            data[key] = value;\n            return true;\n        }\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(instance.props, key)) {\n            ( true) && warn(`Attempting to mutate prop \"${key}\". Props are readonly.`);\n            return false;\n        }\n        if (key[0] === '$' && key.slice(1) in instance) {\n            ( true) &&\n                warn(`Attempting to mutate public property \"${key}\". ` +\n                    `Properties starting with $ are reserved and readonly.`);\n            return false;\n        }\n        else {\n            if (( true) && key in instance.appContext.config.globalProperties) {\n                Object.defineProperty(ctx, key, {\n                    enumerable: true,\n                    configurable: true,\n                    value\n                });\n            }\n            else {\n                ctx[key] = value;\n            }\n        }\n        return true;\n    },\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\n        let normalizedProps;\n        return (!!accessCache[key] ||\n            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(data, key)) ||\n            hasSetupBinding(setupState, key) ||\n            ((normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(normalizedProps, key)) ||\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ctx, key) ||\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(publicPropertiesMap, key) ||\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(appContext.config.globalProperties, key));\n    },\n    defineProperty(target, key, descriptor) {\n        if (descriptor.get != null) {\n            // invalidate key cache of a getter based property #5417\n            target._.accessCache[key] = 0;\n        }\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(descriptor, 'value')) {\n            this.set(target, key, descriptor.value, null);\n        }\n        return Reflect.defineProperty(target, key, descriptor);\n    }\n};\nif (true) {\n    PublicInstanceProxyHandlers.ownKeys = (target) => {\n        warn(`Avoid app logic that relies on enumerating keys on a component instance. ` +\n            `The keys will be empty in production mode to avoid performance overhead.`);\n        return Reflect.ownKeys(target);\n    };\n}\nconst RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, PublicInstanceProxyHandlers, {\n    get(target, key) {\n        // fast path for unscopables when using `with` block\n        if (key === Symbol.unscopables) {\n            return;\n        }\n        return PublicInstanceProxyHandlers.get(target, key, target);\n    },\n    has(_, key) {\n        const has = key[0] !== '_' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isGloballyWhitelisted)(key);\n        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {\n            warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);\n        }\n        return has;\n    }\n});\n// dev only\n// In dev mode, the proxy target exposes the same properties as seen on `this`\n// for easier console inspection. In prod mode it will be an empty object so\n// these properties definitions can be skipped.\nfunction createDevRenderContext(instance) {\n    const target = {};\n    // expose internal instance for proxy handlers\n    Object.defineProperty(target, `_`, {\n        configurable: true,\n        enumerable: false,\n        get: () => instance\n    });\n    // expose public properties\n    Object.keys(publicPropertiesMap).forEach(key => {\n        Object.defineProperty(target, key, {\n            configurable: true,\n            enumerable: false,\n            get: () => publicPropertiesMap[key](instance),\n            // intercepted by the proxy so no need for implementation,\n            // but needed to prevent set errors\n            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n        });\n    });\n    return target;\n}\n// dev only\nfunction exposePropsOnRenderContext(instance) {\n    const { ctx, propsOptions: [propsOptions] } = instance;\n    if (propsOptions) {\n        Object.keys(propsOptions).forEach(key => {\n            Object.defineProperty(ctx, key, {\n                enumerable: true,\n                configurable: true,\n                get: () => instance.props[key],\n                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n            });\n        });\n    }\n}\n// dev only\nfunction exposeSetupStateOnRenderContext(instance) {\n    const { ctx, setupState } = instance;\n    Object.keys((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(setupState)).forEach(key => {\n        if (!setupState.__isScriptSetup) {\n            if (isReservedPrefix(key[0])) {\n                warn(`setup() return property ${JSON.stringify(key)} should not start with \"$\" or \"_\" ` +\n                    `which are reserved prefixes for Vue internals.`);\n                return;\n            }\n            Object.defineProperty(ctx, key, {\n                enumerable: true,\n                configurable: true,\n                get: () => setupState[key],\n                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n            });\n        }\n    });\n}\n\nfunction createDuplicateChecker() {\n    const cache = Object.create(null);\n    return (type, key) => {\n        if (cache[key]) {\n            warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\n        }\n        else {\n            cache[key] = type;\n        }\n    };\n}\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n    const options = resolveMergedOptions(instance);\n    const publicThis = instance.proxy;\n    const ctx = instance.ctx;\n    // do not cache property access on public proxy during state initialization\n    shouldCacheAccess = false;\n    // call beforeCreate first before accessing other options since\n    // the hook may mutate resolved options (#2791)\n    if (options.beforeCreate) {\n        callHook(options.beforeCreate, instance, \"bc\" /* LifecycleHooks.BEFORE_CREATE */);\n    }\n    const { \n    // state\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \n    // lifecycle\n    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, \n    // public API\n    expose, inheritAttrs, \n    // assets\n    components, directives, filters } = options;\n    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;\n    if ((true)) {\n        const [propsOptions] = instance.propsOptions;\n        if (propsOptions) {\n            for (const key in propsOptions) {\n                checkDuplicateProperties(\"Props\" /* OptionTypes.PROPS */, key);\n            }\n        }\n    }\n    // options initialization order (to be consistent with Vue 2):\n    // - props (already done outside of this function)\n    // - inject\n    // - methods\n    // - data (deferred since it relies on `this` access)\n    // - computed\n    // - watch (deferred since it relies on `this` access)\n    if (injectOptions) {\n        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);\n    }\n    if (methods) {\n        for (const key in methods) {\n            const methodHandler = methods[key];\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(methodHandler)) {\n                // In dev mode, we use the `createRenderContext` function to define\n                // methods to the proxy target, and those are read-only but\n                // reconfigurable, so it needs to be redefined here\n                if ((true)) {\n                    Object.defineProperty(ctx, key, {\n                        value: methodHandler.bind(publicThis),\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    });\n                }\n                else {}\n                if ((true)) {\n                    checkDuplicateProperties(\"Methods\" /* OptionTypes.METHODS */, key);\n                }\n            }\n            else if ((true)) {\n                warn(`Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` +\n                    `Did you reference the function correctly?`);\n            }\n        }\n    }\n    if (dataOptions) {\n        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(dataOptions)) {\n            warn(`The data option must be a function. ` +\n                `Plain object usage is no longer supported.`);\n        }\n        const data = dataOptions.call(publicThis, publicThis);\n        if (( true) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(data)) {\n            warn(`data() returned a Promise - note data() cannot be async; If you ` +\n                `intend to perform data fetching before component renders, use ` +\n                `async setup() + <Suspense>.`);\n        }\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(data)) {\n            ( true) && warn(`data() should return an object.`);\n        }\n        else {\n            instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.reactive)(data);\n            if ((true)) {\n                for (const key in data) {\n                    checkDuplicateProperties(\"Data\" /* OptionTypes.DATA */, key);\n                    // expose data on ctx during dev\n                    if (!isReservedPrefix(key[0])) {\n                        Object.defineProperty(ctx, key, {\n                            configurable: true,\n                            enumerable: true,\n                            get: () => data[key],\n                            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP\n                        });\n                    }\n                }\n            }\n        }\n    }\n    // state initialization complete at this point - start caching access\n    shouldCacheAccess = true;\n    if (computedOptions) {\n        for (const key in computedOptions) {\n            const opt = computedOptions[key];\n            const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)\n                ? opt.bind(publicThis, publicThis)\n                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.get)\n                    ? opt.get.bind(publicThis, publicThis)\n                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP;\n            if (( true) && get === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {\n                warn(`Computed property \"${key}\" has no getter.`);\n            }\n            const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt.set)\n                ? opt.set.bind(publicThis)\n                : ( true)\n                    ? () => {\n                        warn(`Write operation failed: computed property \"${key}\" is readonly.`);\n                    }\n                    : 0;\n            const c = computed({\n                get,\n                set\n            });\n            Object.defineProperty(ctx, key, {\n                enumerable: true,\n                configurable: true,\n                get: () => c.value,\n                set: v => (c.value = v)\n            });\n            if ((true)) {\n                checkDuplicateProperties(\"Computed\" /* OptionTypes.COMPUTED */, key);\n            }\n        }\n    }\n    if (watchOptions) {\n        for (const key in watchOptions) {\n            createWatcher(watchOptions[key], ctx, publicThis, key);\n        }\n    }\n    if (provideOptions) {\n        const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(provideOptions)\n            ? provideOptions.call(publicThis)\n            : provideOptions;\n        Reflect.ownKeys(provides).forEach(key => {\n            provide(key, provides[key]);\n        });\n    }\n    if (created) {\n        callHook(created, instance, \"c\" /* LifecycleHooks.CREATED */);\n    }\n    function registerLifecycleHook(register, hook) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\n            hook.forEach(_hook => register(_hook.bind(publicThis)));\n        }\n        else if (hook) {\n            register(hook.bind(publicThis));\n        }\n    }\n    registerLifecycleHook(onBeforeMount, beforeMount);\n    registerLifecycleHook(onMounted, mounted);\n    registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n    registerLifecycleHook(onUpdated, updated);\n    registerLifecycleHook(onActivated, activated);\n    registerLifecycleHook(onDeactivated, deactivated);\n    registerLifecycleHook(onErrorCaptured, errorCaptured);\n    registerLifecycleHook(onRenderTracked, renderTracked);\n    registerLifecycleHook(onRenderTriggered, renderTriggered);\n    registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n    registerLifecycleHook(onUnmounted, unmounted);\n    registerLifecycleHook(onServerPrefetch, serverPrefetch);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expose)) {\n        if (expose.length) {\n            const exposed = instance.exposed || (instance.exposed = {});\n            expose.forEach(key => {\n                Object.defineProperty(exposed, key, {\n                    get: () => publicThis[key],\n                    set: val => (publicThis[key] = val)\n                });\n            });\n        }\n        else if (!instance.exposed) {\n            instance.exposed = {};\n        }\n    }\n    // options that are handled when creating the instance but also need to be\n    // applied from mixins\n    if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP) {\n        instance.render = render;\n    }\n    if (inheritAttrs != null) {\n        instance.inheritAttrs = inheritAttrs;\n    }\n    // asset options.\n    if (components)\n        instance.components = components;\n    if (directives)\n        instance.directives = directives;\n}\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, unwrapRef = false) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(injectOptions)) {\n        injectOptions = normalizeInject(injectOptions);\n    }\n    for (const key in injectOptions) {\n        const opt = injectOptions[key];\n        let injected;\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt)) {\n            if ('default' in opt) {\n                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);\n            }\n            else {\n                injected = inject(opt.from || key);\n            }\n        }\n        else {\n            injected = inject(opt);\n        }\n        if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(injected)) {\n            // TODO remove the check in 3.3\n            if (unwrapRef) {\n                Object.defineProperty(ctx, key, {\n                    enumerable: true,\n                    configurable: true,\n                    get: () => injected.value,\n                    set: v => (injected.value = v)\n                });\n            }\n            else {\n                if ((true)) {\n                    warn(`injected property \"${key}\" is a ref and will be auto-unwrapped ` +\n                        `and no longer needs \\`.value\\` in the next minor release. ` +\n                        `To opt-in to the new behavior now, ` +\n                        `set \\`app.config.unwrapInjectedRef = true\\` (this config is ` +\n                        `temporary and will not be needed in the future.)`);\n                }\n                ctx[key] = injected;\n            }\n        }\n        else {\n            ctx[key] = injected;\n        }\n        if ((true)) {\n            checkDuplicateProperties(\"Inject\" /* OptionTypes.INJECT */, key);\n        }\n    }\n}\nfunction callHook(hook, instance, type) {\n    callWithAsyncErrorHandling((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)\n        ? hook.map(h => h.bind(instance.proxy))\n        : hook.bind(instance.proxy), instance, type);\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n    const getter = key.includes('.')\n        ? createPathGetter(publicThis, key)\n        : () => publicThis[key];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw)) {\n        const handler = ctx[raw];\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {\n            watch(getter, handler);\n        }\n        else if ((true)) {\n            warn(`Invalid watch handler specified by key \"${raw}\"`, handler);\n        }\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw)) {\n        watch(getter, raw.bind(publicThis));\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\n            raw.forEach(r => createWatcher(r, ctx, publicThis, key));\n        }\n        else {\n            const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(raw.handler)\n                ? raw.handler.bind(publicThis)\n                : ctx[raw.handler];\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(handler)) {\n                watch(getter, handler, raw);\n            }\n            else if ((true)) {\n                warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\n            }\n        }\n    }\n    else if ((true)) {\n        warn(`Invalid watch option: \"${key}\"`, raw);\n    }\n}\n/**\n * Resolve merged options and cache it on the component.\n * This is done only once per-component since the merging does not involve\n * instances.\n */\nfunction resolveMergedOptions(instance) {\n    const base = instance.type;\n    const { mixins, extends: extendsOptions } = base;\n    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;\n    const cached = cache.get(base);\n    let resolved;\n    if (cached) {\n        resolved = cached;\n    }\n    else if (!globalMixins.length && !mixins && !extendsOptions) {\n        {\n            resolved = base;\n        }\n    }\n    else {\n        resolved = {};\n        if (globalMixins.length) {\n            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));\n        }\n        mergeOptions(resolved, base, optionMergeStrategies);\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(base)) {\n        cache.set(base, resolved);\n    }\n    return resolved;\n}\nfunction mergeOptions(to, from, strats, asMixin = false) {\n    const { mixins, extends: extendsOptions } = from;\n    if (extendsOptions) {\n        mergeOptions(to, extendsOptions, strats, true);\n    }\n    if (mixins) {\n        mixins.forEach((m) => mergeOptions(to, m, strats, true));\n    }\n    for (const key in from) {\n        if (asMixin && key === 'expose') {\n            ( true) &&\n                warn(`\"expose\" option is ignored when declared in mixins or extends. ` +\n                    `It should only be declared in the base component itself.`);\n        }\n        else {\n            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);\n            to[key] = strat ? strat(to[key], from[key]) : from[key];\n        }\n    }\n    return to;\n}\nconst internalOptionMergeStrats = {\n    data: mergeDataFn,\n    props: mergeObjectOptions,\n    emits: mergeObjectOptions,\n    // objects\n    methods: mergeObjectOptions,\n    computed: mergeObjectOptions,\n    // lifecycle\n    beforeCreate: mergeAsArray,\n    created: mergeAsArray,\n    beforeMount: mergeAsArray,\n    mounted: mergeAsArray,\n    beforeUpdate: mergeAsArray,\n    updated: mergeAsArray,\n    beforeDestroy: mergeAsArray,\n    beforeUnmount: mergeAsArray,\n    destroyed: mergeAsArray,\n    unmounted: mergeAsArray,\n    activated: mergeAsArray,\n    deactivated: mergeAsArray,\n    errorCaptured: mergeAsArray,\n    serverPrefetch: mergeAsArray,\n    // assets\n    components: mergeObjectOptions,\n    directives: mergeObjectOptions,\n    // watch\n    watch: mergeWatchOptions,\n    // provide / inject\n    provide: mergeDataFn,\n    inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n    if (!from) {\n        return to;\n    }\n    if (!to) {\n        return from;\n    }\n    return function mergedDataFn() {\n        return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend))((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(to) ? to.call(this, this) : to, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(from) ? from.call(this, this) : from);\n    };\n}\nfunction mergeInject(to, from) {\n    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\n        const res = {};\n        for (let i = 0; i < raw.length; i++) {\n            res[raw[i]] = raw[i];\n        }\n        return res;\n    }\n    return raw;\n}\nfunction mergeAsArray(to, from) {\n    return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n    return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to), from) : from;\n}\nfunction mergeWatchOptions(to, from) {\n    if (!to)\n        return from;\n    if (!from)\n        return to;\n    const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(Object.create(null), to);\n    for (const key in from) {\n        merged[key] = mergeAsArray(to[key], from[key]);\n    }\n    return merged;\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\nisSSR = false) {\n    const props = {};\n    const attrs = {};\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(attrs, InternalObjectKey, 1);\n    instance.propsDefaults = Object.create(null);\n    setFullProps(instance, rawProps, props, attrs);\n    // ensure all declared prop keys are present\n    for (const key in instance.propsOptions[0]) {\n        if (!(key in props)) {\n            props[key] = undefined;\n        }\n    }\n    // validation\n    if ((true)) {\n        validateProps(rawProps || {}, props, instance);\n    }\n    if (isStateful) {\n        // stateful\n        instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReactive)(props);\n    }\n    else {\n        if (!instance.type.props) {\n            // functional w/ optional props, props === attrs\n            instance.props = attrs;\n        }\n        else {\n            // functional w/ declared props\n            instance.props = props;\n        }\n    }\n    instance.attrs = attrs;\n}\nfunction isInHmrContext(instance) {\n    while (instance) {\n        if (instance.type.__hmrId)\n            return true;\n        instance = instance.parent;\n    }\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n    const { props, attrs, vnode: { patchFlag } } = instance;\n    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n    const [options] = instance.propsOptions;\n    let hasAttrsChanged = false;\n    if (\n    // always force full diff in dev\n    // - #1942 if hmr is enabled with sfc component\n    // - vite#872 non-sfc component used by sfc component\n    !(( true) && isInHmrContext(instance)) &&\n        (optimized || patchFlag > 0) &&\n        !(patchFlag & 16 /* PatchFlags.FULL_PROPS */)) {\n        if (patchFlag & 8 /* PatchFlags.PROPS */) {\n            // Compiler-generated props & no keys change, just set the updated\n            // the props.\n            const propsToUpdate = instance.vnode.dynamicProps;\n            for (let i = 0; i < propsToUpdate.length; i++) {\n                let key = propsToUpdate[i];\n                // skip if the prop key is a declared emit event listener\n                if (isEmitListener(instance.emitsOptions, key)) {\n                    continue;\n                }\n                // PROPS flag guarantees rawProps to be non-null\n                const value = rawProps[key];\n                if (options) {\n                    // attr / props separation was done on init and will be consistent\n                    // in this code path, so just check if attrs have it.\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(attrs, key)) {\n                        if (value !== attrs[key]) {\n                            attrs[key] = value;\n                            hasAttrsChanged = true;\n                        }\n                    }\n                    else {\n                        const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);\n                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);\n                    }\n                }\n                else {\n                    if (value !== attrs[key]) {\n                        attrs[key] = value;\n                        hasAttrsChanged = true;\n                    }\n                }\n            }\n        }\n    }\n    else {\n        // full props update.\n        if (setFullProps(instance, rawProps, props, attrs)) {\n            hasAttrsChanged = true;\n        }\n        // in case of dynamic props, check if we need to delete keys from\n        // the props object\n        let kebabKey;\n        for (const key in rawCurrentProps) {\n            if (!rawProps ||\n                // for camelCase\n                (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&\n                    // it's possible the original props was passed in as kebab-case\n                    // and converted to camelCase (#955)\n                    ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, kebabKey)))) {\n                if (options) {\n                    if (rawPrevProps &&\n                        // for camelCase\n                        (rawPrevProps[key] !== undefined ||\n                            // for kebab-case\n                            rawPrevProps[kebabKey] !== undefined)) {\n                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);\n                    }\n                }\n                else {\n                    delete props[key];\n                }\n            }\n        }\n        // in the case of functional component w/o props declaration, props and\n        // attrs point to the same object so it should already have been updated.\n        if (attrs !== rawCurrentProps) {\n            for (const key in attrs) {\n                if (!rawProps ||\n                    (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) &&\n                        (!false ))) {\n                    delete attrs[key];\n                    hasAttrsChanged = true;\n                }\n            }\n        }\n    }\n    // trigger updates for $attrs in case it's used in component slots\n    if (hasAttrsChanged) {\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.trigger)(instance, \"set\" /* TriggerOpTypes.SET */, '$attrs');\n    }\n    if ((true)) {\n        validateProps(rawProps || {}, props, instance);\n    }\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n    const [options, needCastKeys] = instance.propsOptions;\n    let hasAttrsChanged = false;\n    let rawCastValues;\n    if (rawProps) {\n        for (let key in rawProps) {\n            // key, ref are reserved and never passed down\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {\n                continue;\n            }\n            const value = rawProps[key];\n            // prop option names are camelized during normalization, so to support\n            // kebab -> camel conversion here we need to camelize the key.\n            let camelKey;\n            if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(options, (camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)))) {\n                if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n                    props[camelKey] = value;\n                }\n                else {\n                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n                }\n            }\n            else if (!isEmitListener(instance.emitsOptions, key)) {\n                if (!(key in attrs) || value !== attrs[key]) {\n                    attrs[key] = value;\n                    hasAttrsChanged = true;\n                }\n            }\n        }\n    }\n    if (needCastKeys) {\n        const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n        const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n        for (let i = 0; i < needCastKeys.length; i++) {\n            const key = needCastKeys[i];\n            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(castValues, key));\n        }\n    }\n    return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n    const opt = options[key];\n    if (opt != null) {\n        const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(opt, 'default');\n        // default values\n        if (hasDefault && value === undefined) {\n            const defaultValue = opt.default;\n            if (opt.type !== Function && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(defaultValue)) {\n                const { propsDefaults } = instance;\n                if (key in propsDefaults) {\n                    value = propsDefaults[key];\n                }\n                else {\n                    setCurrentInstance(instance);\n                    value = propsDefaults[key] = defaultValue.call(null, props);\n                    unsetCurrentInstance();\n                }\n            }\n            else {\n                value = defaultValue;\n            }\n        }\n        // boolean casting\n        if (opt[0 /* BooleanFlags.shouldCast */]) {\n            if (isAbsent && !hasDefault) {\n                value = false;\n            }\n            else if (opt[1 /* BooleanFlags.shouldCastTrue */] &&\n                (value === '' || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key))) {\n                value = true;\n            }\n        }\n    }\n    return value;\n}\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n    const cache = appContext.propsCache;\n    const cached = cache.get(comp);\n    if (cached) {\n        return cached;\n    }\n    const raw = comp.props;\n    const normalized = {};\n    const needCastKeys = [];\n    // apply mixin/extends props\n    let hasExtends = false;\n    if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comp)) {\n        const extendProps = (raw) => {\n            hasExtends = true;\n            const [props, keys] = normalizePropsOptions(raw, appContext, true);\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(normalized, props);\n            if (keys)\n                needCastKeys.push(...keys);\n        };\n        if (!asMixin && appContext.mixins.length) {\n            appContext.mixins.forEach(extendProps);\n        }\n        if (comp.extends) {\n            extendProps(comp.extends);\n        }\n        if (comp.mixins) {\n            comp.mixins.forEach(extendProps);\n        }\n    }\n    if (!raw && !hasExtends) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {\n            cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR);\n        }\n        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)) {\n        for (let i = 0; i < raw.length; i++) {\n            if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(raw[i])) {\n                warn(`props must be strings when using array syntax.`, raw[i]);\n            }\n            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(raw[i]);\n            if (validatePropName(normalizedKey)) {\n                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n            }\n        }\n    }\n    else if (raw) {\n        if (( true) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(raw)) {\n            warn(`invalid props options`, raw);\n        }\n        for (const key in raw) {\n            const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);\n            if (validatePropName(normalizedKey)) {\n                const opt = raw[key];\n                const prop = (normalized[normalizedKey] =\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt) ? { type: opt } : Object.assign({}, opt));\n                if (prop) {\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\n                    const stringIndex = getTypeIndex(String, prop.type);\n                    prop[0 /* BooleanFlags.shouldCast */] = booleanIndex > -1;\n                    prop[1 /* BooleanFlags.shouldCastTrue */] =\n                        stringIndex < 0 || booleanIndex < stringIndex;\n                    // if the prop needs boolean casting or default value\n                    if (booleanIndex > -1 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(prop, 'default')) {\n                        needCastKeys.push(normalizedKey);\n                    }\n                }\n            }\n        }\n    }\n    const res = [normalized, needCastKeys];\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(comp)) {\n        cache.set(comp, res);\n    }\n    return res;\n}\nfunction validatePropName(key) {\n    if (key[0] !== '$') {\n        return true;\n    }\n    else if ((true)) {\n        warn(`Invalid prop name: \"${key}\" is a reserved property.`);\n    }\n    return false;\n}\n// use function string name to check type constructors\n// so that it works across vms / iframes.\nfunction getType(ctor) {\n    const match = ctor && ctor.toString().match(/^\\s*(function|class) (\\w+)/);\n    return match ? match[2] : ctor === null ? 'null' : '';\n}\nfunction isSameType(a, b) {\n    return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(expectedTypes)) {\n        return expectedTypes.findIndex(t => isSameType(t, type));\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(expectedTypes)) {\n        return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n    return -1;\n}\n/**\n * dev only\n */\nfunction validateProps(rawProps, props, instance) {\n    const resolvedValues = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(props);\n    const options = instance.propsOptions[0];\n    for (const key in options) {\n        let opt = options[key];\n        if (opt == null)\n            continue;\n        validateProp(key, resolvedValues[key], opt, !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(rawProps, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key)));\n    }\n}\n/**\n * dev only\n */\nfunction validateProp(name, value, prop, isAbsent) {\n    const { type, required, validator } = prop;\n    // required!\n    if (required && isAbsent) {\n        warn('Missing required prop: \"' + name + '\"');\n        return;\n    }\n    // missing but optional\n    if (value == null && !prop.required) {\n        return;\n    }\n    // type check\n    if (type != null && type !== true) {\n        let isValid = false;\n        const types = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(type) ? type : [type];\n        const expectedTypes = [];\n        // value is valid as long as one of the specified types match\n        for (let i = 0; i < types.length && !isValid; i++) {\n            const { valid, expectedType } = assertType(value, types[i]);\n            expectedTypes.push(expectedType || '');\n            isValid = valid;\n        }\n        if (!isValid) {\n            warn(getInvalidTypeMessage(name, value, expectedTypes));\n            return;\n        }\n    }\n    // custom validator\n    if (validator && !validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".');\n    }\n}\nconst isSimpleType = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('String,Number,Boolean,Function,Symbol,BigInt');\n/**\n * dev only\n */\nfunction assertType(value, type) {\n    let valid;\n    const expectedType = getType(type);\n    if (isSimpleType(expectedType)) {\n        const t = typeof value;\n        valid = t === expectedType.toLowerCase();\n        // for primitive wrapper objects\n        if (!valid && t === 'object') {\n            valid = value instanceof type;\n        }\n    }\n    else if (expectedType === 'Object') {\n        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(value);\n    }\n    else if (expectedType === 'Array') {\n        valid = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value);\n    }\n    else if (expectedType === 'null') {\n        valid = value === null;\n    }\n    else {\n        valid = value instanceof type;\n    }\n    return {\n        valid,\n        expectedType\n    };\n}\n/**\n * dev only\n */\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n    let message = `Invalid prop: type check failed for prop \"${name}\".` +\n        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize).join(' | ')}`;\n    const expectedType = expectedTypes[0];\n    const receivedType = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toRawType)(value);\n    const expectedValue = styleValue(value, expectedType);\n    const receivedValue = styleValue(value, receivedType);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        !isBoolean(expectedType, receivedType)) {\n        message += ` with value ${expectedValue}`;\n    }\n    message += `, got ${receivedType} `;\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n        message += `with value ${receivedValue}.`;\n    }\n    return message;\n}\n/**\n * dev only\n */\nfunction styleValue(value, type) {\n    if (type === 'String') {\n        return `\"${value}\"`;\n    }\n    else if (type === 'Number') {\n        return `${Number(value)}`;\n    }\n    else {\n        return `${value}`;\n    }\n}\n/**\n * dev only\n */\nfunction isExplicable(type) {\n    const explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(elem => type.toLowerCase() === elem);\n}\n/**\n * dev only\n */\nfunction isBoolean(...args) {\n    return args.some(elem => elem.toLowerCase() === 'boolean');\n}\n\nconst isInternalKey = (key) => key[0] === '_' || key === '$stable';\nconst normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)\n    ? value.map(normalizeVNode)\n    : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n    if (rawSlot._n) {\n        // already normalized - #5353\n        return rawSlot;\n    }\n    const normalized = withCtx((...args) => {\n        if (( true) && currentInstance) {\n            warn(`Slot \"${key}\" invoked outside of the render function: ` +\n                `this will not track dependencies used in the slot. ` +\n                `Invoke the slot function inside the render function instead.`);\n        }\n        return normalizeSlotValue(rawSlot(...args));\n    }, ctx);\n    normalized._c = false;\n    return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n    const ctx = rawSlots._ctx;\n    for (const key in rawSlots) {\n        if (isInternalKey(key))\n            continue;\n        const value = rawSlots[key];\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\n            slots[key] = normalizeSlot(key, value, ctx);\n        }\n        else if (value != null) {\n            if (true) {\n                warn(`Non-function value encountered for slot \"${key}\". ` +\n                    `Prefer function slots for better performance.`);\n            }\n            const normalized = normalizeSlotValue(value);\n            slots[key] = () => normalized;\n        }\n    }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n    if (( true) &&\n        !isKeepAlive(instance.vnode) &&\n        !(false )) {\n        warn(`Non-function value encountered for default slot. ` +\n            `Prefer function slots for better performance.`);\n    }\n    const normalized = normalizeSlotValue(children);\n    instance.slots.default = () => normalized;\n};\nconst initSlots = (instance, children) => {\n    if (instance.vnode.shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */) {\n        const type = children._;\n        if (type) {\n            // users can get the shallow readonly version of the slots object through `this.$slots`,\n            // we should avoid the proxy object polluting the slots of the internal instance\n            instance.slots = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(children);\n            // make compiler marker non-enumerable\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(children, '_', type);\n        }\n        else {\n            normalizeObjectSlots(children, (instance.slots = {}));\n        }\n    }\n    else {\n        instance.slots = {};\n        if (children) {\n            normalizeVNodeSlots(instance, children);\n        }\n    }\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.def)(instance.slots, InternalObjectKey, 1);\n};\nconst updateSlots = (instance, children, optimized) => {\n    const { vnode, slots } = instance;\n    let needDeletionCheck = true;\n    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n    if (vnode.shapeFlag & 32 /* ShapeFlags.SLOTS_CHILDREN */) {\n        const type = children._;\n        if (type) {\n            // compiled slots.\n            if (( true) && isHmrUpdating) {\n                // Parent was HMR updated so slot content may have changed.\n                // force update slots and mark instance for hmr as well\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);\n            }\n            else if (optimized && type === 1 /* SlotFlags.STABLE */) {\n                // compiled AND stable.\n                // no need to update, and skip stale slots removal.\n                needDeletionCheck = false;\n            }\n            else {\n                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\n                // normalization.\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(slots, children);\n                // #2893\n                // when rendering the optimized slots by manually written render function,\n                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\n                // i.e. let the `renderSlot` create the bailed Fragment\n                if (!optimized && type === 1 /* SlotFlags.STABLE */) {\n                    delete slots._;\n                }\n            }\n        }\n        else {\n            needDeletionCheck = !children.$stable;\n            normalizeObjectSlots(children, slots);\n        }\n        deletionComparisonTarget = children;\n    }\n    else if (children) {\n        // non slot object children (direct value) passed to a component\n        normalizeVNodeSlots(instance, children);\n        deletionComparisonTarget = { default: 1 };\n    }\n    // delete stale slots\n    if (needDeletionCheck) {\n        for (const key in slots) {\n            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\n                delete slots[key];\n            }\n        }\n    }\n};\n\nfunction createAppContext() {\n    return {\n        app: null,\n        config: {\n            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,\n            performance: false,\n            globalProperties: {},\n            optionMergeStrategies: {},\n            errorHandler: undefined,\n            warnHandler: undefined,\n            compilerOptions: {}\n        },\n        mixins: [],\n        components: {},\n        directives: {},\n        provides: Object.create(null),\n        optionsCache: new WeakMap(),\n        propsCache: new WeakMap(),\n        emitsCache: new WeakMap()\n    };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n    return function createApp(rootComponent, rootProps = null) {\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(rootComponent)) {\n            rootComponent = Object.assign({}, rootComponent);\n        }\n        if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(rootProps)) {\n            ( true) && warn(`root props passed to app.mount() must be an object.`);\n            rootProps = null;\n        }\n        const context = createAppContext();\n        const installedPlugins = new Set();\n        let isMounted = false;\n        const app = (context.app = {\n            _uid: uid$1++,\n            _component: rootComponent,\n            _props: rootProps,\n            _container: null,\n            _context: context,\n            _instance: null,\n            version,\n            get config() {\n                return context.config;\n            },\n            set config(v) {\n                if ((true)) {\n                    warn(`app.config cannot be replaced. Modify individual options instead.`);\n                }\n            },\n            use(plugin, ...options) {\n                if (installedPlugins.has(plugin)) {\n                    ( true) && warn(`Plugin has already been applied to target app.`);\n                }\n                else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin.install)) {\n                    installedPlugins.add(plugin);\n                    plugin.install(app, ...options);\n                }\n                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(plugin)) {\n                    installedPlugins.add(plugin);\n                    plugin(app, ...options);\n                }\n                else if ((true)) {\n                    warn(`A plugin must either be a function or an object with an \"install\" ` +\n                        `function.`);\n                }\n                return app;\n            },\n            mixin(mixin) {\n                if (true) {\n                    if (!context.mixins.includes(mixin)) {\n                        context.mixins.push(mixin);\n                    }\n                    else if ((true)) {\n                        warn('Mixin has already been applied to target app' +\n                            (mixin.name ? `: ${mixin.name}` : ''));\n                    }\n                }\n                else {}\n                return app;\n            },\n            component(name, component) {\n                if ((true)) {\n                    validateComponentName(name, context.config);\n                }\n                if (!component) {\n                    return context.components[name];\n                }\n                if (( true) && context.components[name]) {\n                    warn(`Component \"${name}\" has already been registered in target app.`);\n                }\n                context.components[name] = component;\n                return app;\n            },\n            directive(name, directive) {\n                if ((true)) {\n                    validateDirectiveName(name);\n                }\n                if (!directive) {\n                    return context.directives[name];\n                }\n                if (( true) && context.directives[name]) {\n                    warn(`Directive \"${name}\" has already been registered in target app.`);\n                }\n                context.directives[name] = directive;\n                return app;\n            },\n            mount(rootContainer, isHydrate, isSVG) {\n                if (!isMounted) {\n                    // #5571\n                    if (( true) && rootContainer.__vue_app__) {\n                        warn(`There is already an app instance mounted on the host container.\\n` +\n                            ` If you want to mount another app on the same host container,` +\n                            ` you need to unmount the previous app by calling \\`app.unmount()\\` first.`);\n                    }\n                    const vnode = createVNode(rootComponent, rootProps);\n                    // store app context on the root VNode.\n                    // this will be set on the root instance on initial mount.\n                    vnode.appContext = context;\n                    // HMR root reload\n                    if ((true)) {\n                        context.reload = () => {\n                            render(cloneVNode(vnode), rootContainer, isSVG);\n                        };\n                    }\n                    if (isHydrate && hydrate) {\n                        hydrate(vnode, rootContainer);\n                    }\n                    else {\n                        render(vnode, rootContainer, isSVG);\n                    }\n                    isMounted = true;\n                    app._container = rootContainer;\n                    rootContainer.__vue_app__ = app;\n                    if (true) {\n                        app._instance = vnode.component;\n                        devtoolsInitApp(app, version);\n                    }\n                    return getExposeProxy(vnode.component) || vnode.component.proxy;\n                }\n                else if ((true)) {\n                    warn(`App has already been mounted.\\n` +\n                        `If you want to remount the same app, move your app creation logic ` +\n                        `into a factory function and create fresh app instances for each ` +\n                        `mount - e.g. \\`const createMyApp = () => createApp(App)\\``);\n                }\n            },\n            unmount() {\n                if (isMounted) {\n                    render(null, app._container);\n                    if (true) {\n                        app._instance = null;\n                        devtoolsUnmountApp(app);\n                    }\n                    delete app._container.__vue_app__;\n                }\n                else if ((true)) {\n                    warn(`Cannot unmount an app that is not mounted.`);\n                }\n            },\n            provide(key, value) {\n                if (( true) && key in context.provides) {\n                    warn(`App already provides property with key \"${String(key)}\". ` +\n                        `It will be overwritten with the new value.`);\n                }\n                context.provides[key] = value;\n                return app;\n            }\n        });\n        return app;\n    };\n}\n\n/**\n * Function for handling a template ref\n */\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(rawRef)) {\n        rawRef.forEach((r, i) => setRef(r, oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));\n        return;\n    }\n    if (isAsyncWrapper(vnode) && !isUnmount) {\n        // when mounting async components, nothing needs to be done,\n        // because the template ref is forwarded to inner component\n        return;\n    }\n    const refValue = vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */\n        ? getExposeProxy(vnode.component) || vnode.component.proxy\n        : vnode.el;\n    const value = isUnmount ? null : refValue;\n    const { i: owner, r: ref } = rawRef;\n    if (( true) && !owner) {\n        warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\n            `A vnode with ref must be created inside the render function.`);\n        return;\n    }\n    const oldRef = oldRawRef && oldRawRef.r;\n    const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;\n    const setupState = owner.setupState;\n    // dynamic ref changed. unset old ref\n    if (oldRef != null && oldRef !== ref) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(oldRef)) {\n            refs[oldRef] = null;\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, oldRef)) {\n                setupState[oldRef] = null;\n            }\n        }\n        else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(oldRef)) {\n            oldRef.value = null;\n        }\n    }\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)) {\n        callWithErrorHandling(ref, owner, 12 /* ErrorCodes.FUNCTION_REF */, [value, refs]);\n    }\n    else {\n        const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref);\n        const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref);\n        if (_isString || _isRef) {\n            const doSet = () => {\n                if (rawRef.f) {\n                    const existing = _isString\n                        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)\n                            ? setupState[ref]\n                            : refs[ref]\n                        : ref.value;\n                    if (isUnmount) {\n                        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.remove)(existing, refValue);\n                    }\n                    else {\n                        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing)) {\n                            if (_isString) {\n                                refs[ref] = [refValue];\n                                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {\n                                    setupState[ref] = refs[ref];\n                                }\n                            }\n                            else {\n                                ref.value = [refValue];\n                                if (rawRef.k)\n                                    refs[rawRef.k] = ref.value;\n                            }\n                        }\n                        else if (!existing.includes(refValue)) {\n                            existing.push(refValue);\n                        }\n                    }\n                }\n                else if (_isString) {\n                    refs[ref] = value;\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(setupState, ref)) {\n                        setupState[ref] = value;\n                    }\n                }\n                else if (_isRef) {\n                    ref.value = value;\n                    if (rawRef.k)\n                        refs[rawRef.k] = value;\n                }\n                else if ((true)) {\n                    warn('Invalid template ref type:', ref, `(${typeof ref})`);\n                }\n            };\n            if (value) {\n                doSet.id = -1;\n                queuePostRenderEffect(doSet, parentSuspense);\n            }\n            else {\n                doSet();\n            }\n        }\n        else if ((true)) {\n            warn('Invalid template ref type:', ref, `(${typeof ref})`);\n        }\n    }\n}\n\nlet hasMismatch = false;\nconst isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\nconst isComment = (node) => node.nodeType === 8 /* DOMNodeTypes.COMMENT */;\n// Note: hydration is DOM-specific\n// But we have to place it in core due to tight coupling with core - splitting\n// it out creates a ton of unnecessary complexity.\n// Hydration also depends on some renderer internal logic which needs to be\n// passed in via arguments.\nfunction createHydrationFunctions(rendererInternals) {\n    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\n    const hydrate = (vnode, container) => {\n        if (!container.hasChildNodes()) {\n            ( true) &&\n                warn(`Attempting to hydrate existing markup but container is empty. ` +\n                    `Performing full mount instead.`);\n            patch(null, vnode, container);\n            flushPostFlushCbs();\n            container._vnode = vnode;\n            return;\n        }\n        hasMismatch = false;\n        hydrateNode(container.firstChild, vnode, null, null, null);\n        flushPostFlushCbs();\n        container._vnode = vnode;\n        if (hasMismatch && !false) {\n            // this error should show up in production\n            console.error(`Hydration completed but contains mismatches.`);\n        }\n    };\n    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\n        const isFragmentStart = isComment(node) && node.data === '[';\n        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\n        const { type, ref, shapeFlag, patchFlag } = vnode;\n        let domType = node.nodeType;\n        vnode.el = node;\n        if (patchFlag === -2 /* PatchFlags.BAIL */) {\n            optimized = false;\n            vnode.dynamicChildren = null;\n        }\n        let nextNode = null;\n        switch (type) {\n            case Text:\n                if (domType !== 3 /* DOMNodeTypes.TEXT */) {\n                    // #5728 empty text node inside a slot can cause hydration failure\n                    // because the server rendered HTML won't contain a text node\n                    if (vnode.children === '') {\n                        insert((vnode.el = createText('')), parentNode(node), node);\n                        nextNode = node;\n                    }\n                    else {\n                        nextNode = onMismatch();\n                    }\n                }\n                else {\n                    if (node.data !== vnode.children) {\n                        hasMismatch = true;\n                        ( true) &&\n                            warn(`Hydration text mismatch:` +\n                                `\\n- Client: ${JSON.stringify(node.data)}` +\n                                `\\n- Server: ${JSON.stringify(vnode.children)}`);\n                        node.data = vnode.children;\n                    }\n                    nextNode = nextSibling(node);\n                }\n                break;\n            case Comment:\n                if (domType !== 8 /* DOMNodeTypes.COMMENT */ || isFragmentStart) {\n                    nextNode = onMismatch();\n                }\n                else {\n                    nextNode = nextSibling(node);\n                }\n                break;\n            case Static:\n                if (isFragmentStart) {\n                    // entire template is static but SSRed as a fragment\n                    node = nextSibling(node);\n                    domType = node.nodeType;\n                }\n                if (domType === 1 /* DOMNodeTypes.ELEMENT */ || domType === 3 /* DOMNodeTypes.TEXT */) {\n                    // determine anchor, adopt content\n                    nextNode = node;\n                    // if the static vnode has its content stripped during build,\n                    // adopt it from the server-rendered HTML.\n                    const needToAdoptContent = !vnode.children.length;\n                    for (let i = 0; i < vnode.staticCount; i++) {\n                        if (needToAdoptContent)\n                            vnode.children +=\n                                nextNode.nodeType === 1 /* DOMNodeTypes.ELEMENT */\n                                    ? nextNode.outerHTML\n                                    : nextNode.data;\n                        if (i === vnode.staticCount - 1) {\n                            vnode.anchor = nextNode;\n                        }\n                        nextNode = nextSibling(nextNode);\n                    }\n                    return isFragmentStart ? nextSibling(nextNode) : nextNode;\n                }\n                else {\n                    onMismatch();\n                }\n                break;\n            case Fragment:\n                if (!isFragmentStart) {\n                    nextNode = onMismatch();\n                }\n                else {\n                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n                }\n                break;\n            default:\n                if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n                    if (domType !== 1 /* DOMNodeTypes.ELEMENT */ ||\n                        vnode.type.toLowerCase() !==\n                            node.tagName.toLowerCase()) {\n                        nextNode = onMismatch();\n                    }\n                    else {\n                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n                    }\n                }\n                else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n                    // when setting up the render effect, if the initial vnode already\n                    // has .el set, the component will perform hydration instead of mount\n                    // on its sub-tree.\n                    vnode.slotScopeIds = slotScopeIds;\n                    const container = parentNode(node);\n                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\n                    // component may be async, so in the case of fragments we cannot rely\n                    // on component's rendered output to determine the end of the fragment\n                    // instead, we do a lookahead to find the end anchor node.\n                    nextNode = isFragmentStart\n                        ? locateClosingAsyncAnchor(node)\n                        : nextSibling(node);\n                    // #4293 teleport as component root\n                    if (nextNode &&\n                        isComment(nextNode) &&\n                        nextNode.data === 'teleport end') {\n                        nextNode = nextSibling(nextNode);\n                    }\n                    // #3787\n                    // if component is async, it may get moved / unmounted before its\n                    // inner component is loaded, so we need to give it a placeholder\n                    // vnode that matches its adopted DOM.\n                    if (isAsyncWrapper(vnode)) {\n                        let subTree;\n                        if (isFragmentStart) {\n                            subTree = createVNode(Fragment);\n                            subTree.anchor = nextNode\n                                ? nextNode.previousSibling\n                                : container.lastChild;\n                        }\n                        else {\n                            subTree =\n                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');\n                        }\n                        subTree.el = node;\n                        vnode.component.subTree = subTree;\n                    }\n                }\n                else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n                    if (domType !== 8 /* DOMNodeTypes.COMMENT */) {\n                        nextNode = onMismatch();\n                    }\n                    else {\n                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\n                    }\n                }\n                else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\n                }\n                else if ((true)) {\n                    warn('Invalid HostVNode type:', type, `(${typeof type})`);\n                }\n        }\n        if (ref != null) {\n            setRef(ref, null, parentSuspense, vnode);\n        }\n        return nextNode;\n    };\n    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n        optimized = optimized || !!vnode.dynamicChildren;\n        const { type, props, patchFlag, shapeFlag, dirs } = vnode;\n        // #4006 for form elements with non-string v-model value bindings\n        // e.g. <option :value=\"obj\">, <input type=\"checkbox\" :true-value=\"1\">\n        const forcePatchValue = (type === 'input' && dirs) || type === 'option';\n        // skip props & children if this is hoisted static nodes\n        // #5405 in dev, always hydrate children for HMR\n        if (true /* PatchFlags.HOISTED */) {\n            if (dirs) {\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\n            }\n            // props\n            if (props) {\n                if (forcePatchValue ||\n                    !optimized ||\n                    patchFlag & (16 /* PatchFlags.FULL_PROPS */ | 32 /* PatchFlags.HYDRATE_EVENTS */)) {\n                    for (const key in props) {\n                        if ((forcePatchValue && key.endsWith('value')) ||\n                            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))) {\n                            patchProp(el, key, null, props[key], false, undefined, parentComponent);\n                        }\n                    }\n                }\n                else if (props.onClick) {\n                    // Fast path for click listeners (which is most often) to avoid\n                    // iterating through props.\n                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);\n                }\n            }\n            // vnode / directive hooks\n            let vnodeHooks;\n            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\n                invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n            }\n            if (dirs) {\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\n            }\n            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\n                queueEffectWithSuspense(() => {\n                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\n                }, parentSuspense);\n            }\n            // children\n            if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */ &&\n                // skip if element has innerHTML / textContent\n                !(props && (props.innerHTML || props.textContent))) {\n                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\n                let hasWarned = false;\n                while (next) {\n                    hasMismatch = true;\n                    if (( true) && !hasWarned) {\n                        warn(`Hydration children mismatch in <${vnode.type}>: ` +\n                            `server rendered element contains more child nodes than client vdom.`);\n                        hasWarned = true;\n                    }\n                    // The SSRed DOM contains more nodes than it should. Remove them.\n                    const cur = next;\n                    next = next.nextSibling;\n                    remove(cur);\n                }\n            }\n            else if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n                if (el.textContent !== vnode.children) {\n                    hasMismatch = true;\n                    ( true) &&\n                        warn(`Hydration text content mismatch in <${vnode.type}>:\\n` +\n                            `- Client: ${el.textContent}\\n` +\n                            `- Server: ${vnode.children}`);\n                    el.textContent = vnode.children;\n                }\n            }\n        }\n        return el.nextSibling;\n    };\n    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n        optimized = optimized || !!parentVNode.dynamicChildren;\n        const children = parentVNode.children;\n        const l = children.length;\n        let hasWarned = false;\n        for (let i = 0; i < l; i++) {\n            const vnode = optimized\n                ? children[i]\n                : (children[i] = normalizeVNode(children[i]));\n            if (node) {\n                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\n            }\n            else if (vnode.type === Text && !vnode.children) {\n                continue;\n            }\n            else {\n                hasMismatch = true;\n                if (( true) && !hasWarned) {\n                    warn(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +\n                        `server rendered element contains fewer child nodes than client vdom.`);\n                    hasWarned = true;\n                }\n                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\n                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\n            }\n        }\n        return node;\n    };\n    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n        const { slotScopeIds: fragmentSlotScopeIds } = vnode;\n        if (fragmentSlotScopeIds) {\n            slotScopeIds = slotScopeIds\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\n                : fragmentSlotScopeIds;\n        }\n        const container = parentNode(node);\n        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\n        if (next && isComment(next) && next.data === ']') {\n            return nextSibling((vnode.anchor = next));\n        }\n        else {\n            // fragment didn't hydrate successfully, since we didn't get a end anchor\n            // back. This should have led to node/children mismatch warnings.\n            hasMismatch = true;\n            // since the anchor is missing, we need to create one and insert it\n            insert((vnode.anchor = createComment(`]`)), container, next);\n            return next;\n        }\n    };\n    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n        hasMismatch = true;\n        ( true) &&\n            warn(`Hydration node mismatch:\\n- Client vnode:`, vnode.type, `\\n- Server rendered DOM:`, node, node.nodeType === 3 /* DOMNodeTypes.TEXT */\n                ? `(text)`\n                : isComment(node) && node.data === '['\n                    ? `(start of fragment)`\n                    : ``);\n        vnode.el = null;\n        if (isFragment) {\n            // remove excessive fragment nodes\n            const end = locateClosingAsyncAnchor(node);\n            while (true) {\n                const next = nextSibling(node);\n                if (next && next !== end) {\n                    remove(next);\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        const next = nextSibling(node);\n        const container = parentNode(node);\n        remove(node);\n        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\n        return next;\n    };\n    const locateClosingAsyncAnchor = (node) => {\n        let match = 0;\n        while (node) {\n            node = nextSibling(node);\n            if (node && isComment(node)) {\n                if (node.data === '[')\n                    match++;\n                if (node.data === ']') {\n                    if (match === 0) {\n                        return nextSibling(node);\n                    }\n                    else {\n                        match--;\n                    }\n                }\n            }\n        }\n        return node;\n    };\n    return [hydrate, hydrateNode];\n}\n\n/* eslint-disable no-restricted-globals */\nlet supported;\nlet perf;\nfunction startMeasure(instance, type) {\n    if (instance.appContext.config.performance && isSupported()) {\n        perf.mark(`vue-${type}-${instance.uid}`);\n    }\n    if (true) {\n        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\n    }\n}\nfunction endMeasure(instance, type) {\n    if (instance.appContext.config.performance && isSupported()) {\n        const startTag = `vue-${type}-${instance.uid}`;\n        const endTag = startTag + `:end`;\n        perf.mark(endTag);\n        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n    }\n    if (true) {\n        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\n    }\n}\nfunction isSupported() {\n    if (supported !== undefined) {\n        return supported;\n    }\n    if (typeof window !== 'undefined' && window.performance) {\n        supported = true;\n        perf = window.performance;\n    }\n    else {\n        supported = false;\n    }\n    return supported;\n}\n\n/**\n * This is only called in esm-bundler builds.\n * It is called when a renderer is created, in `baseCreateRenderer` so that\n * importing runtime-core is side-effects free.\n *\n * istanbul-ignore-next\n */\nfunction initFeatureFlags() {\n    const needWarn = [];\n    if (false) {}\n    if (false) {}\n    if (( true) && needWarn.length) {\n        const multi = needWarn.length > 1;\n        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` +\n            `which expects these compile-time feature flags to be globally injected ` +\n            `via the bundler config in order to get better tree-shaking in the ` +\n            `production bundle.\\n\\n` +\n            `For more details, see https://link.vuejs.org/feature-flags.`);\n    }\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense\n    ;\n/**\n * The createRenderer function accepts two generic arguments:\n * HostNode and HostElement, corresponding to Node and Element types in the\n * host environment. For example, for runtime-dom, HostNode would be the DOM\n * `Node` interface and HostElement would be the DOM `Element` interface.\n *\n * Custom renderers can pass in the platform specific types like this:\n *\n * ``` js\n * const { render, createApp } = createRenderer<Node, Element>({\n *   patchProp,\n *   ...nodeOps\n * })\n * ```\n */\nfunction createRenderer(options) {\n    return baseCreateRenderer(options);\n}\n// Separate API for creating hydration-enabled renderer.\n// Hydration logic is only used when calling this function, making it\n// tree-shakable.\nfunction createHydrationRenderer(options) {\n    return baseCreateRenderer(options, createHydrationFunctions);\n}\n// implementation\nfunction baseCreateRenderer(options, createHydrationFns) {\n    // compile-time feature flags check\n    {\n        initFeatureFlags();\n    }\n    const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();\n    target.__VUE__ = true;\n    if (true) {\n        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\n    }\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP, insertStaticContent: hostInsertStaticContent } = options;\n    // Note: functions inside this closure should use `const xxx = () => {}`\n    // style in order to prevent being inlined by minifiers.\n    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = ( true) && isHmrUpdating ? false : !!n2.dynamicChildren) => {\n        if (n1 === n2) {\n            return;\n        }\n        // patching & not same type, unmount old tree\n        if (n1 && !isSameVNodeType(n1, n2)) {\n            anchor = getNextHostNode(n1);\n            unmount(n1, parentComponent, parentSuspense, true);\n            n1 = null;\n        }\n        if (n2.patchFlag === -2 /* PatchFlags.BAIL */) {\n            optimized = false;\n            n2.dynamicChildren = null;\n        }\n        const { type, ref, shapeFlag } = n2;\n        switch (type) {\n            case Text:\n                processText(n1, n2, container, anchor);\n                break;\n            case Comment:\n                processCommentNode(n1, n2, container, anchor);\n                break;\n            case Static:\n                if (n1 == null) {\n                    mountStaticNode(n2, container, anchor, isSVG);\n                }\n                else if ((true)) {\n                    patchStaticNode(n1, n2, container, isSVG);\n                }\n                break;\n            case Fragment:\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                break;\n            default:\n                if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                }\n                else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                }\n                else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\n                }\n                else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\n                }\n                else if ((true)) {\n                    warn('Invalid VNode type:', type, `(${typeof type})`);\n                }\n        }\n        // set ref\n        if (ref != null && parentComponent) {\n            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n        }\n    };\n    const processText = (n1, n2, container, anchor) => {\n        if (n1 == null) {\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\n        }\n        else {\n            const el = (n2.el = n1.el);\n            if (n2.children !== n1.children) {\n                hostSetText(el, n2.children);\n            }\n        }\n    };\n    const processCommentNode = (n1, n2, container, anchor) => {\n        if (n1 == null) {\n            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);\n        }\n        else {\n            // there's no support for dynamic comments\n            n2.el = n1.el;\n        }\n    };\n    const mountStaticNode = (n2, container, anchor, isSVG) => {\n        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);\n    };\n    /**\n     * Dev / HMR only\n     */\n    const patchStaticNode = (n1, n2, container, isSVG) => {\n        // static nodes are only patched during dev for HMR\n        if (n2.children !== n1.children) {\n            const anchor = hostNextSibling(n1.anchor);\n            // remove existing\n            removeStaticNode(n1);\n            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\n        }\n        else {\n            n2.el = n1.el;\n            n2.anchor = n1.anchor;\n        }\n    };\n    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\n        let next;\n        while (el && el !== anchor) {\n            next = hostNextSibling(el);\n            hostInsert(el, container, nextSibling);\n            el = next;\n        }\n        hostInsert(anchor, container, nextSibling);\n    };\n    const removeStaticNode = ({ el, anchor }) => {\n        let next;\n        while (el && el !== anchor) {\n            next = hostNextSibling(el);\n            hostRemove(el);\n            el = next;\n        }\n        hostRemove(anchor);\n    };\n    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n        isSVG = isSVG || n2.type === 'svg';\n        if (n1 == null) {\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n        else {\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n    };\n    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n        let el;\n        let vnodeHook;\n        const { type, props, shapeFlag, transition, dirs } = vnode;\n        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\n        // mount children first, since some props may rely on child content\n        // being already rendered, e.g. `<select value>`\n        if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n            hostSetElementText(el, vnode.children);\n        }\n        else if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n            mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);\n        }\n        if (dirs) {\n            invokeDirectiveHook(vnode, null, parentComponent, 'created');\n        }\n        // scopeId\n        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n        // props\n        if (props) {\n            for (const key in props) {\n                if (key !== 'value' && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key)) {\n                    hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n                }\n            }\n            /**\n             * Special case for setting value on DOM elements:\n             * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\n             * - it needs to be forced (#1471)\n             * #2353 proposes adding another renderer option to configure this, but\n             * the properties affects are so finite it is worth special casing it\n             * here to reduce the complexity. (Special casing it also should not\n             * affect non-DOM renderers)\n             */\n            if ('value' in props) {\n                hostPatchProp(el, 'value', null, props.value);\n            }\n            if ((vnodeHook = props.onVnodeBeforeMount)) {\n                invokeVNodeHook(vnodeHook, parentComponent, vnode);\n            }\n        }\n        if (true) {\n            Object.defineProperty(el, '__vnode', {\n                value: vnode,\n                enumerable: false\n            });\n            Object.defineProperty(el, '__vueParentComponent', {\n                value: parentComponent,\n                enumerable: false\n            });\n        }\n        if (dirs) {\n            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\n        }\n        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\n        // #1689 For inside suspense + suspense resolved case, just call it\n        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\n            transition &&\n            !transition.persisted;\n        if (needCallTransitionHooks) {\n            transition.beforeEnter(el);\n        }\n        hostInsert(el, container, anchor);\n        if ((vnodeHook = props && props.onVnodeMounted) ||\n            needCallTransitionHooks ||\n            dirs) {\n            queuePostRenderEffect(() => {\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n                needCallTransitionHooks && transition.enter(el);\n                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\n            }, parentSuspense);\n        }\n    };\n    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n        if (scopeId) {\n            hostSetScopeId(el, scopeId);\n        }\n        if (slotScopeIds) {\n            for (let i = 0; i < slotScopeIds.length; i++) {\n                hostSetScopeId(el, slotScopeIds[i]);\n            }\n        }\n        if (parentComponent) {\n            let subTree = parentComponent.subTree;\n            if (( true) &&\n                subTree.patchFlag > 0 &&\n                subTree.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */) {\n                subTree =\n                    filterSingleRoot(subTree.children) || subTree;\n            }\n            if (vnode === subTree) {\n                const parentVNode = parentComponent.vnode;\n                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\n            }\n        }\n    };\n    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {\n        for (let i = start; i < children.length; i++) {\n            const child = (children[i] = optimized\n                ? cloneIfMounted(children[i])\n                : normalizeVNode(children[i]));\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n    };\n    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n        const el = (n2.el = n1.el);\n        let { patchFlag, dynamicChildren, dirs } = n2;\n        // #1426 take the old vnode's patch flag into account since user may clone a\n        // compiler-generated vnode, which de-opts to FULL_PROPS\n        patchFlag |= n1.patchFlag & 16 /* PatchFlags.FULL_PROPS */;\n        const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n        let vnodeHook;\n        // disable recurse in beforeUpdate hooks\n        parentComponent && toggleRecurse(parentComponent, false);\n        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\n            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        }\n        if (dirs) {\n            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\n        }\n        parentComponent && toggleRecurse(parentComponent, true);\n        if (( true) && isHmrUpdating) {\n            // HMR updated, force full diff\n            patchFlag = 0;\n            optimized = false;\n            dynamicChildren = null;\n        }\n        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\n        if (dynamicChildren) {\n            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\n            if (( true) && parentComponent && parentComponent.type.__hmrId) {\n                traverseStaticChildren(n1, n2);\n            }\n        }\n        else if (!optimized) {\n            // full diff\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\n        }\n        if (patchFlag > 0) {\n            // the presence of a patchFlag means this element's render code was\n            // generated by the compiler and can take the fast path.\n            // in this path old node and new node are guaranteed to have the same shape\n            // (i.e. at the exact same position in the source template)\n            if (patchFlag & 16 /* PatchFlags.FULL_PROPS */) {\n                // element props contain dynamic keys, full diff needed\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n            }\n            else {\n                // class\n                // this flag is matched when the element has dynamic class bindings.\n                if (patchFlag & 2 /* PatchFlags.CLASS */) {\n                    if (oldProps.class !== newProps.class) {\n                        hostPatchProp(el, 'class', null, newProps.class, isSVG);\n                    }\n                }\n                // style\n                // this flag is matched when the element has dynamic style bindings\n                if (patchFlag & 4 /* PatchFlags.STYLE */) {\n                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\n                }\n                // props\n                // This flag is matched when the element has dynamic prop/attr bindings\n                // other than class and style. The keys of dynamic prop/attrs are saved for\n                // faster iteration.\n                // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\n                // bail out and go through a full diff because we need to unset the old key\n                if (patchFlag & 8 /* PatchFlags.PROPS */) {\n                    // if the flag is present then dynamicProps must be non-null\n                    const propsToUpdate = n2.dynamicProps;\n                    for (let i = 0; i < propsToUpdate.length; i++) {\n                        const key = propsToUpdate[i];\n                        const prev = oldProps[key];\n                        const next = newProps[key];\n                        // #1471 force patch value\n                        if (next !== prev || key === 'value') {\n                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\n                        }\n                    }\n                }\n            }\n            // text\n            // This flag is matched when the element has only dynamic text children.\n            if (patchFlag & 1 /* PatchFlags.TEXT */) {\n                if (n1.children !== n2.children) {\n                    hostSetElementText(el, n2.children);\n                }\n            }\n        }\n        else if (!optimized && dynamicChildren == null) {\n            // unoptimized, full diff\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\n        }\n        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n            queuePostRenderEffect(() => {\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\n            }, parentSuspense);\n        }\n    };\n    // The fast path for blocks.\n    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\n        for (let i = 0; i < newChildren.length; i++) {\n            const oldVNode = oldChildren[i];\n            const newVNode = newChildren[i];\n            // Determine the container (parent element) for the patch.\n            const container = \n            // oldVNode may be an errored async setup() component inside Suspense\n            // which will not have a mounted element\n            oldVNode.el &&\n                // - In the case of a Fragment, we need to provide the actual parent\n                // of the Fragment itself so it can move its children.\n                (oldVNode.type === Fragment ||\n                    // - In the case of different nodes, there is going to be a replacement\n                    // which also requires the correct parent container\n                    !isSameVNodeType(oldVNode, newVNode) ||\n                    // - In the case of a component, it could contain anything.\n                    oldVNode.shapeFlag & (6 /* ShapeFlags.COMPONENT */ | 64 /* ShapeFlags.TELEPORT */))\n                ? hostParentNode(oldVNode.el)\n                : // In other cases, the parent container is not actually used so we\n                    // just pass the block element here to avoid a DOM parentNode call.\n                    fallbackContainer;\n            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\n        }\n    };\n    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\n        if (oldProps !== newProps) {\n            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n                for (const key in oldProps) {\n                    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key) && !(key in newProps)) {\n                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n                    }\n                }\n            }\n            for (const key in newProps) {\n                // empty string is not valid prop\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isReservedProp)(key))\n                    continue;\n                const next = newProps[key];\n                const prev = oldProps[key];\n                // defer patching value\n                if (next !== prev && key !== 'value') {\n                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\n                }\n            }\n            if ('value' in newProps) {\n                hostPatchProp(el, 'value', oldProps.value, newProps.value);\n            }\n        }\n    };\n    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));\n        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));\n        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\n        if (( true) &&\n            // #5523 dev root fragment may inherit directives\n            (isHmrUpdating || patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */)) {\n            // HMR updated / Dev root fragment (w/ comments), force full diff\n            patchFlag = 0;\n            optimized = false;\n            dynamicChildren = null;\n        }\n        // check if this is a slot fragment with :slotted scope ids\n        if (fragmentSlotScopeIds) {\n            slotScopeIds = slotScopeIds\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\n                : fragmentSlotScopeIds;\n        }\n        if (n1 == null) {\n            hostInsert(fragmentStartAnchor, container, anchor);\n            hostInsert(fragmentEndAnchor, container, anchor);\n            // a fragment can only have array children\n            // since they are either generated by the compiler, or implicitly created\n            // from arrays.\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n        else {\n            if (patchFlag > 0 &&\n                patchFlag & 64 /* PatchFlags.STABLE_FRAGMENT */ &&\n                dynamicChildren &&\n                // #2715 the previous fragment could've been a BAILed one as a result\n                // of renderSlot() with no valid children\n                n1.dynamicChildren) {\n                // a stable fragment (template root or <template v-for>) doesn't need to\n                // patch children order, but it may contain dynamicChildren.\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\n                if (( true) && parentComponent && parentComponent.type.__hmrId) {\n                    traverseStaticChildren(n1, n2);\n                }\n                else if (\n                // #2080 if the stable fragment has a key, it's a <template v-for> that may\n                //  get moved around. Make sure all root level vnodes inherit el.\n                // #2134 or if it's a component root, it may also get moved around\n                // as the component is being moved.\n                n2.key != null ||\n                    (parentComponent && n2 === parentComponent.subTree)) {\n                    traverseStaticChildren(n1, n2, true /* shallow */);\n                }\n            }\n            else {\n                // keyed / unkeyed, or manual fragments.\n                // for keyed & unkeyed, since they are compiler generated from v-for,\n                // each child is guaranteed to be a block so the fragment will never\n                // have dynamicChildren.\n                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n            }\n        }\n    };\n    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n        n2.slotScopeIds = slotScopeIds;\n        if (n1 == null) {\n            if (n2.shapeFlag & 512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */) {\n                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\n            }\n            else {\n                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\n            }\n        }\n        else {\n            updateComponent(n1, n2, optimized);\n        }\n    };\n    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\n        if (( true) && instance.type.__hmrId) {\n            registerHMR(instance);\n        }\n        if ((true)) {\n            pushWarningContext(initialVNode);\n            startMeasure(instance, `mount`);\n        }\n        // inject renderer internals for keepAlive\n        if (isKeepAlive(initialVNode)) {\n            instance.ctx.renderer = internals;\n        }\n        // resolve props and slots for setup context\n        {\n            if ((true)) {\n                startMeasure(instance, `init`);\n            }\n            setupComponent(instance);\n            if ((true)) {\n                endMeasure(instance, `init`);\n            }\n        }\n        // setup() is async. This component relies on async logic to be resolved\n        // before proceeding\n        if (instance.asyncDep) {\n            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\n            // Give it a placeholder if this is not hydration\n            // TODO handle self-defined fallback\n            if (!initialVNode.el) {\n                const placeholder = (instance.subTree = createVNode(Comment));\n                processCommentNode(null, placeholder, container, anchor);\n            }\n            return;\n        }\n        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\n        if ((true)) {\n            popWarningContext();\n            endMeasure(instance, `mount`);\n        }\n    };\n    const updateComponent = (n1, n2, optimized) => {\n        const instance = (n2.component = n1.component);\n        if (shouldUpdateComponent(n1, n2, optimized)) {\n            if (instance.asyncDep &&\n                !instance.asyncResolved) {\n                // async & still pending - just update props and slots\n                // since the component's reactive effect for render isn't set-up yet\n                if ((true)) {\n                    pushWarningContext(n2);\n                }\n                updateComponentPreRender(instance, n2, optimized);\n                if ((true)) {\n                    popWarningContext();\n                }\n                return;\n            }\n            else {\n                // normal update\n                instance.next = n2;\n                // in case the child component is also queued, remove it to avoid\n                // double updating the same child component in the same flush.\n                invalidateJob(instance.update);\n                // instance.update is the reactive effect.\n                instance.update();\n            }\n        }\n        else {\n            // no update needed. just copy over properties\n            n2.el = n1.el;\n            instance.vnode = n2;\n        }\n    };\n    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n        const componentUpdateFn = () => {\n            if (!instance.isMounted) {\n                let vnodeHook;\n                const { el, props } = initialVNode;\n                const { bm, m, parent } = instance;\n                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n                toggleRecurse(instance, false);\n                // beforeMount hook\n                if (bm) {\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bm);\n                }\n                // onVnodeBeforeMount\n                if (!isAsyncWrapperVNode &&\n                    (vnodeHook = props && props.onVnodeBeforeMount)) {\n                    invokeVNodeHook(vnodeHook, parent, initialVNode);\n                }\n                toggleRecurse(instance, true);\n                if (el && hydrateNode) {\n                    // vnode has adopted host node - perform hydration instead of mount.\n                    const hydrateSubTree = () => {\n                        if ((true)) {\n                            startMeasure(instance, `render`);\n                        }\n                        instance.subTree = renderComponentRoot(instance);\n                        if ((true)) {\n                            endMeasure(instance, `render`);\n                        }\n                        if ((true)) {\n                            startMeasure(instance, `hydrate`);\n                        }\n                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);\n                        if ((true)) {\n                            endMeasure(instance, `hydrate`);\n                        }\n                    };\n                    if (isAsyncWrapperVNode) {\n                        initialVNode.type.__asyncLoader().then(\n                        // note: we are moving the render call into an async callback,\n                        // which means it won't track dependencies - but it's ok because\n                        // a server-rendered async wrapper is already in resolved state\n                        // and it will never need to change.\n                        () => !instance.isUnmounted && hydrateSubTree());\n                    }\n                    else {\n                        hydrateSubTree();\n                    }\n                }\n                else {\n                    if ((true)) {\n                        startMeasure(instance, `render`);\n                    }\n                    const subTree = (instance.subTree = renderComponentRoot(instance));\n                    if ((true)) {\n                        endMeasure(instance, `render`);\n                    }\n                    if ((true)) {\n                        startMeasure(instance, `patch`);\n                    }\n                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\n                    if ((true)) {\n                        endMeasure(instance, `patch`);\n                    }\n                    initialVNode.el = subTree.el;\n                }\n                // mounted hook\n                if (m) {\n                    queuePostRenderEffect(m, parentSuspense);\n                }\n                // onVnodeMounted\n                if (!isAsyncWrapperVNode &&\n                    (vnodeHook = props && props.onVnodeMounted)) {\n                    const scopedInitialVNode = initialVNode;\n                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);\n                }\n                // activated hook for keep-alive roots.\n                // #1742 activated hook must be accessed after first render\n                // since the hook may be injected by a child keep-alive\n                if (initialVNode.shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */ ||\n                    (parent &&\n                        isAsyncWrapper(parent.vnode) &&\n                        parent.vnode.shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */)) {\n                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n                }\n                instance.isMounted = true;\n                if (true) {\n                    devtoolsComponentAdded(instance);\n                }\n                // #2458: deference mount-only object parameters to prevent memleaks\n                initialVNode = container = anchor = null;\n            }\n            else {\n                // updateComponent\n                // This is triggered by mutation of component's own state (next: null)\n                // OR parent calling processComponent (next: VNode)\n                let { next, bu, u, parent, vnode } = instance;\n                let originNext = next;\n                let vnodeHook;\n                if ((true)) {\n                    pushWarningContext(next || instance.vnode);\n                }\n                // Disallow component effect recursion during pre-lifecycle hooks.\n                toggleRecurse(instance, false);\n                if (next) {\n                    next.el = vnode.el;\n                    updateComponentPreRender(instance, next, optimized);\n                }\n                else {\n                    next = vnode;\n                }\n                // beforeUpdate hook\n                if (bu) {\n                    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bu);\n                }\n                // onVnodeBeforeUpdate\n                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\n                    invokeVNodeHook(vnodeHook, parent, next, vnode);\n                }\n                toggleRecurse(instance, true);\n                // render\n                if ((true)) {\n                    startMeasure(instance, `render`);\n                }\n                const nextTree = renderComponentRoot(instance);\n                if ((true)) {\n                    endMeasure(instance, `render`);\n                }\n                const prevTree = instance.subTree;\n                instance.subTree = nextTree;\n                if ((true)) {\n                    startMeasure(instance, `patch`);\n                }\n                patch(prevTree, nextTree, \n                // parent may have changed if it's in a teleport\n                hostParentNode(prevTree.el), \n                // anchor may have changed if it's in a fragment\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\n                if ((true)) {\n                    endMeasure(instance, `patch`);\n                }\n                next.el = nextTree.el;\n                if (originNext === null) {\n                    // self-triggered update. In case of HOC, update parent component\n                    // vnode el. HOC is indicated by parent instance's subTree pointing\n                    // to child component's vnode\n                    updateHOCHostEl(instance, nextTree.el);\n                }\n                // updated hook\n                if (u) {\n                    queuePostRenderEffect(u, parentSuspense);\n                }\n                // onVnodeUpdated\n                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\n                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);\n                }\n                if (true) {\n                    devtoolsComponentUpdated(instance);\n                }\n                if ((true)) {\n                    popWarningContext();\n                }\n            }\n        };\n        // create reactive effect for rendering\n        const effect = (instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope\n        ));\n        const update = (instance.update = () => effect.run());\n        update.id = instance.uid;\n        // allowRecurse\n        // #1801, #2043 component render effects should allow recursive updates\n        toggleRecurse(instance, true);\n        if ((true)) {\n            effect.onTrack = instance.rtc\n                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtc, e)\n                : void 0;\n            effect.onTrigger = instance.rtg\n                ? e => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(instance.rtg, e)\n                : void 0;\n            update.ownerInstance = instance;\n        }\n        update();\n    };\n    const updateComponentPreRender = (instance, nextVNode, optimized) => {\n        nextVNode.component = instance;\n        const prevProps = instance.vnode.props;\n        instance.vnode = nextVNode;\n        instance.next = null;\n        updateProps(instance, nextVNode.props, prevProps, optimized);\n        updateSlots(instance, nextVNode.children, optimized);\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n        // props update may have triggered pre-flush watchers.\n        // flush them before the render update.\n        flushPreFlushCbs();\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n    };\n    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\n        const c1 = n1 && n1.children;\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n        const c2 = n2.children;\n        const { patchFlag, shapeFlag } = n2;\n        // fast path\n        if (patchFlag > 0) {\n            if (patchFlag & 128 /* PatchFlags.KEYED_FRAGMENT */) {\n                // this could be either fully-keyed or mixed (some keyed some not)\n                // presence of patchFlag means children are guaranteed to be arrays\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                return;\n            }\n            else if (patchFlag & 256 /* PatchFlags.UNKEYED_FRAGMENT */) {\n                // unkeyed\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                return;\n            }\n        }\n        // children has 3 possibilities: text, array or no children.\n        if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n            // text children fast path\n            if (prevShapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                unmountChildren(c1, parentComponent, parentSuspense);\n            }\n            if (c2 !== c1) {\n                hostSetElementText(container, c2);\n            }\n        }\n        else {\n            if (prevShapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                // prev children was array\n                if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                    // two arrays, cannot assume anything, do full diff\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                }\n                else {\n                    // no new children, just unmount old\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\n                }\n            }\n            else {\n                // prev children was text OR null\n                // new children is array OR null\n                if (prevShapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n                    hostSetElementText(container, '');\n                }\n                // mount new if array\n                if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                }\n            }\n        }\n    };\n    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\n        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\n        const oldLength = c1.length;\n        const newLength = c2.length;\n        const commonLength = Math.min(oldLength, newLength);\n        let i;\n        for (i = 0; i < commonLength; i++) {\n            const nextChild = (c2[i] = optimized\n                ? cloneIfMounted(c2[i])\n                : normalizeVNode(c2[i]));\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n        }\n        if (oldLength > newLength) {\n            // remove old\n            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\n        }\n        else {\n            // mount new\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\n        }\n    };\n    // can be all-keyed or mixed\n    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n        let i = 0;\n        const l2 = c2.length;\n        let e1 = c1.length - 1; // prev ending index\n        let e2 = l2 - 1; // next ending index\n        // 1. sync from start\n        // (a b) c\n        // (a b) d e\n        while (i <= e1 && i <= e2) {\n            const n1 = c1[i];\n            const n2 = (c2[i] = optimized\n                ? cloneIfMounted(c2[i])\n                : normalizeVNode(c2[i]));\n            if (isSameVNodeType(n1, n2)) {\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n            }\n            else {\n                break;\n            }\n            i++;\n        }\n        // 2. sync from end\n        // a (b c)\n        // d e (b c)\n        while (i <= e1 && i <= e2) {\n            const n1 = c1[e1];\n            const n2 = (c2[e2] = optimized\n                ? cloneIfMounted(c2[e2])\n                : normalizeVNode(c2[e2]));\n            if (isSameVNodeType(n1, n2)) {\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n            }\n            else {\n                break;\n            }\n            e1--;\n            e2--;\n        }\n        // 3. common sequence + mount\n        // (a b)\n        // (a b) c\n        // i = 2, e1 = 1, e2 = 2\n        // (a b)\n        // c (a b)\n        // i = 0, e1 = -1, e2 = 0\n        if (i > e1) {\n            if (i <= e2) {\n                const nextPos = e2 + 1;\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n                while (i <= e2) {\n                    patch(null, (c2[i] = optimized\n                        ? cloneIfMounted(c2[i])\n                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                    i++;\n                }\n            }\n        }\n        // 4. common sequence + unmount\n        // (a b) c\n        // (a b)\n        // i = 2, e1 = 2, e2 = 1\n        // a (b c)\n        // (b c)\n        // i = 0, e1 = 0, e2 = -1\n        else if (i > e2) {\n            while (i <= e1) {\n                unmount(c1[i], parentComponent, parentSuspense, true);\n                i++;\n            }\n        }\n        // 5. unknown sequence\n        // [i ... e1 + 1]: a b [c d e] f g\n        // [i ... e2 + 1]: a b [e d c h] f g\n        // i = 2, e1 = 4, e2 = 5\n        else {\n            const s1 = i; // prev starting index\n            const s2 = i; // next starting index\n            // 5.1 build key:index map for newChildren\n            const keyToNewIndexMap = new Map();\n            for (i = s2; i <= e2; i++) {\n                const nextChild = (c2[i] = optimized\n                    ? cloneIfMounted(c2[i])\n                    : normalizeVNode(c2[i]));\n                if (nextChild.key != null) {\n                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {\n                        warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);\n                    }\n                    keyToNewIndexMap.set(nextChild.key, i);\n                }\n            }\n            // 5.2 loop through old children left to be patched and try to patch\n            // matching nodes & remove nodes that are no longer present\n            let j;\n            let patched = 0;\n            const toBePatched = e2 - s2 + 1;\n            let moved = false;\n            // used to track whether any node has moved\n            let maxNewIndexSoFar = 0;\n            // works as Map<newIndex, oldIndex>\n            // Note that oldIndex is offset by +1\n            // and oldIndex = 0 is a special value indicating the new node has\n            // no corresponding old node.\n            // used for determining longest stable subsequence\n            const newIndexToOldIndexMap = new Array(toBePatched);\n            for (i = 0; i < toBePatched; i++)\n                newIndexToOldIndexMap[i] = 0;\n            for (i = s1; i <= e1; i++) {\n                const prevChild = c1[i];\n                if (patched >= toBePatched) {\n                    // all new children have been patched so this can only be a removal\n                    unmount(prevChild, parentComponent, parentSuspense, true);\n                    continue;\n                }\n                let newIndex;\n                if (prevChild.key != null) {\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\n                }\n                else {\n                    // key-less node, try to locate a key-less node of the same type\n                    for (j = s2; j <= e2; j++) {\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\n                            isSameVNodeType(prevChild, c2[j])) {\n                            newIndex = j;\n                            break;\n                        }\n                    }\n                }\n                if (newIndex === undefined) {\n                    unmount(prevChild, parentComponent, parentSuspense, true);\n                }\n                else {\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\n                    if (newIndex >= maxNewIndexSoFar) {\n                        maxNewIndexSoFar = newIndex;\n                    }\n                    else {\n                        moved = true;\n                    }\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                    patched++;\n                }\n            }\n            // 5.3 move and mount\n            // generate longest stable subsequence only when nodes have moved\n            const increasingNewIndexSequence = moved\n                ? getSequence(newIndexToOldIndexMap)\n                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR;\n            j = increasingNewIndexSequence.length - 1;\n            // looping backwards so that we can use last patched node as anchor\n            for (i = toBePatched - 1; i >= 0; i--) {\n                const nextIndex = s2 + i;\n                const nextChild = c2[nextIndex];\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n                if (newIndexToOldIndexMap[i] === 0) {\n                    // mount new\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                }\n                else if (moved) {\n                    // move if:\n                    // There is no stable subsequence (e.g. a reverse)\n                    // OR current node is not among the stable sequence\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\n                        move(nextChild, container, anchor, 2 /* MoveType.REORDER */);\n                    }\n                    else {\n                        j--;\n                    }\n                }\n            }\n        }\n    };\n    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n        const { el, type, transition, children, shapeFlag } = vnode;\n        if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n            move(vnode.component.subTree, container, anchor, moveType);\n            return;\n        }\n        if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n            vnode.suspense.move(container, anchor, moveType);\n            return;\n        }\n        if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n            type.move(vnode, container, anchor, internals);\n            return;\n        }\n        if (type === Fragment) {\n            hostInsert(el, container, anchor);\n            for (let i = 0; i < children.length; i++) {\n                move(children[i], container, anchor, moveType);\n            }\n            hostInsert(vnode.anchor, container, anchor);\n            return;\n        }\n        if (type === Static) {\n            moveStaticNode(vnode, container, anchor);\n            return;\n        }\n        // single nodes\n        const needTransition = moveType !== 2 /* MoveType.REORDER */ &&\n            shapeFlag & 1 /* ShapeFlags.ELEMENT */ &&\n            transition;\n        if (needTransition) {\n            if (moveType === 0 /* MoveType.ENTER */) {\n                transition.beforeEnter(el);\n                hostInsert(el, container, anchor);\n                queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n            }\n            else {\n                const { leave, delayLeave, afterLeave } = transition;\n                const remove = () => hostInsert(el, container, anchor);\n                const performLeave = () => {\n                    leave(el, () => {\n                        remove();\n                        afterLeave && afterLeave();\n                    });\n                };\n                if (delayLeave) {\n                    delayLeave(el, remove, performLeave);\n                }\n                else {\n                    performLeave();\n                }\n            }\n        }\n        else {\n            hostInsert(el, container, anchor);\n        }\n    };\n    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\n        // unset ref\n        if (ref != null) {\n            setRef(ref, null, parentSuspense, vnode, true);\n        }\n        if (shapeFlag & 256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */) {\n            parentComponent.ctx.deactivate(vnode);\n            return;\n        }\n        const shouldInvokeDirs = shapeFlag & 1 /* ShapeFlags.ELEMENT */ && dirs;\n        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n        let vnodeHook;\n        if (shouldInvokeVnodeHook &&\n            (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n            invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        }\n        if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n            unmountComponent(vnode.component, parentSuspense, doRemove);\n        }\n        else {\n            if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n                vnode.suspense.unmount(parentSuspense, doRemove);\n                return;\n            }\n            if (shouldInvokeDirs) {\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\n            }\n            if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\n            }\n            else if (dynamicChildren &&\n                // #1153: fast path should not be taken for non-stable (v-for) fragments\n                (type !== Fragment ||\n                    (patchFlag > 0 && patchFlag & 64 /* PatchFlags.STABLE_FRAGMENT */))) {\n                // fast path for block nodes: only need to unmount dynamic children.\n                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\n            }\n            else if ((type === Fragment &&\n                patchFlag &\n                    (128 /* PatchFlags.KEYED_FRAGMENT */ | 256 /* PatchFlags.UNKEYED_FRAGMENT */)) ||\n                (!optimized && shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */)) {\n                unmountChildren(children, parentComponent, parentSuspense);\n            }\n            if (doRemove) {\n                remove(vnode);\n            }\n        }\n        if ((shouldInvokeVnodeHook &&\n            (vnodeHook = props && props.onVnodeUnmounted)) ||\n            shouldInvokeDirs) {\n            queuePostRenderEffect(() => {\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n                shouldInvokeDirs &&\n                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\n            }, parentSuspense);\n        }\n    };\n    const remove = vnode => {\n        const { type, el, anchor, transition } = vnode;\n        if (type === Fragment) {\n            if (( true) &&\n                vnode.patchFlag > 0 &&\n                vnode.patchFlag & 2048 /* PatchFlags.DEV_ROOT_FRAGMENT */ &&\n                transition &&\n                !transition.persisted) {\n                vnode.children.forEach(child => {\n                    if (child.type === Comment) {\n                        hostRemove(child.el);\n                    }\n                    else {\n                        remove(child);\n                    }\n                });\n            }\n            else {\n                removeFragment(el, anchor);\n            }\n            return;\n        }\n        if (type === Static) {\n            removeStaticNode(vnode);\n            return;\n        }\n        const performRemove = () => {\n            hostRemove(el);\n            if (transition && !transition.persisted && transition.afterLeave) {\n                transition.afterLeave();\n            }\n        };\n        if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ &&\n            transition &&\n            !transition.persisted) {\n            const { leave, delayLeave } = transition;\n            const performLeave = () => leave(el, performRemove);\n            if (delayLeave) {\n                delayLeave(vnode.el, performRemove, performLeave);\n            }\n            else {\n                performLeave();\n            }\n        }\n        else {\n            performRemove();\n        }\n    };\n    const removeFragment = (cur, end) => {\n        // For fragments, directly remove all contained DOM nodes.\n        // (fragment child nodes cannot have transition)\n        let next;\n        while (cur !== end) {\n            next = hostNextSibling(cur);\n            hostRemove(cur);\n            cur = next;\n        }\n        hostRemove(end);\n    };\n    const unmountComponent = (instance, parentSuspense, doRemove) => {\n        if (( true) && instance.type.__hmrId) {\n            unregisterHMR(instance);\n        }\n        const { bum, scope, update, subTree, um } = instance;\n        // beforeUnmount hook\n        if (bum) {\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(bum);\n        }\n        // stop effects in component scope\n        scope.stop();\n        // update may be null if a component is unmounted before its async\n        // setup has resolved.\n        if (update) {\n            // so that scheduler will no longer invoke it\n            update.active = false;\n            unmount(subTree, instance, parentSuspense, doRemove);\n        }\n        // unmounted hook\n        if (um) {\n            queuePostRenderEffect(um, parentSuspense);\n        }\n        queuePostRenderEffect(() => {\n            instance.isUnmounted = true;\n        }, parentSuspense);\n        // A component with async dep inside a pending suspense is unmounted before\n        // its async dep resolves. This should remove the dep from the suspense, and\n        // cause the suspense to resolve immediately if that was the last dep.\n        if (parentSuspense &&\n            parentSuspense.pendingBranch &&\n            !parentSuspense.isUnmounted &&\n            instance.asyncDep &&\n            !instance.asyncResolved &&\n            instance.suspenseId === parentSuspense.pendingId) {\n            parentSuspense.deps--;\n            if (parentSuspense.deps === 0) {\n                parentSuspense.resolve();\n            }\n        }\n        if (true) {\n            devtoolsComponentRemoved(instance);\n        }\n    };\n    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n        for (let i = start; i < children.length; i++) {\n            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n        }\n    };\n    const getNextHostNode = vnode => {\n        if (vnode.shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n            return getNextHostNode(vnode.component.subTree);\n        }\n        if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n            return vnode.suspense.next();\n        }\n        return hostNextSibling((vnode.anchor || vnode.el));\n    };\n    const render = (vnode, container, isSVG) => {\n        if (vnode == null) {\n            if (container._vnode) {\n                unmount(container._vnode, null, null, true);\n            }\n        }\n        else {\n            patch(container._vnode || null, vnode, container, null, null, null, isSVG);\n        }\n        flushPreFlushCbs();\n        flushPostFlushCbs();\n        container._vnode = vnode;\n    };\n    const internals = {\n        p: patch,\n        um: unmount,\n        m: move,\n        r: remove,\n        mt: mountComponent,\n        mc: mountChildren,\n        pc: patchChildren,\n        pbc: patchBlockChildren,\n        n: getNextHostNode,\n        o: options\n    };\n    let hydrate;\n    let hydrateNode;\n    if (createHydrationFns) {\n        [hydrate, hydrateNode] = createHydrationFns(internals);\n    }\n    return {\n        render,\n        hydrate,\n        createApp: createAppAPI(render, hydrate)\n    };\n}\nfunction toggleRecurse({ effect, update }, allowed) {\n    effect.allowRecurse = update.allowRecurse = allowed;\n}\n/**\n * #1156\n * When a component is HMR-enabled, we need to make sure that all static nodes\n * inside a block also inherit the DOM element from the previous tree so that\n * HMR updates (which are full updates) can retrieve the element for patching.\n *\n * #2080\n * Inside keyed `template` fragment static children, if a fragment is moved,\n * the children will always be moved. Therefore, in order to ensure correct move\n * position, el should be inherited from previous nodes.\n */\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n    const ch1 = n1.children;\n    const ch2 = n2.children;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ch2)) {\n        for (let i = 0; i < ch1.length; i++) {\n            // this is only called in the optimized path so array children are\n            // guaranteed to be vnodes\n            const c1 = ch1[i];\n            let c2 = ch2[i];\n            if (c2.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && !c2.dynamicChildren) {\n                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* PatchFlags.HYDRATE_EVENTS */) {\n                    c2 = ch2[i] = cloneIfMounted(ch2[i]);\n                    c2.el = c1.el;\n                }\n                if (!shallow)\n                    traverseStaticChildren(c1, c2);\n            }\n            // #6852 also inherit for text nodes\n            if (c2.type === Text) {\n                c2.el = c1.el;\n            }\n            // also inherit for comment nodes, but not placeholders (e.g. v-if which\n            // would have received .el during block patch)\n            if (( true) && c2.type === Comment && !c2.el) {\n                c2.el = c1.el;\n            }\n        }\n    }\n}\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction getSequence(arr) {\n    const p = arr.slice();\n    const result = [0];\n    let i, j, u, v, c;\n    const len = arr.length;\n    for (i = 0; i < len; i++) {\n        const arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[result.length - 1];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result.push(i);\n                continue;\n            }\n            u = 0;\n            v = result.length - 1;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = result.length;\n    v = result[u - 1];\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n    return result;\n}\n\nconst isTeleport = (type) => type.__isTeleport;\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');\nconst isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;\nconst resolveTarget = (props, select) => {\n    const targetSelector = props && props.to;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetSelector)) {\n        if (!select) {\n            ( true) &&\n                warn(`Current renderer does not support string target for Teleports. ` +\n                    `(missing querySelector renderer option)`);\n            return null;\n        }\n        else {\n            const target = select(targetSelector);\n            if (!target) {\n                ( true) &&\n                    warn(`Failed to locate Teleport target with selector \"${targetSelector}\". ` +\n                        `Note the target element must exist before the component is mounted - ` +\n                        `i.e. the target cannot be rendered by the component itself, and ` +\n                        `ideally should be outside of the entire Vue component tree.`);\n            }\n            return target;\n        }\n    }\n    else {\n        if (( true) && !targetSelector && !isTeleportDisabled(props)) {\n            warn(`Invalid Teleport target: ${targetSelector}`);\n        }\n        return targetSelector;\n    }\n};\nconst TeleportImpl = {\n    __isTeleport: true,\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\n        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\n        const disabled = isTeleportDisabled(n2.props);\n        let { shapeFlag, children, dynamicChildren } = n2;\n        // #3302\n        // HMR updated, force full diff\n        if (( true) && isHmrUpdating) {\n            optimized = false;\n            dynamicChildren = null;\n        }\n        if (n1 == null) {\n            // insert anchors in the main view\n            const placeholder = (n2.el = ( true)\n                ? createComment('teleport start')\n                : 0);\n            const mainAnchor = (n2.anchor = ( true)\n                ? createComment('teleport end')\n                : 0);\n            insert(placeholder, container, anchor);\n            insert(mainAnchor, container, anchor);\n            const target = (n2.target = resolveTarget(n2.props, querySelector));\n            const targetAnchor = (n2.targetAnchor = createText(''));\n            if (target) {\n                insert(targetAnchor, target);\n                // #2652 we could be teleporting from a non-SVG tree into an SVG tree\n                isSVG = isSVG || isTargetSVG(target);\n            }\n            else if (( true) && !disabled) {\n                warn('Invalid Teleport target on mount:', target, `(${typeof target})`);\n            }\n            const mount = (container, anchor) => {\n                // Teleport *always* has Array children. This is enforced in both the\n                // compiler and vnode children normalization.\n                if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\n                }\n            };\n            if (disabled) {\n                mount(container, mainAnchor);\n            }\n            else if (target) {\n                mount(target, targetAnchor);\n            }\n        }\n        else {\n            // update content\n            n2.el = n1.el;\n            const mainAnchor = (n2.anchor = n1.anchor);\n            const target = (n2.target = n1.target);\n            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\n            const wasDisabled = isTeleportDisabled(n1.props);\n            const currentContainer = wasDisabled ? container : target;\n            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n            isSVG = isSVG || isTargetSVG(target);\n            if (dynamicChildren) {\n                // fast path when the teleport happens to be a block root\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);\n                // even in block tree mode we need to make sure all root-level nodes\n                // in the teleport inherit previous DOM references so that they can\n                // be moved in future patches.\n                traverseStaticChildren(n1, n2, true);\n            }\n            else if (!optimized) {\n                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);\n            }\n            if (disabled) {\n                if (!wasDisabled) {\n                    // enabled -> disabled\n                    // move into main container\n                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);\n                }\n            }\n            else {\n                // target changed\n                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\n                    if (nextTarget) {\n                        moveTeleport(n2, nextTarget, null, internals, 0 /* TeleportMoveTypes.TARGET_CHANGE */);\n                    }\n                    else if ((true)) {\n                        warn('Invalid Teleport target on update:', target, `(${typeof target})`);\n                    }\n                }\n                else if (wasDisabled) {\n                    // disabled -> enabled\n                    // move into teleport target\n                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TeleportMoveTypes.TOGGLE */);\n                }\n            }\n        }\n        updateCssVars(n2);\n    },\n    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {\n        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;\n        if (target) {\n            hostRemove(targetAnchor);\n        }\n        // an unmounted teleport should always remove its children if not disabled\n        if (doRemove || !isTeleportDisabled(props)) {\n            hostRemove(anchor);\n            if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                for (let i = 0; i < children.length; i++) {\n                    const child = children[i];\n                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);\n                }\n            }\n        }\n    },\n    move: moveTeleport,\n    hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* TeleportMoveTypes.REORDER */) {\n    // move target anchor if this is a target change.\n    if (moveType === 0 /* TeleportMoveTypes.TARGET_CHANGE */) {\n        insert(vnode.targetAnchor, container, parentAnchor);\n    }\n    const { el, anchor, shapeFlag, children, props } = vnode;\n    const isReorder = moveType === 2 /* TeleportMoveTypes.REORDER */;\n    // move main view anchor if this is a re-order.\n    if (isReorder) {\n        insert(el, container, parentAnchor);\n    }\n    // if this is a re-order and teleport is enabled (content is in target)\n    // do not move children. So the opposite is: only move children if this\n    // is not a reorder, or the teleport is disabled\n    if (!isReorder || isTeleportDisabled(props)) {\n        // Teleport has either Array children or no children.\n        if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n            for (let i = 0; i < children.length; i++) {\n                move(children[i], container, parentAnchor, 2 /* MoveType.REORDER */);\n            }\n        }\n    }\n    // move main view anchor if this is a re-order.\n    if (isReorder) {\n        insert(anchor, container, parentAnchor);\n    }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\n    const target = (vnode.target = resolveTarget(vnode.props, querySelector));\n    if (target) {\n        // if multiple teleports rendered to the same target element, we need to\n        // pick up from where the last teleport finished instead of the first node\n        const targetNode = target._lpa || target.firstChild;\n        if (vnode.shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n            if (isTeleportDisabled(vnode.props)) {\n                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\n                vnode.targetAnchor = targetNode;\n            }\n            else {\n                vnode.anchor = nextSibling(node);\n                // lookahead until we find the target anchor\n                // we cannot rely on return value of hydrateChildren() because there\n                // could be nested teleports\n                let targetAnchor = targetNode;\n                while (targetAnchor) {\n                    targetAnchor = nextSibling(targetAnchor);\n                    if (targetAnchor &&\n                        targetAnchor.nodeType === 8 &&\n                        targetAnchor.data === 'teleport anchor') {\n                        vnode.targetAnchor = targetAnchor;\n                        target._lpa =\n                            vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n                        break;\n                    }\n                }\n                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\n            }\n        }\n        updateCssVars(vnode);\n    }\n    return vnode.anchor && nextSibling(vnode.anchor);\n}\n// Force-casted public typing for h and TSX props inference\nconst Teleport = TeleportImpl;\nfunction updateCssVars(vnode) {\n    // presence of .ut method indicates owner component uses css vars.\n    // code path here can assume browser environment.\n    const ctx = vnode.ctx;\n    if (ctx && ctx.ut) {\n        let node = vnode.children[0].el;\n        while (node !== vnode.targetAnchor) {\n            if (node.nodeType === 1)\n                node.setAttribute('data-v-owner', ctx.uid);\n            node = node.nextSibling;\n        }\n        ctx.ut();\n    }\n}\n\nconst Fragment = Symbol(( true) ? 'Fragment' : 0);\nconst Text = Symbol(( true) ? 'Text' : 0);\nconst Comment = Symbol(( true) ? 'Comment' : 0);\nconst Static = Symbol(( true) ? 'Static' : 0);\n// Since v-if and v-for are the two possible ways node structure can dynamically\n// change, once we consider v-if branches and each v-for fragment a block, we\n// can divide a template into nested blocks, and within each block the node\n// structure would be stable. This allows us to skip most children diffing\n// and only worry about the dynamic nodes (indicated by patch flags).\nconst blockStack = [];\nlet currentBlock = null;\n/**\n * Open a block.\n * This must be called before `createBlock`. It cannot be part of `createBlock`\n * because the children of the block are evaluated before `createBlock` itself\n * is called. The generated code typically looks like this:\n *\n * ```js\n * function render() {\n *   return (openBlock(),createBlock('div', null, [...]))\n * }\n * ```\n * disableTracking is true when creating a v-for fragment block, since a v-for\n * fragment always diffs its children.\n *\n * @private\n */\nfunction openBlock(disableTracking = false) {\n    blockStack.push((currentBlock = disableTracking ? null : []));\n}\nfunction closeBlock() {\n    blockStack.pop();\n    currentBlock = blockStack[blockStack.length - 1] || null;\n}\n// Whether we should be tracking dynamic child nodes inside a block.\n// Only tracks when this value is > 0\n// We are not using a simple boolean because this value may need to be\n// incremented/decremented by nested usage of v-once (see below)\nlet isBlockTreeEnabled = 1;\n/**\n * Block tracking sometimes needs to be disabled, for example during the\n * creation of a tree that needs to be cached by v-once. The compiler generates\n * code like this:\n *\n * ``` js\n * _cache[1] || (\n *   setBlockTracking(-1),\n *   _cache[1] = createVNode(...),\n *   setBlockTracking(1),\n *   _cache[1]\n * )\n * ```\n *\n * @private\n */\nfunction setBlockTracking(value) {\n    isBlockTreeEnabled += value;\n}\nfunction setupBlock(vnode) {\n    // save current block children on the block vnode\n    vnode.dynamicChildren =\n        isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ARR : null;\n    // close block\n    closeBlock();\n    // a block is always going to be patched, so track it as a child of its\n    // parent block\n    if (isBlockTreeEnabled > 0 && currentBlock) {\n        currentBlock.push(vnode);\n    }\n    return vnode;\n}\n/**\n * @private\n */\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));\n}\n/**\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\n * A block root keeps track of dynamic nodes within the block in the\n * `dynamicChildren` array.\n *\n * @private\n */\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));\n}\nfunction isVNode(value) {\n    return value ? value.__v_isVNode === true : false;\n}\nfunction isSameVNodeType(n1, n2) {\n    if (( true) &&\n        n2.shapeFlag & 6 /* ShapeFlags.COMPONENT */ &&\n        hmrDirtyComponents.has(n2.type)) {\n        // #7042, ensure the vnode being unmounted during HMR\n        // bitwise operations to remove keep alive flags\n        n1.shapeFlag &= ~256 /* ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE */;\n        n2.shapeFlag &= ~512 /* ShapeFlags.COMPONENT_KEPT_ALIVE */;\n        // HMR only: if the component has been hot-updated, force a reload.\n        return false;\n    }\n    return n1.type === n2.type && n1.key === n2.key;\n}\nlet vnodeArgsTransformer;\n/**\n * Internal API for registering an arguments transform for createVNode\n * used for creating stubs in the test-utils\n * It is *internal* but needs to be exposed for test-utils to pick up proper\n * typings\n */\nfunction transformVNodeArgs(transformer) {\n    vnodeArgsTransformer = transformer;\n}\nconst createVNodeWithArgsTransform = (...args) => {\n    return _createVNode(...(vnodeArgsTransformer\n        ? vnodeArgsTransformer(args, currentRenderingInstance)\n        : args));\n};\nconst InternalObjectKey = `__vInternal`;\nconst normalizeKey = ({ key }) => key != null ? key : null;\nconst normalizeRef = ({ ref, ref_key, ref_for }) => {\n    return (ref != null\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ref)\n            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }\n            : ref\n        : null);\n};\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ShapeFlags.ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {\n    const vnode = {\n        __v_isVNode: true,\n        __v_skip: true,\n        type,\n        props,\n        key: props && normalizeKey(props),\n        ref: props && normalizeRef(props),\n        scopeId: currentScopeId,\n        slotScopeIds: null,\n        children,\n        component: null,\n        suspense: null,\n        ssContent: null,\n        ssFallback: null,\n        dirs: null,\n        transition: null,\n        el: null,\n        anchor: null,\n        target: null,\n        targetAnchor: null,\n        staticCount: 0,\n        shapeFlag,\n        patchFlag,\n        dynamicProps,\n        dynamicChildren: null,\n        appContext: null,\n        ctx: currentRenderingInstance\n    };\n    if (needFullChildrenNormalization) {\n        normalizeChildren(vnode, children);\n        // normalize suspense children\n        if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n            type.normalize(vnode);\n        }\n    }\n    else if (children) {\n        // compiled element vnode - if children is passed, only possible types are\n        // string or Array.\n        vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(children)\n            ? 8 /* ShapeFlags.TEXT_CHILDREN */\n            : 16 /* ShapeFlags.ARRAY_CHILDREN */;\n    }\n    // validate key\n    if (( true) && vnode.key !== vnode.key) {\n        warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\n    }\n    // track vnode for block tree\n    if (isBlockTreeEnabled > 0 &&\n        // avoid a block node from tracking itself\n        !isBlockNode &&\n        // has current parent block\n        currentBlock &&\n        // presence of a patch flag indicates this node needs patching on updates.\n        // component nodes also should always be patched, because even if the\n        // component doesn't need to update, it needs to persist the instance on to\n        // the next vnode so that it can be properly unmounted later.\n        (vnode.patchFlag > 0 || shapeFlag & 6 /* ShapeFlags.COMPONENT */) &&\n        // the EVENTS flag is only for hydration and if it is the only flag, the\n        // vnode should not be considered dynamic due to handler caching.\n        vnode.patchFlag !== 32 /* PatchFlags.HYDRATE_EVENTS */) {\n        currentBlock.push(vnode);\n    }\n    return vnode;\n}\nconst createVNode = (( true) ? createVNodeWithArgsTransform : 0);\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\n        if (( true) && !type) {\n            warn(`Invalid vnode type when creating vnode: ${type}.`);\n        }\n        type = Comment;\n    }\n    if (isVNode(type)) {\n        // createVNode receiving an existing vnode. This happens in cases like\n        // <component :is=\"vnode\"/>\n        // #2078 make sure to merge refs during the clone instead of overwriting it\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\n        if (children) {\n            normalizeChildren(cloned, children);\n        }\n        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n            if (cloned.shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n                currentBlock[currentBlock.indexOf(type)] = cloned;\n            }\n            else {\n                currentBlock.push(cloned);\n            }\n        }\n        cloned.patchFlag |= -2 /* PatchFlags.BAIL */;\n        return cloned;\n    }\n    // class component normalization.\n    if (isClassComponent(type)) {\n        type = type.__vccOpts;\n    }\n    // class & style normalization.\n    if (props) {\n        // for reactive or proxy objects, we need to clone it to enable mutation.\n        props = guardReactiveProps(props);\n        let { class: klass, style } = props;\n        if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(klass)) {\n            props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)(klass);\n        }\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(style)) {\n            // reactive state objects need to be cloned since they are likely to be\n            // mutated\n            if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(style)) {\n                style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, style);\n            }\n            props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)(style);\n        }\n    }\n    // encode the vnode type information into a bitmap\n    const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(type)\n        ? 1 /* ShapeFlags.ELEMENT */\n        : isSuspense(type)\n            ? 128 /* ShapeFlags.SUSPENSE */\n            : isTeleport(type)\n                ? 64 /* ShapeFlags.TELEPORT */\n                : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(type)\n                    ? 4 /* ShapeFlags.STATEFUL_COMPONENT */\n                    : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(type)\n                        ? 2 /* ShapeFlags.FUNCTIONAL_COMPONENT */\n                        : 0;\n    if (( true) && shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */ && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(type)) {\n        type = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(type);\n        warn(`Vue received a Component which was made a reactive object. This can ` +\n            `lead to unnecessary performance overhead, and should be avoided by ` +\n            `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\n            `instead of \\`ref\\`.`, `\\nComponent that was made reactive: `, type);\n    }\n    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);\n}\nfunction guardReactiveProps(props) {\n    if (!props)\n        return null;\n    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isProxy)(props) || InternalObjectKey in props\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, props)\n        : props;\n}\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\n    // This is intentionally NOT using spread or extend to avoid the runtime\n    // key enumeration cost.\n    const { props, ref, patchFlag, children } = vnode;\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n    const cloned = {\n        __v_isVNode: true,\n        __v_skip: true,\n        type: vnode.type,\n        props: mergedProps,\n        key: mergedProps && normalizeKey(mergedProps),\n        ref: extraProps && extraProps.ref\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n                // if the vnode itself already has a ref, cloneVNode will need to merge\n                // the refs so the single vnode can be set on multiple refs\n                mergeRef && ref\n                    ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(ref)\n                        ? ref.concat(normalizeRef(extraProps))\n                        : [ref, normalizeRef(extraProps)]\n                    : normalizeRef(extraProps)\n            : ref,\n        scopeId: vnode.scopeId,\n        slotScopeIds: vnode.slotScopeIds,\n        children: ( true) && patchFlag === -1 /* PatchFlags.HOISTED */ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)\n            ? children.map(deepCloneVNode)\n            : children,\n        target: vnode.target,\n        targetAnchor: vnode.targetAnchor,\n        staticCount: vnode.staticCount,\n        shapeFlag: vnode.shapeFlag,\n        // if the vnode is cloned with extra props, we can no longer assume its\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n        // note: preserve flag for fragments since they use the flag for children\n        // fast paths only.\n        patchFlag: extraProps && vnode.type !== Fragment\n            ? patchFlag === -1 // hoisted node\n                ? 16 /* PatchFlags.FULL_PROPS */\n                : patchFlag | 16 /* PatchFlags.FULL_PROPS */\n            : patchFlag,\n        dynamicProps: vnode.dynamicProps,\n        dynamicChildren: vnode.dynamicChildren,\n        appContext: vnode.appContext,\n        dirs: vnode.dirs,\n        transition: vnode.transition,\n        // These should technically only be non-null on mounted VNodes. However,\n        // they *should* be copied for kept-alive vnodes. So we just always copy\n        // them since them being non-null during a mount doesn't affect the logic as\n        // they will simply be overwritten.\n        component: vnode.component,\n        suspense: vnode.suspense,\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n        el: vnode.el,\n        anchor: vnode.anchor,\n        ctx: vnode.ctx,\n        ce: vnode.ce\n    };\n    return cloned;\n}\n/**\n * Dev only, for HMR of hoisted vnodes reused in v-for\n * https://github.com/vitejs/vite/issues/2022\n */\nfunction deepCloneVNode(vnode) {\n    const cloned = cloneVNode(vnode);\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(vnode.children)) {\n        cloned.children = vnode.children.map(deepCloneVNode);\n    }\n    return cloned;\n}\n/**\n * @private\n */\nfunction createTextVNode(text = ' ', flag = 0) {\n    return createVNode(Text, null, text, flag);\n}\n/**\n * @private\n */\nfunction createStaticVNode(content, numberOfNodes) {\n    // A static vnode can contain multiple stringified elements, and the number\n    // of elements is necessary for hydration.\n    const vnode = createVNode(Static, null, content);\n    vnode.staticCount = numberOfNodes;\n    return vnode;\n}\n/**\n * @private\n */\nfunction createCommentVNode(text = '', \n// when used as the v-else branch, the comment node must be created as a\n// block to ensure correct updates.\nasBlock = false) {\n    return asBlock\n        ? (openBlock(), createBlock(Comment, null, text))\n        : createVNode(Comment, null, text);\n}\nfunction normalizeVNode(child) {\n    if (child == null || typeof child === 'boolean') {\n        // empty placeholder\n        return createVNode(Comment);\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(child)) {\n        // fragment\n        return createVNode(Fragment, null, \n        // #3666, avoid reference pollution when reusing vnode\n        child.slice());\n    }\n    else if (typeof child === 'object') {\n        // already vnode, this should be the most common since compiled templates\n        // always produce all-vnode children arrays\n        return cloneIfMounted(child);\n    }\n    else {\n        // strings and numbers\n        return createVNode(Text, null, String(child));\n    }\n}\n// optimized normalization for template-compiled render fns\nfunction cloneIfMounted(child) {\n    return (child.el === null && child.patchFlag !== -1 /* PatchFlags.HOISTED */) ||\n        child.memo\n        ? child\n        : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n    let type = 0;\n    const { shapeFlag } = vnode;\n    if (children == null) {\n        children = null;\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(children)) {\n        type = 16 /* ShapeFlags.ARRAY_CHILDREN */;\n    }\n    else if (typeof children === 'object') {\n        if (shapeFlag & (1 /* ShapeFlags.ELEMENT */ | 64 /* ShapeFlags.TELEPORT */)) {\n            // Normalize slot to plain children for plain element and Teleport\n            const slot = children.default;\n            if (slot) {\n                // _c marker is added by withCtx() indicating this is a compiled slot\n                slot._c && (slot._d = false);\n                normalizeChildren(vnode, slot());\n                slot._c && (slot._d = true);\n            }\n            return;\n        }\n        else {\n            type = 32 /* ShapeFlags.SLOTS_CHILDREN */;\n            const slotFlag = children._;\n            if (!slotFlag && !(InternalObjectKey in children)) {\n                children._ctx = currentRenderingInstance;\n            }\n            else if (slotFlag === 3 /* SlotFlags.FORWARDED */ && currentRenderingInstance) {\n                // a child component receives forwarded slots from the parent.\n                // its slot type is determined by its parent's slot type.\n                if (currentRenderingInstance.slots._ === 1 /* SlotFlags.STABLE */) {\n                    children._ = 1 /* SlotFlags.STABLE */;\n                }\n                else {\n                    children._ = 2 /* SlotFlags.DYNAMIC */;\n                    vnode.patchFlag |= 1024 /* PatchFlags.DYNAMIC_SLOTS */;\n                }\n            }\n        }\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(children)) {\n        children = { default: children, _ctx: currentRenderingInstance };\n        type = 32 /* ShapeFlags.SLOTS_CHILDREN */;\n    }\n    else {\n        children = String(children);\n        // force teleport children to array so it can be moved around\n        if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n            type = 16 /* ShapeFlags.ARRAY_CHILDREN */;\n            children = [createTextVNode(children)];\n        }\n        else {\n            type = 8 /* ShapeFlags.TEXT_CHILDREN */;\n        }\n    }\n    vnode.children = children;\n    vnode.shapeFlag |= type;\n}\nfunction mergeProps(...args) {\n    const ret = {};\n    for (let i = 0; i < args.length; i++) {\n        const toMerge = args[i];\n        for (const key in toMerge) {\n            if (key === 'class') {\n                if (ret.class !== toMerge.class) {\n                    ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeClass)([ret.class, toMerge.class]);\n                }\n            }\n            else if (key === 'style') {\n                ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.normalizeStyle)([ret.style, toMerge.style]);\n            }\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n                const existing = ret[key];\n                const incoming = toMerge[key];\n                if (incoming &&\n                    existing !== incoming &&\n                    !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(existing) && existing.includes(incoming))) {\n                    ret[key] = existing\n                        ? [].concat(existing, incoming)\n                        : incoming;\n                }\n            }\n            else if (key !== '') {\n                ret[key] = toMerge[key];\n            }\n        }\n    }\n    return ret;\n}\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n    callWithAsyncErrorHandling(hook, instance, 7 /* ErrorCodes.VNODE_HOOK */, [\n        vnode,\n        prevVNode\n    ]);\n}\n\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n    const type = vnode.type;\n    // inherit parent app context - or - if root, adopt from root vnode\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n    const instance = {\n        uid: uid++,\n        vnode,\n        type,\n        parent,\n        appContext,\n        root: null,\n        next: null,\n        subTree: null,\n        effect: null,\n        update: null,\n        scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.EffectScope(true /* detached */),\n        render: null,\n        proxy: null,\n        exposed: null,\n        exposeProxy: null,\n        withProxy: null,\n        provides: parent ? parent.provides : Object.create(appContext.provides),\n        accessCache: null,\n        renderCache: [],\n        // local resolved assets\n        components: null,\n        directives: null,\n        // resolved props and emits options\n        propsOptions: normalizePropsOptions(type, appContext),\n        emitsOptions: normalizeEmitsOptions(type, appContext),\n        // emit\n        emit: null,\n        emitted: null,\n        // props default value\n        propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n        // inheritAttrs\n        inheritAttrs: type.inheritAttrs,\n        // state\n        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ,\n        setupContext: null,\n        // suspense related\n        suspense,\n        suspenseId: suspense ? suspense.pendingId : 0,\n        asyncDep: null,\n        asyncResolved: false,\n        // lifecycle hooks\n        // not using enums here because it results in computed properties\n        isMounted: false,\n        isUnmounted: false,\n        isDeactivated: false,\n        bc: null,\n        c: null,\n        bm: null,\n        m: null,\n        bu: null,\n        u: null,\n        um: null,\n        bum: null,\n        da: null,\n        a: null,\n        rtg: null,\n        rtc: null,\n        ec: null,\n        sp: null\n    };\n    if ((true)) {\n        instance.ctx = createDevRenderContext(instance);\n    }\n    else {}\n    instance.root = parent ? parent.root : instance;\n    instance.emit = emit.bind(null, instance);\n    // apply custom element special handling\n    if (vnode.ce) {\n        vnode.ce(instance);\n    }\n    return instance;\n}\nlet currentInstance = null;\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\nconst setCurrentInstance = (instance) => {\n    currentInstance = instance;\n    instance.scope.on();\n};\nconst unsetCurrentInstance = () => {\n    currentInstance && currentInstance.scope.off();\n    currentInstance = null;\n};\nconst isBuiltInTag = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.makeMap)('slot,component');\nfunction validateComponentName(name, config) {\n    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO;\n    if (isBuiltInTag(name) || appIsNativeTag(name)) {\n        warn('Do not use built-in or reserved HTML elements as component id: ' + name);\n    }\n}\nfunction isStatefulComponent(instance) {\n    return instance.vnode.shapeFlag & 4 /* ShapeFlags.STATEFUL_COMPONENT */;\n}\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance, isSSR = false) {\n    isInSSRComponentSetup = isSSR;\n    const { props, children } = instance.vnode;\n    const isStateful = isStatefulComponent(instance);\n    initProps(instance, props, isStateful, isSSR);\n    initSlots(instance, children);\n    const setupResult = isStateful\n        ? setupStatefulComponent(instance, isSSR)\n        : undefined;\n    isInSSRComponentSetup = false;\n    return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n    var _a;\n    const Component = instance.type;\n    if ((true)) {\n        if (Component.name) {\n            validateComponentName(Component.name, instance.appContext.config);\n        }\n        if (Component.components) {\n            const names = Object.keys(Component.components);\n            for (let i = 0; i < names.length; i++) {\n                validateComponentName(names[i], instance.appContext.config);\n            }\n        }\n        if (Component.directives) {\n            const names = Object.keys(Component.directives);\n            for (let i = 0; i < names.length; i++) {\n                validateDirectiveName(names[i]);\n            }\n        }\n        if (Component.compilerOptions && isRuntimeOnly()) {\n            warn(`\"compilerOptions\" is only supported when using a build of Vue that ` +\n                `includes the runtime compiler. Since you are using a runtime-only ` +\n                `build, the options should be passed via your build tool config instead.`);\n        }\n    }\n    // 0. create render proxy property access cache\n    instance.accessCache = Object.create(null);\n    // 1. create public instance / render proxy\n    // also mark it raw so it's never observed\n    instance.proxy = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(new Proxy(instance.ctx, PublicInstanceProxyHandlers));\n    if ((true)) {\n        exposePropsOnRenderContext(instance);\n    }\n    // 2. call setup()\n    const { setup } = Component;\n    if (setup) {\n        const setupContext = (instance.setupContext =\n            setup.length > 1 ? createSetupContext(instance) : null);\n        setCurrentInstance(instance);\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* ErrorCodes.SETUP_FUNCTION */, [( true) ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.props) : 0, setupContext]);\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n        unsetCurrentInstance();\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(setupResult)) {\n            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n            if (isSSR) {\n                // return the promise so server-renderer can wait on it\n                return setupResult\n                    .then((resolvedResult) => {\n                    handleSetupResult(instance, resolvedResult, isSSR);\n                })\n                    .catch(e => {\n                    handleError(e, instance, 0 /* ErrorCodes.SETUP_FUNCTION */);\n                });\n            }\n            else {\n                // async setup returned Promise.\n                // bail here and wait for re-entry.\n                instance.asyncDep = setupResult;\n                if (( true) && !instance.suspense) {\n                    const name = (_a = Component.name) !== null && _a !== void 0 ? _a : 'Anonymous';\n                    warn(`Component <${name}>: setup function returned a promise, but no ` +\n                        `<Suspense> boundary was found in the parent component tree. ` +\n                        `A component with async setup() must be nested in a <Suspense> ` +\n                        `in order to be rendered.`);\n                }\n            }\n        }\n        else {\n            handleSetupResult(instance, setupResult, isSSR);\n        }\n    }\n    else {\n        finishComponentSetup(instance, isSSR);\n    }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(setupResult)) {\n        // setup returned an inline render function\n        if (instance.type.__ssrInlineRender) {\n            // when the function's name is `ssrRender` (compiled by SFC inline mode),\n            // set it as ssrRender instead.\n            instance.ssrRender = setupResult;\n        }\n        else {\n            instance.render = setupResult;\n        }\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(setupResult)) {\n        if (( true) && isVNode(setupResult)) {\n            warn(`setup() should not return VNodes directly - ` +\n                `return a render function instead.`);\n        }\n        // setup returned bindings.\n        // assuming a render function compiled from template is present.\n        if (true) {\n            instance.devtoolsRawSetupState = setupResult;\n        }\n        instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)(setupResult);\n        if ((true)) {\n            exposeSetupStateOnRenderContext(instance);\n        }\n    }\n    else if (( true) && setupResult !== undefined) {\n        warn(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);\n    }\n    finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\n/**\n * For runtime-dom to register the compiler.\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\n */\nfunction registerRuntimeCompiler(_compile) {\n    compile = _compile;\n    installWithProxy = i => {\n        if (i.render._rc) {\n            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n        }\n    };\n}\n// dev only\nconst isRuntimeOnly = () => !compile;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n    const Component = instance.type;\n    // template / render function normalization\n    // could be already set when returned from setup()\n    if (!instance.render) {\n        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\n        // is done by server-renderer\n        if (!isSSR && compile && !Component.render) {\n            const template = Component.template ||\n                resolveMergedOptions(instance).template;\n            if (template) {\n                if ((true)) {\n                    startMeasure(instance, `compile`);\n                }\n                const { isCustomElement, compilerOptions } = instance.appContext.config;\n                const { delimiters, compilerOptions: componentCompilerOptions } = Component;\n                const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({\n                    isCustomElement,\n                    delimiters\n                }, compilerOptions), componentCompilerOptions);\n                Component.render = compile(template, finalCompilerOptions);\n                if ((true)) {\n                    endMeasure(instance, `compile`);\n                }\n            }\n        }\n        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP);\n        // for runtime-compiled render functions using `with` blocks, the render\n        // proxy used needs a different `has` handler which is more performant and\n        // also only allows a whitelist of globals to fallthrough.\n        if (installWithProxy) {\n            installWithProxy(instance);\n        }\n    }\n    // support for 2.x options\n    if (true) {\n        setCurrentInstance(instance);\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.pauseTracking)();\n        applyOptions(instance);\n        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.resetTracking)();\n        unsetCurrentInstance();\n    }\n    // warn missing template/render\n    // the runtime compilation of template in SSR is done by server-render\n    if (( true) && !Component.render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NOOP && !isSSR) {\n        /* istanbul ignore if */\n        if (!compile && Component.template) {\n            warn(`Component provided template option but ` +\n                `runtime compilation is not supported in this build of Vue.` +\n                (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\n                    ) /* should not happen */);\n        }\n        else {\n            warn(`Component is missing template or render function.`);\n        }\n    }\n}\nfunction createAttrsProxy(instance) {\n    return new Proxy(instance.attrs, ( true)\n        ? {\n            get(target, key) {\n                markAttrsAccessed();\n                (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.track)(instance, \"get\" /* TrackOpTypes.GET */, '$attrs');\n                return target[key];\n            },\n            set() {\n                warn(`setupContext.attrs is readonly.`);\n                return false;\n            },\n            deleteProperty() {\n                warn(`setupContext.attrs is readonly.`);\n                return false;\n            }\n        }\n        : 0);\n}\nfunction createSetupContext(instance) {\n    const expose = exposed => {\n        if ((true)) {\n            if (instance.exposed) {\n                warn(`expose() should be called only once per setup().`);\n            }\n            if (exposed != null) {\n                let exposedType = typeof exposed;\n                if (exposedType === 'object') {\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(exposed)) {\n                        exposedType = 'array';\n                    }\n                    else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(exposed)) {\n                        exposedType = 'ref';\n                    }\n                }\n                if (exposedType !== 'object') {\n                    warn(`expose() should be passed a plain object, received ${exposedType}.`);\n                }\n            }\n        }\n        instance.exposed = exposed || {};\n    };\n    let attrs;\n    if ((true)) {\n        // We use getters in dev in case libs like test-utils overwrite instance\n        // properties (overwrites should not be done in prod)\n        return Object.freeze({\n            get attrs() {\n                return attrs || (attrs = createAttrsProxy(instance));\n            },\n            get slots() {\n                return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly)(instance.slots);\n            },\n            get emit() {\n                return (event, ...args) => instance.emit(event, ...args);\n            },\n            expose\n        });\n    }\n    else {}\n}\nfunction getExposeProxy(instance) {\n    if (instance.exposed) {\n        return (instance.exposeProxy ||\n            (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.proxyRefs)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.markRaw)(instance.exposed)), {\n                get(target, key) {\n                    if (key in target) {\n                        return target[key];\n                    }\n                    else if (key in publicPropertiesMap) {\n                        return publicPropertiesMap[key](instance);\n                    }\n                },\n                has(target, key) {\n                    return key in target || key in publicPropertiesMap;\n                }\n            })));\n    }\n}\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\nfunction getComponentName(Component, includeInferred = true) {\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Component)\n        ? Component.displayName || Component.name\n        : Component.name || (includeInferred && Component.__name);\n}\n/* istanbul ignore next */\nfunction formatComponentName(instance, Component, isRoot = false) {\n    let name = getComponentName(Component);\n    if (!name && Component.__file) {\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n        if (match) {\n            name = match[1];\n        }\n    }\n    if (!name && instance && instance.parent) {\n        // try to infer the name based on reverse resolution\n        const inferFromRegistry = (registry) => {\n            for (const key in registry) {\n                if (registry[key] === Component) {\n                    return key;\n                }\n            }\n        };\n        name =\n            inferFromRegistry(instance.components ||\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n    }\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\nfunction isClassComponent(value) {\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value) && '__vccOpts' in value;\n}\n\nconst computed = ((getterOrOptions, debugOptions) => {\n    // @ts-ignore\n    return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.computed)(getterOrOptions, debugOptions, isInSSRComponentSetup);\n});\n\n// dev only\nconst warnRuntimeUsage = (method) => warn(`${method}() is a compiler-hint helper that is only usable inside ` +\n    `<script setup> of a single file component. Its arguments should be ` +\n    `compiled away and passing it at runtime has no effect.`);\n// implementation\nfunction defineProps() {\n    if ((true)) {\n        warnRuntimeUsage(`defineProps`);\n    }\n    return null;\n}\n// implementation\nfunction defineEmits() {\n    if ((true)) {\n        warnRuntimeUsage(`defineEmits`);\n    }\n    return null;\n}\n/**\n * Vue `<script setup>` compiler macro for declaring a component's exposed\n * instance properties when it is accessed by a parent component via template\n * refs.\n *\n * `<script setup>` components are closed by default - i.e. variables inside\n * the `<script setup>` scope is not exposed to parent unless explicitly exposed\n * via `defineExpose`.\n *\n * This is only usable inside `<script setup>`, is compiled away in the\n * output and should **not** be actually called at runtime.\n */\nfunction defineExpose(exposed) {\n    if ((true)) {\n        warnRuntimeUsage(`defineExpose`);\n    }\n}\n/**\n * Vue `<script setup>` compiler macro for providing props default values when\n * using type-based `defineProps` declaration.\n *\n * Example usage:\n * ```ts\n * withDefaults(defineProps<{\n *   size?: number\n *   labels?: string[]\n * }>(), {\n *   size: 3,\n *   labels: () => ['default label']\n * })\n * ```\n *\n * This is only usable inside `<script setup>`, is compiled away in the output\n * and should **not** be actually called at runtime.\n */\nfunction withDefaults(props, defaults) {\n    if ((true)) {\n        warnRuntimeUsage(`withDefaults`);\n    }\n    return null;\n}\nfunction useSlots() {\n    return getContext().slots;\n}\nfunction useAttrs() {\n    return getContext().attrs;\n}\nfunction getContext() {\n    const i = getCurrentInstance();\n    if (( true) && !i) {\n        warn(`useContext() called without active instance.`);\n    }\n    return i.setupContext || (i.setupContext = createSetupContext(i));\n}\n/**\n * Runtime helper for merging default declarations. Imported by compiled code\n * only.\n * @internal\n */\nfunction mergeDefaults(raw, defaults) {\n    const props = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(raw)\n        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})\n        : raw;\n    for (const key in defaults) {\n        const opt = props[key];\n        if (opt) {\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {\n                props[key] = { type: opt, default: defaults[key] };\n            }\n            else {\n                opt.default = defaults[key];\n            }\n        }\n        else if (opt === null) {\n            props[key] = { default: defaults[key] };\n        }\n        else if ((true)) {\n            warn(`props default key \"${key}\" has no corresponding declaration.`);\n        }\n    }\n    return props;\n}\n/**\n * Used to create a proxy for the rest element when destructuring props with\n * defineProps().\n * @internal\n */\nfunction createPropsRestProxy(props, excludedKeys) {\n    const ret = {};\n    for (const key in props) {\n        if (!excludedKeys.includes(key)) {\n            Object.defineProperty(ret, key, {\n                enumerable: true,\n                get: () => props[key]\n            });\n        }\n    }\n    return ret;\n}\n/**\n * `<script setup>` helper for persisting the current instance context over\n * async/await flows.\n *\n * `@vue/compiler-sfc` converts the following:\n *\n * ```ts\n * const x = await foo()\n * ```\n *\n * into:\n *\n * ```ts\n * let __temp, __restore\n * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\n * ```\n * @internal\n */\nfunction withAsyncContext(getAwaitable) {\n    const ctx = getCurrentInstance();\n    if (( true) && !ctx) {\n        warn(`withAsyncContext called without active current instance. ` +\n            `This is likely a bug.`);\n    }\n    let awaitable = getAwaitable();\n    unsetCurrentInstance();\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isPromise)(awaitable)) {\n        awaitable = awaitable.catch(e => {\n            setCurrentInstance(ctx);\n            throw e;\n        });\n    }\n    return [awaitable, () => setCurrentInstance(ctx)];\n}\n\n// Actual implementation\nfunction h(type, propsOrChildren, children) {\n    const l = arguments.length;\n    if (l === 2) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(propsOrChildren)) {\n            // single vnode without props\n            if (isVNode(propsOrChildren)) {\n                return createVNode(type, null, [propsOrChildren]);\n            }\n            // props without children\n            return createVNode(type, propsOrChildren);\n        }\n        else {\n            // omit props\n            return createVNode(type, null, propsOrChildren);\n        }\n    }\n    else {\n        if (l > 3) {\n            children = Array.prototype.slice.call(arguments, 2);\n        }\n        else if (l === 3 && isVNode(children)) {\n            children = [children];\n        }\n        return createVNode(type, propsOrChildren, children);\n    }\n}\n\nconst ssrContextKey = Symbol(( true) ? `ssrContext` : 0);\nconst useSSRContext = () => {\n    {\n        const ctx = inject(ssrContextKey);\n        if (!ctx) {\n            ( true) &&\n                warn(`Server rendering context not provided. Make sure to only call ` +\n                    `useSSRContext() conditionally in the server build.`);\n        }\n        return ctx;\n    }\n};\n\nfunction isShallow(value) {\n    return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\n\nfunction initCustomFormatter() {\n    /* eslint-disable no-restricted-globals */\n    if ( false || typeof window === 'undefined') {\n        return;\n    }\n    const vueStyle = { style: 'color:#3ba776' };\n    const numberStyle = { style: 'color:#0b1bc9' };\n    const stringStyle = { style: 'color:#b62e24' };\n    const keywordStyle = { style: 'color:#9d288c' };\n    // custom formatter for Chrome\n    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\n    const formatter = {\n        header(obj) {\n            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {\n                return null;\n            }\n            if (obj.__isVue) {\n                return ['div', vueStyle, `VueInstance`];\n            }\n            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isRef)(obj)) {\n                return [\n                    'div',\n                    {},\n                    ['span', vueStyle, genRefFlag(obj)],\n                    '<',\n                    formatValue(obj.value),\n                    `>`\n                ];\n            }\n            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReactive)(obj)) {\n                return [\n                    'div',\n                    {},\n                    ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],\n                    '<',\n                    formatValue(obj),\n                    `>${(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj) ? ` (readonly)` : ``}`\n                ];\n            }\n            else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.isReadonly)(obj)) {\n                return [\n                    'div',\n                    {},\n                    ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],\n                    '<',\n                    formatValue(obj),\n                    '>'\n                ];\n            }\n            return null;\n        },\n        hasBody(obj) {\n            return obj && obj.__isVue;\n        },\n        body(obj) {\n            if (obj && obj.__isVue) {\n                return [\n                    'div',\n                    {},\n                    ...formatInstance(obj.$)\n                ];\n            }\n        }\n    };\n    function formatInstance(instance) {\n        const blocks = [];\n        if (instance.type.props && instance.props) {\n            blocks.push(createInstanceBlock('props', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.props)));\n        }\n        if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n            blocks.push(createInstanceBlock('setup', instance.setupState));\n        }\n        if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {\n            blocks.push(createInstanceBlock('data', (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(instance.data)));\n        }\n        const computed = extractKeys(instance, 'computed');\n        if (computed) {\n            blocks.push(createInstanceBlock('computed', computed));\n        }\n        const injected = extractKeys(instance, 'inject');\n        if (injected) {\n            blocks.push(createInstanceBlock('injected', injected));\n        }\n        blocks.push([\n            'div',\n            {},\n            [\n                'span',\n                {\n                    style: keywordStyle.style + ';opacity:0.66'\n                },\n                '$ (internal): '\n            ],\n            ['object', { object: instance }]\n        ]);\n        return blocks;\n    }\n    function createInstanceBlock(type, target) {\n        target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, target);\n        if (!Object.keys(target).length) {\n            return ['span', {}];\n        }\n        return [\n            'div',\n            { style: 'line-height:1.25em;margin-bottom:0.6em' },\n            [\n                'div',\n                {\n                    style: 'color:#476582'\n                },\n                type\n            ],\n            [\n                'div',\n                {\n                    style: 'padding-left:1.25em'\n                },\n                ...Object.keys(target).map(key => {\n                    return [\n                        'div',\n                        {},\n                        ['span', keywordStyle, key + ': '],\n                        formatValue(target[key], false)\n                    ];\n                })\n            ]\n        ];\n    }\n    function formatValue(v, asRaw = true) {\n        if (typeof v === 'number') {\n            return ['span', numberStyle, v];\n        }\n        else if (typeof v === 'string') {\n            return ['span', stringStyle, JSON.stringify(v)];\n        }\n        else if (typeof v === 'boolean') {\n            return ['span', keywordStyle, v];\n        }\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(v)) {\n            return ['object', { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.toRaw)(v) : v }];\n        }\n        else {\n            return ['span', stringStyle, String(v)];\n        }\n    }\n    function extractKeys(instance, type) {\n        const Comp = instance.type;\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(Comp)) {\n            return;\n        }\n        const extracted = {};\n        for (const key in instance.ctx) {\n            if (isKeyOfType(Comp, key, type)) {\n                extracted[key] = instance.ctx[key];\n            }\n        }\n        return extracted;\n    }\n    function isKeyOfType(Comp, key, type) {\n        const opts = Comp[type];\n        if (((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(opts) && opts.includes(key)) ||\n            ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(opts) && key in opts)) {\n            return true;\n        }\n        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n            return true;\n        }\n        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\n            return true;\n        }\n    }\n    function genRefFlag(v) {\n        if (isShallow(v)) {\n            return `ShallowRef`;\n        }\n        if (v.effect) {\n            return `ComputedRef`;\n        }\n        return `Ref`;\n    }\n    if (window.devtoolsFormatters) {\n        window.devtoolsFormatters.push(formatter);\n    }\n    else {\n        window.devtoolsFormatters = [formatter];\n    }\n}\n\nfunction withMemo(memo, render, cache, index) {\n    const cached = cache[index];\n    if (cached && isMemoSame(cached, memo)) {\n        return cached;\n    }\n    const ret = render();\n    // shallow clone\n    ret.memo = memo.slice();\n    return (cache[index] = ret);\n}\nfunction isMemoSame(cached, memo) {\n    const prev = cached.memo;\n    if (prev.length != memo.length) {\n        return false;\n    }\n    for (let i = 0; i < prev.length; i++) {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hasChanged)(prev[i], memo[i])) {\n            return false;\n        }\n    }\n    // make sure to let parent block track it when returning cached\n    if (isBlockTreeEnabled > 0 && currentBlock) {\n        currentBlock.push(cached);\n    }\n    return true;\n}\n\n// Core API ------------------------------------------------------------------\nconst version = \"3.2.47\";\nconst _ssrUtils = {\n    createComponentInstance,\n    setupComponent,\n    renderComponentRoot,\n    setCurrentRenderingInstance,\n    isVNode,\n    normalizeVNode\n};\n/**\n * SSR utils for \\@vue/server-renderer. Only exposed in ssr-possible builds.\n * @internal\n */\nconst ssrUtils = (_ssrUtils );\n/**\n * @internal only exposed in compat builds\n */\nconst resolveFilter = null;\n/**\n * @internal only exposed in compat builds.\n */\nconst compatUtils = (null);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvZGlzdC9ydW50aW1lLWNvcmUuZXNtLWJ1bmRsZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtUztBQUN5QjtBQUNrSDtBQUM1Uzs7QUFFbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBd0M7QUFDaEQsUUFBUSxFQUFPO0FBQ2Y7QUFDQTtBQUNBLElBQUksOERBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLFlBQVksMENBQTBDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4REFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pELCtDQUErQyxjQUFjO0FBQzdEO0FBQ0EseUJBQXlCLHlEQUF5RDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBUTtBQUNoQjtBQUNBLGlD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QUFDQSxTQUFTLElBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFxQztBQUN4RDtBQUNBLFVBQVUsQ0FBSTtBQUNkO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0EscUJBQXFCLEtBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0NBQWtDLGNBQWMsUUFBUTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQXFDO0FBQzFDLElBQUksMERBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBTztBQUNmO0FBQ0E7QUFDQSxhQUFhLHFEQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLHFEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQXFDO0FBQy9ELDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkRBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQWdFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFODJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL2Rpc3QvcnVudGltZS1jb3JlLmVzbS1idW5kbGVyLmpzP2QyZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGF1c2VUcmFja2luZywgcmVzZXRUcmFja2luZywgaXNSZWYsIHRvUmF3LCBnZXRDdXJyZW50U2NvcGUsIGlzU2hhbGxvdyBhcyBpc1NoYWxsb3ckMSwgaXNSZWFjdGl2ZSwgUmVhY3RpdmVFZmZlY3QsIHJlZiwgc2hhbGxvd1JlYWRvbmx5LCB0cmFjaywgcmVhY3RpdmUsIHNoYWxsb3dSZWFjdGl2ZSwgdHJpZ2dlciwgaXNQcm94eSwgcHJveHlSZWZzLCBtYXJrUmF3LCBFZmZlY3RTY29wZSwgY29tcHV0ZWQgYXMgY29tcHV0ZWQkMSwgaXNSZWFkb25seSB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5leHBvcnQgeyBFZmZlY3RTY29wZSwgUmVhY3RpdmVFZmZlY3QsIGN1c3RvbVJlZiwgZWZmZWN0LCBlZmZlY3RTY29wZSwgZ2V0Q3VycmVudFNjb3BlLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmlnZ2VyUmVmLCB1bnJlZiB9IGZyb20gJ0B2dWUvcmVhY3Rpdml0eSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNGdW5jdGlvbiwgaXNQcm9taXNlLCBpc0FycmF5LCBOT09QLCBnZXRHbG9iYWxUaGlzLCBleHRlbmQsIEVNUFRZX09CSiwgdG9IYW5kbGVyS2V5LCBsb29zZVRvTnVtYmVyLCBoeXBoZW5hdGUsIGNhbWVsaXplLCBpc09iamVjdCwgaXNPbiwgaGFzT3duLCBpc01vZGVsTGlzdGVuZXIsIHRvTnVtYmVyLCBoYXNDaGFuZ2VkLCByZW1vdmUsIGlzU2V0LCBpc01hcCwgaXNQbGFpbk9iamVjdCwgaW52b2tlQXJyYXlGbnMsIGlzUmVnRXhwLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGNhcGl0YWxpemUsIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgZGVmLCBpc1Jlc2VydmVkUHJvcCwgRU1QVFlfQVJSLCB0b1Jhd1R5cGUsIG1ha2VNYXAsIE5PLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplU3R5bGUgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5leHBvcnQgeyBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXkgfSBmcm9tICdAdnVlL3NoYXJlZCc7XG5cbmNvbnN0IHN0YWNrID0gW107XG5mdW5jdGlvbiBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpIHtcbiAgICBzdGFjay5wdXNoKHZub2RlKTtcbn1cbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xuICAgIHN0YWNrLnBvcCgpO1xufVxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIGF2b2lkIHByb3BzIGZvcm1hdHRpbmcgb3Igd2FybiBoYW5kbGVyIHRyYWNraW5nIGRlcHMgdGhhdCBtaWdodCBiZSBtdXRhdGVkXG4gICAgLy8gZHVyaW5nIHBhdGNoLCBsZWFkaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBzdGFjay5sZW5ndGggPyBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5jb21wb25lbnQgOiBudWxsO1xuICAgIGNvbnN0IGFwcFdhcm5IYW5kbGVyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcud2FybkhhbmRsZXI7XG4gICAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xuICAgIGlmIChhcHBXYXJuSGFuZGxlcikge1xuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwV2FybkhhbmRsZXIsIGluc3RhbmNlLCAxMSAvKiBFcnJvckNvZGVzLkFQUF9XQVJOX0hBTkRMRVIgKi8sIFtcbiAgICAgICAgICAgIG1zZyArIGFyZ3Muam9pbignJyksXG4gICAgICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcbiAgICAgICAgICAgIHRyYWNlXG4gICAgICAgICAgICAgICAgLm1hcCgoeyB2bm9kZSB9KSA9PiBgYXQgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgdm5vZGUudHlwZSl9PmApXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgdHJhY2VcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB3YXJuQXJncyA9IFtgW1Z1ZSB3YXJuXTogJHttc2d9YCwgLi4uYXJnc107XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodHJhY2UubGVuZ3RoICYmXG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFtbWluZyBjb25zb2xlIGR1cmluZyB0ZXN0c1xuICAgICAgICAgICAgIWZhbHNlKSB7XG4gICAgICAgICAgICB3YXJuQXJncy5wdXNoKGBcXG5gLCAuLi5mb3JtYXRUcmFjZSh0cmFjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XG4gICAgfVxuICAgIHJlc2V0VHJhY2tpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRyYWNlKCkge1xuICAgIGxldCBjdXJyZW50Vk5vZGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWN1cnJlbnRWTm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBzdGFjayBiZWNhdXNlIGl0IHdpbGwgYmUgaW5jb21wbGV0ZSBkdXJpbmcgdXBkYXRlc1xuICAgIC8vIHRoYXQgZGlkIG5vdCBzdGFydCBmcm9tIHRoZSByb290LiBSZS1jb25zdHJ1Y3QgdGhlIHBhcmVudCBjaGFpbiB1c2luZ1xuICAgIC8vIGluc3RhbmNlIHBhcmVudCBwb2ludGVycy5cbiAgICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcbiAgICB3aGlsZSAoY3VycmVudFZOb2RlKSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBub3JtYWxpemVkU3RhY2tbMF07XG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xuICAgICAgICAgICAgbGFzdC5yZWN1cnNlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB2bm9kZTogY3VycmVudFZOb2RlLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2VDb3VudDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xuICAgICAgICBjdXJyZW50Vk5vZGUgPSBwYXJlbnRJbnN0YW5jZSAmJiBwYXJlbnRJbnN0YW5jZS52bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xuICAgIGNvbnN0IGxvZ3MgPSBbXTtcbiAgICB0cmFjZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgICAgICBsb2dzLnB1c2goLi4uKGkgPT09IDAgPyBbXSA6IFtgXFxuYF0pLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvZ3M7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFjZUVudHJ5KHsgdm5vZGUsIHJlY3Vyc2VDb3VudCB9KSB7XG4gICAgY29uc3QgcG9zdGZpeCA9IHJlY3Vyc2VDb3VudCA+IDAgPyBgLi4uICgke3JlY3Vyc2VDb3VudH0gcmVjdXJzaXZlIGNhbGxzKWAgOiBgYDtcbiAgICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcbiAgICBjb25zdCBvcGVuID0gYCBhdCA8JHtmb3JtYXRDb21wb25lbnROYW1lKHZub2RlLmNvbXBvbmVudCwgdm5vZGUudHlwZSwgaXNSb290KX1gO1xuICAgIGNvbnN0IGNsb3NlID0gYD5gICsgcG9zdGZpeDtcbiAgICByZXR1cm4gdm5vZGUucHJvcHNcbiAgICAgICAgPyBbb3BlbiwgLi4uZm9ybWF0UHJvcHModm5vZGUucHJvcHMpLCBjbG9zZV1cbiAgICAgICAgOiBbb3BlbiArIGNsb3NlXTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBmb3JtYXRQcm9wcyhwcm9wcykge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAga2V5cy5zbGljZSgwLCAzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XG4gICAgfSk7XG4gICAgaWYgKGtleXMubGVuZ3RoID4gMykge1xuICAgICAgICByZXMucHVzaChgIC4uLmApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGZvcm1hdFByb3Aoa2V5LCB2YWx1ZSwgcmF3KSB7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fFxuICAgICAgICB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IGZvcm1hdFByb3Aoa2V5LCB0b1Jhdyh2YWx1ZS52YWx1ZSksIHRydWUpO1xuICAgICAgICByZXR1cm4gcmF3ID8gdmFsdWUgOiBbYCR7a2V5fT1SZWY8YCwgdmFsdWUsIGA+YF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbYCR7a2V5fT1mbiR7dmFsdWUubmFtZSA/IGA8JHt2YWx1ZS5uYW1lfT5gIDogYGB9YF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE51bWJlcih2YWwsIHR5cGUpIHtcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHdhcm4oYCR7dHlwZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICB3YXJuKGAke3R5cGV9IGlzIE5hTiAtIGAgKyAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicpO1xuICAgIH1cbn1cblxuY29uc3QgRXJyb3JUeXBlU3RyaW5ncyA9IHtcbiAgICBbXCJzcFwiIC8qIExpZmVjeWNsZUhvb2tzLlNFUlZFUl9QUkVGRVRDSCAqL106ICdzZXJ2ZXJQcmVmZXRjaCBob29rJyxcbiAgICBbXCJiY1wiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9DUkVBVEUgKi9dOiAnYmVmb3JlQ3JlYXRlIGhvb2snLFxuICAgIFtcImNcIiAvKiBMaWZlY3ljbGVIb29rcy5DUkVBVEVEICovXTogJ2NyZWF0ZWQgaG9vaycsXG4gICAgW1wiYm1cIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfTU9VTlQgKi9dOiAnYmVmb3JlTW91bnQgaG9vaycsXG4gICAgW1wibVwiIC8qIExpZmVjeWNsZUhvb2tzLk1PVU5URUQgKi9dOiAnbW91bnRlZCBob29rJyxcbiAgICBbXCJidVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9VUERBVEUgKi9dOiAnYmVmb3JlVXBkYXRlIGhvb2snLFxuICAgIFtcInVcIiAvKiBMaWZlY3ljbGVIb29rcy5VUERBVEVEICovXTogJ3VwZGF0ZWQnLFxuICAgIFtcImJ1bVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9VTk1PVU5UICovXTogJ2JlZm9yZVVubW91bnQgaG9vaycsXG4gICAgW1widW1cIiAvKiBMaWZlY3ljbGVIb29rcy5VTk1PVU5URUQgKi9dOiAndW5tb3VudGVkIGhvb2snLFxuICAgIFtcImFcIiAvKiBMaWZlY3ljbGVIb29rcy5BQ1RJVkFURUQgKi9dOiAnYWN0aXZhdGVkIGhvb2snLFxuICAgIFtcImRhXCIgLyogTGlmZWN5Y2xlSG9va3MuREVBQ1RJVkFURUQgKi9dOiAnZGVhY3RpdmF0ZWQgaG9vaycsXG4gICAgW1wiZWNcIiAvKiBMaWZlY3ljbGVIb29rcy5FUlJPUl9DQVBUVVJFRCAqL106ICdlcnJvckNhcHR1cmVkIGhvb2snLFxuICAgIFtcInJ0Y1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUkFDS0VEICovXTogJ3JlbmRlclRyYWNrZWQgaG9vaycsXG4gICAgW1wicnRnXCIgLyogTGlmZWN5Y2xlSG9va3MuUkVOREVSX1RSSUdHRVJFRCAqL106ICdyZW5kZXJUcmlnZ2VyZWQgaG9vaycsXG4gICAgWzAgLyogRXJyb3JDb2Rlcy5TRVRVUF9GVU5DVElPTiAqL106ICdzZXR1cCBmdW5jdGlvbicsXG4gICAgWzEgLyogRXJyb3JDb2Rlcy5SRU5ERVJfRlVOQ1RJT04gKi9dOiAncmVuZGVyIGZ1bmN0aW9uJyxcbiAgICBbMiAvKiBFcnJvckNvZGVzLldBVENIX0dFVFRFUiAqL106ICd3YXRjaGVyIGdldHRlcicsXG4gICAgWzMgLyogRXJyb3JDb2Rlcy5XQVRDSF9DQUxMQkFDSyAqL106ICd3YXRjaGVyIGNhbGxiYWNrJyxcbiAgICBbNCAvKiBFcnJvckNvZGVzLldBVENIX0NMRUFOVVAgKi9dOiAnd2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uJyxcbiAgICBbNSAvKiBFcnJvckNvZGVzLk5BVElWRV9FVkVOVF9IQU5ETEVSICovXTogJ25hdGl2ZSBldmVudCBoYW5kbGVyJyxcbiAgICBbNiAvKiBFcnJvckNvZGVzLkNPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovXTogJ2NvbXBvbmVudCBldmVudCBoYW5kbGVyJyxcbiAgICBbNyAvKiBFcnJvckNvZGVzLlZOT0RFX0hPT0sgKi9dOiAndm5vZGUgaG9vaycsXG4gICAgWzggLyogRXJyb3JDb2Rlcy5ESVJFQ1RJVkVfSE9PSyAqL106ICdkaXJlY3RpdmUgaG9vaycsXG4gICAgWzkgLyogRXJyb3JDb2Rlcy5UUkFOU0lUSU9OX0hPT0sgKi9dOiAndHJhbnNpdGlvbiBob29rJyxcbiAgICBbMTAgLyogRXJyb3JDb2Rlcy5BUFBfRVJST1JfSEFORExFUiAqL106ICdhcHAgZXJyb3JIYW5kbGVyJyxcbiAgICBbMTEgLyogRXJyb3JDb2Rlcy5BUFBfV0FSTl9IQU5ETEVSICovXTogJ2FwcCB3YXJuSGFuZGxlcicsXG4gICAgWzEyIC8qIEVycm9yQ29kZXMuRlVOQ1RJT05fUkVGICovXTogJ3JlZiBmdW5jdGlvbicsXG4gICAgWzEzIC8qIEVycm9yQ29kZXMuQVNZTkNfQ09NUE9ORU5UX0xPQURFUiAqL106ICdhc3luYyBjb21wb25lbnQgbG9hZGVyJyxcbiAgICBbMTQgLyogRXJyb3JDb2Rlcy5TQ0hFRFVMRVIgKi9dOiAnc2NoZWR1bGVyIGZsdXNoLiBUaGlzIGlzIGxpa2VseSBhIFZ1ZSBpbnRlcm5hbHMgYnVnLiAnICtcbiAgICAgICAgJ1BsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vbmV3LWlzc3VlLnZ1ZWpzLm9yZy8/cmVwbz12dWVqcy9jb3JlJ1xufTtcbmZ1bmN0aW9uIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGFyZ3MgPyBmbiguLi5hcmdzKSA6IGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbiwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncyk7XG4gICAgICAgIGlmIChyZXMgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgICAgIHJlcy5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZXMucHVzaChjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhmbltpXSwgaW5zdGFuY2UsIHR5cGUsIGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XG4gICAgY29uc3QgY29udGV4dFZOb2RlID0gaW5zdGFuY2UgPyBpbnN0YW5jZS52bm9kZSA6IG51bGw7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgICAgIC8vIHRoZSBleHBvc2VkIGluc3RhbmNlIGlzIHRoZSByZW5kZXIgcHJveHkgdG8ga2VlcCBpdCBjb25zaXN0ZW50IHdpdGggMi54XG4gICAgICAgIGNvbnN0IGV4cG9zZWRJbnN0YW5jZSA9IGluc3RhbmNlLnByb3h5O1xuICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBob29rIHJlY2VpdmVzIG9ubHkgdGhlIGVycm9yIGNvZGVcbiAgICAgICAgY29uc3QgZXJyb3JJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gRXJyb3JUeXBlU3RyaW5nc1t0eXBlXSA6IHR5cGU7XG4gICAgICAgIHdoaWxlIChjdXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcbiAgICAgICAgICAgIGlmIChlcnJvckNhcHR1cmVkSG9va3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9yQ2FwdHVyZWRIb29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHAtbGV2ZWwgaGFuZGxpbmdcbiAgICAgICAgY29uc3QgYXBwRXJyb3JIYW5kbGVyID0gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZXJyb3JIYW5kbGVyO1xuICAgICAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoYXBwRXJyb3JIYW5kbGVyLCBudWxsLCAxMCAvKiBFcnJvckNvZGVzLkFQUF9FUlJPUl9IQU5ETEVSICovLCBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb10pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2KTtcbn1cbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IEVycm9yVHlwZVN0cmluZ3NbdHlwZV07XG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChjb250ZXh0Vk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHdhcm4oYFVuaGFuZGxlZCBlcnJvciR7aW5mbyA/IGAgZHVyaW5nIGV4ZWN1dGlvbiBvZiAke2luZm99YCA6IGBgfWApO1xuICAgICAgICBpZiAoY29udGV4dFZOb2RlKSB7XG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyYXNoIGluIGRldiBieSBkZWZhdWx0IHNvIGl0J3MgbW9yZSBub3RpY2VhYmxlXG4gICAgICAgIGlmICh0aHJvd0luRGV2KSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHJlY292ZXIgaW4gcHJvZCB0byByZWR1Y2UgdGhlIGltcGFjdCBvbiBlbmQtdXNlclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxufVxuXG5sZXQgaXNGbHVzaGluZyA9IGZhbHNlO1xubGV0IGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XG5jb25zdCBxdWV1ZSA9IFtdO1xubGV0IGZsdXNoSW5kZXggPSAwO1xuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xubGV0IGFjdGl2ZVBvc3RGbHVzaENicyA9IG51bGw7XG5sZXQgcG9zdEZsdXNoSW5kZXggPSAwO1xuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyojX19QVVJFX18qLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbmNvbnN0IFJFQ1VSU0lPTl9MSU1JVCA9IDEwMDtcbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xuICAgIHJldHVybiBmbiA/IHAudGhlbih0aGlzID8gZm4uYmluZCh0aGlzKSA6IGZuKSA6IHA7XG59XG4vLyAjMjc2OFxuLy8gVXNlIGJpbmFyeS1zZWFyY2ggdG8gZmluZCBhIHN1aXRhYmxlIHBvc2l0aW9uIGluIHRoZSBxdWV1ZSxcbi8vIHNvIHRoYXQgdGhlIHF1ZXVlIG1haW50YWlucyB0aGUgaW5jcmVhc2luZyBvcmRlciBvZiBqb2IncyBpZCxcbi8vIHdoaWNoIGNhbiBwcmV2ZW50IHRoZSBqb2IgZnJvbSBiZWluZyBza2lwcGVkIGFuZCBhbHNvIGNhbiBhdm9pZCByZXBlYXRlZCBwYXRjaGluZy5cbmZ1bmN0aW9uIGZpbmRJbnNlcnRpb25JbmRleChpZCkge1xuICAgIC8vIHRoZSBzdGFydCBpbmRleCBzaG91bGQgYmUgYGZsdXNoSW5kZXggKyAxYFxuICAgIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xuICAgIGxldCBlbmQgPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IChzdGFydCArIGVuZCkgPj4+IDE7XG4gICAgICAgIGNvbnN0IG1pZGRsZUpvYklkID0gZ2V0SWQocXVldWVbbWlkZGxlXSk7XG4gICAgICAgIG1pZGRsZUpvYklkIDwgaWQgPyAoc3RhcnQgPSBtaWRkbGUgKyAxKSA6IChlbmQgPSBtaWRkbGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG59XG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcbiAgICAvLyB0aGUgZGVkdXBlIHNlYXJjaCB1c2VzIHRoZSBzdGFydEluZGV4IGFyZ3VtZW50IG9mIEFycmF5LmluY2x1ZGVzKClcbiAgICAvLyBieSBkZWZhdWx0IHRoZSBzZWFyY2ggaW5kZXggaW5jbHVkZXMgdGhlIGN1cnJlbnQgam9iIHRoYXQgaXMgYmVpbmcgcnVuXG4gICAgLy8gc28gaXQgY2Fubm90IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIGFnYWluLlxuICAgIC8vIGlmIHRoZSBqb2IgaXMgYSB3YXRjaCgpIGNhbGxiYWNrLCB0aGUgc2VhcmNoIHdpbGwgc3RhcnQgd2l0aCBhICsxIGluZGV4IHRvXG4gICAgLy8gYWxsb3cgaXQgcmVjdXJzaXZlbHkgdHJpZ2dlciBpdHNlbGYgLSBpdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvXG4gICAgLy8gZW5zdXJlIGl0IGRvZXNuJ3QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AuXG4gICAgaWYgKCFxdWV1ZS5sZW5ndGggfHxcbiAgICAgICAgIXF1ZXVlLmluY2x1ZGVzKGpvYiwgaXNGbHVzaGluZyAmJiBqb2IuYWxsb3dSZWN1cnNlID8gZmx1c2hJbmRleCArIDEgOiBmbHVzaEluZGV4KSkge1xuICAgICAgICBpZiAoam9iLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goam9iKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iLmlkKSwgMCwgam9iKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUZsdXNoKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcXVldWVGbHVzaCgpIHtcbiAgICBpZiAoIWlzRmx1c2hpbmcgJiYgIWlzRmx1c2hQZW5kaW5nKSB7XG4gICAgICAgIGlzRmx1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudEZsdXNoUHJvbWlzZSA9IHJlc29sdmVkUHJvbWlzZS50aGVuKGZsdXNoSm9icyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUpvYihqb2IpIHtcbiAgICBjb25zdCBpID0gcXVldWUuaW5kZXhPZihqb2IpO1xuICAgIGlmIChpID4gZmx1c2hJbmRleCkge1xuICAgICAgICBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xuICAgIGlmICghaXNBcnJheShjYikpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVQb3N0Rmx1c2hDYnMgfHxcbiAgICAgICAgICAgICFhY3RpdmVQb3N0Rmx1c2hDYnMuaW5jbHVkZXMoY2IsIGNiLmFsbG93UmVjdXJzZSA/IHBvc3RGbHVzaEluZGV4ICsgMSA6IHBvc3RGbHVzaEluZGV4KSkge1xuICAgICAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKGNiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaWYgY2IgaXMgYW4gYXJyYXksIGl0IGlzIGEgY29tcG9uZW50IGxpZmVjeWNsZSBob29rIHdoaWNoIGNhbiBvbmx5IGJlXG4gICAgICAgIC8vIHRyaWdnZXJlZCBieSBhIGpvYiwgd2hpY2ggaXMgYWxyZWFkeSBkZWR1cGVkIGluIHRoZSBtYWluIHF1ZXVlLCBzb1xuICAgICAgICAvLyB3ZSBjYW4gc2tpcCBkdXBsaWNhdGUgY2hlY2sgaGVyZSB0byBpbXByb3ZlIHBlcmZcbiAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5wdXNoKC4uLmNiKTtcbiAgICB9XG4gICAgcXVldWVGbHVzaCgpO1xufVxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhzZWVuLCBcbi8vIGlmIGN1cnJlbnRseSBmbHVzaGluZywgc2tpcCB0aGUgY3VycmVudCBqb2IgaXRzZWxmXG5pID0gaXNGbHVzaGluZyA/IGZsdXNoSW5kZXggKyAxIDogMCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNiID0gcXVldWVbaV07XG4gICAgICAgIGlmIChjYiAmJiBjYi5wcmUpIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGNiKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcbiAgICBpZiAocGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVkdXBlZCA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQb3N0Rmx1c2hDYnMpXTtcbiAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xuICAgICAgICAvLyAjMTk0NyBhbHJlYWR5IGhhcyBhY3RpdmUgcXVldWUsIG5lc3RlZCBmbHVzaFBvc3RGbHVzaENicyBjYWxsXG4gICAgICAgIGlmIChhY3RpdmVQb3N0Rmx1c2hDYnMpIHtcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMuc29ydCgoYSwgYikgPT4gZ2V0SWQoYSkgLSBnZXRJZChiKSk7XG4gICAgICAgIGZvciAocG9zdEZsdXNoSW5kZXggPSAwOyBwb3N0Rmx1c2hJbmRleCA8IGFjdGl2ZVBvc3RGbHVzaENicy5sZW5ndGg7IHBvc3RGbHVzaEluZGV4KyspIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2VlbiwgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENic1twb3N0Rmx1c2hJbmRleF0oKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xuICAgICAgICBwb3N0Rmx1c2hJbmRleCA9IDA7XG4gICAgfVxufVxuY29uc3QgZ2V0SWQgPSAoam9iKSA9PiBqb2IuaWQgPT0gbnVsbCA/IEluZmluaXR5IDogam9iLmlkO1xuY29uc3QgY29tcGFyYXRvciA9IChhLCBiKSA9PiB7XG4gICAgY29uc3QgZGlmZiA9IGdldElkKGEpIC0gZ2V0SWQoYik7XG4gICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgaWYgKGEucHJlICYmICFiLnByZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGIucHJlICYmICFhLnByZSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZjtcbn07XG5mdW5jdGlvbiBmbHVzaEpvYnMoc2Vlbikge1xuICAgIGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgaXNGbHVzaGluZyA9IHRydWU7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAgIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQgc28gaXRzIHJlbmRlciBlZmZlY3Qgd2lsbCBoYXZlIHNtYWxsZXJcbiAgICAvLyAgICBwcmlvcml0eSBudW1iZXIpXG4gICAgLy8gMi4gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB1cGRhdGUsXG4gICAgLy8gICAgaXRzIHVwZGF0ZSBjYW4gYmUgc2tpcHBlZC5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIC8vIGNvbmRpdGlvbmFsIHVzYWdlIG9mIGNoZWNrUmVjdXJzaXZlVXBkYXRlIG11c3QgYmUgZGV0ZXJtaW5lZCBvdXQgb2ZcbiAgICAvLyB0cnkgLi4uIGNhdGNoIGJsb2NrIHNpbmNlIFJvbGx1cCBieSBkZWZhdWx0IGRlLW9wdGltaXplcyB0cmVlc2hha2luZ1xuICAgIC8vIGluc2lkZSB0cnktY2F0Y2guIFRoaXMgY2FuIGxlYXZlIGFsbCB3YXJuaW5nIGNvZGUgdW5zaGFrZWQuIEFsdGhvdWdoXG4gICAgLy8gdGhleSB3b3VsZCBnZXQgZXZlbnR1YWxseSBzaGFrZW4gYnkgYSBtaW5pZmllciBsaWtlIHRlcnNlciwgc29tZSBtaW5pZmllcnNcbiAgICAvLyB3b3VsZCBmYWlsIHRvIGRvIHRoYXQgKGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2VzYnVpbGQvaXNzdWVzLzE2MTApXG4gICAgY29uc3QgY2hlY2sgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgPyAoam9iKSA9PiBjaGVja1JlY3Vyc2l2ZVVwZGF0ZXMoc2Vlbiwgam9iKVxuICAgICAgICA6IE5PT1A7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yIChmbHVzaEluZGV4ID0gMDsgZmx1c2hJbmRleCA8IHF1ZXVlLmxlbmd0aDsgZmx1c2hJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBqb2IgPSBxdWV1ZVtmbHVzaEluZGV4XTtcbiAgICAgICAgICAgIGlmIChqb2IgJiYgam9iLmFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNoZWNrKGpvYikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBydW5uaW5nOmAsIGpvYi5pZClcbiAgICAgICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoam9iLCBudWxsLCAxNCAvKiBFcnJvckNvZGVzLlNDSEVEVUxFUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGZsdXNoSW5kZXggPSAwO1xuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICBmbHVzaFBvc3RGbHVzaENicyhzZWVuKTtcbiAgICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICBjdXJyZW50Rmx1c2hQcm9taXNlID0gbnVsbDtcbiAgICAgICAgLy8gc29tZSBwb3N0Rmx1c2hDYiBxdWV1ZWQgam9icyFcbiAgICAgICAgLy8ga2VlcCBmbHVzaGluZyB1bnRpbCBpdCBkcmFpbnMuXG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggfHwgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZsdXNoSm9icyhzZWVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBmbikge1xuICAgIGlmICghc2Vlbi5oYXMoZm4pKSB7XG4gICAgICAgIHNlZW4uc2V0KGZuLCAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pO1xuICAgICAgICBpZiAoY291bnQgPiBSRUNVUlNJT05fTElNSVQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZm4ub3duZXJJbnN0YW5jZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBpbnN0YW5jZSAmJiBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlLnR5cGUpO1xuICAgICAgICAgICAgd2FybihgTWF4aW11bSByZWN1cnNpdmUgdXBkYXRlcyBleGNlZWRlZCR7Y29tcG9uZW50TmFtZSA/IGAgaW4gY29tcG9uZW50IDwke2NvbXBvbmVudE5hbWV9PmAgOiBgYH0uIGAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBgICtcbiAgICAgICAgICAgICAgICBgZGVwZW5kZW5jaWVzIGFuZCB0aHVzIHJlY3Vyc2l2ZWx5IHRyaWdnZXJpbmcgaXRzZWxmLiBQb3NzaWJsZSBzb3VyY2VzIGAgK1xuICAgICAgICAgICAgICAgIGBpbmNsdWRlIGNvbXBvbmVudCB0ZW1wbGF0ZSwgcmVuZGVyIGZ1bmN0aW9uLCB1cGRhdGVkIGhvb2sgb3IgYCArXG4gICAgICAgICAgICAgICAgYHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWVuLnNldChmbiwgY291bnQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG5sZXQgaXNIbXJVcGRhdGluZyA9IGZhbHNlO1xuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gbmV3IFNldCgpO1xuLy8gRXhwb3NlIHRoZSBITVIgcnVudGltZSBvbiB0aGUgZ2xvYmFsIG9iamVjdFxuLy8gVGhpcyBtYWtlcyBpdCBlbnRpcmVseSB0cmVlLXNoYWthYmxlIHdpdGhvdXQgcG9sbHV0aW5nIHRoZSBleHBvcnRzIGFuZCBtYWtlc1xuLy8gaXQgZWFzaWVyIHRvIGJlIHVzZWQgaW4gdG9vbGluZ3MgbGlrZSB2dWUtbG9hZGVyXG4vLyBOb3RlOiBmb3IgYSBjb21wb25lbnQgdG8gYmUgZWxpZ2libGUgZm9yIEhNUiBpdCBhbHNvIG5lZWRzIHRoZSBfX2htcklkIG9wdGlvblxuLy8gdG8gYmUgc2V0IHNvIHRoYXQgaXRzIGluc3RhbmNlcyBjYW4gYmUgcmVnaXN0ZXJlZCAvIHJlbW92ZWQuXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgZ2V0R2xvYmFsVGhpcygpLl9fVlVFX0hNUl9SVU5USU1FX18gPSB7XG4gICAgICAgIGNyZWF0ZVJlY29yZDogdHJ5V3JhcChjcmVhdGVSZWNvcmQpLFxuICAgICAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXG4gICAgICAgIHJlbG9hZDogdHJ5V3JhcChyZWxvYWQpXG4gICAgfTtcbn1cbmNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gICAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XG4gICAgbGV0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XG4gICAgICAgIHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICAgIH1cbiAgICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKSB7XG4gICAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBpbml0aWFsRGVmKSB7XG4gICAgaWYgKG1hcC5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwLnNldChpZCwge1xuICAgICAgICBpbml0aWFsRGVmOiBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbml0aWFsRGVmKSxcbiAgICAgICAgaW5zdGFuY2VzOiBuZXcgU2V0KClcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgPyBjb21wb25lbnQuX192Y2NPcHRzIDogY29tcG9uZW50O1xufVxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xuICAgIGNvbnN0IHJlY29yZCA9IG1hcC5nZXQoaWQpO1xuICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGluaXRpYWwgcmVjb3JkIChmb3Igbm90LXlldC1yZW5kZXJlZCBjb21wb25lbnQpXG4gICAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgIFsuLi5yZWNvcmQuaW5zdGFuY2VzXS5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgaWYgKG5ld1JlbmRlcikge1xuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgICAgICAgICAgbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSkucmVuZGVyID0gbmV3UmVuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XG4gICAgICAgIC8vIHRoaXMgZmxhZyBmb3JjZXMgY2hpbGQgY29tcG9uZW50cyB3aXRoIHNsb3QgY29udGVudCB0byB1cGRhdGVcbiAgICAgICAgaXNIbXJVcGRhdGluZyA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICBpc0htclVwZGF0aW5nID0gZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZWxvYWQoaWQsIG5ld0NvbXApIHtcbiAgICBjb25zdCByZWNvcmQgPSBtYXAuZ2V0KGlkKTtcbiAgICBpZiAoIXJlY29yZClcbiAgICAgICAgcmV0dXJuO1xuICAgIG5ld0NvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChuZXdDb21wKTtcbiAgICAvLyB1cGRhdGUgaW5pdGlhbCBkZWYgKGZvciBub3QteWV0LXJlbmRlcmVkIGNvbXBvbmVudHMpXG4gICAgdXBkYXRlQ29tcG9uZW50RGVmKHJlY29yZC5pbml0aWFsRGVmLCBuZXdDb21wKTtcbiAgICAvLyBjcmVhdGUgYSBzbmFwc2hvdCB3aGljaCBhdm9pZHMgdGhlIHNldCBiZWluZyBtdXRhdGVkIGR1cmluZyB1cGRhdGVzXG4gICAgY29uc3QgaW5zdGFuY2VzID0gWy4uLnJlY29yZC5pbnN0YW5jZXNdO1xuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IG9sZENvbXAgPSBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKTtcbiAgICAgICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG9sZENvbXApKSB7XG4gICAgICAgICAgICAvLyAxLiBVcGRhdGUgZXhpc3RpbmcgY29tcCBkZWZpbml0aW9uIHRvIG1hdGNoIG5ldyBvbmVcbiAgICAgICAgICAgIGlmIChvbGRDb21wICE9PSByZWNvcmQuaW5pdGlhbERlZikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIuIG1hcmsgZGVmaW5pdGlvbiBkaXJ0eS4gVGhpcyBmb3JjZXMgdGhlIHJlbmRlcmVyIHRvIHJlcGxhY2UgdGhlXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgb24gcGF0Y2guXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIGludmFsaWRhdGUgb3B0aW9ucyByZXNvbHV0aW9uIGNhY2hlXG4gICAgICAgIGluc3RhbmNlLmFwcENvbnRleHQub3B0aW9uc0NhY2hlLmRlbGV0ZShpbnN0YW5jZS50eXBlKTtcbiAgICAgICAgLy8gNC4gYWN0dWFsbHkgdXBkYXRlXG4gICAgICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xuICAgICAgICAgICAgLy8gY3VzdG9tIGVsZW1lbnRcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XG4gICAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKG9sZENvbXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xuICAgICAgICAgICAgLy8gNC4gRm9yY2UgdGhlIHBhcmVudCBpbnN0YW5jZSB0byByZS1yZW5kZXIuIFRoaXMgd2lsbCBjYXVzZSBhbGwgdXBkYXRlZFxuICAgICAgICAgICAgLy8gY29tcG9uZW50cyB0byBiZSB1bm1vdW50ZWQgYW5kIHJlLW1vdW50ZWQuIFF1ZXVlIHRoZSB1cGRhdGUgc28gdGhhdCB3ZVxuICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGZvcmNpbmcgdGhlIHNhbWUgcGFyZW50IHRvIHJlLXJlbmRlciBtdWx0aXBsZSB0aW1lcy5cbiAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIG1vdW50ZWQgdmlhIGNyZWF0ZUFwcCgpIGhhcyBhIHJlbG9hZCBtZXRob2RcbiAgICAgICAgICAgIGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgaW5zaWRlIHRyZWUgY3JlYXRlZCB2aWEgcmF3IHJlbmRlcigpLiBGb3JjZSByZWxvYWQuXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gNS4gbWFrZSBzdXJlIHRvIGNsZWFudXAgZGlydHkgaG1yIGNvbXBvbmVudHMgYWZ0ZXIgdXBkYXRlXG4gICAgcXVldWVQb3N0Rmx1c2hDYigoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RGVmKG9sZENvbXAsIG5ld0NvbXApIHtcbiAgICBleHRlbmQob2xkQ29tcCwgbmV3Q29tcCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xuICAgICAgICBpZiAoa2V5ICE9PSAnX19maWxlJyAmJiAhKGtleSBpbiBuZXdDb21wKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9sZENvbXBba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcbiAgICByZXR1cm4gKGlkLCBhcmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gYCArXG4gICAgICAgICAgICAgICAgYEZ1bGwgcmVsb2FkIHJlcXVpcmVkLmApO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxubGV0IGRldnRvb2xzO1xubGV0IGJ1ZmZlciA9IFtdO1xubGV0IGRldnRvb2xzTm90SW5zdGFsbGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbWl0JDEoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFkZXZ0b29sc05vdEluc3RhbGxlZCkge1xuICAgICAgICBidWZmZXIucHVzaCh7IGV2ZW50LCBhcmdzIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayhob29rLCB0YXJnZXQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGRldnRvb2xzID0gaG9vaztcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlci5mb3JFYWNoKCh7IGV2ZW50LCBhcmdzIH0pID0+IGRldnRvb2xzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpKTtcbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXG4gICAgLy8gYnJvd3NlciBlbnZpcm9ubWVudCB0byBhdm9pZCB0aGUgdGltZXIgaGFuZGxlIHN0YWxsaW5nIHRlc3QgcnVubmVyIGV4aXRcbiAgICAvLyAoIzQ4MTUpXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgLy8gc29tZSBlbnZzIG1vY2sgd2luZG93IGJ1dCBub3QgZnVsbHlcbiAgICAgICAgd2luZG93LkhUTUxFbGVtZW50ICYmXG4gICAgICAgIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxuICAgICAgICAhKChfYiA9IChfYSA9IHdpbmRvdy5uYXZpZ2F0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VyQWdlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcygnanNkb20nKSkpIHtcbiAgICAgICAgY29uc3QgcmVwbGF5ID0gKHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fID1cbiAgICAgICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdKTtcbiAgICAgICAgcmVwbGF5LnB1c2goKG5ld0hvb2spID0+IHtcbiAgICAgICAgICAgIHNldERldnRvb2xzSG9vayhuZXdIb29rLCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2xlYXIgYnVmZmVyIGFmdGVyIDNzIC0gdGhlIHVzZXIgcHJvYmFibHkgZG9lc24ndCBoYXZlIGRldnRvb2xzIGluc3RhbGxlZFxuICAgICAgICAvLyBhdCBhbGwsIGFuZCBrZWVwaW5nIHRoZSBidWZmZXIgd2lsbCBjYXVzZSBtZW1vcnkgbGVha3MgKCM0NzM4KVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghZGV2dG9vbHMpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG5vbi1icm93c2VyIGVudiwgYXNzdW1lIG5vdCBpbnN0YWxsZWRcbiAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXZ0b29sc0luaXRBcHAoYXBwLCB2ZXJzaW9uKSB7XG4gICAgZW1pdCQxKFwiYXBwOmluaXRcIiAvKiBEZXZ0b29sc0hvb2tzLkFQUF9JTklUICovLCBhcHAsIHZlcnNpb24sIHtcbiAgICAgICAgRnJhZ21lbnQsXG4gICAgICAgIFRleHQsXG4gICAgICAgIENvbW1lbnQsXG4gICAgICAgIFN0YXRpY1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGV2dG9vbHNVbm1vdW50QXBwKGFwcCkge1xuICAgIGVtaXQkMShcImFwcDp1bm1vdW50XCIgLyogRGV2dG9vbHNIb29rcy5BUFBfVU5NT1VOVCAqLywgYXBwKTtcbn1cbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIERldnRvb2xzSG9va3MuQ09NUE9ORU5UX0FEREVEICovKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IFxuLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6dXBkYXRlZFwiIC8qIERldnRvb2xzSG9va3MuQ09NUE9ORU5UX1VQREFURUQgKi8pO1xuY29uc3QgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKFwiY29tcG9uZW50OnJlbW92ZWRcIiAvKiBEZXZ0b29sc0hvb2tzLkNPTVBPTkVOVF9SRU1PVkVEICovKTtcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZCA9IChjb21wb25lbnQpID0+IHtcbiAgICBpZiAoZGV2dG9vbHMgJiZcbiAgICAgICAgdHlwZW9mIGRldnRvb2xzLmNsZWFudXBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb21wb25lbnQgaWYgaXQgd2Fzbid0IGJ1ZmZlcmVkXG4gICAgICAgICFkZXZ0b29scy5jbGVhbnVwQnVmZmVyKGNvbXBvbmVudCkpIHtcbiAgICAgICAgX2RldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChjb21wb25lbnQpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soaG9vaykge1xuICAgIHJldHVybiAoY29tcG9uZW50KSA9PiB7XG4gICAgICAgIGVtaXQkMShob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHVuZGVmaW5lZCwgY29tcG9uZW50KTtcbiAgICB9O1xufVxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjpzdGFydFwiIC8qIERldnRvb2xzSG9va3MuUEVSRk9STUFOQ0VfU1RBUlQgKi8pO1xuY29uc3QgZGV2dG9vbHNQZXJmRW5kID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6ZW5kXCIgLyogRGV2dG9vbHNIb29rcy5QRVJGT1JNQU5DRV9FTkQgKi8pO1xuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soaG9vaykge1xuICAgIHJldHVybiAoY29tcG9uZW50LCB0eXBlLCB0aW1lKSA9PiB7XG4gICAgICAgIGVtaXQkMShob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudCwgdHlwZSwgdGltZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRldnRvb2xzQ29tcG9uZW50RW1pdChjb21wb25lbnQsIGV2ZW50LCBwYXJhbXMpIHtcbiAgICBlbWl0JDEoXCJjb21wb25lbnQ6ZW1pdFwiIC8qIERldnRvb2xzSG9va3MuQ09NUE9ORU5UX0VNSVQgKi8sIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LCBldmVudCwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gZW1pdChpbnN0YW5jZSwgZXZlbnQsIC4uLnJhd0FyZ3MpIHtcbiAgICBpZiAoaW5zdGFuY2UuaXNVbm1vdW50ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IHsgZW1pdHNPcHRpb25zLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgaWYgKGVtaXRzT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEoZXZlbnQgaW4gZW1pdHNPcHRpb25zKSAmJlxuICAgICAgICAgICAgICAgICEoZmFsc2UgKSkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcHNPcHRpb25zIHx8ICEodG9IYW5kbGVyS2V5KGV2ZW50KSBpbiBwcm9wc09wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENvbXBvbmVudCBlbWl0dGVkIGV2ZW50IFwiJHtldmVudH1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7dG9IYW5kbGVyS2V5KGV2ZW50KX1cIiBwcm9wLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdG9yKC4uLnJhd0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V2ZW50fVwiLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBhcmdzID0gcmF3QXJncztcbiAgICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKCd1cGRhdGU6Jyk7XG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFwcGx5IG1vZGlmaWVycyBvbiBhcmdzXG4gICAgY29uc3QgbW9kZWxBcmcgPSBpc01vZGVsTGlzdGVuZXIgJiYgZXZlbnQuc2xpY2UoNyk7XG4gICAgaWYgKG1vZGVsQXJnICYmIG1vZGVsQXJnIGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVyc0tleSA9IGAke21vZGVsQXJnID09PSAnbW9kZWxWYWx1ZScgPyAnbW9kZWwnIDogbW9kZWxBcmd9TW9kaWZpZXJzYDtcbiAgICAgICAgY29uc3QgeyBudW1iZXIsIHRyaW0gfSA9IHByb3BzW21vZGlmaWVyc0tleV0gfHwgRU1QVFlfT0JKO1xuICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGEgPT4gKGlzU3RyaW5nKGEpID8gYS50cmltKCkgOiBhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWJlcikge1xuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKGxvb3NlVG9OdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiBwcm9wc1t0b0hhbmRsZXJLZXkobG93ZXJDYXNlRXZlbnQpXSkge1xuICAgICAgICAgICAgd2FybihgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IGAgK1xuICAgICAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBgICtcbiAgICAgICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXG4gICAgICAgICAgICAgICAgYHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBgICtcbiAgICAgICAgICAgICAgICBgWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhhbmRsZXJOYW1lO1xuICAgIGxldCBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGV2ZW50KSldIHx8XG4gICAgICAgIC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcbiAgICAgICAgcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGNhbWVsaXplKGV2ZW50KSkpXTtcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYWxzbyB0cmlnZ2VyIGtlYmFiLWNhc2UgZXF1aXZhbGVudFxuICAgIC8vIGZvciBwcm9wcyBwYXNzZWQgdmlhIGtlYmFiLWNhc2VcbiAgICBpZiAoIWhhbmRsZXIgJiYgaXNNb2RlbExpc3RlbmVyKSB7XG4gICAgICAgIGhhbmRsZXIgPSBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoaHlwaGVuYXRlKGV2ZW50KSkpXTtcbiAgICB9XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaGFuZGxlciwgaW5zdGFuY2UsIDYgLyogRXJyb3JDb2Rlcy5DT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XG4gICAgfVxuICAgIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xuICAgIGlmIChvbmNlSGFuZGxlcikge1xuICAgICAgICBpZiAoIWluc3RhbmNlLmVtaXR0ZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmVtaXR0ZWRbaGFuZGxlck5hbWVdID0gdHJ1ZTtcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcob25jZUhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIEVycm9yQ29kZXMuQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi8sIGFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYWNoZSA9IGFwcENvbnRleHQuZW1pdHNDYWNoZTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XG4gICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJhdyA9IGNvbXAuZW1pdHM7XG4gICAgbGV0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXG4gICAgbGV0IGhhc0V4dGVuZHMgPSBmYWxzZTtcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGcm9tRXh0ZW5kID0gbm9ybWFsaXplRW1pdHNPcHRpb25zKHJhdywgYXBwQ29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZEZyb21FeHRlbmQpIHtcbiAgICAgICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgbm9ybWFsaXplZEZyb21FeHRlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWFzTWl4aW4gJiYgYXBwQ29udGV4dC5taXhpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcHBDb250ZXh0Lm1peGlucy5mb3JFYWNoKGV4dGVuZEVtaXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcC5leHRlbmRzKSB7XG4gICAgICAgICAgICBleHRlbmRFbWl0cyhjb21wLmV4dGVuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wLm1peGlucykge1xuICAgICAgICAgICAgY29tcC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyYXcgJiYgIWhhc0V4dGVuZHMpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoY29tcCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmF3LmZvckVhY2goa2V5ID0+IChub3JtYWxpemVkW2tleV0gPSBudWxsKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleHRlbmQobm9ybWFsaXplZCwgcmF3KTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGNvbXApKSB7XG4gICAgICAgIGNhY2hlLnNldChjb21wLCBub3JtYWxpemVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG4vLyBDaGVjayBpZiBhbiBpbmNvbWluZyBwcm9wIGtleSBpcyBhIGRlY2xhcmVkIGVtaXQgZXZlbnQgbGlzdGVuZXIuXG4vLyBlLmcuIFdpdGggYGVtaXRzOiB7IGNsaWNrOiBudWxsIH1gLCBwcm9wcyBuYW1lZCBgb25DbGlja2AgYW5kIGBvbmNsaWNrYCBhcmVcbi8vIGJvdGggY29uc2lkZXJlZCBtYXRjaGVkIGxpc3RlbmVycy5cbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xuICAgIGlmICghb3B0aW9ucyB8fCAhaXNPbihrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAga2V5ID0ga2V5LnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgJycpO1xuICAgIHJldHVybiAoaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fFxuICAgICAgICBoYXNPd24ob3B0aW9ucywgaHlwaGVuYXRlKGtleSkpIHx8XG4gICAgICAgIGhhc093bihvcHRpb25zLCBrZXkpKTtcbn1cblxuLyoqXG4gKiBtYXJrIHRoZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZSBmb3IgYXNzZXQgcmVzb2x1dGlvbiAoZS5nLlxuICogcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSkgZHVyaW5nIHJlbmRlclxuICovXG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmxldCBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG4vKipcbiAqIE5vdGU6IHJlbmRlcmluZyBjYWxscyBtYXliZSBuZXN0ZWQuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSBwYXJlbnQgcmVuZGVyaW5nXG4gKiBpbnN0YW5jZSBpZiBwcmVzZW50LCB3aGljaCBzaG91bGQgYmUgcmVzdG9yZWQgYWZ0ZXIgdGhlIHJlbmRlciBpcyBkb25lOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwcmV2ID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGkpXG4gKiAvLyAuLi5yZW5kZXJcbiAqIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2KVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgIGNvbnN0IHByZXYgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgY3VycmVudFNjb3BlSWQgPSAoaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5fX3Njb3BlSWQpIHx8IG51bGw7XG4gICAgcmV0dXJuIHByZXY7XG59XG4vKipcbiAqIFNldCBzY29wZSBpZCB3aGVuIGNyZWF0aW5nIGhvaXN0ZWQgdm5vZGVzLlxuICogQHByaXZhdGUgY29tcGlsZXIgaGVscGVyXG4gKi9cbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XG4gICAgY3VycmVudFNjb3BlSWQgPSBpZDtcbn1cbi8qKlxuICogVGVjaG5pY2FsbHkgd2Ugbm8gbG9uZ2VyIG5lZWQgdGhpcyBhZnRlciAzLjAuOCBidXQgd2UgbmVlZCB0byBrZWVwIHRoZSBzYW1lXG4gKiBBUEkgZm9yIGJhY2t3YXJkcyBjb21wYXQgdy8gY29kZSBnZW5lcmF0ZWQgYnkgY29tcGlsZXJzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcG9wU2NvcGVJZCgpIHtcbiAgICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XG59XG4vKipcbiAqIE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcbi8qKlxuICogV3JhcCBhIHNsb3QgZnVuY3Rpb24gdG8gbWVtb2l6ZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZVxuICogQHByaXZhdGUgY29tcGlsZXIgaGVscGVyXG4gKi9cbmZ1bmN0aW9uIHdpdGhDdHgoZm4sIGN0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgaXNOb25TY29wZWRTbG90IC8vIGZhbHNlIG9ubHlcbikge1xuICAgIGlmICghY3R4KVxuICAgICAgICByZXR1cm4gZm47XG4gICAgLy8gYWxyZWFkeSBub3JtYWxpemVkXG4gICAgaWYgKGZuLl9uKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgY29uc3QgcmVuZGVyRm5XaXRoQ29udGV4dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIC8vIElmIGEgdXNlciBjYWxscyBhIGNvbXBpbGVkIHNsb3QgaW5zaWRlIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiAoIzE3NDUpLCBpdFxuICAgICAgICAvLyBjYW4gbWVzcyB1cCBibG9jayB0cmFja2luZywgc28gYnkgZGVmYXVsdCB3ZSBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGFuZFxuICAgICAgICAvLyBmb3JjZSBiYWlsIG91dCB3aGVuIGludm9raW5nIGEgY29tcGlsZWQgc2xvdCAoaW5kaWNhdGVkIGJ5IHRoZSAuX2QgZmxhZykuXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgbmVjZXNzYXJ5IGlmIHJlbmRlcmluZyBhIGNvbXBpbGVkIGA8c2xvdD5gLCBzbyB3ZSBmbGlwIHRoZVxuICAgICAgICAvLyAuX2QgZmxhZyBvZmYgd2hlbiBpbnZva2luZyB0aGUgd3JhcHBlZCBmbiBpbnNpZGUgYHJlbmRlclNsb3RgLlxuICAgICAgICBpZiAocmVuZGVyRm5XaXRoQ29udGV4dC5fZCkge1xuICAgICAgICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkluc3RhbmNlID0gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGN0eCk7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xuICAgICAgICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcbiAgICAgICAgICAgICAgICBzZXRCbG9ja1RyYWNraW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLy8gbWFyayBub3JtYWxpemVkIHRvIGF2b2lkIGR1cGxpY2F0ZWQgd3JhcHBpbmdcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcbiAgICAvLyBtYXJrIHRoaXMgYXMgY29tcGlsZWQgYnkgZGVmYXVsdFxuICAgIC8vIHRoaXMgaXMgdXNlZCBpbiB2bm9kZS50cyAtPiBub3JtYWxpemVDaGlsZHJlbigpIHRvIHNldCB0aGUgc2xvdFxuICAgIC8vIHJlbmRlcmluZyBmbGFnLlxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2MgPSB0cnVlO1xuICAgIC8vIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdFxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xuICAgIHJldHVybiByZW5kZXJGbldpdGhDb250ZXh0O1xufVxuXG4vKipcbiAqIGRldiBvbmx5IGZsYWcgdG8gdHJhY2sgd2hldGhlciAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlci5cbiAqIElmICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyIHRoZW4gdGhlIHdhcm5pbmcgZm9yIGZhaWxlZCBhdHRyc1xuICogZmFsbHRocm91Z2ggY2FuIGJlIHN1cHByZXNzZWQuXG4gKi9cbmxldCBhY2Nlc3NlZEF0dHJzID0gZmFsc2U7XG5mdW5jdGlvbiBtYXJrQXR0cnNBY2Nlc3NlZCgpIHtcbiAgICBhY2Nlc3NlZEF0dHJzID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCwgdm5vZGUsIHByb3h5LCB3aXRoUHJveHksIHByb3BzLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdLCBzbG90cywgYXR0cnMsIGVtaXQsIHJlbmRlciwgcmVuZGVyQ2FjaGUsIGRhdGEsIHNldHVwU3RhdGUsIGN0eCwgaW5oZXJpdEF0dHJzIH0gPSBpbnN0YW5jZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xuICAgIGNvbnN0IHByZXYgPSBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTaGFwZUZsYWdzLlNUQVRFRlVMX0NPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgLy8gd2l0aFByb3h5IGlzIGEgcHJveHkgd2l0aCBhIGRpZmZlcmVudCBgaGFzYCB0cmFwIG9ubHkgZm9yXG4gICAgICAgICAgICAvLyBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrLlxuICAgICAgICAgICAgY29uc3QgcHJveHlUb1VzZSA9IHdpdGhQcm94eSB8fCBwcm94eTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5jYWxsKHByb3h5VG9Vc2UsIHByb3h5VG9Vc2UsIHJlbmRlckNhY2hlLCBwcm9wcywgc2V0dXBTdGF0ZSwgZGF0YSwgY3R4KSk7XG4gICAgICAgICAgICBmYWxsdGhyb3VnaEF0dHJzID0gYXR0cnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsXG4gICAgICAgICAgICBjb25zdCByZW5kZXIgPSBDb21wb25lbnQ7XG4gICAgICAgICAgICAvLyBpbiBkZXYsIG1hcmsgYXR0cnMgYWNjZXNzZWQgaWYgb3B0aW9uYWwgcHJvcHMgKGF0dHJzID09PSBwcm9wcylcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYXR0cnMgPT09IHByb3BzKSB7XG4gICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgPyByZW5kZXIocHJvcHMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG90cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHsgYXR0cnMsIHNsb3RzLCBlbWl0IH0pXG4gICAgICAgICAgICAgICAgOiByZW5kZXIocHJvcHMsIG51bGwgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi8pKTtcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBDb21wb25lbnQucHJvcHNcbiAgICAgICAgICAgICAgICA/IGF0dHJzXG4gICAgICAgICAgICAgICAgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgYmxvY2tTdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxIC8qIEVycm9yQ29kZXMuUkVOREVSX0ZVTkNUSU9OICovKTtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlVk5vZGUoQ29tbWVudCk7XG4gICAgfVxuICAgIC8vIGF0dHIgbWVyZ2luZ1xuICAgIC8vIGluIGRldiBtb2RlLCBjb21tZW50cyBhcmUgcHJlc2VydmVkLCBhbmQgaXQncyBwb3NzaWJsZSBmb3IgYSB0ZW1wbGF0ZVxuICAgIC8vIHRvIGhhdmUgY29tbWVudHMgYWxvbmcgc2lkZSB0aGUgcm9vdCBlbGVtZW50IHdoaWNoIG1ha2VzIGl0IGEgZnJhZ21lbnRcbiAgICBsZXQgcm9vdCA9IHJlc3VsdDtcbiAgICBsZXQgc2V0Um9vdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgIHJlc3VsdC5wYXRjaEZsYWcgPiAwICYmXG4gICAgICAgIHJlc3VsdC5wYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8pIHtcbiAgICAgICAgW3Jvb3QsIHNldFJvb3RdID0gZ2V0Q2hpbGRSb290KHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChmYWxsdGhyb3VnaEF0dHJzICYmIGluaGVyaXRBdHRycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZhbGx0aHJvdWdoQXR0cnMpO1xuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgKDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovIHwgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLykpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNPcHRpb25zICYmIGtleXMuc29tZShpc01vZGVsTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgdi1tb2RlbCBsaXN0ZW5lciAob25VcGRhdGU6eHh4KSBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY2xhcmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3AsIGl0IGluZGljYXRlcyB0aGlzIGNvbXBvbmVudCBleHBlY3RzIHRvIGhhbmRsZSB2LW1vZGVsIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgbm90IGZhbGx0aHJvdWdoLlxuICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGVkOiAjMTU0MywgIzE2NDMsICMxOTg5XG4gICAgICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhmYWxsdGhyb3VnaEF0dHJzLCBwcm9wc09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCBmYWxsdGhyb3VnaEF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhYWNjZXNzZWRBdHRycyAmJiByb290LnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFBdHRycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYWxsQXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPbihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBoYW5kbGVycyB3aGVuIHRoZXkgZmFpbCB0byBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBgb25gLCBsb3dlcmNhc2UgZmlyc3QgbGV0dGVyIHRvIHJlZmxlY3QgZXZlbnQgY2FzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjdXJhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYUF0dHJzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtleHRyYUF0dHJzLmpvaW4oJywgJyl9KSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50QXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtldmVudEF0dHJzLmpvaW4oJywgJyl9KSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgSWYgdGhlIGxpc3RlbmVyIGlzIGludGVuZGVkIHRvIGJlIGEgY29tcG9uZW50IGN1c3RvbSBldmVudCBsaXN0ZW5lciBvbmx5LCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpbmhlcml0IGRpcmVjdGl2ZXNcbiAgICBpZiAodm5vZGUuZGlycykge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICAgICAgICB3YXJuKGBSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gYCArXG4gICAgICAgICAgICAgICAgYFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsb25lIGJlZm9yZSBtdXRhdGluZyBzaW5jZSB0aGUgcm9vdCBtYXkgYmUgYSBob2lzdGVkIHZub2RlXG4gICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QpO1xuICAgICAgICByb290LmRpcnMgPSByb290LmRpcnMgPyByb290LmRpcnMuY29uY2F0KHZub2RlLmRpcnMpIDogdm5vZGUuZGlycztcbiAgICB9XG4gICAgLy8gaW5oZXJpdCB0cmFuc2l0aW9uIGRhdGFcbiAgICBpZiAodm5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XG4gICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgaW5zaWRlIDxUcmFuc2l0aW9uPiByZW5kZXJzIG5vbi1lbGVtZW50IHJvb3Qgbm9kZSBgICtcbiAgICAgICAgICAgICAgICBgdGhhdCBjYW5ub3QgYmUgYW5pbWF0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC50cmFuc2l0aW9uID0gdm5vZGUudHJhbnNpdGlvbjtcbiAgICB9XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzZXRSb290KSB7XG4gICAgICAgIHNldFJvb3Qocm9vdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByb290O1xuICAgIH1cbiAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqIEluIGRldiBtb2RlLCB0ZW1wbGF0ZSByb290IGxldmVsIGNvbW1lbnRzIGFyZSByZW5kZXJlZCwgd2hpY2ggdHVybnMgdGhlXG4gKiB0ZW1wbGF0ZSBpbnRvIGEgZnJhZ21lbnQgcm9vdCwgYnV0IHdlIG5lZWQgdG8gbG9jYXRlIHRoZSBzaW5nbGUgZWxlbWVudFxuICogcm9vdCBmb3IgYXR0cnMgYW5kIHNjb3BlIGlkIHByb2Nlc3NpbmcuXG4gKi9cbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xuICAgIGNvbnN0IHJhd0NoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgZHluYW1pY0NoaWxkcmVuID0gdm5vZGUuZHluYW1pY0NoaWxkcmVuO1xuICAgIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4pO1xuICAgIGlmICghY2hpbGRSb290KSB7XG4gICAgICAgIHJldHVybiBbdm5vZGUsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gcmF3Q2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpO1xuICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGR5bmFtaWNDaGlsZHJlbiA/IGR5bmFtaWNDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCkgOiAtMTtcbiAgICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XG4gICAgICAgIHJhd0NoaWxkcmVuW2luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW5bZHluYW1pY0luZGV4XSA9IHVwZGF0ZWRSb290O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xuICAgICAgICAgICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5keW5hbWljQ2hpbGRyZW4sIHVwZGF0ZWRSb290XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFtub3JtYWxpemVWTm9kZShjaGlsZFJvb3QpLCBzZXRSb290XTtcbn07XG5mdW5jdGlvbiBmaWx0ZXJTaW5nbGVSb290KGNoaWxkcmVuKSB7XG4gICAgbGV0IHNpbmdsZVJvb3Q7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNWTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSB1c2VyIGNvbW1lbnRcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSBDb21tZW50IHx8IGNoaWxkLmNoaWxkcmVuID09PSAndi1pZicpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbW9yZSB0aGFuIDEgbm9uLWNvbW1lbnQgY2hpbGQsIHJldHVybiBub3dcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlUm9vdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2luZ2xlUm9vdDtcbn1cbmNvbnN0IGdldEZ1bmN0aW9uYWxGYWxsdGhyb3VnaCA9IChhdHRycykgPT4ge1xuICAgIGxldCByZXM7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScgfHwgaXNPbihrZXkpKSB7XG4gICAgICAgICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuY29uc3QgZmlsdGVyTW9kZWxMaXN0ZW5lcnMgPSAoYXR0cnMsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSB8fCAhKGtleS5zbGljZSg5KSBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGlzRWxlbWVudFJvb3QgPSAodm5vZGUpID0+IHtcbiAgICByZXR1cm4gKHZub2RlLnNoYXBlRmxhZyAmICg2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovIHwgMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8pIHx8XG4gICAgICAgIHZub2RlLnR5cGUgPT09IENvbW1lbnQgLy8gcG90ZW50aWFsIHYtaWYgYnJhbmNoIHN3aXRjaFxuICAgICk7XG59O1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlQ29tcG9uZW50KHByZXZWTm9kZSwgbmV4dFZOb2RlLCBvcHRpbWl6ZWQpIHtcbiAgICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xuICAgIGNvbnN0IHsgcHJvcHM6IG5leHRQcm9wcywgY2hpbGRyZW46IG5leHRDaGlsZHJlbiwgcGF0Y2hGbGFnIH0gPSBuZXh0Vk5vZGU7XG4gICAgY29uc3QgZW1pdHMgPSBjb21wb25lbnQuZW1pdHNPcHRpb25zO1xuICAgIC8vIFBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24gd2FzIGhvdC11cGRhdGVkLiBTaW5jZSB0aGlzIG1heSBoYXZlXG4gICAgLy8gY2F1c2VkIHRoZSBjaGlsZCBjb21wb25lbnQncyBzbG90cyBjb250ZW50IHRvIGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0b1xuICAgIC8vIGZvcmNlIHRoZSBjaGlsZCB0byB1cGRhdGUgYXMgd2VsbC5cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBmb3JjZSBjaGlsZCB1cGRhdGUgZm9yIHJ1bnRpbWUgZGlyZWN0aXZlIG9yIHRyYW5zaXRpb24gb24gY29tcG9uZW50IHZub2RlLlxuICAgIGlmIChuZXh0Vk5vZGUuZGlycyB8fCBuZXh0Vk5vZGUudHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGltaXplZCAmJiBwYXRjaEZsYWcgPj0gMCkge1xuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi8pIHtcbiAgICAgICAgICAgIC8vIHNsb3QgY29udGVudCB0aGF0IHJlZmVyZW5jZXMgdmFsdWVzIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLFxuICAgICAgICAgICAgLy8gZS5nLiBpbiBhIHYtZm9yXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovKSB7XG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHRoaXMgZmxhZyBpbmRpY2F0ZXMgcHJvcHMgYXJlIGFsd2F5cyBub24tbnVsbFxuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3BzQ2hhbmdlZChwcmV2UHJvcHMsIG5leHRQcm9wcywgZW1pdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDggLyogUGF0Y2hGbGFncy5QUk9QUyAqLykge1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Byb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY1Byb3BzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzRW1pdExpc3RlbmVyKGVtaXRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBwYXRoIGlzIG9ubHkgdGFrZW4gYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXG4gICAgICAgIC8vIHNvIHByZXNlbmNlIG9mIGFueSBjaGlsZHJlbiBsZWFkcyB0byBhIGZvcmNlZCB1cGRhdGVcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbiB8fCBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghbmV4dENoaWxkcmVuIHx8ICFuZXh0Q2hpbGRyZW4uJHN0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gISFuZXh0UHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0c09wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0S2V5cyA9IE9iamVjdC5rZXlzKG5leHRQcm9wcyk7XG4gICAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV4dEtleXNbaV07XG4gICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcbiAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwgLy8gSG9zdE5vZGVcbikge1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XG4gICAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XG4vLyBTdXNwZW5zZSBleHBvc2VzIGEgY29tcG9uZW50LWxpa2UgQVBJLCBhbmQgaXMgdHJlYXRlZCBsaWtlIGEgY29tcG9uZW50XG4vLyBpbiB0aGUgY29tcGlsZXIsIGJ1dCBpbnRlcm5hbGx5IGl0J3MgYSBzcGVjaWFsIGJ1aWx0LWluIHR5cGUgdGhhdCBob29rc1xuLy8gZGlyZWN0bHkgaW50byB0aGUgcmVuZGVyZXIuXG5jb25zdCBTdXNwZW5zZUltcGwgPSB7XG4gICAgbmFtZTogJ1N1c3BlbnNlJyxcbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XG4gICAgLy8gZGlyZWN0bHkgaW4gdGhlIHJlbmRlcmVyLiBUaGUgcmVuZGVyZXIgY2hlY2tzIGZvciB0aGUgX19pc1N1c3BlbnNlIGZsYWdcbiAgICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcbiAgICAvLyBpbnRlcm5hbHMuXG4gICAgX19pc1N1c3BlbnNlOiB0cnVlLFxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBcbiAgICAvLyBwbGF0Zm9ybS1zcGVjaWZpYyBpbXBsIHBhc3NlZCBmcm9tIHJlbmRlcmVyXG4gICAgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdW50U3VzcGVuc2UobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxuICAgIGNyZWF0ZTogY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSxcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW5cbn07XG4vLyBGb3JjZS1jYXN0ZWQgcHVibGljIHR5cGluZyBmb3IgaCBhbmQgVFNYIHByb3BzIGluZmVyZW5jZVxuY29uc3QgU3VzcGVuc2UgPSAoU3VzcGVuc2VJbXBsXG4gICAgKTtcbmZ1bmN0aW9uIHRyaWdnZXJFdmVudCh2bm9kZSwgbmFtZSkge1xuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcbiAgICBpZiAoaXNGdW5jdGlvbihldmVudExpc3RlbmVyKSkge1xuICAgICAgICBldmVudExpc3RlbmVyKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gICAgY29uc3QgaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgc3VzcGVuc2UgPSAodm5vZGUuc3VzcGVuc2UgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHZub2RlLCBwYXJlbnRTdXNwZW5zZSwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSk7XG4gICAgLy8gc3RhcnQgbW91bnRpbmcgdGhlIGNvbnRlbnQgc3VidHJlZSBpbiBhbiBvZmYtZG9tIGNvbnRhaW5lclxuICAgIHBhdGNoKG51bGwsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKTtcbiAgICAvLyBub3cgY2hlY2sgaWYgd2UgaGF2ZSBlbmNvdW50ZXJlZCBhbnkgYXN5bmMgZGVwc1xuICAgIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xuICAgICAgICAvLyBoYXMgYXN5bmNcbiAgICAgICAgLy8gaW52b2tlIEBmYWxsYmFjayBldmVudFxuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvblBlbmRpbmcnKTtcbiAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25GYWxsYmFjaycpO1xuICAgICAgICAvLyBtb3VudCB0aGUgZmFsbGJhY2sgdHJlZVxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZS5zc0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzKTtcbiAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCB2bm9kZS5zc0ZhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFN1c3BlbnNlIGhhcyBubyBhc3luYyBkZXBzLiBKdXN0IHJlc29sdmUuXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xuICAgIGNvbnN0IHN1c3BlbnNlID0gKG4yLnN1c3BlbnNlID0gbjEuc3VzcGVuc2UpO1xuICAgIHN1c3BlbnNlLnZub2RlID0gbjI7XG4gICAgbjIuZWwgPSBuMS5lbDtcbiAgICBjb25zdCBuZXdCcmFuY2ggPSBuMi5zc0NvbnRlbnQ7XG4gICAgY29uc3QgbmV3RmFsbGJhY2sgPSBuMi5zc0ZhbGxiYWNrO1xuICAgIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcbiAgICBpZiAocGVuZGluZ0JyYW5jaCkge1xuICAgICAgICBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gbmV3QnJhbmNoO1xuICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcbiAgICAgICAgICAgIC8vIHNhbWUgcm9vdCB0eXBlIGJ1dCBjb250ZW50IG1heSBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAgICBwYXRjaChwZW5kaW5nQnJhbmNoLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2dnbGVkIGJlZm9yZSBwZW5kaW5nIHRyZWUgaXMgcmVzb2x2ZWRcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdJZCsrO1xuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdG9nZ2xlZCBiZWZvcmUgaHlkcmF0aW9uIGlzIGZpbmlzaGVkLCB0aGUgY3VycmVudCBET00gdHJlZSBpc1xuICAgICAgICAgICAgICAgIC8vIG5vIGxvbmdlciB2YWxpZC4gc2V0IGl0IGFzIHRoZSBhY3RpdmUgYnJhbmNoIHNvIGl0IHdpbGwgYmUgdW5tb3VudGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZXNvbHZlZFxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gcGVuZGluZ0JyYW5jaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVubW91bnQocGVuZGluZ0JyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgcGVuZGluZyBJRC4gdGhpcyBpcyB1c2VkIHRvIGludmFsaWRhdGUgYXN5bmMgY2FsbGJhY2tzXG4gICAgICAgICAgICAvLyByZXNldCBzdXNwZW5zZSBzdGF0ZVxuICAgICAgICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XG4gICAgICAgICAgICAvLyBkaXNjYXJkIGVmZmVjdHMgZnJvbSBwZW5kaW5nIGJyYW5jaFxuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBjb250YWluZXJcbiAgICAgICAgICAgIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaWYgKGlzSW5GYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgaW4gZmFsbGJhY2sgc3RhdGVcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGl2ZUJyYW5jaCAmJiBpc1NhbWVWTm9kZVR5cGUobmV3QnJhbmNoLCBhY3RpdmVCcmFuY2gpKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlZCBcImJhY2tcIiB0byBjdXJyZW50IGFjdGl2ZSBicmFuY2hcbiAgICAgICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgcmVzb2x2ZVxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hlZCB0byBhIDNyZCBicmFuY2hcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBuZXdCcmFuY2gsIHN1c3BlbnNlLmhpZGRlbkNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xuICAgICAgICAgICAgLy8gcm9vdCBkaWQgbm90IGNoYW5nZSwganVzdCBub3JtYWwgcGF0Y2hcbiAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSB0b2dnbGVkXG4gICAgICAgICAgICAvLyBpbnZva2UgQHBlbmRpbmcgZXZlbnRcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChuMiwgJ29uUGVuZGluZycpO1xuICAgICAgICAgICAgLy8gbW91bnQgcGVuZGluZyBicmFuY2ggaW4gb2ZmLWRvbSBjb250YWluZXJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBuZXdCcmFuY2g7XG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGluY29taW5nIGJyYW5jaCBoYXMgbm8gYXN5bmMgZGVwcywgcmVzb2x2ZSBub3cuXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLmZhbGxiYWNrKG5ld0ZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudCwgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIsIGhpZGRlbkNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBpc0h5ZHJhdGluZyA9IGZhbHNlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAvLyBAdHMtaWdub3JlIGBjb25zb2xlLmluZm9gIGNhbm5vdCBiZSBudWxsIGVycm9yXG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IHVubW91bnQsIG46IG5leHQsIG86IHsgcGFyZW50Tm9kZSwgcmVtb3ZlIH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xuICAgIGNvbnN0IHRpbWVvdXQgPSB2bm9kZS5wcm9wcyA/IHRvTnVtYmVyKHZub2RlLnByb3BzLnRpbWVvdXQpIDogdW5kZWZpbmVkO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKHRpbWVvdXQsIGBTdXNwZW5zZSB0aW1lb3V0YCk7XG4gICAgfVxuICAgIGNvbnN0IHN1c3BlbnNlID0ge1xuICAgICAgICB2bm9kZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGlzU1ZHLFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIGhpZGRlbkNvbnRhaW5lcixcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBkZXBzOiAwLFxuICAgICAgICBwZW5kaW5nSWQ6IDAsXG4gICAgICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0ID09PSAnbnVtYmVyJyA/IHRpbWVvdXQgOiAtMSxcbiAgICAgICAgYWN0aXZlQnJhbmNoOiBudWxsLFxuICAgICAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxuICAgICAgICBpc0luRmFsbGJhY2s6IHRydWUsXG4gICAgICAgIGlzSHlkcmF0aW5nLFxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXG4gICAgICAgIGVmZmVjdHM6IFtdLFxuICAgICAgICByZXNvbHZlKHJlc3VtZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bWUgJiYgIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIHdpdGhvdXQgYSBwZW5kaW5nIGJyYW5jaC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzVW5tb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHVubW91bnRlZCBzdXNwZW5zZSBib3VuZGFyeS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBlbmRpbmdCcmFuY2gsIHBlbmRpbmdJZCwgZWZmZWN0cywgcGFyZW50Q29tcG9uZW50LCBjb250YWluZXIgfSA9IHN1c3BlbnNlO1xuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXN1bWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gYWN0aXZlQnJhbmNoICYmXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdCcmFuY2gudHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogTW92ZVR5cGUuRU5URVIgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGluaXRpYWwgYW5jaG9yIG9uIG1vdW50XG4gICAgICAgICAgICAgICAgbGV0IHsgYW5jaG9yIH0gPSBzdXNwZW5zZTtcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50IGN1cnJlbnQgYWN0aXZlIHRyZWVcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmYWxsYmFjayB0cmVlIHdhcyBtb3VudGVkLCBpdCBtYXkgaGF2ZSBiZWVuIG1vdmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHBhcnQgb2YgYSBwYXJlbnQgc3VzcGVuc2UuIGdldCB0aGUgbGF0ZXN0IGFuY2hvciBmb3IgaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IG5leHQoYWN0aXZlQnJhbmNoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBjb250ZW50IGZyb20gb2ZmLWRvbSBjb250YWluZXIgdG8gYWN0dWFsIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBtb3ZlKHBlbmRpbmdCcmFuY2gsIGNvbnRhaW5lciwgYW5jaG9yLCAwIC8qIE1vdmVUeXBlLkVOVEVSICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIHBlbmRpbmdCcmFuY2gpO1xuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG51bGw7XG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGZsdXNoIGJ1ZmZlcmVkIGVmZmVjdHNcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2VcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XG4gICAgICAgICAgICBsZXQgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIG1lcmdlIGJ1ZmZlcmVkIHBvc3Qgam9ic1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIHRoYXQgcGFyZW50XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1VucmVzb2x2ZWRBbmNlc3RvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIGZsdXNoIGFsbCBqb2JzXG4gICAgICAgICAgICBpZiAoIWhhc1VucmVzb2x2ZWRBbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZWZmZWN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzID0gW107XG4gICAgICAgICAgICAvLyBpbnZva2UgQHJlc29sdmUgZXZlbnRcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uUmVzb2x2ZScpO1xuICAgICAgICB9LFxuICAgICAgICBmYWxsYmFjayhmYWxsYmFja1ZOb2RlKSB7XG4gICAgICAgICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBpc1NWRyB9ID0gc3VzcGVuc2U7XG4gICAgICAgICAgICAvLyBpbnZva2UgQGZhbGxiYWNrIGV2ZW50XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvbkZhbGxiYWNrJyk7XG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XG4gICAgICAgICAgICBjb25zdCBtb3VudEZhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3VzcGVuc2UuaXNJbkZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBmYWxsYmFja1ZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgICAgICAgICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBmYWxsYmFja1ZOb2RlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkZWxheUVudGVyID0gZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uICYmIGZhbGxiYWNrVk5vZGUudHJhbnNpdGlvbi5tb2RlID09PSAnb3V0LWluJztcbiAgICAgICAgICAgIGlmIChkZWxheUVudGVyKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgLy8gdW5tb3VudCBjdXJyZW50IGFjdGl2ZSBicmFuY2hcbiAgICAgICAgICAgIHVubW91bnQoYWN0aXZlQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIG5vIHN1c3BlbnNlIHNvIHVubW91bnQgaG9va3MgZmlyZSBub3dcbiAgICAgICAgICAgIHRydWUgLy8gc2hvdWxkUmVtb3ZlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XG4gICAgICAgICAgICAgICAgbW91bnRGYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCB0eXBlKSB7XG4gICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiZcbiAgICAgICAgICAgICAgICBtb3ZlKHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHR5cGUpO1xuICAgICAgICAgICAgc3VzcGVuc2UuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCAmJiBuZXh0KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyRGVwKGluc3RhbmNlLCBzZXR1cFJlbmRlckVmZmVjdCkge1xuICAgICAgICAgICAgY29uc3QgaXNJblBlbmRpbmdTdXNwZW5zZSA9ICEhc3VzcGVuc2UucGVuZGluZ0JyYW5jaDtcbiAgICAgICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuZGVwcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAuYXN5bmNEZXAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwIC8qIEVycm9yQ29kZXMuU0VUVVBfRlVOQ1RJT04gKi8pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihhc3luY1NldHVwUmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyByZXRyeSB3aGVuIHRoZSBzZXR1cCgpIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gdW5tb3VudGVkIGJlZm9yZSByZXNvbHZlLlxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5pc1VubW91bnRlZCB8fFxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCB8fFxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXRyeSBmcm9tIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2bm9kZSB9ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlZEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIG1heSBoYXZlIGJlZW4gcmVwbGFjZWQgaWYgYW4gdXBkYXRlIGhhcHBlbmVkIGJlZm9yZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYXN5bmMgZGVwIGlzIHJlc29sdmVkLlxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5lbCA9IGh5ZHJhdGVkRWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcbiAgICAgICAgICAgICAgICBzZXR1cFJlbmRlckVmZmVjdChpbnN0YW5jZSwgdm5vZGUsIFxuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgaGF2ZSBiZWVuIG1vdmVkIGJlZm9yZSByZXNvbHZlLlxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlci5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlKGh5ZHJhdGVkRWwgfHwgaW5zdGFuY2Uuc3ViVHJlZS5lbCksIFxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlciB0aGUgY29tbWVudCBwbGFjZWhvbGRlciBjYXNlLlxuICAgICAgICAgICAgICAgIGh5ZHJhdGVkRWwgPyBudWxsIDogbmV4dChpbnN0YW5jZS5zdWJUcmVlKSwgc3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmUocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlLmVsKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZGVjcmVhc2UgZGVwcyBjb3VudCBpZiBzdXNwZW5zZSBpcyBub3QgYWxyZWFkeSByZXNvbHZlZFxuICAgICAgICAgICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlICYmIC0tc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKSB7XG4gICAgICAgICAgICBzdXNwZW5zZS5pc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzdXNwZW5zZTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIG5vZGUucGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIG51bGwsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIHRydWUgLyogaHlkcmF0aW5nICovKSk7XG4gICAgLy8gdGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzY2VuYXJpb3MgZm9yIHNlcnZlci1yZW5kZXJlZCBzdXNwZW5zZTpcbiAgICAvLyAtIHN1Y2Nlc3M6IHNzciBjb250ZW50IHNob3VsZCBiZSBmdWxseSByZXNvbHZlZFxuICAgIC8vIC0gZmFpbHVyZTogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIHRoZSBmYWxsYmFjayBicmFuY2guXG4gICAgLy8gaG93ZXZlciwgb24gdGhlIGNsaWVudCB3ZSBkb24ndCByZWFsbHkga25vdyBpZiBpdCBoYXMgZmFpbGVkIG9yIG5vdFxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgRE9NIGFzc3VtaW5nIGl0IGhhcyBzdWNjZWVkZWQsIGJ1dCB3ZSBzdGlsbFxuICAgIC8vIG5lZWQgdG8gY29uc3RydWN0IGEgc3VzcGVuc2UgYm91bmRhcnkgZmlyc3RcbiAgICBjb25zdCByZXN1bHQgPSBoeWRyYXRlTm9kZShub2RlLCAoc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IHZub2RlLnNzQ29udGVudCksIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICBpZiAoc3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlQ2hpbGRyZW4odm5vZGUpIHtcbiAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICAgIGNvbnN0IGlzU2xvdENoaWxkcmVuID0gc2hhcGVGbGFnICYgMzIgLyogU2hhcGVGbGFncy5TTE9UU19DSElMRFJFTiAqLztcbiAgICB2bm9kZS5zc0NvbnRlbnQgPSBub3JtYWxpemVTdXNwZW5zZVNsb3QoaXNTbG90Q2hpbGRyZW4gPyBjaGlsZHJlbi5kZWZhdWx0IDogY2hpbGRyZW4pO1xuICAgIHZub2RlLnNzRmFsbGJhY2sgPSBpc1Nsb3RDaGlsZHJlblxuICAgICAgICA/IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjaylcbiAgICAgICAgOiBjcmVhdGVWTm9kZShDb21tZW50KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XG4gICAgbGV0IGJsb2NrO1xuICAgIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcbiAgICAgICAgaWYgKHRyYWNrQmxvY2spIHtcbiAgICAgICAgICAgIC8vIGRpc2FibGVUcmFja2luZzogZmFsc2VcbiAgICAgICAgICAgIC8vIGFsbG93IGJsb2NrIHRyYWNraW5nIGZvciBjb21waWxlZCBzbG90c1xuICAgICAgICAgICAgLy8gKHNlZSAuL2NvbXBvbmVudFJlbmRlckNvbnRleHQudHMpXG4gICAgICAgICAgICBzLl9kID0gZmFsc2U7XG4gICAgICAgICAgICBvcGVuQmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgICBzID0gcygpO1xuICAgICAgICBpZiAodHJhY2tCbG9jaykge1xuICAgICAgICAgICAgcy5fZCA9IHRydWU7XG4gICAgICAgICAgICBibG9jayA9IGN1cnJlbnRCbG9jaztcbiAgICAgICAgICAgIGNsb3NlQmxvY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBcnJheShzKSkge1xuICAgICAgICBjb25zdCBzaW5nbGVDaGlsZCA9IGZpbHRlclNpbmdsZVJvb3Qocyk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXNpbmdsZUNoaWxkKSB7XG4gICAgICAgICAgICB3YXJuKGA8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xuICAgIH1cbiAgICBzID0gbm9ybWFsaXplVk5vZGUocyk7XG4gICAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xuICAgICAgICBzLmR5bmFtaWNDaGlsZHJlbiA9IGJsb2NrLmZpbHRlcihjID0+IGMgIT09IHMpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlKGZuLCBzdXNwZW5zZSkge1xuICAgIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGZuKSkge1xuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKC4uLmZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaChmbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XG4gICAgc3VzcGVuc2UuYWN0aXZlQnJhbmNoID0gYnJhbmNoO1xuICAgIGNvbnN0IHsgdm5vZGUsIHBhcmVudENvbXBvbmVudCB9ID0gc3VzcGVuc2U7XG4gICAgY29uc3QgZWwgPSAodm5vZGUuZWwgPSBicmFuY2guZWwpO1xuICAgIC8vIGluIGNhc2Ugc3VzcGVuc2UgaXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNvbXBvbmVudCxcbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgdGhlIEhPQyBlbFxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XG4gICAgICAgIHBhcmVudENvbXBvbmVudC52bm9kZS5lbCA9IGVsO1xuICAgICAgICB1cGRhdGVIT0NIb3N0RWwocGFyZW50Q29tcG9uZW50LCBlbCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBwcm92aWRlKCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xuICAgICAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcbiAgICAgICAgLy8gYnV0IHdoZW4gaXQgbmVlZHMgdG8gcHJvdmlkZSB2YWx1ZXMgb2YgaXRzIG93biwgaXQgY3JlYXRlcyBpdHNcbiAgICAgICAgLy8gb3duIHByb3ZpZGVzIG9iamVjdCB1c2luZyBwYXJlbnQgcHJvdmlkZXMgb2JqZWN0IGFzIHByb3RvdHlwZS5cbiAgICAgICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcbiAgICAgICAgLy8gcGFyZW50IGFuZCBsZXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkbyB0aGUgd29yay5cbiAgICAgICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XG4gICAgICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gcHJvdmlkZXMpIHtcbiAgICAgICAgICAgIHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxuICAgICAgICBwcm92aWRlc1trZXldID0gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5qZWN0KGtleSwgZGVmYXVsdFZhbHVlLCB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgPSBmYWxzZSkge1xuICAgIC8vIGZhbGxiYWNrIHRvIGBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VgIHNvIHRoYXQgdGhpcyBjYW4gYmUgY2FsbGVkIGluXG4gICAgLy8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlIHx8IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gIzI0MDBcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBgYXBwLnVzZWAgcGx1Z2lucyxcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGluc3RhbmNlIGlzIGF0IHJvb3RcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpbnN0YW5jZS5wYXJlbnQgPT0gbnVsbFxuICAgICAgICAgICAgPyBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0ICYmIGluc3RhbmNlLnZub2RlLmFwcENvbnRleHQucHJvdmlkZXNcbiAgICAgICAgICAgIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xuICAgICAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XG4gICAgICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlLnByb3h5KVxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybihgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm4oYGluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLmApO1xuICAgIH1cbn1cblxuLy8gU2ltcGxlIGVmZmVjdC5cbmZ1bmN0aW9uIHdhdGNoRWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB3YXRjaFBvc3RFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZsdXNoOiAncG9zdCcgfSkgOiB7IGZsdXNoOiAncG9zdCcgfSk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZsdXNoOiAnc3luYycgfSkgOiB7IGZsdXNoOiAnc3luYycgfSk7XG59XG4vLyBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycyB0byB0cmlnZ2VyIG9uIHVuZGVmaW5lZCBpbml0aWFsIHZhbHVlc1xuY29uc3QgSU5JVElBTF9XQVRDSEVSX1ZBTFVFID0ge307XG4vLyBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzRnVuY3Rpb24oY2IpKSB7XG4gICAgICAgIHdhcm4oYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBgICtcbiAgICAgICAgICAgIGBVc2UgXFxgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KVxcYCBpbnN0ZWFkLiBcXGB3YXRjaFxcYCBub3cgb25seSBgICtcbiAgICAgICAgICAgIGBzdXBwb3J0cyBcXGB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xuICAgIH1cbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IEVNUFRZX09CSikge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWNiKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2Fybihgd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YXJuKGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLCBzLCBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYCArXG4gICAgICAgICAgICBgYSByZWFjdGl2ZSBvYmplY3QsIG9yIGFuIGFycmF5IG9mIHRoZXNlIHR5cGVzLmApO1xuICAgIH07XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50U2NvcGUoKSA9PT0gKGN1cnJlbnRJbnN0YW5jZSA9PT0gbnVsbCB8fCBjdXJyZW50SW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRJbnN0YW5jZS5zY29wZSkgPyBjdXJyZW50SW5zdGFuY2UgOiBudWxsO1xuICAgIC8vIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlXG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XG4gICAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcbiAgICBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UudmFsdWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyQxKHNvdXJjZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2U7XG4gICAgICAgIGRlZXAgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKHMgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3ckMShzKSk7XG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS5tYXAocyA9PiB7XG4gICAgICAgICAgICBpZiAoaXNSZWYocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2Uocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzLCBpbnN0YW5jZSwgMiAvKiBFcnJvckNvZGVzLldBVENIX0dFVFRFUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkludmFsaWRTb3VyY2Uocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAvLyBnZXR0ZXIgd2l0aCBjYlxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDIgLyogRXJyb3JDb2Rlcy5XQVRDSF9HRVRURVIgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc1VubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDMgLyogRXJyb3JDb2Rlcy5XQVRDSF9DQUxMQkFDSyAqLywgW29uQ2xlYW51cF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gTk9PUDtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmIChjYiAmJiBkZWVwKSB7XG4gICAgICAgIGNvbnN0IGJhc2VHZXR0ZXIgPSBnZXR0ZXI7XG4gICAgICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSk7XG4gICAgfVxuICAgIGxldCBjbGVhbnVwO1xuICAgIGxldCBvbkNsZWFudXAgPSAoZm4pID0+IHtcbiAgICAgICAgY2xlYW51cCA9IGVmZmVjdC5vblN0b3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCA0IC8qIEVycm9yQ29kZXMuV0FUQ0hfQ0xFQU5VUCAqLyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBpbiBTU1IgdGhlcmUgaXMgbm8gbmVlZCB0byBzZXR1cCBhbiBhY3R1YWwgZWZmZWN0LCBhbmQgaXQgc2hvdWxkIGJlIG5vb3BcbiAgICAvLyB1bmxlc3MgaXQncyBlYWdlciBvciBzeW5jIGZsdXNoXG4gICAgbGV0IHNzckNsZWFudXA7XG4gICAgaWYgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkge1xuICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbm90IGNhbGwgdGhlIGludmFsaWRhdGUgY2FsbGJhY2sgKCsgcnVubmVyIGlzIG5vdCBzZXQgdXApXG4gICAgICAgIG9uQ2xlYW51cCA9IE5PT1A7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIGdldHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIEVycm9yQ29kZXMuV0FUQ0hfQ0FMTEJBQ0sgKi8sIFtcbiAgICAgICAgICAgICAgICBnZXR0ZXIoKSxcbiAgICAgICAgICAgICAgICBpc011bHRpU291cmNlID8gW10gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb25DbGVhbnVwXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdXNlU1NSQ29udGV4dCgpO1xuICAgICAgICAgICAgc3NyQ2xlYW51cCA9IGN0eC5fX3dhdGNoZXJIYW5kbGVzIHx8IChjdHguX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOT09QO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2VcbiAgICAgICAgPyBuZXcgQXJyYXkoc291cmNlLmxlbmd0aCkuZmlsbChJTklUSUFMX1dBVENIRVJfVkFMVUUpXG4gICAgICAgIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xuICAgIGNvbnN0IGpvYiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICAgICAgICBpZiAoZGVlcCB8fFxuICAgICAgICAgICAgICAgIGZvcmNlVHJpZ2dlciB8fFxuICAgICAgICAgICAgICAgIChpc011bHRpU291cmNlXG4gICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQ2hhbmdlZChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIChmYWxzZSAgKSkge1xuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBFcnJvckNvZGVzLldBVENIX0NBTExCQUNLICovLCBbXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzIHVuZGVmaW5lZCBhcyB0aGUgb2xkIHZhbHVlIHdoZW4gaXQncyBjaGFuZ2VkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9PT0gSU5JVElBTF9XQVRDSEVSX1ZBTFVFXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpc011bHRpU291cmNlICYmIG9sZFZhbHVlWzBdID09PSBJTklUSUFMX1dBVENIRVJfVkFMVUVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGVhbnVwXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhdGNoRWZmZWN0XG4gICAgICAgICAgICBlZmZlY3QucnVuKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGltcG9ydGFudDogbWFyayB0aGUgam9iIGFzIGEgd2F0Y2hlciBjYWxsYmFjayBzbyB0aGF0IHNjaGVkdWxlciBrbm93c1xuICAgIC8vIGl0IGlzIGFsbG93ZWQgdG8gc2VsZi10cmlnZ2VyICgjMTcyNylcbiAgICBqb2IuYWxsb3dSZWN1cnNlID0gISFjYjtcbiAgICBsZXQgc2NoZWR1bGVyO1xuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGpvYjsgLy8gdGhlIHNjaGVkdWxlciBmdW5jdGlvbiBnZXRzIGNhbGxlZCBkaXJlY3RseVxuICAgIH1cbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlUG9zdFJlbmRlckVmZmVjdChqb2IsIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQ6ICdwcmUnXG4gICAgICAgIGpvYi5wcmUgPSB0cnVlO1xuICAgICAgICBpZiAoaW5zdGFuY2UpXG4gICAgICAgICAgICBqb2IuaWQgPSBpbnN0YW5jZS51aWQ7XG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlSm9iKGpvYik7XG4gICAgfVxuICAgIGNvbnN0IGVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsIHNjaGVkdWxlcik7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBlZmZlY3Qub25UcmFjayA9IG9uVHJhY2s7XG4gICAgICAgIGVmZmVjdC5vblRyaWdnZXIgPSBvblRyaWdnZXI7XG4gICAgfVxuICAgIC8vIGluaXRpYWwgcnVuXG4gICAgaWYgKGNiKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIGpvYigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZWZmZWN0LnJ1bi5iaW5kKGVmZmVjdCksIGluc3RhbmNlICYmIGluc3RhbmNlLnN1c3BlbnNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICB9XG4gICAgY29uc3QgdW53YXRjaCA9ICgpID0+IHtcbiAgICAgICAgZWZmZWN0LnN0b3AoKTtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnNjb3BlKSB7XG4gICAgICAgICAgICByZW1vdmUoaW5zdGFuY2Uuc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKHNzckNsZWFudXApXG4gICAgICAgIHNzckNsZWFudXAucHVzaCh1bndhdGNoKTtcbiAgICByZXR1cm4gdW53YXRjaDtcbn1cbi8vIHRoaXMuJHdhdGNoXG5mdW5jdGlvbiBpbnN0YW5jZVdhdGNoKHNvdXJjZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gdGhpcy5wcm94eTtcbiAgICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpXG4gICAgICAgID8gc291cmNlLmluY2x1ZGVzKCcuJylcbiAgICAgICAgICAgID8gY3JlYXRlUGF0aEdldHRlcihwdWJsaWNUaGlzLCBzb3VyY2UpXG4gICAgICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXVxuICAgICAgICA6IHNvdXJjZS5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgIGxldCBjYjtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgY2IgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNiID0gdmFsdWUuaGFuZGxlcjtcbiAgICAgICAgb3B0aW9ucyA9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBjdXIgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgc2V0Q3VycmVudEluc3RhbmNlKHRoaXMpO1xuICAgIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgbGV0IGN1ciA9IGN0eDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGggJiYgY3VyOyBpKyspIHtcbiAgICAgICAgICAgIGN1ciA9IGN1cltzZWdtZW50c1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJhdmVyc2UodmFsdWUsIHNlZW4pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZVtcIl9fdl9za2lwXCIgLyogUmVhY3RpdmVGbGFncy5TS0lQICovXSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBTZXQoKTtcbiAgICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2Vlbi5hZGQodmFsdWUpO1xuICAgIGlmIChpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUudmFsdWUsIHNlZW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtpXSwgc2Vlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTZXQodmFsdWUpIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICB0cmF2ZXJzZSh2LCBzZWVuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBzZWVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0ZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAgICAgaXNMZWF2aW5nOiBmYWxzZSxcbiAgICAgICAgaXNVbm1vdW50aW5nOiBmYWxzZSxcbiAgICAgICAgbGVhdmluZ1ZOb2RlczogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xuICAgICAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIG9uQmVmb3JlVW5tb3VudCgoKSA9PiB7XG4gICAgICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IgPSBbRnVuY3Rpb24sIEFycmF5XTtcbmNvbnN0IEJhc2VUcmFuc2l0aW9uSW1wbCA9IHtcbiAgICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxuICAgIHByb3BzOiB7XG4gICAgICAgIG1vZGU6IFN0cmluZyxcbiAgICAgICAgYXBwZWFyOiBCb29sZWFuLFxuICAgICAgICBwZXJzaXN0ZWQ6IEJvb2xlYW4sXG4gICAgICAgIC8vIGVudGVyXG4gICAgICAgIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BZnRlckVudGVyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIC8vIGxlYXZlXG4gICAgICAgIG9uQmVmb3JlTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxuICAgICAgICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BZnRlckxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25MZWF2ZUNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIC8vIGFwcGVhclxuICAgICAgICBvbkJlZm9yZUFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIG9uQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcbiAgICAgICAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvclxuICAgIH0sXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHVzZVRyYW5zaXRpb25TdGF0ZSgpO1xuICAgICAgICBsZXQgcHJldlRyYW5zaXRpb25LZXk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgJiYgZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKHNsb3RzLmRlZmF1bHQoKSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhc0ZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gbG9jYXRlIGZpcnN0IG5vbi1jb21tZW50IGNoaWxkXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaGFzRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YXJuIG1vcmUgdGhhbiBvbmUgbm9uLWNvbW1lbnQgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHRyYWNrIHJlYWN0aXZpdHkgZm9yIHRoZXNlIHByb3BzIHNvIHVzZSB0aGUgcmF3XG4gICAgICAgICAgICAvLyBwcm9wcyBmb3IgYSBiaXQgYmV0dGVyIHBlcmZcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgeyBtb2RlIH0gPSByYXdQcm9wcztcbiAgICAgICAgICAgIC8vIGNoZWNrIG1vZGVcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICBtb2RlICYmXG4gICAgICAgICAgICAgICAgbW9kZSAhPT0gJ2luLW91dCcgJiZcbiAgICAgICAgICAgICAgICBtb2RlICE9PSAnb3V0LWluJyAmJlxuICAgICAgICAgICAgICAgIG1vZGUgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHdhcm4oYGludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiA8dHJhbnNpdGlvbj48a2VlcC1hbGl2ZS8+PC90cmFuc2l0aW9uPiwgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgdHlwZSBvZiB0aGUga2VwdC1hbGl2ZSBjaGlsZHJlbi5cbiAgICAgICAgICAgIGNvbnN0IGlubmVyQ2hpbGQgPSBnZXRLZWVwQWxpdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCBlbnRlckhvb2tzKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gaW5zdGFuY2Uuc3ViVHJlZTtcbiAgICAgICAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbktleUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0VHJhbnNpdGlvbktleSB9ID0gaW5uZXJDaGlsZC50eXBlO1xuICAgICAgICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRUcmFuc2l0aW9uS2V5KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZUcmFuc2l0aW9uS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gcHJldlRyYW5zaXRpb25LZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25LZXlDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgbW9kZVxuICAgICAgICAgICAgaWYgKG9sZElubmVyQ2hpbGQgJiZcbiAgICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiZcbiAgICAgICAgICAgICAgICAoIWlzU2FtZVZOb2RlVHlwZShpbm5lckNoaWxkLCBvbGRJbm5lckNoaWxkKSB8fCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWF2aW5nSG9va3MgPSByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIHJhd1Byb3BzLCBzdGF0ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvbGQgdHJlZSdzIGhvb2tzIGluIGNhc2Ugb2YgZHluYW1pYyB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKG9sZElubmVyQ2hpbGQsIGxlYXZpbmdIb29rcyk7XG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGJldHdlZW4gZGlmZmVyZW50IHZpZXdzXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzY4MzVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGFsc28gbmVlZHMgdG8gYmUgdXBkYXRlZCB3aGVuIGFjdGl2ZSBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS51cGRhdGUuYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlQbGFjZWhvbGRlcihjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnICYmIGlubmVyQ2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuZGVsYXlMZWF2ZSA9IChlbCwgZWFybHlSZW1vdmUsIGRlbGF5ZWRMZWF2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgb2xkSW5uZXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGVzQ2FjaGVbU3RyaW5nKG9sZElubmVyQ2hpbGQua2V5KV0gPSBvbGRJbm5lckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFybHkgcmVtb3ZhbCBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFybHlSZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXJIb29rcy5kZWxheWVkTGVhdmUgPSBkZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2Vcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXG5jb25zdCBCYXNlVHJhbnNpdGlvbiA9IEJhc2VUcmFuc2l0aW9uSW1wbDtcbmZ1bmN0aW9uIGdldExlYXZpbmdOb2Rlc0ZvclR5cGUoc3RhdGUsIHZub2RlKSB7XG4gICAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcbiAgICBsZXQgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gbGVhdmluZ1ZOb2Rlcy5nZXQodm5vZGUudHlwZSk7XG4gICAgaWYgKCFsZWF2aW5nVk5vZGVzQ2FjaGUpIHtcbiAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGVhdmluZ1ZOb2Rlcy5zZXQodm5vZGUudHlwZSwgbGVhdmluZ1ZOb2Rlc0NhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcbn1cbi8vIFRoZSB0cmFuc2l0aW9uIGhvb2tzIGFyZSBhdHRhY2hlZCB0byB0aGUgdm5vZGUgYXMgdm5vZGUudHJhbnNpdGlvblxuLy8gYW5kIHdpbGwgYmUgY2FsbGVkIGF0IGFwcHJvcHJpYXRlIHRpbWluZyBpbiB0aGUgcmVuZGVyZXIuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKSB7XG4gICAgY29uc3QgeyBhcHBlYXIsIG1vZGUsIHBlcnNpc3RlZCA9IGZhbHNlLCBvbkJlZm9yZUVudGVyLCBvbkVudGVyLCBvbkFmdGVyRW50ZXIsIG9uRW50ZXJDYW5jZWxsZWQsIG9uQmVmb3JlTGVhdmUsIG9uTGVhdmUsIG9uQWZ0ZXJMZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIsIG9uQXBwZWFyLCBvbkFmdGVyQXBwZWFyLCBvbkFwcGVhckNhbmNlbGxlZCB9ID0gcHJvcHM7XG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XG4gICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgdm5vZGUpO1xuICAgIGNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MpID0+IHtcbiAgICAgICAgaG9vayAmJlxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDkgLyogRXJyb3JDb2Rlcy5UUkFOU0lUSU9OX0hPT0sgKi8sIGFyZ3MpO1xuICAgIH07XG4gICAgY29uc3QgY2FsbEFzeW5jSG9vayA9IChob29rLCBhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSBhcmdzWzFdO1xuICAgICAgICBjYWxsSG9vayhob29rLCBhcmdzKTtcbiAgICAgICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgICAgICAgIGlmIChob29rLmV2ZXJ5KGhvb2sgPT4gaG9vay5sZW5ndGggPD0gMSkpXG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaG9va3MgPSB7XG4gICAgICAgIG1vZGUsXG4gICAgICAgIHBlcnNpc3RlZCxcbiAgICAgICAgYmVmb3JlRW50ZXIoZWwpIHtcbiAgICAgICAgICAgIGxldCBob29rID0gb25CZWZvcmVFbnRlcjtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGVhcikge1xuICAgICAgICAgICAgICAgICAgICBob29rID0gb25CZWZvcmVBcHBlYXIgfHwgb25CZWZvcmVFbnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3Igc2FtZSBlbGVtZW50ICh2LXNob3cpXG4gICAgICAgICAgICBpZiAoZWwuX2xlYXZlQ2IpIHtcbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3IgdG9nZ2xlZCBlbGVtZW50IHdpdGggc2FtZSBrZXkgKHYtaWYpXG4gICAgICAgICAgICBjb25zdCBsZWF2aW5nVk5vZGUgPSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcbiAgICAgICAgICAgIGlmIChsZWF2aW5nVk5vZGUgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiZcbiAgICAgICAgICAgICAgICBsZWF2aW5nVk5vZGUuZWwuX2xlYXZlQ2IpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBlYXJseSByZW1vdmFsIChub3QgY2FuY2VsbGVkKVxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudGVyKGVsKSB7XG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uRW50ZXI7XG4gICAgICAgICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xuICAgICAgICAgICAgbGV0IGNhbmNlbEhvb2sgPSBvbkVudGVyQ2FuY2VsbGVkO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2sgPSBvbkFwcGVhciB8fCBvbkVudGVyO1xuICAgICAgICAgICAgICAgICAgICBhZnRlckhvb2sgPSBvbkFmdGVyQXBwZWFyIHx8IG9uQWZ0ZXJFbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsSG9vayA9IG9uQXBwZWFyQ2FuY2VsbGVkIHx8IG9uRW50ZXJDYW5jZWxsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZG9uZSA9IChlbC5fZW50ZXJDYiA9IChjYW5jZWxsZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhvb2tzLmRlbGF5ZWRMZWF2ZSkge1xuICAgICAgICAgICAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChob29rKSB7XG4gICAgICAgICAgICAgICAgY2FsbEFzeW5jSG9vayhob29rLCBbZWwsIGRvbmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGVhdmUoZWwsIHJlbW92ZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XG4gICAgICAgICAgICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICAgICAgICAgICAgICBlbC5fZW50ZXJDYih0cnVlIC8qIGNhbmNlbGxlZCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNVbm1vdW50aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVMZWF2ZSwgW2VsXSk7XG4gICAgICAgICAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9sZWF2ZUNiID0gKGNhbmNlbGxlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5fbGVhdmVDYiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPT09IHZub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsZWF2aW5nVk5vZGVzQ2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgICAgICBpZiAob25MZWF2ZSkge1xuICAgICAgICAgICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lKHZub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyh2bm9kZSwgcHJvcHMsIHN0YXRlLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBob29rcztcbn1cbi8vIHRoZSBwbGFjZWhvbGRlciByZWFsbHkgb25seSBoYW5kbGVzIG9uZSBzcGVjaWFsIGNhc2U6IEtlZXBBbGl2ZVxuLy8gaW4gdGhlIGNhc2Ugb2YgYSBLZWVwQWxpdmUgaW4gYSBsZWF2ZSBwaGFzZSB3ZSBuZWVkIHRvIHJldHVybiBhIEtlZXBBbGl2ZVxuLy8gcGxhY2Vob2xkZXIgd2l0aCBlbXB0eSBjb250ZW50IHRvIGF2b2lkIHRoZSBLZWVwQWxpdmUgaW5zdGFuY2UgZnJvbSBiZWluZ1xuLy8gdW5tb3VudGVkLlxuZnVuY3Rpb24gZW1wdHlQbGFjZWhvbGRlcih2bm9kZSkge1xuICAgIGlmIChpc0tlZXBBbGl2ZSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgdm5vZGUuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0S2VlcEFsaXZlQ2hpbGQodm5vZGUpIHtcbiAgICByZXR1cm4gaXNLZWVwQWxpdmUodm5vZGUpXG4gICAgICAgID8gdm5vZGUuY2hpbGRyZW5cbiAgICAgICAgICAgID8gdm5vZGUuY2hpbGRyZW5bMF1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIDogdm5vZGU7XG59XG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8gJiYgdm5vZGUuY29tcG9uZW50KSB7XG4gICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSwgaG9va3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykge1xuICAgICAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XG4gICAgICAgIHZub2RlLnNzRmFsbGJhY2sudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzRmFsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdm5vZGUudHJhbnNpdGlvbiA9IGhvb2tzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZHJlbiwga2VlcENvbW1lbnQgPSBmYWxzZSwgcGFyZW50S2V5KSB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIC8vICM1MzYwIGluaGVyaXQgcGFyZW50IGtleSBpbiBjYXNlIG9mIDx0ZW1wbGF0ZSB2LWZvcj5cbiAgICAgICAgY29uc3Qga2V5ID0gcGFyZW50S2V5ID09IG51bGxcbiAgICAgICAgICAgID8gY2hpbGQua2V5XG4gICAgICAgICAgICA6IFN0cmluZyhwYXJlbnRLZXkpICsgU3RyaW5nKGNoaWxkLmtleSAhPSBudWxsID8gY2hpbGQua2V5IDogaSk7XG4gICAgICAgIC8vIGhhbmRsZSBmcmFnbWVudCBjaGlsZHJlbiBjYXNlLCBlLmcuIHYtZm9yXG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCAvKiBQYXRjaEZsYWdzLktFWUVEX0ZSQUdNRU5UICovKVxuICAgICAgICAgICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oY2hpbGQuY2hpbGRyZW4sIGtlZXBDb21tZW50LCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21tZW50IHBsYWNlaG9sZGVycyBzaG91bGQgYmUgc2tpcHBlZCwgZS5nLiB2LWlmXG4gICAgICAgIGVsc2UgaWYgKGtlZXBDb21tZW50IHx8IGNoaWxkLnR5cGUgIT09IENvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGtleSAhPSBudWxsID8gY2xvbmVWTm9kZShjaGlsZCwgeyBrZXkgfSkgOiBjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gIzExMjYgaWYgYSB0cmFuc2l0aW9uIGNoaWxkcmVuIGxpc3QgY29udGFpbnMgbXVsdGlwbGUgc3ViIGZyYWdtZW50cywgdGhlc2VcbiAgICAvLyBmcmFnbWVudHMgd2lsbCBiZSBtZXJnZWQgaW50byBhIGZsYXQgY2hpbGRyZW4gYXJyYXkuIFNpbmNlIGVhY2ggdi1mb3JcbiAgICAvLyBmcmFnbWVudCBtYXkgY29udGFpbiBkaWZmZXJlbnQgc3RhdGljIGJpbmRpbmdzIGluc2lkZSwgd2UgbmVlZCB0byBkZS1vcFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIHRvIGZvcmNlIGZ1bGwgZGlmZnMgdG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IuXG4gICAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXS5wYXRjaEZsYWcgPSAtMiAvKiBQYXRjaEZsYWdzLkJBSUwgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLy8gaW1wbGVtZW50YXRpb24sIGNsb3NlIHRvIG5vLW9wXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG9wdGlvbnMpID8geyBzZXR1cDogb3B0aW9ucywgbmFtZTogb3B0aW9ucy5uYW1lIH0gOiBvcHRpb25zO1xufVxuXG5jb25zdCBpc0FzeW5jV3JhcHBlciA9IChpKSA9PiAhIWkudHlwZS5fX2FzeW5jTG9hZGVyO1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gdHJ1ZSwgb25FcnJvcjogdXNlck9uRXJyb3IgfSA9IHNvdXJjZTtcbiAgICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xuICAgIGxldCByZXNvbHZlZENvbXA7XG4gICAgbGV0IHJldHJpZXMgPSAwO1xuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgICAgICByZXRyaWVzKys7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGxldCB0aGlzUmVxdWVzdDtcbiAgICAgICAgcmV0dXJuIChwZW5kaW5nUmVxdWVzdCB8fFxuICAgICAgICAgICAgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPVxuICAgICAgICAgICAgICAgIGxvYWRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVyb3AgbW9kdWxlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wLl9fZXNNb2R1bGUgfHwgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQ29tcCA9IGNvbXA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gZGVmaW5lQ29tcG9uZW50KHtcbiAgICAgICAgbmFtZTogJ0FzeW5jQ29tcG9uZW50V3JhcHBlcicsXG4gICAgICAgIF9fYXN5bmNMb2FkZXI6IGxvYWQsXG4gICAgICAgIGdldCBfX2FzeW5jUmVzb2x2ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xuICAgICAgICB9LFxuICAgICAgICBzZXR1cCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICAgICAgLy8gYWxyZWFkeSByZXNvbHZlZFxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ29tcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAxMyAvKiBFcnJvckNvZGVzLkFTWU5DX0NPTVBPTkVOVF9MT0FERVIgKi8sICFlcnJvckNvbXBvbmVudCAvKiBkbyBub3QgdGhyb3cgaW4gZGV2IGlmIHVzZXIgcHJvdmlkZWQgZXJyb3IgY29tcG9uZW50ICovKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBzdXNwZW5zZS1jb250cm9sbGVkIG9yIFNTUi5cbiAgICAgICAgICAgIGlmICgoc3VzcGVuc2libGUgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpIHx8XG4gICAgICAgICAgICAgICAgKGlzSW5TU1JDb21wb25lbnRTZXR1cCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZCgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGNvbXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY3JlYXRlSW5uZXJDb21wKGNvbXAsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZXJyb3JDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVmKCk7XG4gICAgICAgICAgICBjb25zdCBkZWxheWVkID0gcmVmKCEhZGVsYXkpO1xuICAgICAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5ZWQudmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkLnZhbHVlICYmICFlcnJvci52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBBc3luYyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tcy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2FkKClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9hZGVkLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50ICYmIGlzS2VlcEFsaXZlKGluc3RhbmNlLnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IGlzIGtlZXAtYWxpdmUsIGZvcmNlIHVwZGF0ZSBzbyB0aGUgbG9hZGVkIGNvbXBvbmVudCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgaXMgdGFrZW4gaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlSm9iKGluc3RhbmNlLnBhcmVudC51cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIGVycm9yLnZhbHVlID0gZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2FkZWQudmFsdWUgJiYgcmVzb2x2ZWRDb21wKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yLnZhbHVlICYmIGVycm9yQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShlcnJvckNvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShsb2FkaW5nQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbm5lckNvbXAoY29tcCwgcGFyZW50KSB7XG4gICAgY29uc3QgeyByZWYsIHByb3BzLCBjaGlsZHJlbiwgY2UgfSA9IHBhcmVudC52bm9kZTtcbiAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKGNvbXAsIHByb3BzLCBjaGlsZHJlbik7XG4gICAgLy8gZW5zdXJlIGlubmVyIGNvbXBvbmVudCBpbmhlcml0cyB0aGUgYXN5bmMgd3JhcHBlcidzIHJlZiBvd25lclxuICAgIHZub2RlLnJlZiA9IHJlZjtcbiAgICAvLyBwYXNzIHRoZSBjdXN0b20gZWxlbWVudCBjYWxsYmFjayBvbiB0byB0aGUgaW5uZXIgY29tcFxuICAgIC8vIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgYXN5bmMgd3JhcHBlclxuICAgIHZub2RlLmNlID0gY2U7XG4gICAgZGVsZXRlIHBhcmVudC52bm9kZS5jZTtcbiAgICByZXR1cm4gdm5vZGU7XG59XG5cbmNvbnN0IGlzS2VlcEFsaXZlID0gKHZub2RlKSA9PiB2bm9kZS50eXBlLl9faXNLZWVwQWxpdmU7XG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xuICAgIG5hbWU6IGBLZWVwQWxpdmVgLFxuICAgIC8vIE1hcmtlciBmb3Igc3BlY2lhbCBoYW5kbGluZyBpbnNpZGUgdGhlIHJlbmRlcmVyLiBXZSBhcmUgbm90IHVzaW5nIGEgPT09XG4gICAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcbiAgICAvLyB3b3VsZCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXG4gICAgX19pc0tlZXBBbGl2ZTogdHJ1ZSxcbiAgICBwcm9wczoge1xuICAgICAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICAgICAgZXhjbHVkZTogW1N0cmluZywgUmVnRXhwLCBBcnJheV0sXG4gICAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICAgIH0sXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICAvLyBLZWVwQWxpdmUgY29tbXVuaWNhdGVzIHdpdGggdGhlIGluc3RhbnRpYXRlZCByZW5kZXJlciB2aWEgdGhlXG4gICAgICAgIC8vIGN0eCB3aGVyZSB0aGUgcmVuZGVyZXIgcGFzc2VzIGluIGl0cyBpbnRlcm5hbHMsXG4gICAgICAgIC8vIGFuZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGV4cG9zZXMgYWN0aXZhdGUvZGVhY3RpdmF0ZSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICAgIC8vIFRoZSB3aG9sZSBwb2ludCBvZiB0aGlzIGlzIHRvIGF2b2lkIGltcG9ydGluZyBLZWVwQWxpdmUgZGlyZWN0bHkgaW4gdGhlXG4gICAgICAgIC8vIHJlbmRlcmVyIHRvIGZhY2lsaXRhdGUgdHJlZS1zaGFraW5nLlxuICAgICAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xuICAgICAgICAvLyBpZiB0aGUgaW50ZXJuYWwgcmVuZGVyZXIgaXMgbm90IHJlZ2lzdGVyZWQsIGl0IGluZGljYXRlcyB0aGF0IHRoaXMgaXMgc2VydmVyLXNpZGUgcmVuZGVyaW5nLFxuICAgICAgICAvLyBmb3IgS2VlcEFsaXZlLCB3ZSBqdXN0IG5lZWQgdG8gcmVuZGVyIGl0cyBjaGlsZHJlblxuICAgICAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIHNsb3RzLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBjdXJyZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgIGluc3RhbmNlLl9fdl9jYWNoZSA9IGNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFN1c3BlbnNlID0gaW5zdGFuY2Uuc3VzcGVuc2U7XG4gICAgICAgIGNvbnN0IHsgcmVuZGVyZXI6IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiBfdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSB9ID0gc2hhcmVkQ29udGV4dDtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBNb3ZlVHlwZS5FTlRFUiAqLywgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgIHBhdGNoKGluc3RhbmNlLnZub2RlLCB2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHZub2RlLnNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGluc3RhbmNlLmEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlTW91bnRlZDtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGVIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlLnBhcmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbXBvbmVudHMgdHJlZVxuICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzaGFyZWRDb250ZXh0LmRlYWN0aXZhdGUgPSAodm5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgbW92ZSh2bm9kZSwgc3RvcmFnZUNvbnRhaW5lciwgbnVsbCwgMSAvKiBNb3ZlVHlwZS5MRUFWRSAqLywgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoaW5zdGFuY2UuZGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgaW5zdGFuY2UucGFyZW50LCB2bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlzRGVhY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRBZGRlZChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHVubW91bnQodm5vZGUpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBzaGFwZUZsYWcgc28gaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZFxuICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcodm5vZGUpO1xuICAgICAgICAgICAgX3VubW91bnQodm5vZGUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJ1bmVDYWNoZShmaWx0ZXIpIHtcbiAgICAgICAgICAgIGNhY2hlLmZvckVhY2goKHZub2RlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiAoIWZpbHRlciB8fCAhZmlsdGVyKG5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghY3VycmVudCB8fCAhaXNTYW1lVk5vZGVUeXBlKGNhY2hlZCwgY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNhY2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBhY3RpdmUgaW5zdGFuY2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBrZXB0LWFsaXZlLlxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IHVubW91bnQgaXQgbm93IGJ1dCBpdCBtaWdodCBiZSBsYXRlciwgc28gcmVzZXQgaXRzIGZsYWcgbm93LlxuICAgICAgICAgICAgICAgIHJlc2V0U2hhcGVGbGFnKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBrZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBydW5lIGNhY2hlIG9uIGluY2x1ZGUvZXhjbHVkZSBwcm9wIGNoYW5nZVxuICAgICAgICB3YXRjaCgoKSA9PiBbcHJvcHMuaW5jbHVkZSwgcHJvcHMuZXhjbHVkZV0sIChbaW5jbHVkZSwgZXhjbHVkZV0pID0+IHtcbiAgICAgICAgICAgIGluY2x1ZGUgJiYgcHJ1bmVDYWNoZShuYW1lID0+IG1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpO1xuICAgICAgICAgICAgZXhjbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xuICAgICAgICB9LCBcbiAgICAgICAgLy8gcHJ1bmUgcG9zdC1yZW5kZXIgYWZ0ZXIgYGN1cnJlbnRgIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgICAgeyBmbHVzaDogJ3Bvc3QnLCBkZWVwOiB0cnVlIH0pO1xuICAgICAgICAvLyBjYWNoZSBzdWIgdHJlZSBhZnRlciByZW5kZXJcbiAgICAgICAgbGV0IHBlbmRpbmdDYWNoZUtleSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGNhY2hlU3VidHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGZpeCAjMTYyMSwgdGhlIHBlbmRpbmdDYWNoZUtleSBjb3VsZCBiZSAwXG4gICAgICAgICAgICBpZiAocGVuZGluZ0NhY2hlS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XG4gICAgICAgIG9uVXBkYXRlZChjYWNoZVN1YnRyZWUpO1xuICAgICAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaChjYWNoZWQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3ViVHJlZSwgc3VzcGVuc2UgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChzdWJUcmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUgJiYgY2FjaGVkLmtleSA9PT0gdm5vZGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgaW5zdGFuY2Ugd2lsbCBiZSB1bm1vdW50ZWQgYXMgcGFydCBvZiBrZWVwLWFsaXZlJ3MgdW5tb3VudFxuICAgICAgICAgICAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnZva2UgaXRzIGRlYWN0aXZhdGVkIGhvb2sgaGVyZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYSA9IHZub2RlLmNvbXBvbmVudC5kYTtcbiAgICAgICAgICAgICAgICAgICAgZGEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRhLCBzdXNwZW5zZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5tb3VudChjYWNoZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcGVuZGluZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghc2xvdHMuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0KCk7XG4gICAgICAgICAgICBjb25zdCByYXdWTm9kZSA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEtlZXBBbGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBjb21wb25lbnQgY2hpbGQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fFxuICAgICAgICAgICAgICAgICghKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi8pICYmXG4gICAgICAgICAgICAgICAgICAgICEocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2bm9kZSA9IGdldElubmVyQ2hpbGQocmF3Vk5vZGUpO1xuICAgICAgICAgICAgY29uc3QgY29tcCA9IHZub2RlLnR5cGU7XG4gICAgICAgICAgICAvLyBmb3IgYXN5bmMgY29tcG9uZW50cywgbmFtZSBjaGVjayBzaG91bGQgYmUgYmFzZWQgaW4gaXRzIGxvYWRlZFxuICAgICAgICAgICAgLy8gaW5uZXIgY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoaXNBc3luY1dyYXBwZXIodm5vZGUpXG4gICAgICAgICAgICAgICAgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fVxuICAgICAgICAgICAgICAgIDogY29tcCk7XG4gICAgICAgICAgICBjb25zdCB7IGluY2x1ZGUsIGV4Y2x1ZGUsIG1heCB9ID0gcHJvcHM7XG4gICAgICAgICAgICBpZiAoKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsID8gY29tcCA6IHZub2RlLmtleTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBjbG9uZSB2bm9kZSBpZiBpdCdzIHJldXNlZCBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBtdXRhdGUgaXRcbiAgICAgICAgICAgIGlmICh2bm9kZS5lbCkge1xuICAgICAgICAgICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1ZOb2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd1ZOb2RlLnNzQ29udGVudCA9IHZub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICMxNTEzIGl0J3MgcG9zc2libGUgZm9yIHRoZSByZXR1cm5lZCB2bm9kZSB0byBiZSBjbG9uZWQgZHVlIHRvIGF0dHJcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoIG9yIHNjb3BlSWQsIHNvIHRoZSB2bm9kZSBoZXJlIG1heSBub3QgYmUgdGhlIGZpbmFsIHZub2RlXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG1vdW50ZWQuIEluc3RlYWQgb2YgY2FjaGluZyBpdCBkaXJlY3RseSwgd2Ugc3RvcmUgdGhlIHBlbmRpbmdcbiAgICAgICAgICAgIC8vIGtleSBhbmQgY2FjaGUgYGluc3RhbmNlLnN1YlRyZWVgICh0aGUgbm9ybWFsaXplZCB2bm9kZSkgaW5cbiAgICAgICAgICAgIC8vIGJlZm9yZU1vdW50L2JlZm9yZVVwZGF0ZSBob29rcy5cbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRWTm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgb3ZlciBtb3VudGVkIHN0YXRlXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcbiAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQgPSBjYWNoZWRWTm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRyYW5zaXRpb24gaG9va3Mgb24gc3ViVHJlZVxuICAgICAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIHZub2RlLnRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyBtb3VudGVkIGFzIGZyZXNoXG4gICAgICAgICAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IDUxMiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhpcyBrZXkgdGhlIGZyZXNoZXN0XG4gICAgICAgICAgICAgICAga2V5cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgICAgICAgICBpZiAobWF4ICYmIGtleXMuc2l6ZSA+IHBhcnNlSW50KG1heCwgMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXZvaWQgdm5vZGUgYmVpbmcgdW5tb3VudGVkXG4gICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gMjU2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xuICAgICAgICAgICAgY3VycmVudCA9IHZub2RlO1xuICAgICAgICAgICAgcmV0dXJuIGlzU3VzcGVuc2UocmF3Vk5vZGUudHlwZSkgPyByYXdWTm9kZSA6IHZub2RlO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2Vcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXG5jb25zdCBLZWVwQWxpdmUgPSBLZWVwQWxpdmVJbXBsO1xuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XG4gICAgaWYgKGlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc29tZSgocCkgPT4gbWF0Y2hlcyhwLCBuYW1lKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5jbHVkZXMobmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiYVwiIC8qIExpZmVjeWNsZUhvb2tzLkFDVElWQVRFRCAqLywgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XG4gICAgcmVnaXN0ZXJLZWVwQWxpdmVIb29rKGhvb2ssIFwiZGFcIiAvKiBMaWZlY3ljbGVIb29rcy5ERUFDVElWQVRFRCAqLywgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAvLyBjYWNoZSB0aGUgZGVhY3RpdmF0ZSBicmFuY2ggY2hlY2sgd3JhcHBlciBmb3IgaW5qZWN0ZWQgaG9va3Mgc28gdGhlIHNhbWVcbiAgICAvLyBob29rIGNhbiBiZSBwcm9wZXJseSBkZWR1cGVkIGJ5IHRoZSBzY2hlZHVsZXIuIFwiX193ZGNcIiBzdGFuZHMgZm9yIFwid2l0aFxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxuICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dkYyB8fFxuICAgICAgICAoaG9vay5fX3dkYyA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvb2soKTtcbiAgICAgICAgfSk7XG4gICAgaW5qZWN0SG9vayh0eXBlLCB3cmFwcGVkSG9vaywgdGFyZ2V0KTtcbiAgICAvLyBJbiBhZGRpdGlvbiB0byByZWdpc3RlcmluZyBpdCBvbiB0aGUgdGFyZ2V0IGluc3RhbmNlLCB3ZSB3YWxrIHVwIHRoZSBwYXJlbnRcbiAgICAvLyBjaGFpbiBhbmQgcmVnaXN0ZXIgaXQgb24gYWxsIGFuY2VzdG9yIGluc3RhbmNlcyB0aGF0IGFyZSBrZWVwLWFsaXZlIHJvb3RzLlxuICAgIC8vIFRoaXMgYXZvaWRzIHRoZSBuZWVkIHRvIHdhbGsgdGhlIGVudGlyZSBjb21wb25lbnQgdHJlZSB3aGVuIGludm9raW5nIHRoZXNlXG4gICAgLy8gaG9va3MsIGFuZCBtb3JlIGltcG9ydGFudGx5LCBhdm9pZHMgdGhlIG5lZWQgdG8gdHJhY2sgY2hpbGQgY29tcG9uZW50cyBpblxuICAgIC8vIGFycmF5cy5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0LnBhcmVudDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc0tlZXBBbGl2ZShjdXJyZW50LnBhcmVudC52bm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpbmplY3RUb0tlZXBBbGl2ZVJvb3Qod3JhcHBlZEhvb2ssIHR5cGUsIHRhcmdldCwgY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpbmplY3RUb0tlZXBBbGl2ZVJvb3QoaG9vaywgdHlwZSwgdGFyZ2V0LCBrZWVwQWxpdmVSb290KSB7XG4gICAgLy8gaW5qZWN0SG9vayB3cmFwcyB0aGUgb3JpZ2luYWwgZm9yIGVycm9yIGhhbmRsaW5nLCBzbyBtYWtlIHN1cmUgdG8gcmVtb3ZlXG4gICAgLy8gdGhlIHdyYXBwZWQgdmVyc2lvbi5cbiAgICBjb25zdCBpbmplY3RlZCA9IGluamVjdEhvb2sodHlwZSwgaG9vaywga2VlcEFsaXZlUm9vdCwgdHJ1ZSAvKiBwcmVwZW5kICovKTtcbiAgICBvblVubW91bnRlZCgoKSA9PiB7XG4gICAgICAgIHJlbW92ZShrZWVwQWxpdmVSb290W3R5cGVdLCBpbmplY3RlZCk7XG4gICAgfSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2hhcGVGbGFnKHZub2RlKSB7XG4gICAgLy8gYml0d2lzZSBvcGVyYXRpb25zIHRvIHJlbW92ZSBrZWVwIGFsaXZlIGZsYWdzXG4gICAgdm5vZGUuc2hhcGVGbGFnICY9IH4yNTYgLyogU2hhcGVGbGFncy5DT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi87XG4gICAgdm5vZGUuc2hhcGVGbGFnICY9IH41MTIgLyogU2hhcGVGbGFncy5DT01QT05FTlRfS0VQVF9BTElWRSAqLztcbn1cbmZ1bmN0aW9uIGdldElubmVyQ2hpbGQodm5vZGUpIHtcbiAgICByZXR1cm4gdm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8gPyB2bm9kZS5zc0NvbnRlbnQgOiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SG9vayh0eXBlLCBob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UsIHByZXBlbmQgPSBmYWxzZSkge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgaG9va3MgPSB0YXJnZXRbdHlwZV0gfHwgKHRhcmdldFt0eXBlXSA9IFtdKTtcbiAgICAgICAgLy8gY2FjaGUgdGhlIGVycm9yIGhhbmRsaW5nIHdyYXBwZXIgZm9yIGluamVjdGVkIGhvb2tzIHNvIHRoZSBzYW1lIGhvb2tcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXG4gICAgICAgIC8vIGhhbmRsaW5nXCIuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRIb29rID0gaG9vay5fX3dlaCB8fFxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNVbm1vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlIHRyYWNraW5nIGluc2lkZSBhbGwgbGlmZWN5Y2xlIGhvb2tzXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxuICAgICAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudEluc3RhbmNlIGR1cmluZyBob29rIGludm9jYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBob29rIGRvZXMgbm90IHN5bmNocm9ub3VzbHkgdHJpZ2dlciBvdGhlciBob29rcywgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCB0YXJnZXQsIHR5cGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVuc2hpZnQod3JhcHBlZEhvb2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9va3MucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZWRIb29rO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY29uc3QgYXBpTmFtZSA9IHRvSGFuZGxlcktleShFcnJvclR5cGVTdHJpbmdzW3R5cGVdLnJlcGxhY2UoLyBob29rJC8sICcnKSk7XG4gICAgICAgIHdhcm4oYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcbiAgICAgICAgICAgIGBhc3NvY2lhdGVkIHdpdGguIGAgK1xuICAgICAgICAgICAgYExpZmVjeWNsZSBpbmplY3Rpb24gQVBJcyBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBleGVjdXRpb24gb2Ygc2V0dXAoKS5gICtcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYGhvb2tzIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQgc3RhdGVtZW50LmBcbiAgICAgICAgICAgICAgICApKTtcbiAgICB9XG59XG5jb25zdCBjcmVhdGVIb29rID0gKGxpZmVjeWNsZSkgPT4gKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkgPT4gXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcbighaXNJblNTUkNvbXBvbmVudFNldHVwIHx8IGxpZmVjeWNsZSA9PT0gXCJzcFwiIC8qIExpZmVjeWNsZUhvb2tzLlNFUlZFUl9QUkVGRVRDSCAqLykgJiZcbiAgICBpbmplY3RIb29rKGxpZmVjeWNsZSwgKC4uLmFyZ3MpID0+IGhvb2soLi4uYXJncyksIHRhcmdldCk7XG5jb25zdCBvbkJlZm9yZU1vdW50ID0gY3JlYXRlSG9vayhcImJtXCIgLyogTGlmZWN5Y2xlSG9va3MuQkVGT1JFX01PVU5UICovKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUhvb2soXCJtXCIgLyogTGlmZWN5Y2xlSG9va3MuTU9VTlRFRCAqLyk7XG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXCJidVwiIC8qIExpZmVjeWNsZUhvb2tzLkJFRk9SRV9VUERBVEUgKi8pO1xuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlSG9vayhcInVcIiAvKiBMaWZlY3ljbGVIb29rcy5VUERBVEVEICovKTtcbmNvbnN0IG9uQmVmb3JlVW5tb3VudCA9IGNyZWF0ZUhvb2soXCJidW1cIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfVU5NT1VOVCAqLyk7XG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiIC8qIExpZmVjeWNsZUhvb2tzLlVOTU9VTlRFRCAqLyk7XG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlSG9vayhcInNwXCIgLyogTGlmZWN5Y2xlSG9va3MuU0VSVkVSX1BSRUZFVENIICovKTtcbmNvbnN0IG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlSG9vayhcInJ0Z1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUklHR0VSRUQgKi8pO1xuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIExpZmVjeWNsZUhvb2tzLlJFTkRFUl9UUkFDS0VEICovKTtcbmZ1bmN0aW9uIG9uRXJyb3JDYXB0dXJlZChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICBpbmplY3RIb29rKFwiZWNcIiAvKiBMaWZlY3ljbGVIb29rcy5FUlJPUl9DQVBUVVJFRCAqLywgaG9vaywgdGFyZ2V0KTtcbn1cblxuLyoqXG5SdW50aW1lIGhlbHBlciBmb3IgYXBwbHlpbmcgZGlyZWN0aXZlcyB0byBhIHZub2RlLiBFeGFtcGxlIHVzYWdlOlxuXG5jb25zdCBjb21wID0gcmVzb2x2ZUNvbXBvbmVudCgnY29tcCcpXG5jb25zdCBmb28gPSByZXNvbHZlRGlyZWN0aXZlKCdmb28nKVxuY29uc3QgYmFyID0gcmVzb2x2ZURpcmVjdGl2ZSgnYmFyJylcblxucmV0dXJuIHdpdGhEaXJlY3RpdmVzKGgoY29tcCksIFtcbiAgW2ZvbywgdGhpcy54XSxcbiAgW2JhciwgdGhpcy55XVxuXSlcbiovXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xuICAgIGlmIChpc0J1aWx0SW5EaXJlY3RpdmUobmFtZSkpIHtcbiAgICAgICAgd2FybignRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcbiAgICB9XG59XG4vKipcbiAqIEFkZHMgZGlyZWN0aXZlcyB0byBhIFZOb2RlLlxuICovXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xuICAgIGNvbnN0IGludGVybmFsSW5zdGFuY2UgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4oYHdpdGhEaXJlY3RpdmVzIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHJlbmRlciBmdW5jdGlvbnMuYCk7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRFeHBvc2VQcm94eShpbnRlcm5hbEluc3RhbmNlKSB8fFxuICAgICAgICBpbnRlcm5hbEluc3RhbmNlLnByb3h5O1xuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IFtkaXIsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyA9IEVNUFRZX09CSl0gPSBkaXJlY3RpdmVzW2ldO1xuICAgICAgICBpZiAoZGlyKSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkaXIpKSB7XG4gICAgICAgICAgICAgICAgZGlyID0ge1xuICAgICAgICAgICAgICAgICAgICBtb3VudGVkOiBkaXIsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQ6IGRpclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyLmRlZXApIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59XG5mdW5jdGlvbiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBwcmV2Vk5vZGUsIGluc3RhbmNlLCBuYW1lKSB7XG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xuICAgIGNvbnN0IG9sZEJpbmRpbmdzID0gcHJldlZOb2RlICYmIHByZXZWTm9kZS5kaXJzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICBpZiAob2xkQmluZGluZ3MpIHtcbiAgICAgICAgICAgIGJpbmRpbmcub2xkVmFsdWUgPSBvbGRCaW5kaW5nc1tpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaG9vayA9IGJpbmRpbmcuZGlyW25hbWVdO1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgLy8gZGlzYWJsZSB0cmFja2luZyBpbnNpZGUgYWxsIGxpZmVjeWNsZSBob29rc1xuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgaW5zdGFuY2UsIDggLyogRXJyb3JDb2Rlcy5ESVJFQ1RJVkVfSE9PSyAqLywgW1xuICAgICAgICAgICAgICAgIHZub2RlLmVsLFxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXG4gICAgICAgICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgICAgICAgcHJldlZOb2RlXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJlc2V0VHJhY2tpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgQ09NUE9ORU5UUyA9ICdjb21wb25lbnRzJztcbmNvbnN0IERJUkVDVElWRVMgPSAnZGlyZWN0aXZlcyc7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChDT01QT05FTlRTLCBuYW1lLCB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UpIHx8IG5hbWU7XG59XG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKCk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIGlmIChpc1N0cmluZyhjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaW52YWxpZCB0eXBlcyB3aWxsIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZVZOb2RlIGFuZCByYWlzZSB3YXJuaW5nXG4gICAgICAgIHJldHVybiAoY29tcG9uZW50IHx8IE5VTExfRFlOQU1JQ19DT01QT05FTlQpO1xuICAgIH1cbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldChESVJFQ1RJVkVTLCBuYW1lKTtcbn1cbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQodHlwZSwgbmFtZSwgd2Fybk1pc3NpbmcgPSB0cnVlLCBtYXliZVNlbGZSZWZlcmVuY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIHx8IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICAgICAgLy8gZXhwbGljaXQgc2VsZiBuYW1lIGhhcyBoaWdoZXN0IHByaW9yaXR5XG4gICAgICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmTmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50LCBmYWxzZSAvKiBkbyBub3QgaW5jbHVkZSBpbmZlcnJlZCBuYW1lIHRvIGF2b2lkIGJyZWFraW5nIGV4aXN0aW5nIGNvZGUgKi8pO1xuICAgICAgICAgICAgaWYgKHNlbGZOYW1lICYmXG4gICAgICAgICAgICAgICAgKHNlbGZOYW1lID09PSBuYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGZOYW1lID09PSBjYW1lbGl6ZShuYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmTmFtZSA9PT0gY2FwaXRhbGl6ZShjYW1lbGl6ZShuYW1lKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBcbiAgICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXG4gICAgICAgIC8vIGNoZWNrIGluc3RhbmNlW3R5cGVdIGZpcnN0IHdoaWNoIGlzIHJlc29sdmVkIGZvciBvcHRpb25zIEFQSVxuICAgICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHxcbiAgICAgICAgICAgIC8vIGdsb2JhbCByZWdpc3RyYXRpb25cbiAgICAgICAgICAgIHJlc29sdmUoaW5zdGFuY2UuYXBwQ29udGV4dFt0eXBlXSwgbmFtZSk7XG4gICAgICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gaW1wbGljaXQgc2VsZi1yZWZlcmVuY2VcbiAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHR5cGUgPT09IENPTVBPTkVOVFNcbiAgICAgICAgICAgICAgICA/IGBcXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGAgK1xuICAgICAgICAgICAgICAgICAgICBgY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYFxuICAgICAgICAgICAgICAgIDogYGA7XG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gcmVzb2x2ZSAke3R5cGUuc2xpY2UoMCwgLTEpfTogJHtuYW1lfSR7ZXh0cmF9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm4oYHJlc29sdmUke2NhcGl0YWxpemUodHlwZS5zbGljZSgwLCAtMSkpfSBgICtcbiAgICAgICAgICAgIGBjYW4gb25seSBiZSB1c2VkIGluIHJlbmRlcigpIG9yIHNldHVwKCkuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZShyZWdpc3RyeSwgbmFtZSkge1xuICAgIHJldHVybiAocmVnaXN0cnkgJiZcbiAgICAgICAgKHJlZ2lzdHJ5W25hbWVdIHx8XG4gICAgICAgICAgICByZWdpc3RyeVtjYW1lbGl6ZShuYW1lKV0gfHxcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSkpO1xufVxuXG4vKipcbiAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0KHNvdXJjZSwgcmVuZGVySXRlbSwgY2FjaGUsIGluZGV4KSB7XG4gICAgbGV0IHJldDtcbiAgICBjb25zdCBjYWNoZWQgPSAoY2FjaGUgJiYgY2FjaGVbaW5kZXhdKTtcbiAgICBpZiAoaXNBcnJheShzb3VyY2UpIHx8IGlzU3RyaW5nKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlckl0ZW0oc291cmNlW2ldLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xuICAgICAgICAgICAgd2FybihgVGhlIHYtZm9yIHJhbmdlIGV4cGVjdCBhbiBpbnRlZ2VyIHZhbHVlIGJ1dCBnb3QgJHtzb3VyY2V9LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IG5ldyBBcnJheShzb3VyY2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZTsgaSsrKSB7XG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgICAgICByZXQgPSBBcnJheS5mcm9tKHNvdXJjZSwgKGl0ZW0sIGkpID0+IHJlbmRlckl0ZW0oaXRlbSwgaSwgdW5kZWZpbmVkLCBjYWNoZWQgJiYgY2FjaGVkW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGksIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXQgPSBbXTtcbiAgICB9XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlW2luZGV4XSA9IHJldDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgY3JlYXRpbmcgZHluYW1pYyBzbG90cyBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzbG90ID0gZHluYW1pY1Nsb3RzW2ldO1xuICAgICAgICAvLyBhcnJheSBvZiBkeW5hbWljIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiICNbLi4uXT5cbiAgICAgICAgaWYgKGlzQXJyYXkoc2xvdCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xvdC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIC8vIGNvbmRpdGlvbmFsIHNpbmdsZSBzbG90IGdlbmVyYXRlZCBieSA8dGVtcGxhdGUgdi1pZj1cIi4uLlwiICNmb28+XG4gICAgICAgICAgICBzbG90c1tzbG90Lm5hbWVdID0gc2xvdC5rZXlcbiAgICAgICAgICAgICAgICA/ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHNsb3QuZm4oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dGFjaCBicmFuY2gga2V5IHNvIGVhY2ggY29uZGl0aW9uYWwgYnJhbmNoIGlzIGNvbnNpZGVyZWQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5rZXkgPSBzbG90LmtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiBzbG90LmZuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90cztcbn1cblxuLyoqXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIGA8c2xvdC8+YFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgXG4vLyB0aGlzIGlzIG5vdCBhIHVzZXItZmFjaW5nIGZ1bmN0aW9uLCBzbyB0aGUgZmFsbGJhY2sgaXMgYWx3YXlzIGdlbmVyYXRlZCBieVxuLy8gdGhlIGNvbXBpbGVyIGFuZCBndWFyYW50ZWVkIHRvIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5XG5mYWxsYmFjaywgbm9TbG90dGVkKSB7XG4gICAgaWYgKGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZS5pc0NFIHx8XG4gICAgICAgIChjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50ICYmXG4gICAgICAgICAgICBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJlxuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudC5pc0NFKSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKVxuICAgICAgICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSgnc2xvdCcsIHByb3BzLCBmYWxsYmFjayAmJiBmYWxsYmFjaygpKTtcbiAgICB9XG4gICAgbGV0IHNsb3QgPSBzbG90c1tuYW1lXTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHdhcm4oYFNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBgICtcbiAgICAgICAgICAgIGBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBgICtcbiAgICAgICAgICAgIGBwYXJlbnQgdGVtcGxhdGUuYCk7XG4gICAgICAgIHNsb3QgPSAoKSA9PiBbXTtcbiAgICB9XG4gICAgLy8gYSBjb21waWxlZCBzbG90IGRpc2FibGVzIGJsb2NrIHRyYWNraW5nIGJ5IGRlZmF1bHQgdG8gYXZvaWQgbWFudWFsXG4gICAgLy8gaW52b2NhdGlvbiBpbnRlcmZlcmluZyB3aXRoIHRlbXBsYXRlLWJhc2VkIGJsb2NrIHRyYWNraW5nLCBidXQgaW5cbiAgICAvLyBgcmVuZGVyU2xvdGAgd2UgY2FuIGJlIHN1cmUgdGhhdCBpdCdzIHRlbXBsYXRlLWJhc2VkIHNvIHdlIGNhbiBmb3JjZVxuICAgIC8vIGVuYWJsZSBpdC5cbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgICAgIHNsb3QuX2QgPSBmYWxzZTtcbiAgICB9XG4gICAgb3BlbkJsb2NrKCk7XG4gICAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XG4gICAgY29uc3QgcmVuZGVyZWQgPSBjcmVhdGVCbG9jayhGcmFnbWVudCwge1xuICAgICAgICBrZXk6IHByb3BzLmtleSB8fFxuICAgICAgICAgICAgLy8gc2xvdCBjb250ZW50IGFycmF5IG9mIGEgZHluYW1pYyBjb25kaXRpb25hbCBzbG90IG1heSBoYXZlIGEgYnJhbmNoXG4gICAgICAgICAgICAvLyBrZXkgYXR0YWNoZWQgaW4gdGhlIGBjcmVhdGVTbG90c2AgaGVscGVyLCByZXNwZWN0IHRoYXRcbiAgICAgICAgICAgICh2YWxpZFNsb3RDb250ZW50ICYmIHZhbGlkU2xvdENvbnRlbnQua2V5KSB8fFxuICAgICAgICAgICAgYF8ke25hbWV9YFxuICAgIH0sIHZhbGlkU2xvdENvbnRlbnQgfHwgKGZhbGxiYWNrID8gZmFsbGJhY2soKSA6IFtdKSwgdmFsaWRTbG90Q29udGVudCAmJiBzbG90cy5fID09PSAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi9cbiAgICAgICAgPyA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL1xuICAgICAgICA6IC0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqLyk7XG4gICAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xuICAgICAgICByZW5kZXJlZC5zbG90U2NvcGVJZHMgPSBbcmVuZGVyZWQuc2NvcGVJZCArICctcyddO1xuICAgIH1cbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XG4gICAgICAgIHNsb3QuX2QgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyZWQ7XG59XG5mdW5jdGlvbiBlbnN1cmVWYWxpZFZOb2RlKHZub2Rlcykge1xuICAgIHJldHVybiB2bm9kZXMuc29tZShjaGlsZCA9PiB7XG4gICAgICAgIGlmICghaXNWTm9kZShjaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09PSBGcmFnbWVudCAmJlxuICAgICAgICAgICAgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KVxuICAgICAgICA/IHZub2Rlc1xuICAgICAgICA6IG51bGw7XG59XG5cbi8qKlxuICogRm9yIHByZWZpeGluZyBrZXlzIGluIHYtb249XCJvYmpcIiB3aXRoIFwib25cIlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9IYW5kbGVycyhvYmosIHByZXNlcnZlQ2FzZUlmTmVjZXNzYXJ5KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNPYmplY3Qob2JqKSkge1xuICAgICAgICB3YXJuKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICByZXRbcHJlc2VydmVDYXNlSWZOZWNlc3NhcnkgJiYgL1tBLVpdLy50ZXN0KGtleSlcbiAgICAgICAgICAgID8gYG9uOiR7a2V5fWBcbiAgICAgICAgICAgIDogdG9IYW5kbGVyS2V5KGtleSldID0gb2JqW2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogIzI0MzcgSW4gVnVlIDMsIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBkbyBub3QgaGF2ZSBhIHB1YmxpYyBpbnN0YW5jZSBwcm94eSBidXRcbiAqIHRoZXkgZXhpc3QgaW4gdGhlIGludGVybmFsIHBhcmVudCBjaGFpbi4gRm9yIGNvZGUgdGhhdCByZWxpZXMgb24gdHJhdmVyc2luZ1xuICogcHVibGljICRwYXJlbnQgY2hhaW5zLCBza2lwIGZ1bmN0aW9uYWwgb25lcyBhbmQgZ28gdG8gdGhlIHBhcmVudCBpbnN0ZWFkLlxuICovXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XG4gICAgaWYgKCFpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSlcbiAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KGkpIHx8IGkucHJveHk7XG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KTtcbn07XG5jb25zdCBwdWJsaWNQcm9wZXJ0aWVzTWFwID0gXG4vLyBNb3ZlIFBVUkUgbWFya2VyIHRvIG5ldyBsaW5lIHRvIHdvcmthcm91bmQgY29tcGlsZXIgZGlzY2FyZGluZyBpdFxuLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuLyojX19QVVJFX18qLyBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICQ6IGkgPT4gaSxcbiAgICAkZWw6IGkgPT4gaS52bm9kZS5lbCxcbiAgICAkZGF0YTogaSA9PiBpLmRhdGEsXG4gICAgJHByb3BzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5wcm9wcykgOiBpLnByb3BzKSxcbiAgICAkYXR0cnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMpLFxuICAgICRzbG90czogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkuc2xvdHMpIDogaS5zbG90cyksXG4gICAgJHJlZnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnJlZnMpIDogaS5yZWZzKSxcbiAgICAkcGFyZW50OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcbiAgICAkcm9vdDogaSA9PiBnZXRQdWJsaWNJbnN0YW5jZShpLnJvb3QpLFxuICAgICRlbWl0OiBpID0+IGkuZW1pdCxcbiAgICAkb3B0aW9uczogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlKSxcbiAgICAkZm9yY2VVcGRhdGU6IGkgPT4gaS5mIHx8IChpLmYgPSAoKSA9PiBxdWV1ZUpvYihpLnVwZGF0ZSkpLFxuICAgICRuZXh0VGljazogaSA9PiBpLm4gfHwgKGkubiA9IG5leHRUaWNrLmJpbmQoaS5wcm94eSkpLFxuICAgICR3YXRjaDogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1ApXG59KTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09ICdfJyB8fCBrZXkgPT09ICckJztcbmNvbnN0IGhhc1NldHVwQmluZGluZyA9IChzdGF0ZSwga2V5KSA9PiBzdGF0ZSAhPT0gRU1QVFlfT0JKICYmICFzdGF0ZS5fX2lzU2NyaXB0U2V0dXAgJiYgaGFzT3duKHN0YXRlLCBrZXkpO1xuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xuICAgIGdldCh7IF86IGluc3RhbmNlIH0sIGtleSkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSwgZGF0YSwgcHJvcHMsIGFjY2Vzc0NhY2hlLCB0eXBlLCBhcHBDb250ZXh0IH0gPSBpbnN0YW5jZTtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIGZvcm1hdHRlcnMgdG8ga25vdyB0aGF0IHRoaXMgaXMgYSBWdWUgaW5zdGFuY2VcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgPT09ICdfX2lzVnVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGF0YSAvIHByb3BzIC8gY3R4XG4gICAgICAgIC8vIFRoaXMgZ2V0dGVyIGdldHMgY2FsbGVkIGZvciBldmVyeSBwcm9wZXJ0eSBhY2Nlc3Mgb24gdGhlIHJlbmRlciBjb250ZXh0XG4gICAgICAgIC8vIGR1cmluZyByZW5kZXIgYW5kIGlzIGEgbWFqb3IgaG90c3BvdC4gVGhlIG1vc3QgZXhwZW5zaXZlIHBhcnQgb2YgdGhpc1xuICAgICAgICAvLyBpcyB0aGUgbXVsdGlwbGUgaGFzT3duKCkgY2FsbHMuIEl0J3MgbXVjaCBmYXN0ZXIgdG8gZG8gYSBzaW1wbGUgcHJvcGVydHlcbiAgICAgICAgLy8gYWNjZXNzIG9uIGEgcGxhaW4gb2JqZWN0LCBzbyB3ZSB1c2UgYW4gYWNjZXNzQ2FjaGUgb2JqZWN0ICh3aXRoIG51bGxcbiAgICAgICAgLy8gcHJvdG90eXBlKSB0byBtZW1vaXplIHdoYXQgYWNjZXNzIHR5cGUgYSBrZXkgY29ycmVzcG9uZHMgdG8uXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgICAgIGlmIChrZXlbMF0gIT09ICckJykge1xuICAgICAgICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAobiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBBY2Nlc3NUeXBlcy5TRVRVUCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR1cFN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBBY2Nlc3NUeXBlcy5EQVRBICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IC8qIEFjY2Vzc1R5cGVzLkNPTlRFWFQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBBY2Nlc3NUeXBlcy5QUk9QUyAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0OiBqdXN0IGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMSAvKiBBY2Nlc3NUeXBlcy5TRVRVUCAqLztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogQWNjZXNzVHlwZXMuREFUQSAqLztcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAvLyBvbmx5IGNhY2hlIG90aGVyIHByb3BlcnRpZXMgd2hlbiBpbnN0YW5jZSBoYXMgZGVjbGFyZWQgKHRodXMgc3RhYmxlKVxuICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmXG4gICAgICAgICAgICAgICAgaGFzT3duKG5vcm1hbGl6ZWRQcm9wcywga2V5KSkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAzIC8qIEFjY2Vzc1R5cGVzLlBST1BTICovO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIEFjY2Vzc1R5cGVzLkNPTlRFWFQgKi87XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMCAvKiBBY2Nlc3NUeXBlcy5PVEhFUiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaWNHZXR0ZXIgPSBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV07XG4gICAgICAgIGxldCBjc3NNb2R1bGUsIGdsb2JhbFByb3BlcnRpZXM7XG4gICAgICAgIC8vIHB1YmxpYyAkeHh4IHByb3BlcnRpZXNcbiAgICAgICAgaWYgKHB1YmxpY0dldHRlcikge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyRhdHRycycpIHtcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLCBrZXkpO1xuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBtYXJrQXR0cnNBY2Nlc3NlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0dldHRlcihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgIC8vIGNzcyBtb2R1bGUgKGluamVjdGVkIGJ5IHZ1ZS1sb2FkZXIpXG4gICAgICAgIChjc3NNb2R1bGUgPSB0eXBlLl9fY3NzTW9kdWxlcykgJiZcbiAgICAgICAgICAgIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjc3NNb2R1bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xuICAgICAgICAgICAgLy8gdXNlciBtYXkgc2V0IGN1c3RvbSBwcm9wZXJ0aWVzIHRvIGB0aGlzYCB0aGF0IHN0YXJ0IHdpdGggYCRgXG4gICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gNCAvKiBBY2Nlc3NUeXBlcy5DT05URVhUICovO1xuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xuICAgICAgICAoKGdsb2JhbFByb3BlcnRpZXMgPSBhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzKSxcbiAgICAgICAgICAgIGhhc093bihnbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxQcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgJiZcbiAgICAgICAgICAgICghaXNTdHJpbmcoa2V5KSB8fFxuICAgICAgICAgICAgICAgIC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXG4gICAgICAgICAgICAgICAgLy8gdG8gaW5maW5pdGUgd2FybmluZyBsb29wXG4gICAgICAgICAgICAgICAga2V5LmluZGV4T2YoJ19fdicpICE9PSAwKSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IG11c3QgYmUgYWNjZXNzZWQgdmlhICRkYXRhIGJlY2F1c2UgaXQgc3RhcnRzIHdpdGggYSByZXNlcnZlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnN0YW5jZSA9PT0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgd2FybihgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSB3YXMgYWNjZXNzZWQgZHVyaW5nIHJlbmRlciBgICtcbiAgICAgICAgICAgICAgICAgICAgYGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIHNldHVwU3RhdGUsIGN0eCB9ID0gaW5zdGFuY2U7XG4gICAgICAgIGlmIChoYXNTZXR1cEJpbmRpbmcoc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgc2V0dXBTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgIHNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwICYmXG4gICAgICAgICAgICBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xuICAgICAgICAgICAgd2FybihgQ2Fubm90IG11dGF0ZSA8c2NyaXB0IHNldHVwPiBiaW5kaW5nIFwiJHtrZXl9XCIgZnJvbSBPcHRpb25zIEFQSS5gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHJvcCBcIiR7a2V5fVwiLiBQcm9wcyBhcmUgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYga2V5IGluIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh7IF86IHsgZGF0YSwgc2V0dXBTdGF0ZSwgYWNjZXNzQ2FjaGUsIGN0eCwgYXBwQ29udGV4dCwgcHJvcHNPcHRpb25zIH0gfSwga2V5KSB7XG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XG4gICAgICAgIHJldHVybiAoISFhY2Nlc3NDYWNoZVtrZXldIHx8XG4gICAgICAgICAgICAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB8fFxuICAgICAgICAgICAgaGFzU2V0dXBCaW5kaW5nKHNldHVwU3RhdGUsIGtleSkgfHxcbiAgICAgICAgICAgICgobm9ybWFsaXplZFByb3BzID0gcHJvcHNPcHRpb25zWzBdKSAmJiBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB8fFxuICAgICAgICAgICAgaGFzT3duKGN0eCwga2V5KSB8fFxuICAgICAgICAgICAgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHxcbiAgICAgICAgICAgIGhhc093bihhcHBDb250ZXh0LmNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzLCBrZXkpKTtcbiAgICB9LFxuICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkYXRlIGtleSBjYWNoZSBvZiBhIGdldHRlciBiYXNlZCBwcm9wZXJ0eSAjNTQxN1xuICAgICAgICAgICAgdGFyZ2V0Ll8uYWNjZXNzQ2FjaGVba2V5XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpKSB7XG4gICAgICAgICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn07XG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFmYWxzZSkge1xuICAgIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xuICAgICAgICB3YXJuKGBBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gYCArXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICB9O1xufVxuY29uc3QgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0gLyojX19QVVJFX18qLyBleHRlbmQoe30sIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycywge1xuICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICAvLyBmYXN0IHBhdGggZm9yIHVuc2NvcGFibGVzIHdoZW4gdXNpbmcgYHdpdGhgIGJsb2NrXG4gICAgICAgIGlmIChrZXkgPT09IFN5bWJvbC51bnNjb3BhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuZ2V0KHRhcmdldCwga2V5LCB0YXJnZXQpO1xuICAgIH0sXG4gICAgaGFzKF8sIGtleSkge1xuICAgICAgICBjb25zdCBoYXMgPSBrZXlbMF0gIT09ICdfJyAmJiAhaXNHbG9iYWxseVdoaXRlbGlzdGVkKGtleSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhcyAmJiBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMuaGFzKF8sIGtleSkpIHtcbiAgICAgICAgICAgIHdhcm4oYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIF8gd2hpY2ggaXMgYSByZXNlcnZlZCBwcmVmaXggZm9yIFZ1ZSBpbnRlcm5hbHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhcztcbiAgICB9XG59KTtcbi8vIGRldiBvbmx5XG4vLyBJbiBkZXYgbW9kZSwgdGhlIHByb3h5IHRhcmdldCBleHBvc2VzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgc2VlbiBvbiBgdGhpc2Bcbi8vIGZvciBlYXNpZXIgY29uc29sZSBpbnNwZWN0aW9uLiBJbiBwcm9kIG1vZGUgaXQgd2lsbCBiZSBhbiBlbXB0eSBvYmplY3Qgc29cbi8vIHRoZXNlIHByb3BlcnRpZXMgZGVmaW5pdGlvbnMgY2FuIGJlIHNraXBwZWQuXG5mdW5jdGlvbiBjcmVhdGVEZXZSZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgLy8gZXhwb3NlIGludGVybmFsIGluc3RhbmNlIGZvciBwcm94eSBoYW5kbGVyc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGBfYCwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlXG4gICAgfSk7XG4gICAgLy8gZXhwb3NlIHB1YmxpYyBwcm9wZXJ0aWVzXG4gICAgT2JqZWN0LmtleXMocHVibGljUHJvcGVydGllc01hcCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpLFxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxuICAgICAgICAgICAgLy8gYnV0IG5lZWRlZCB0byBwcmV2ZW50IHNldCBlcnJvcnNcbiAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLy8gZGV2IG9ubHlcbmZ1bmN0aW9uIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKSB7XG4gICAgY29uc3QgeyBjdHgsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xuICAgIGlmIChwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcHNPcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXG4gICAgICAgICAgICAgICAgc2V0OiBOT09QXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8gZGV2IG9ubHlcbmZ1bmN0aW9uIGV4cG9zZVNldHVwU3RhdGVPblJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcbiAgICBjb25zdCB7IGN0eCwgc2V0dXBTdGF0ZSB9ID0gaW5zdGFuY2U7XG4gICAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKCFzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCkge1xuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcmVmaXgoa2V5WzBdKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIGAgK1xuICAgICAgICAgICAgICAgICAgICBgd2hpY2ggYXJlIHJlc2VydmVkIHByZWZpeGVzIGZvciBWdWUgaW50ZXJuYWxzLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gc2V0dXBTdGF0ZVtrZXldLFxuICAgICAgICAgICAgICAgIHNldDogTk9PUFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuICh0eXBlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgICAgIHdhcm4oYCR7dHlwZX0gcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHtjYWNoZVtrZXldfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSB0eXBlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmxldCBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHB1YmxpY1RoaXMgPSBpbnN0YW5jZS5wcm94eTtcbiAgICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XG4gICAgLy8gZG8gbm90IGNhY2hlIHByb3BlcnR5IGFjY2VzcyBvbiBwdWJsaWMgcHJveHkgZHVyaW5nIHN0YXRlIGluaXRpYWxpemF0aW9uXG4gICAgc2hvdWxkQ2FjaGVBY2Nlc3MgPSBmYWxzZTtcbiAgICAvLyBjYWxsIGJlZm9yZUNyZWF0ZSBmaXJzdCBiZWZvcmUgYWNjZXNzaW5nIG90aGVyIG9wdGlvbnMgc2luY2VcbiAgICAvLyB0aGUgaG9vayBtYXkgbXV0YXRlIHJlc29sdmVkIG9wdGlvbnMgKCMyNzkxKVxuICAgIGlmIChvcHRpb25zLmJlZm9yZUNyZWF0ZSkge1xuICAgICAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIiAvKiBMaWZlY3ljbGVIb29rcy5CRUZPUkVfQ1JFQVRFICovKTtcbiAgICB9XG4gICAgY29uc3QgeyBcbiAgICAvLyBzdGF0ZVxuICAgIGRhdGE6IGRhdGFPcHRpb25zLCBjb21wdXRlZDogY29tcHV0ZWRPcHRpb25zLCBtZXRob2RzLCB3YXRjaDogd2F0Y2hPcHRpb25zLCBwcm92aWRlOiBwcm92aWRlT3B0aW9ucywgaW5qZWN0OiBpbmplY3RPcHRpb25zLCBcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBjcmVhdGVkLCBiZWZvcmVNb3VudCwgbW91bnRlZCwgYmVmb3JlVXBkYXRlLCB1cGRhdGVkLCBhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkLCBiZWZvcmVEZXN0cm95LCBiZWZvcmVVbm1vdW50LCBkZXN0cm95ZWQsIHVubW91bnRlZCwgcmVuZGVyLCByZW5kZXJUcmFja2VkLCByZW5kZXJUcmlnZ2VyZWQsIGVycm9yQ2FwdHVyZWQsIHNlcnZlclByZWZldGNoLCBcbiAgICAvLyBwdWJsaWMgQVBJXG4gICAgZXhwb3NlLCBpbmhlcml0QXR0cnMsIFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsIGZpbHRlcnMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlRHVwbGljYXRlQ2hlY2tlcigpIDogbnVsbDtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNvbnN0IFtwcm9wc09wdGlvbnNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xuICAgICAgICBpZiAocHJvcHNPcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJQcm9wc1wiIC8qIE9wdGlvblR5cGVzLlBST1BTICovLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9wdGlvbnMgaW5pdGlhbGl6YXRpb24gb3JkZXIgKHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBWdWUgMik6XG4gICAgLy8gLSBwcm9wcyAoYWxyZWFkeSBkb25lIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbilcbiAgICAvLyAtIGluamVjdFxuICAgIC8vIC0gbWV0aG9kc1xuICAgIC8vIC0gZGF0YSAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXG4gICAgLy8gLSBjb21wdXRlZFxuICAgIC8vIC0gd2F0Y2ggKGRlZmVycmVkIHNpbmNlIGl0IHJlbGllcyBvbiBgdGhpc2AgYWNjZXNzKVxuICAgIGlmIChpbmplY3RPcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy51bndyYXBJbmplY3RlZFJlZik7XG4gICAgfVxuICAgIGlmIChtZXRob2RzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEhhbmRsZXIgPSBtZXRob2RzW2tleV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIEluIGRldiBtb2RlLCB3ZSB1c2UgdGhlIGBjcmVhdGVSZW5kZXJDb250ZXh0YCBmdW5jdGlvbiB0byBkZWZpbmVcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIHRvIHRoZSBwcm94eSB0YXJnZXQsIGFuZCB0aG9zZSBhcmUgcmVhZC1vbmx5IGJ1dFxuICAgICAgICAgICAgICAgIC8vIHJlY29uZmlndXJhYmxlLCBzbyBpdCBuZWVkcyB0byBiZSByZWRlZmluZWQgaGVyZVxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSBtZXRob2RIYW5kbGVyLmJpbmQocHVibGljVGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiTWV0aG9kc1wiIC8qIE9wdGlvblR5cGVzLk1FVEhPRFMgKi8sIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgd2FybihgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhT3B0aW9ucykge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xuICAgICAgICAgICAgd2FybihgVGhlIGRhdGEgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi4gYCArXG4gICAgICAgICAgICAgICAgYFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhT3B0aW9ucy5jYWxsKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzUHJvbWlzZShkYXRhKSkge1xuICAgICAgICAgICAgd2FybihgZGF0YSgpIHJldHVybmVkIGEgUHJvbWlzZSAtIG5vdGUgZGF0YSgpIGNhbm5vdCBiZSBhc3luYzsgSWYgeW91IGAgK1xuICAgICAgICAgICAgICAgIGBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGAgK1xuICAgICAgICAgICAgICAgIGBhc3luYyBzZXR1cCgpICsgPFN1c3BlbnNlPi5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgZGF0YSgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UuZGF0YSA9IHJlYWN0aXZlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiRGF0YVwiIC8qIE9wdGlvblR5cGVzLkRBVEEgKi8sIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9zZSBkYXRhIG9uIGN0eCBkdXJpbmcgZGV2XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZFByZWZpeChrZXlbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGRhdGFba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHN0YXRlIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlIGF0IHRoaXMgcG9pbnQgLSBzdGFydCBjYWNoaW5nIGFjY2Vzc1xuICAgIHNob3VsZENhY2hlQWNjZXNzID0gdHJ1ZTtcbiAgICBpZiAoY29tcHV0ZWRPcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkT3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0gY29tcHV0ZWRPcHRpb25zW2tleV07XG4gICAgICAgICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdClcbiAgICAgICAgICAgICAgICA/IG9wdC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXG4gICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKG9wdC5nZXQpXG4gICAgICAgICAgICAgICAgICAgID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXG4gICAgICAgICAgICAgICAgICAgIDogTk9PUDtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZ2V0ID09PSBOT09QKSB7XG4gICAgICAgICAgICAgICAgd2FybihgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBoYXMgbm8gZ2V0dGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpXG4gICAgICAgICAgICAgICAgPyBvcHQuc2V0LmJpbmQocHVibGljVGhpcylcbiAgICAgICAgICAgICAgICA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFdyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xuICAgICAgICAgICAgY29uc3QgYyA9IGNvbXB1dGVkKHtcbiAgICAgICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICAgICAgc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gYy52YWx1ZSxcbiAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGMudmFsdWUgPSB2KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiQ29tcHV0ZWRcIiAvKiBPcHRpb25UeXBlcy5DT01QVVRFRCAqLywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2F0Y2hPcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHdhdGNoT3B0aW9ucykge1xuICAgICAgICAgICAgY3JlYXRlV2F0Y2hlcih3YXRjaE9wdGlvbnNba2V5XSwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm92aWRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpXG4gICAgICAgICAgICA/IHByb3ZpZGVPcHRpb25zLmNhbGwocHVibGljVGhpcylcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbnM7XG4gICAgICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgcHJvdmlkZShrZXksIHByb3ZpZGVzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZWQpIHtcbiAgICAgICAgY2FsbEhvb2soY3JlYXRlZCwgaW5zdGFuY2UsIFwiY1wiIC8qIExpZmVjeWNsZUhvb2tzLkNSRUFURUQgKi8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlckxpZmVjeWNsZUhvb2socmVnaXN0ZXIsIGhvb2spIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoaG9vaykpIHtcbiAgICAgICAgICAgIGhvb2suZm9yRWFjaChfaG9vayA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaG9vaykge1xuICAgICAgICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbk1vdW50ZWQsIG1vdW50ZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkJlZm9yZVVwZGF0ZSwgYmVmb3JlVXBkYXRlKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25BY3RpdmF0ZWQsIGFjdGl2YXRlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uRGVhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmFja2VkLCByZW5kZXJUcmFja2VkKTtcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25SZW5kZXJUcmlnZ2VyZWQsIHJlbmRlclRyaWdnZXJlZCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uVW5tb3VudGVkLCB1bm1vdW50ZWQpO1xuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblNlcnZlclByZWZldGNoLCBzZXJ2ZXJQcmVmZXRjaCk7XG4gICAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xuICAgICAgICBpZiAoZXhwb3NlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3NlZCA9IGluc3RhbmNlLmV4cG9zZWQgfHwgKGluc3RhbmNlLmV4cG9zZWQgPSB7fSk7XG4gICAgICAgICAgICBleHBvc2UuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvc2VkLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBwdWJsaWNUaGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogdmFsID0+IChwdWJsaWNUaGlzW2tleV0gPSB2YWwpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCB3aGVuIGNyZWF0aW5nIHRoZSBpbnN0YW5jZSBidXQgYWxzbyBuZWVkIHRvIGJlXG4gICAgLy8gYXBwbGllZCBmcm9tIG1peGluc1xuICAgIGlmIChyZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHJlbmRlcjtcbiAgICB9XG4gICAgaWYgKGluaGVyaXRBdHRycyAhPSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLmluaGVyaXRBdHRycyA9IGluaGVyaXRBdHRycztcbiAgICB9XG4gICAgLy8gYXNzZXQgb3B0aW9ucy5cbiAgICBpZiAoY29tcG9uZW50cylcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgaWYgKGRpcmVjdGl2ZXMpXG4gICAgICAgIGluc3RhbmNlLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMgPSBOT09QLCB1bndyYXBSZWYgPSBmYWxzZSkge1xuICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XG4gICAgICAgIGluamVjdE9wdGlvbnMgPSBub3JtYWxpemVJbmplY3QoaW5qZWN0T3B0aW9ucyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gaW5qZWN0T3B0aW9uc1trZXldO1xuICAgICAgICBsZXQgaW5qZWN0ZWQ7XG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIG9wdCkge1xuICAgICAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSwgb3B0LmRlZmF1bHQsIHRydWUgLyogdHJlYXQgZGVmYXVsdCBmdW5jdGlvbiBhcyBmYWN0b3J5ICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluamVjdGVkID0gaW5qZWN0KG9wdC5mcm9tIHx8IGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlZihpbmplY3RlZCkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoZSBjaGVjayBpbiAzLjNcbiAgICAgICAgICAgIGlmICh1bndyYXBSZWYpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluamVjdGVkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGluamVjdGVkLnZhbHVlID0gdilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgaW5qZWN0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhIHJlZiBhbmQgd2lsbCBiZSBhdXRvLXVud3JhcHBlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBhbmQgbm8gbG9uZ2VyIG5lZWRzIFxcYC52YWx1ZVxcYCBpbiB0aGUgbmV4dCBtaW5vciByZWxlYXNlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBUbyBvcHQtaW4gdG8gdGhlIG5ldyBiZWhhdmlvciBub3csIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHNldCBcXGBhcHAuY29uZmlnLnVud3JhcEluamVjdGVkUmVmID0gdHJ1ZVxcYCAodGhpcyBjb25maWcgaXMgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGVtcG9yYXJ5IGFuZCB3aWxsIG5vdCBiZSBuZWVkZWQgaW4gdGhlIGZ1dHVyZS4pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHhba2V5XSA9IGluamVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkluamVjdFwiIC8qIE9wdGlvblR5cGVzLklOSkVDVCAqLywga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGluc3RhbmNlLCB0eXBlKSB7XG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaXNBcnJheShob29rKVxuICAgICAgICA/IGhvb2subWFwKGggPT4gaC5iaW5kKGluc3RhbmNlLnByb3h5KSlcbiAgICAgICAgOiBob29rLmJpbmQoaW5zdGFuY2UucHJveHkpLCBpbnN0YW5jZSwgdHlwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyKHJhdywgY3R4LCBwdWJsaWNUaGlzLCBrZXkpIHtcbiAgICBjb25zdCBnZXR0ZXIgPSBrZXkuaW5jbHVkZXMoJy4nKVxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxuICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNba2V5XTtcbiAgICBpZiAoaXNTdHJpbmcocmF3KSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICB3YXRjaChnZXR0ZXIsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xuICAgICAgICB3YXRjaChnZXR0ZXIsIHJhdy5iaW5kKHB1YmxpY1RoaXMpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QocmF3KSkge1xuICAgICAgICBpZiAoaXNBcnJheShyYXcpKSB7XG4gICAgICAgICAgICByYXcuZm9yRWFjaChyID0+IGNyZWF0ZVdhdGNoZXIociwgY3R4LCBwdWJsaWNUaGlzLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBpc0Z1bmN0aW9uKHJhdy5oYW5kbGVyKVxuICAgICAgICAgICAgICAgID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKVxuICAgICAgICAgICAgICAgIDogY3R4W3Jhdy5oYW5kbGVyXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhdy5oYW5kbGVyfVwiYCwgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgd2F0Y2ggb3B0aW9uOiBcIiR7a2V5fVwiYCwgcmF3KTtcbiAgICB9XG59XG4vKipcbiAqIFJlc29sdmUgbWVyZ2VkIG9wdGlvbnMgYW5kIGNhY2hlIGl0IG9uIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIGlzIGRvbmUgb25seSBvbmNlIHBlci1jb21wb25lbnQgc2luY2UgdGhlIG1lcmdpbmcgZG9lcyBub3QgaW52b2x2ZVxuICogaW5zdGFuY2VzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xuICAgIGNvbnN0IGJhc2UgPSBpbnN0YW5jZS50eXBlO1xuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gYmFzZTtcbiAgICBjb25zdCB7IG1peGluczogZ2xvYmFsTWl4aW5zLCBvcHRpb25zQ2FjaGU6IGNhY2hlLCBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH0gfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGJhc2UpO1xuICAgIGxldCByZXNvbHZlZDtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHJlc29sdmVkID0gY2FjaGVkO1xuICAgIH1cbiAgICBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xuICAgICAgICB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IGJhc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc29sdmVkID0ge307XG4gICAgICAgIGlmIChnbG9iYWxNaXhpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBnbG9iYWxNaXhpbnMuZm9yRWFjaChtID0+IG1lcmdlT3B0aW9ucyhyZXNvbHZlZCwgbSwgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VPcHRpb25zKHJlc29sdmVkLCBiYXNlLCBvcHRpb25NZXJnZVN0cmF0ZWdpZXMpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QoYmFzZSkpIHtcbiAgICAgICAgY2FjaGUuc2V0KGJhc2UsIHJlc29sdmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHRvLCBmcm9tLCBzdHJhdHMsIGFzTWl4aW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcbiAgICBpZiAoZXh0ZW5kc09wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VPcHRpb25zKHRvLCBleHRlbmRzT3B0aW9ucywgc3RyYXRzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKG1peGlucykge1xuICAgICAgICBtaXhpbnMuZm9yRWFjaCgobSkgPT4gbWVyZ2VPcHRpb25zKHRvLCBtLCBzdHJhdHMsIHRydWUpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgICAgICBpZiAoYXNNaXhpbiAmJiBrZXkgPT09ICdleHBvc2UnKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICB3YXJuKGBcImV4cG9zZVwiIG9wdGlvbiBpcyBpZ25vcmVkIHdoZW4gZGVjbGFyZWQgaW4gbWl4aW5zIG9yIGV4dGVuZHMuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IChzdHJhdHMgJiYgc3RyYXRzW2tleV0pO1xuICAgICAgICAgICAgdG9ba2V5XSA9IHN0cmF0ID8gc3RyYXQodG9ba2V5XSwgZnJvbVtrZXldKSA6IGZyb21ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG59XG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xuICAgIGRhdGE6IG1lcmdlRGF0YUZuLFxuICAgIHByb3BzOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gICAgZW1pdHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgICAvLyBvYmplY3RzXG4gICAgbWV0aG9kczogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAgIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXG4gICAgLy8gbGlmZWN5Y2xlXG4gICAgYmVmb3JlQ3JlYXRlOiBtZXJnZUFzQXJyYXksXG4gICAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGJlZm9yZU1vdW50OiBtZXJnZUFzQXJyYXksXG4gICAgbW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxuICAgIHVwZGF0ZWQ6IG1lcmdlQXNBcnJheSxcbiAgICBiZWZvcmVEZXN0cm95OiBtZXJnZUFzQXJyYXksXG4gICAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxuICAgIGRlc3Ryb3llZDogbWVyZ2VBc0FycmF5LFxuICAgIHVubW91bnRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxuICAgIGRlYWN0aXZhdGVkOiBtZXJnZUFzQXJyYXksXG4gICAgZXJyb3JDYXB0dXJlZDogbWVyZ2VBc0FycmF5LFxuICAgIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXG4gICAgLy8gYXNzZXRzXG4gICAgY29tcG9uZW50czogbWVyZ2VPYmplY3RPcHRpb25zLFxuICAgIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcbiAgICAvLyB3YXRjaFxuICAgIHdhdGNoOiBtZXJnZVdhdGNoT3B0aW9ucyxcbiAgICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gICAgcHJvdmlkZTogbWVyZ2VEYXRhRm4sXG4gICAgaW5qZWN0OiBtZXJnZUluamVjdFxufTtcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgaWYgKCF0bykge1xuICAgICAgICByZXR1cm4gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbigpIHtcbiAgICAgICAgcmV0dXJuIChleHRlbmQpKGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLCBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0T3B0aW9ucyhub3JtYWxpemVJbmplY3QodG8pLCBub3JtYWxpemVJbmplY3QoZnJvbSkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xuICAgIGlmIChpc0FycmF5KHJhdykpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbcmF3W2ldXSA9IHJhd1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gcmF3O1xufVxuZnVuY3Rpb24gbWVyZ2VBc0FycmF5KHRvLCBmcm9tKSB7XG4gICAgcmV0dXJuIHRvID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHRvLCBmcm9tKSldIDogZnJvbTtcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0T3B0aW9ucyh0bywgZnJvbSkge1xuICAgIHJldHVybiB0byA/IGV4dGVuZChleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgdG8pLCBmcm9tKSA6IGZyb207XG59XG5mdW5jdGlvbiBtZXJnZVdhdGNoT3B0aW9ucyh0bywgZnJvbSkge1xuICAgIGlmICghdG8pXG4gICAgICAgIHJldHVybiBmcm9tO1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIGNvbnN0IG1lcmdlZCA9IGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB0byk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgICAgICBtZXJnZWRba2V5XSA9IG1lcmdlQXNBcnJheSh0b1trZXldLCBmcm9tW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCAvLyByZXN1bHQgb2YgYml0d2lzZSBmbGFnIGNvbXBhcmlzb25cbmlzU1NSID0gZmFsc2UpIHtcbiAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgZGVmKGF0dHJzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG4gICAgaW5zdGFuY2UucHJvcHNEZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcbiAgICAvLyBlbnN1cmUgYWxsIGRlY2xhcmVkIHByb3Aga2V5cyBhcmUgcHJlc2VudFxuICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLnByb3BzT3B0aW9uc1swXSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHZhbGlkYXRpb25cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChpc1N0YXRlZnVsKSB7XG4gICAgICAgIC8vIHN0YXRlZnVsXG4gICAgICAgIGluc3RhbmNlLnByb3BzID0gaXNTU1IgPyBwcm9wcyA6IHNoYWxsb3dSZWFjdGl2ZShwcm9wcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWluc3RhbmNlLnR5cGUucHJvcHMpIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gb3B0aW9uYWwgcHJvcHMsIHByb3BzID09PSBhdHRyc1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gZGVjbGFyZWQgcHJvcHNcbiAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuYXR0cnMgPSBhdHRycztcbn1cbmZ1bmN0aW9uIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSB7XG4gICAgd2hpbGUgKGluc3RhbmNlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLl9faG1ySWQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCByYXdQcmV2UHJvcHMsIG9wdGltaXplZCkge1xuICAgIGNvbnN0IHsgcHJvcHMsIGF0dHJzLCB2bm9kZTogeyBwYXRjaEZsYWcgfSB9ID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xuICAgIGNvbnN0IFtvcHRpb25zXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSW5IbXJDb250ZXh0KGluc3RhbmNlKSkgJiZcbiAgICAgICAgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJlxuICAgICAgICAhKHBhdGNoRmxhZyAmIDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqLykpIHtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDggLyogUGF0Y2hGbGFncy5QUk9QUyAqLykge1xuICAgICAgICAgICAgLy8gQ29tcGlsZXItZ2VuZXJhdGVkIHByb3BzICYgbm8ga2V5cyBjaGFuZ2UsIGp1c3Qgc2V0IHRoZSB1cGRhdGVkXG4gICAgICAgICAgICAvLyB0aGUgcHJvcHMuXG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUFJPUFMgZmxhZyBndWFyYW50ZWVzIHJhd1Byb3BzIHRvIGJlIG5vbi1udWxsXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByYXdQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHIgLyBwcm9wcyBzZXBhcmF0aW9uIHdhcyBkb25lIG9uIGluaXQgYW5kIHdpbGwgYmUgY29uc2lzdGVudFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNvZGUgcGF0aCwgc28ganVzdCBjaGVjayBpZiBhdHRycyBoYXZlIGl0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tjYW1lbGl6ZWRLZXldID0gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCByYXdDdXJyZW50UHJvcHMsIGNhbWVsaXplZEtleSwgdmFsdWUsIGluc3RhbmNlLCBmYWxzZSAvKiBpc0Fic2VudCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZnVsbCBwcm9wcyB1cGRhdGUuXG4gICAgICAgIGlmIChzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpKSB7XG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgZHluYW1pYyBwcm9wcywgY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUga2V5cyBmcm9tXG4gICAgICAgIC8vIHRoZSBwcm9wcyBvYmplY3RcbiAgICAgICAgbGV0IGtlYmFiS2V5O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdDdXJyZW50UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcbiAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgICAgICAgKCFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlICgjOTU1KVxuICAgICAgICAgICAgICAgICAgICAoKGtlYmFiS2V5ID0gaHlwaGVuYXRlKGtleSkpID09PSBrZXkgfHwgIWhhc093bihyYXdQcm9wcywga2ViYWJLZXkpKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3UHJldlByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgY2FtZWxDYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBrZWJhYi1jYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3UHJldlByb3BzW2tlYmFiS2V5XSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIHVuZGVmaW5lZCwgaW5zdGFuY2UsIHRydWUgLyogaXNBYnNlbnQgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgZnVuY3Rpb25hbCBjb21wb25lbnQgdy9vIHByb3BzIGRlY2xhcmF0aW9uLCBwcm9wcyBhbmRcbiAgICAgICAgLy8gYXR0cnMgcG9pbnQgdG8gdGhlIHNhbWUgb2JqZWN0IHNvIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgICAgICBpZiAoYXR0cnMgIT09IHJhd0N1cnJlbnRQcm9wcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8XG4gICAgICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWZhbHNlICkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZXMgZm9yICRhdHRycyBpbiBjYXNlIGl0J3MgdXNlZCBpbiBjb21wb25lbnQgc2xvdHNcbiAgICBpZiAoaGFzQXR0cnNDaGFuZ2VkKSB7XG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovLCAnJGF0dHJzJyk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcbiAgICBjb25zdCBbb3B0aW9ucywgbmVlZENhc3RLZXlzXSA9IGluc3RhbmNlLnByb3BzT3B0aW9ucztcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgbGV0IHJhd0Nhc3RWYWx1ZXM7XG4gICAgaWYgKHJhd1Byb3BzKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiByYXdQcm9wcykge1xuICAgICAgICAgICAgLy8ga2V5LCByZWYgYXJlIHJlc2VydmVkIGFuZCBuZXZlciBwYXNzZWQgZG93blxuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcbiAgICAgICAgICAgIC8vIHByb3Agb3B0aW9uIG5hbWVzIGFyZSBjYW1lbGl6ZWQgZHVyaW5nIG5vcm1hbGl6YXRpb24sIHNvIHRvIHN1cHBvcnRcbiAgICAgICAgICAgIC8vIGtlYmFiIC0+IGNhbWVsIGNvbnZlcnNpb24gaGVyZSB3ZSBuZWVkIHRvIGNhbWVsaXplIHRoZSBrZXkuXG4gICAgICAgICAgICBsZXQgY2FtZWxLZXk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgKGNhbWVsS2V5ID0gY2FtZWxpemUoa2V5KSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkQ2FzdEtleXMgfHwgIW5lZWRDYXN0S2V5cy5pbmNsdWRlcyhjYW1lbEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBhdHRycykgfHwgdmFsdWUgIT09IGF0dHJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZENhc3RLZXlzKSB7XG4gICAgICAgIGNvbnN0IHJhd0N1cnJlbnRQcm9wcyA9IHRvUmF3KHByb3BzKTtcbiAgICAgICAgY29uc3QgY2FzdFZhbHVlcyA9IHJhd0Nhc3RWYWx1ZXMgfHwgRU1QVFlfT0JKO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmVlZENhc3RLZXlzW2ldO1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIGNhc3RWYWx1ZXNba2V5XSwgaW5zdGFuY2UsICFoYXNPd24oY2FzdFZhbHVlcywga2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc0F0dHJzQ2hhbmdlZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcHJvcHMsIGtleSwgdmFsdWUsIGluc3RhbmNlLCBpc0Fic2VudCkge1xuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAob3B0ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IGhhc093bihvcHQsICdkZWZhdWx0Jyk7XG4gICAgICAgIC8vIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG9wdC5kZWZhdWx0O1xuICAgICAgICAgICAgaWYgKG9wdC50eXBlICE9PSBGdW5jdGlvbiAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcHJvcHNEZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzRGVmYXVsdHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwobnVsbCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGJvb2xlYW4gY2FzdGluZ1xuICAgICAgICBpZiAob3B0WzAgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3QgKi9dKSB7XG4gICAgICAgICAgICBpZiAoaXNBYnNlbnQgJiYgIWhhc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0WzEgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3RUcnVlICovXSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wc09wdGlvbnMoY29tcCwgYXBwQ29udGV4dCwgYXNNaXhpbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LnByb3BzQ2FjaGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgcmF3ID0gY29tcC5wcm9wcztcbiAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XG4gICAgLy8gYXBwbHkgbWl4aW4vZXh0ZW5kcyBwcm9wc1xuICAgIGxldCBoYXNFeHRlbmRzID0gZmFsc2U7XG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kUHJvcHMgPSAocmF3KSA9PiB7XG4gICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFhc01peGluICYmIGFwcENvbnRleHQubWl4aW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAuZXh0ZW5kcykge1xuICAgICAgICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcC5taXhpbnMpIHtcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XG4gICAgICAgIGlmIChpc09iamVjdChjb21wKSkge1xuICAgICAgICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVNUFRZX0FSUjtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNTdHJpbmcocmF3W2ldKSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKHJhd1tpXSk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplZEtleV0gPSBFTVBUWV9PQko7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmF3KSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0KHJhdykpIHtcbiAgICAgICAgICAgIHdhcm4oYGludmFsaWQgcHJvcHMgb3B0aW9uc2AsIHJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3KSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gcmF3W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IChub3JtYWxpemVkW25vcm1hbGl6ZWRLZXldID1cbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBPYmplY3QuYXNzaWduKHt9LCBvcHQpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wWzAgLyogQm9vbGVhbkZsYWdzLnNob3VsZENhc3QgKi9dID0gYm9vbGVhbkluZGV4ID4gLTE7XG4gICAgICAgICAgICAgICAgICAgIHByb3BbMSAvKiBCb29sZWFuRmxhZ3Muc2hvdWxkQ2FzdFRydWUgKi9dID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByb3AgbmVlZHMgYm9vbGVhbiBjYXN0aW5nIG9yIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb2xlYW5JbmRleCA+IC0xIHx8IGhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcbiAgICBpZiAoaXNPYmplY3QoY29tcCkpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xuICAgIGlmIChrZXlbMF0gIT09ICckJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm4oYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIHVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayB0eXBlIGNvbnN0cnVjdG9yc1xuLy8gc28gdGhhdCBpdCB3b3JrcyBhY3Jvc3Mgdm1zIC8gaWZyYW1lcy5cbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xuICAgIGNvbnN0IG1hdGNoID0gY3RvciAmJiBjdG9yLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqKGZ1bmN0aW9ufGNsYXNzKSAoXFx3KykvKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsyXSA6IGN0b3IgPT09IG51bGwgPyAnbnVsbCcgOiAnJztcbn1cbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBpZiAoaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWRUeXBlcy5maW5kSW5kZXgodCA9PiBpc1NhbWVUeXBlKHQsIHR5cGUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihleHBlY3RlZFR5cGVzKSkge1xuICAgICAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcbiAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IHRvUmF3KHByb3BzKTtcbiAgICBjb25zdCBvcHRpb25zID0gaW5zdGFuY2UucHJvcHNPcHRpb25zWzBdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdCA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgaWYgKG9wdCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhbGlkYXRlUHJvcChrZXksIHJlc29sdmVkVmFsdWVzW2tleV0sIG9wdCwgIWhhc093bihyYXdQcm9wcywga2V5KSAmJiAhaGFzT3duKHJhd1Byb3BzLCBoeXBoZW5hdGUoa2V5KSkpO1xuICAgIH1cbn1cbi8qKlxuICogZGV2IG9ubHlcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKG5hbWUsIHZhbHVlLCBwcm9wLCBpc0Fic2VudCkge1xuICAgIGNvbnN0IHsgdHlwZSwgcmVxdWlyZWQsIHZhbGlkYXRvciB9ID0gcHJvcDtcbiAgICAvLyByZXF1aXJlZCFcbiAgICBpZiAocmVxdWlyZWQgJiYgaXNBYnNlbnQpIHtcbiAgICAgICAgd2FybignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbWlzc2luZyBidXQgb3B0aW9uYWxcbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHR5cGUgY2hlY2tcbiAgICBpZiAodHlwZSAhPSBudWxsICYmIHR5cGUgIT09IHRydWUpIHtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBpc0FycmF5KHR5cGUpID8gdHlwZSA6IFt0eXBlXTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgICAvLyB2YWx1ZSBpcyB2YWxpZCBhcyBsb25nIGFzIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzIG1hdGNoXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoICYmICFpc1ZhbGlkOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWQsIGV4cGVjdGVkVHlwZSB9ID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZXNbaV0pO1xuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICAgICAgICBpc1ZhbGlkID0gdmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICB3YXJuKGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGN1c3RvbSB2YWxpZGF0b3JcbiAgICBpZiAodmFsaWRhdG9yICYmICF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICAgIHdhcm4oJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcbiAgICB9XG59XG5jb25zdCBpc1NpbXBsZVR5cGUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ1N0cmluZyxOdW1iZXIsQm9vbGVhbixGdW5jdGlvbixTeW1ib2wsQmlnSW50Jyk7XG4vKipcbiAqIGRldiBvbmx5XG4gKi9cbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUpIHtcbiAgICBsZXQgdmFsaWQ7XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgICBpZiAoaXNTaW1wbGVUeXBlKGV4cGVjdGVkVHlwZSkpIHtcbiAgICAgICAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICB2YWxpZCA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ251bGwnKSB7XG4gICAgICAgIHZhbGlkID0gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQsXG4gICAgICAgIGV4cGVjdGVkVHlwZVxuICAgIH07XG59XG4vKipcbiAqIGRldiBvbmx5XG4gKi9cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcykge1xuICAgIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXG4gICAgICAgIGAgRXhwZWN0ZWQgJHtleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcgfCAnKX1gO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgICBjb25zdCByZWNlaXZlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKTtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtleHBlY3RlZFZhbHVlfWA7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vKipcbiAqIGRldiBvbmx5XG4gKi9cbmZ1bmN0aW9uIHN0eWxlVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgICAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XG4gICAgfVxufVxuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xuICAgIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuICAgIHJldHVybiBleHBsaWNpdFR5cGVzLnNvbWUoZWxlbSA9PiB0eXBlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xufVxuLyoqXG4gKiBkZXYgb25seVxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4oLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnNvbWUoZWxlbSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJyk7XG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09ICdfJyB8fCBrZXkgPT09ICckc3RhYmxlJztcbmNvbnN0IG5vcm1hbGl6ZVNsb3RWYWx1ZSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSlcbiAgICA/IHZhbHVlLm1hcChub3JtYWxpemVWTm9kZSlcbiAgICA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xuY29uc3Qgbm9ybWFsaXplU2xvdCA9IChrZXksIHJhd1Nsb3QsIGN0eCkgPT4ge1xuICAgIGlmIChyYXdTbG90Ll9uKSB7XG4gICAgICAgIC8vIGFscmVhZHkgbm9ybWFsaXplZCAtICM1MzUzXG4gICAgICAgIHJldHVybiByYXdTbG90O1xuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgd2FybihgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiBgICtcbiAgICAgICAgICAgICAgICBgdGhpcyB3aWxsIG5vdCB0cmFjayBkZXBlbmRlbmNpZXMgdXNlZCBpbiB0aGUgc2xvdC4gYCArXG4gICAgICAgICAgICAgICAgYEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVTbG90VmFsdWUocmF3U2xvdCguLi5hcmdzKSk7XG4gICAgfSwgY3R4KTtcbiAgICBub3JtYWxpemVkLl9jID0gZmFsc2U7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IHJhd1Nsb3RzLl9jdHg7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3U2xvdHMpIHtcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJhd1Nsb3RzW2tleV07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgc2xvdHNba2V5XSA9IG5vcm1hbGl6ZVNsb3Qoa2V5LCB2YWx1ZSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgIShmYWxzZSApKSB7XG4gICAgICAgICAgICAgICAgd2FybihgTm9uLWZ1bmN0aW9uIHZhbHVlIGVuY291bnRlcmVkIGZvciBzbG90IFwiJHtrZXl9XCIuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplU2xvdFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IG5vcm1hbGl6ZVZOb2RlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuKSA9PiB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmXG4gICAgICAgICEoZmFsc2UgKSkge1xuICAgICAgICB3YXJuKGBOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gYCArXG4gICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTbG90VmFsdWUoY2hpbGRyZW4pO1xuICAgIGluc3RhbmNlLnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBub3JtYWxpemVkO1xufTtcbmNvbnN0IGluaXRTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcbiAgICBpZiAoaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgMzIgLyogU2hhcGVGbGFncy5TTE9UU19DSElMRFJFTiAqLykge1xuICAgICAgICBjb25zdCB0eXBlID0gY2hpbGRyZW4uXztcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIHVzZXJzIGNhbiBnZXQgdGhlIHNoYWxsb3cgcmVhZG9ubHkgdmVyc2lvbiBvZiB0aGUgc2xvdHMgb2JqZWN0IHRocm91Z2ggYHRoaXMuJHNsb3RzYCxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhdm9pZCB0aGUgcHJveHkgb2JqZWN0IHBvbGx1dGluZyB0aGUgc2xvdHMgb2YgdGhlIGludGVybmFsIGluc3RhbmNlXG4gICAgICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHRvUmF3KGNoaWxkcmVuKTtcbiAgICAgICAgICAgIC8vIG1ha2UgY29tcGlsZXIgbWFya2VyIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgICBkZWYoY2hpbGRyZW4sICdfJywgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgKGluc3RhbmNlLnNsb3RzID0ge30pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2Uuc2xvdHMgPSB7fTtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBub3JtYWxpemVWTm9kZVNsb3RzKGluc3RhbmNlLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVmKGluc3RhbmNlLnNsb3RzLCBJbnRlcm5hbE9iamVjdEtleSwgMSk7XG59O1xuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcbiAgICBjb25zdCB7IHZub2RlLCBzbG90cyB9ID0gaW5zdGFuY2U7XG4gICAgbGV0IG5lZWREZWxldGlvbkNoZWNrID0gdHJ1ZTtcbiAgICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xuICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAzMiAvKiBTaGFwZUZsYWdzLlNMT1RTX0NISUxEUkVOICovKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGlsZHJlbi5fO1xuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgLy8gY29tcGlsZWQgc2xvdHMuXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJlbnQgd2FzIEhNUiB1cGRhdGVkIHNvIHNsb3QgY29udGVudCBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBzbG90cyBhbmQgbWFyayBpbnN0YW5jZSBmb3IgaG1yIGFzIHdlbGxcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBBTkQgc3RhYmxlLlxuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdXBkYXRlLCBhbmQgc2tpcCBzdGFsZSBzbG90cyByZW1vdmFsLlxuICAgICAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlZCBidXQgZHluYW1pYyAodi1pZi92LWZvciBvbiBzbG90cykgLSB1cGRhdGUgc2xvdHMsIGJ1dCBza2lwXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvbi5cbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAvLyAjMjg5M1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIHRoZSBvcHRpbWl6ZWQgc2xvdHMgYnkgbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxldGUgdGhlIGBzbG90cy5fYCBmbGFnIGlmIG5lY2Vzc2FyeSB0byBtYWtlIHN1YnNlcXVlbnQgdXBkYXRlcyByZWxpYWJsZSxcbiAgICAgICAgICAgICAgICAvLyBpLmUuIGxldCB0aGUgYHJlbmRlclNsb3RgIGNyZWF0ZSB0aGUgYmFpbGVkIEZyYWdtZW50XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpbWl6ZWQgJiYgdHlwZSA9PT0gMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90cy5fO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XG4gICAgICAgICAgICBub3JtYWxpemVPYmplY3RTbG90cyhjaGlsZHJlbiwgc2xvdHMpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0aW9uQ29tcGFyaXNvblRhcmdldCA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgICAgICAvLyBub24gc2xvdCBvYmplY3QgY2hpbGRyZW4gKGRpcmVjdCB2YWx1ZSkgcGFzc2VkIHRvIGEgY29tcG9uZW50XG4gICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICAgICAgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0geyBkZWZhdWx0OiAxIH07XG4gICAgfVxuICAgIC8vIGRlbGV0ZSBzdGFsZSBzbG90c1xuICAgIGlmIChuZWVkRGVsZXRpb25DaGVjaykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzbG90c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQXBwQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhcHA6IG51bGwsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgaXNOYXRpdmVUYWc6IE5PLFxuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllczoge30sXG4gICAgICAgICAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IHt9LFxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3YXJuSGFuZGxlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29tcGlsZXJPcHRpb25zOiB7fVxuICAgICAgICB9LFxuICAgICAgICBtaXhpbnM6IFtdLFxuICAgICAgICBjb21wb25lbnRzOiB7fSxcbiAgICAgICAgZGlyZWN0aXZlczoge30sXG4gICAgICAgIHByb3ZpZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBvcHRpb25zQ2FjaGU6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgIHByb3BzQ2FjaGU6IG5ldyBXZWFrTWFwKCksXG4gICAgICAgIGVtaXRzQ2FjaGU6IG5ldyBXZWFrTWFwKClcbiAgICB9O1xufVxubGV0IHVpZCQxID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUFwcEFQSShyZW5kZXIsIGh5ZHJhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXBwKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJvb3RDb21wb25lbnQpKSB7XG4gICAgICAgICAgICByb290Q29tcG9uZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcm9vdENvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2Fybihgcm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgICAgICAgICByb290UHJvcHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXBwID0gKGNvbnRleHQuYXBwID0ge1xuICAgICAgICAgICAgX3VpZDogdWlkJDErKyxcbiAgICAgICAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXG4gICAgICAgICAgICBfcHJvcHM6IHJvb3RQcm9wcyxcbiAgICAgICAgICAgIF9jb250YWluZXI6IG51bGwsXG4gICAgICAgICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIF9pbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmZpZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgY29uZmlnKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5oYXMocGx1Z2luKSkge1xuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwbHVnaW4gJiYgaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwoYXBwLCAuLi5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbGxlZFBsdWdpbnMuYWRkKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbihhcHAsIC4uLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBmdW5jdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaXhpbihtaXhpbikge1xuICAgICAgICAgICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dC5taXhpbnMuaW5jbHVkZXMobWl4aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1peGlucy5wdXNoKG1peGluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1peGluLm5hbWUgPyBgOiAke21peGluLm5hbWV9YCA6ICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ01peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUEknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wb25lbnQobmFtZSwgY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBDb21wb25lbnQgXCIke25hbWV9XCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIGluIHRhcmdldCBhcHAuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV0gPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VudChyb290Q29udGFpbmVyLCBpc0h5ZHJhdGUsIGlzU1ZHKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIzU1NzFcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgIElmIHlvdSB3YW50IHRvIG1vdW50IGFub3RoZXIgYXBwIG9uIHRoZSBzYW1lIGhvc3QgY29udGFpbmVyLGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZVZOb2RlKHJvb3RDb21wb25lbnQsIHJvb3RQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGFwcCBjb250ZXh0IG9uIHRoZSByb290IFZOb2RlLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgc2V0IG9uIHRoZSByb290IGluc3RhbmNlIG9uIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmFwcENvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAvLyBITVIgcm9vdCByZWxvYWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNsb25lVk5vZGUodm5vZGUpLCByb290Q29udGFpbmVyLCBpc1NWRyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZSh2bm9kZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXIodm5vZGUsIHJvb3RDb250YWluZXIsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IHJvb3RDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb250YWluZXIuX192dWVfYXBwX18gPSBhcHA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQXBwIGhhcyBhbHJlYWR5IGJlZW4gbW91bnRlZC5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbnRvIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgY3JlYXRlIGZyZXNoIGFwcCBpbnN0YW5jZXMgZm9yIGVhY2ggYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgbW91bnQgLSBlLmcuIFxcYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClcXGBgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcihudWxsLCBhcHAuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzVW5tb3VudEFwcChhcHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYENhbm5vdCB1bm1vdW50IGFuIGFwcCB0aGF0IGlzIG5vdCBtb3VudGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSBpbiBjb250ZXh0LnByb3ZpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4oYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoa2V5KX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgSXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSBuZXcgdmFsdWUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHQucHJvdmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZm9yIGhhbmRsaW5nIGEgdGVtcGxhdGUgcmVmXG4gKi9cbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xuICAgIGlmIChpc0FycmF5KHJhd1JlZikpIHtcbiAgICAgICAgcmF3UmVmLmZvckVhY2goKHIsIGkpID0+IHNldFJlZihyLCBvbGRSYXdSZWYgJiYgKGlzQXJyYXkob2xkUmF3UmVmKSA/IG9sZFJhd1JlZltpXSA6IG9sZFJhd1JlZiksIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgaXNVbm1vdW50KSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSAmJiAhaXNVbm1vdW50KSB7XG4gICAgICAgIC8vIHdoZW4gbW91bnRpbmcgYXN5bmMgY29tcG9uZW50cywgbm90aGluZyBuZWVkcyB0byBiZSBkb25lLFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSB0ZW1wbGF0ZSByZWYgaXMgZm9yd2FyZGVkIHRvIGlubmVyIGNvbXBvbmVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlZlZhbHVlID0gdm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTaGFwZUZsYWdzLlNUQVRFRlVMX0NPTVBPTkVOVCAqL1xuICAgICAgICA/IGdldEV4cG9zZVByb3h5KHZub2RlLmNvbXBvbmVudCkgfHwgdm5vZGUuY29tcG9uZW50LnByb3h5XG4gICAgICAgIDogdm5vZGUuZWw7XG4gICAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XG4gICAgY29uc3QgeyBpOiBvd25lciwgcjogcmVmIH0gPSByYXdSZWY7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhb3duZXIpIHtcbiAgICAgICAgd2FybihgTWlzc2luZyByZWYgb3duZXIgY29udGV4dC4gcmVmIGNhbm5vdCBiZSB1c2VkIG9uIGhvaXN0ZWQgdm5vZGVzLiBgICtcbiAgICAgICAgICAgIGBBIHZub2RlIHdpdGggcmVmIG11c3QgYmUgY3JlYXRlZCBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbi5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbGRSZWYgPSBvbGRSYXdSZWYgJiYgb2xkUmF3UmVmLnI7XG4gICAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IChvd25lci5yZWZzID0ge30pIDogb3duZXIucmVmcztcbiAgICBjb25zdCBzZXR1cFN0YXRlID0gb3duZXIuc2V0dXBTdGF0ZTtcbiAgICAvLyBkeW5hbWljIHJlZiBjaGFuZ2VkLiB1bnNldCBvbGQgcmVmXG4gICAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyhvbGRSZWYpKSB7XG4gICAgICAgICAgICByZWZzW29sZFJlZl0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XG4gICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtvbGRSZWZdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZihvbGRSZWYpKSB7XG4gICAgICAgICAgICBvbGRSZWYudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKHJlZikpIHtcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyIC8qIEVycm9yQ29kZXMuRlVOQ1RJT05fUkVGICovLCBbdmFsdWUsIHJlZnNdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IF9pc1N0cmluZyA9IGlzU3RyaW5nKHJlZik7XG4gICAgICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XG4gICAgICAgIGlmIChfaXNTdHJpbmcgfHwgX2lzUmVmKSB7XG4gICAgICAgICAgICBjb25zdCBkb1NldCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBfaXNTdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gaGFzT3duKHNldHVwU3RhdGUsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNldHVwU3RhdGVbcmVmXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmc1tyZWZdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNBcnJheShleGlzdGluZykgJiYgcmVtb3ZlKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSBbcmVmVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW3JlZl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmF3UmVmLmtdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkb1NldC5pZCA9IC0xO1xuICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChkb1NldCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9TZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oJ0ludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6JywgcmVmLCBgKCR7dHlwZW9mIHJlZn0pYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmxldCBoYXNNaXNtYXRjaCA9IGZhbHNlO1xuY29uc3QgaXNTVkdDb250YWluZXIgPSAoY29udGFpbmVyKSA9PiAvc3ZnLy50ZXN0KGNvbnRhaW5lci5uYW1lc3BhY2VVUkkpICYmIGNvbnRhaW5lci50YWdOYW1lICE9PSAnZm9yZWlnbk9iamVjdCc7XG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBET01Ob2RlVHlwZXMuQ09NTUVOVCAqLztcbi8vIE5vdGU6IGh5ZHJhdGlvbiBpcyBET00tc3BlY2lmaWNcbi8vIEJ1dCB3ZSBoYXZlIHRvIHBsYWNlIGl0IGluIGNvcmUgZHVlIHRvIHRpZ2h0IGNvdXBsaW5nIHdpdGggY29yZSAtIHNwbGl0dGluZ1xuLy8gaXQgb3V0IGNyZWF0ZXMgYSB0b24gb2YgdW5uZWNlc3NhcnkgY29tcGxleGl0eS5cbi8vIEh5ZHJhdGlvbiBhbHNvIGRlcGVuZHMgb24gc29tZSByZW5kZXJlciBpbnRlcm5hbCBsb2dpYyB3aGljaCBuZWVkcyB0byBiZVxuLy8gcGFzc2VkIGluIHZpYSBhcmd1bWVudHMuXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMocmVuZGVyZXJJbnRlcm5hbHMpIHtcbiAgICBjb25zdCB7IG10OiBtb3VudENvbXBvbmVudCwgcDogcGF0Y2gsIG86IHsgcGF0Y2hQcm9wLCBjcmVhdGVUZXh0LCBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcmVtb3ZlLCBpbnNlcnQsIGNyZWF0ZUNvbW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XG4gICAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XG4gICAgICAgIGlmICghY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFBlcmZvcm1pbmcgZnVsbCBtb3VudCBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICBmbHVzaFBvc3RGbHVzaENicygpO1xuICAgICAgICAgICAgY29udGFpbmVyLl92bm9kZSA9IHZub2RlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhhc01pc21hdGNoID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICAgICAgaWYgKGhhc01pc21hdGNoICYmICFmYWxzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBlcnJvciBzaG91bGQgc2hvdyB1cCBpbiBwcm9kdWN0aW9uXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBIeWRyYXRpb24gY29tcGxldGVkIGJ1dCBjb250YWlucyBtaXNtYXRjaGVzLmApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoeWRyYXRlTm9kZSA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xuICAgICAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWyc7XG4gICAgICAgIGNvbnN0IG9uTWlzbWF0Y2ggPSAoKSA9PiBoYW5kbGVNaXNtYXRjaChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBpc0ZyYWdtZW50U3RhcnQpO1xuICAgICAgICBjb25zdCB7IHR5cGUsIHJlZiwgc2hhcGVGbGFnLCBwYXRjaEZsYWcgfSA9IHZub2RlO1xuICAgICAgICBsZXQgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIHZub2RlLmVsID0gbm9kZTtcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIgLyogUGF0Y2hGbGFncy5CQUlMICovKSB7XG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHROb2RlID0gbnVsbDtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFRleHQ6XG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogRE9NTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIzU3MjggZW1wdHkgdGV4dCBub2RlIGluc2lkZSBhIHNsb3QgY2FuIGNhdXNlIGh5ZHJhdGlvbiBmYWlsdXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIHdvbid0IGNvbnRhaW4gYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KCh2bm9kZS5lbCA9IGNyZWF0ZVRleHQoJycpKSwgcGFyZW50Tm9kZShub2RlKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IG1pc21hdGNoOmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBDbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkobm9kZS5kYXRhKX1gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcbi0gU2VydmVyOiAke0pTT04uc3RyaW5naWZ5KHZub2RlLmNoaWxkcmVuKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSA4IC8qIERPTU5vZGVUeXBlcy5DT01NRU5UICovIHx8IGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XG4gICAgICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnRpcmUgdGVtcGxhdGUgaXMgc3RhdGljIGJ1dCBTU1JlZCBhcyBhIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlID09PSAxIC8qIERPTU5vZGVUeXBlcy5FTEVNRU5UICovIHx8IGRvbVR5cGUgPT09IDMgLyogRE9NTm9kZVR5cGVzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGFuY2hvciwgYWRvcHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0aWMgdm5vZGUgaGFzIGl0cyBjb250ZW50IHN0cmlwcGVkIGR1cmluZyBidWlsZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRvcHQgaXQgZnJvbSB0aGUgc2VydmVyLXJlbmRlcmVkIEhUTUwuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWRUb0Fkb3B0Q29udGVudCA9ICF2bm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRUb0Fkb3B0Q29udGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbiArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBET01Ob2RlVHlwZXMuRUxFTUVOVCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0Tm9kZS5vdXRlckhUTUxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dE5vZGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB2bm9kZS5zdGF0aWNDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gbmV4dFNpYmxpbmcobmV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0ZyYWdtZW50U3RhcnQgPyBuZXh0U2libGluZyhuZXh0Tm9kZSkgOiBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICAgICAgICAgIGlmICghaXNGcmFnbWVudFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRnJhZ21lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBET01Ob2RlVHlwZXMuRUxFTUVOVCAqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudHlwZS50b0xvd2VyQ2FzZSgpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUVsZW1lbnQobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gc2V0dGluZyB1cCB0aGUgcmVuZGVyIGVmZmVjdCwgaWYgdGhlIGluaXRpYWwgdm5vZGUgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgLmVsIHNldCwgdGhlIGNvbXBvbmVudCB3aWxsIHBlcmZvcm0gaHlkcmF0aW9uIGluc3RlYWQgb2YgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gaXRzIHN1Yi10cmVlLlxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBtYXkgYmUgYXN5bmMsIHNvIGluIHRoZSBjYXNlIG9mIGZyYWdtZW50cyB3ZSBjYW5ub3QgcmVseVxuICAgICAgICAgICAgICAgICAgICAvLyBvbiBjb21wb25lbnQncyByZW5kZXJlZCBvdXRwdXQgdG8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQsIHdlIGRvIGEgbG9va2FoZWFkIHRvIGZpbmQgdGhlIGVuZCBhbmNob3Igbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBpc0ZyYWdtZW50U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbG9jYXRlQ2xvc2luZ0FzeW5jQW5jaG9yKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAvLyAjNDI5MyB0ZWxlcG9ydCBhcyBjb21wb25lbnQgcm9vdFxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tbWVudChuZXh0Tm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlLmRhdGEgPT09ICd0ZWxlcG9ydCBlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHRTaWJsaW5nKG5leHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyAjMzc4N1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb21wb25lbnQgaXMgYXN5bmMsIGl0IG1heSBnZXQgbW92ZWQgLyB1bm1vdW50ZWQgYmVmb3JlIGl0c1xuICAgICAgICAgICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaXMgbG9hZGVkLCBzbyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSB0aGF0IG1hdGNoZXMgaXRzIGFkb3B0ZWQgRE9NLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXIodm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ViVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZyYWdtZW50U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlID0gY3JlYXRlVk5vZGUoRnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjb250YWluZXIubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoJycpIDogY3JlYXRlVk5vZGUoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZS5lbCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBET01Ob2RlVHlwZXMuQ09NTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdm5vZGUudHlwZS5oeWRyYXRlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihwYXJlbnROb2RlKG5vZGUpKSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKCdJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbnVsbCwgcGFyZW50U3VzcGVuc2UsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dE5vZGU7XG4gICAgfTtcbiAgICBjb25zdCBoeWRyYXRlRWxlbWVudCA9IChlbCwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcGF0Y2hGbGFnLCBzaGFwZUZsYWcsIGRpcnMgfSA9IHZub2RlO1xuICAgICAgICAvLyAjNDAwNiBmb3IgZm9ybSBlbGVtZW50cyB3aXRoIG5vbi1zdHJpbmcgdi1tb2RlbCB2YWx1ZSBiaW5kaW5nc1xuICAgICAgICAvLyBlLmcuIDxvcHRpb24gOnZhbHVlPVwib2JqXCI+LCA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgOnRydWUtdmFsdWU9XCIxXCI+XG4gICAgICAgIGNvbnN0IGZvcmNlUGF0Y2hWYWx1ZSA9ICh0eXBlID09PSAnaW5wdXQnICYmIGRpcnMpIHx8IHR5cGUgPT09ICdvcHRpb24nO1xuICAgICAgICAvLyBza2lwIHByb3BzICYgY2hpbGRyZW4gaWYgdGhpcyBpcyBob2lzdGVkIHN0YXRpYyBub2Rlc1xuICAgICAgICAvLyAjNTQwNSBpbiBkZXYsIGFsd2F5cyBoeWRyYXRlIGNoaWxkcmVuIGZvciBITVJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBmb3JjZVBhdGNoVmFsdWUgfHwgcGF0Y2hGbGFnICE9PSAtMSAvKiBQYXRjaEZsYWdzLkhPSVNURUQgKi8pIHtcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICAgICAgIW9wdGltaXplZCB8fFxuICAgICAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiAoMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovIHwgMzIgLyogUGF0Y2hGbGFncy5IWURSQVRFX0VWRU5UUyAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZm9yY2VQYXRjaFZhbHVlICYmIGtleS5lbmRzV2l0aCgndmFsdWUnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBmYWxzZSwgdW5kZWZpbmVkLCBwYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBjbGljayBsaXN0ZW5lcnMgKHdoaWNoIGlzIG1vc3Qgb2Z0ZW4pIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGluZyB0aHJvdWdoIHByb3BzLlxuICAgICAgICAgICAgICAgICAgICBwYXRjaFByb3AoZWwsICdvbkNsaWNrJywgbnVsbCwgcHJvcHMub25DbGljaywgZmFsc2UsIHVuZGVmaW5lZCwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2bm9kZSAvIGRpcmVjdGl2ZSBob29rc1xuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdiZWZvcmVNb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2tzID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8IGRpcnMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8gJiZcbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihlbC5maXJzdENoaWxkLCB2bm9kZSwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHt2bm9kZS50eXBlfT46IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBTU1JlZCBET00gY29udGFpbnMgbW9yZSBub2RlcyB0aGFuIGl0IHNob3VsZC4gUmVtb3ZlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmUoY3VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA4IC8qIFNoYXBlRmxhZ3MuVEVYVF9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAtIENsaWVudDogJHtlbC50ZXh0Q29udGVudH1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLSBTZXJ2ZXI6ICR7dm5vZGUuY2hpbGRyZW59YCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5uZXh0U2libGluZztcbiAgICB9O1xuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBvcHRpbWl6ZWQgPSBvcHRpbWl6ZWQgfHwgISFwYXJlbnRWTm9kZS5keW5hbWljQ2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50Vk5vZGUuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkXG4gICAgICAgICAgICAgICAgPyBjaGlsZHJlbltpXVxuICAgICAgICAgICAgICAgIDogKGNoaWxkcmVuW2ldID0gbm9ybWFsaXplVk5vZGUoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGh5ZHJhdGVOb2RlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWhhc1dhcm5lZCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggaW4gPCR7Y29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBzZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGUgU1NSZWQgRE9NIGRpZG4ndCBjb250YWluIGVub3VnaCBub2Rlcy4gTW91bnQgdGhlIG1pc3Npbmcgb25lcy5cbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgY29uc3QgaHlkcmF0ZUZyYWdtZW50ID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHQgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKG5leHQgJiYgaXNDb21tZW50KG5leHQpICYmIG5leHQuZGF0YSA9PT0gJ10nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcbiAgICAgICAgICAgIC8vIGJhY2suIFRoaXMgc2hvdWxkIGhhdmUgbGVkIHRvIG5vZGUvY2hpbGRyZW4gbWlzbWF0Y2ggd2FybmluZ3MuXG4gICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XG4gICAgICAgICAgICBpbnNlcnQoKHZub2RlLmFuY2hvciA9IGNyZWF0ZUNvbW1lbnQoYF1gKSksIGNvbnRhaW5lciwgbmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlTWlzbWF0Y2ggPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgaXNGcmFnbWVudCkgPT4ge1xuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgd2FybihgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XFxuLSBDbGllbnQgdm5vZGU6YCwgdm5vZGUudHlwZSwgYFxcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLCBub2RlLCBub2RlLm5vZGVUeXBlID09PSAzIC8qIERPTU5vZGVUeXBlcy5URVhUICovXG4gICAgICAgICAgICAgICAgPyBgKHRleHQpYFxuICAgICAgICAgICAgICAgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snXG4gICAgICAgICAgICAgICAgICAgID8gYChzdGFydCBvZiBmcmFnbWVudClgXG4gICAgICAgICAgICAgICAgICAgIDogYGApO1xuICAgICAgICB2bm9kZS5lbCA9IG51bGw7XG4gICAgICAgIGlmIChpc0ZyYWdtZW50KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhjZXNzaXZlIGZyYWdtZW50IG5vZGVzXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHQgPSBuZXh0U2libGluZyhub2RlKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcbiAgICAgICAgcmVtb3ZlKG5vZGUpO1xuICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBuZXh0LCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICAgIGNvbnN0IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvciA9IChub2RlKSA9PiB7XG4gICAgICAgIGxldCBtYXRjaCA9IDA7XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBub2RlID0gbmV4dFNpYmxpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSAnWycpXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoKys7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cbmxldCBzdXBwb3J0ZWQ7XG5sZXQgcGVyZjtcbmZ1bmN0aW9uIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgdHlwZSkge1xuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtJHt0eXBlfS0ke2luc3RhbmNlLnVpZH1gO1xuICAgICAgICBjb25zdCBlbmRUYWcgPSBzdGFydFRhZyArIGA6ZW5kYDtcbiAgICAgICAgcGVyZi5tYXJrKGVuZFRhZyk7XG4gICAgICAgIHBlcmYubWVhc3VyZShgPCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9PiAke3R5cGV9YCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICBkZXZ0b29sc1BlcmZFbmQoaW5zdGFuY2UsIHR5cGUsIGlzU3VwcG9ydGVkKCkgPyBwZXJmLm5vdygpIDogRGF0ZS5ub3coKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgaWYgKHN1cHBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgb25seSBjYWxsZWQgaW4gZXNtLWJ1bmRsZXIgYnVpbGRzLlxuICogSXQgaXMgY2FsbGVkIHdoZW4gYSByZW5kZXJlciBpcyBjcmVhdGVkLCBpbiBgYmFzZUNyZWF0ZVJlbmRlcmVyYCBzbyB0aGF0XG4gKiBpbXBvcnRpbmcgcnVudGltZS1jb3JlIGlzIHNpZGUtZWZmZWN0cyBmcmVlLlxuICpcbiAqIGlzdGFuYnVsLWlnbm9yZS1uZXh0XG4gKi9cbmZ1bmN0aW9uIGluaXRGZWF0dXJlRmxhZ3MoKSB7XG4gICAgY29uc3QgbmVlZFdhcm4gPSBbXTtcbiAgICBpZiAodHlwZW9mIF9fVlVFX09QVElPTlNfQVBJX18gIT09ICdib29sZWFuJykge1xuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ucHVzaChgX19WVUVfT1BUSU9OU19BUElfX2ApO1xuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX19WVUVfUFJPRF9ERVZUT09MU19fICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfUFJPRF9ERVZUT09MU19fID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG11bHRpID0gbmVlZFdhcm4ubGVuZ3RoID4gMTtcbiAgICAgICAgY29uc29sZS53YXJuKGBGZWF0dXJlIGZsYWcke211bHRpID8gYHNgIDogYGB9ICR7bmVlZFdhcm4uam9pbignLCAnKX0gJHttdWx0aSA/IGBhcmVgIDogYGlzYH0gbm90IGV4cGxpY2l0bHkgZGVmaW5lZC4gWW91IGFyZSBydW5uaW5nIHRoZSBlc20tYnVuZGxlciBidWlsZCBvZiBWdWUsIGAgK1xuICAgICAgICAgICAgYHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgYCArXG4gICAgICAgICAgICBgdmlhIHRoZSBidW5kbGVyIGNvbmZpZyBpbiBvcmRlciB0byBnZXQgYmV0dGVyIHRyZWUtc2hha2luZyBpbiB0aGUgYCArXG4gICAgICAgICAgICBgcHJvZHVjdGlvbiBidW5kbGUuXFxuXFxuYCArXG4gICAgICAgICAgICBgRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncy5gKTtcbiAgICB9XG59XG5cbmNvbnN0IHF1ZXVlUG9zdFJlbmRlckVmZmVjdCA9IHF1ZXVlRWZmZWN0V2l0aFN1c3BlbnNlXG4gICAgO1xuLyoqXG4gKiBUaGUgY3JlYXRlUmVuZGVyZXIgZnVuY3Rpb24gYWNjZXB0cyB0d28gZ2VuZXJpYyBhcmd1bWVudHM6XG4gKiBIb3N0Tm9kZSBhbmQgSG9zdEVsZW1lbnQsIGNvcnJlc3BvbmRpbmcgdG8gTm9kZSBhbmQgRWxlbWVudCB0eXBlcyBpbiB0aGVcbiAqIGhvc3QgZW52aXJvbm1lbnQuIEZvciBleGFtcGxlLCBmb3IgcnVudGltZS1kb20sIEhvc3ROb2RlIHdvdWxkIGJlIHRoZSBET01cbiAqIGBOb2RlYCBpbnRlcmZhY2UgYW5kIEhvc3RFbGVtZW50IHdvdWxkIGJlIHRoZSBET00gYEVsZW1lbnRgIGludGVyZmFjZS5cbiAqXG4gKiBDdXN0b20gcmVuZGVyZXJzIGNhbiBwYXNzIGluIHRoZSBwbGF0Zm9ybSBzcGVjaWZpYyB0eXBlcyBsaWtlIHRoaXM6XG4gKlxuICogYGBgIGpzXG4gKiBjb25zdCB7IHJlbmRlciwgY3JlYXRlQXBwIH0gPSBjcmVhdGVSZW5kZXJlcjxOb2RlLCBFbGVtZW50Pih7XG4gKiAgIHBhdGNoUHJvcCxcbiAqICAgLi4ubm9kZU9wc1xuICogfSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zKTtcbn1cbi8vIFNlcGFyYXRlIEFQSSBmb3IgY3JlYXRpbmcgaHlkcmF0aW9uLWVuYWJsZWQgcmVuZGVyZXIuXG4vLyBIeWRyYXRpb24gbG9naWMgaXMgb25seSB1c2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCBtYWtpbmcgaXRcbi8vIHRyZWUtc2hha2FibGUuXG5mdW5jdGlvbiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GdW5jdGlvbnMpO1xufVxuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGJhc2VDcmVhdGVSZW5kZXJlcihvcHRpb25zLCBjcmVhdGVIeWRyYXRpb25GbnMpIHtcbiAgICAvLyBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyBjaGVja1xuICAgIHtcbiAgICAgICAgaW5pdEZlYXR1cmVGbGFncygpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRHbG9iYWxUaGlzKCk7XG4gICAgdGFyZ2V0Ll9fVlVFX18gPSB0cnVlO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgIHNldERldnRvb2xzSG9vayh0YXJnZXQuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgdGFyZ2V0KTtcbiAgICB9XG4gICAgY29uc3QgeyBpbnNlcnQ6IGhvc3RJbnNlcnQsIHJlbW92ZTogaG9zdFJlbW92ZSwgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLCBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCwgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LCBzZXRUZXh0OiBob3N0U2V0VGV4dCwgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCwgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCwgaW5zZXJ0U3RhdGljQ29udGVudDogaG9zdEluc2VydFN0YXRpY0NvbnRlbnQgfSA9IG9wdGlvbnM7XG4gICAgLy8gTm90ZTogZnVuY3Rpb25zIGluc2lkZSB0aGlzIGNsb3N1cmUgc2hvdWxkIHVzZSBgY29uc3QgeHh4ID0gKCkgPT4ge31gXG4gICAgLy8gc3R5bGUgaW4gb3JkZXIgdG8gcHJldmVudCBiZWluZyBpbmxpbmVkIGJ5IG1pbmlmaWVycy5cbiAgICBjb25zdCBwYXRjaCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yID0gbnVsbCwgcGFyZW50Q29tcG9uZW50ID0gbnVsbCwgcGFyZW50U3VzcGVuc2UgPSBudWxsLCBpc1NWRyA9IGZhbHNlLCBzbG90U2NvcGVJZHMgPSBudWxsLCBvcHRpbWl6ZWQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZyA/IGZhbHNlIDogISFuMi5keW5hbWljQ2hpbGRyZW4pID0+IHtcbiAgICAgICAgaWYgKG4xID09PSBuMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhdGNoaW5nICYgbm90IHNhbWUgdHlwZSwgdW5tb3VudCBvbGQgdHJlZVxuICAgICAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBnZXROZXh0SG9zdE5vZGUobjEpO1xuICAgICAgICAgICAgdW5tb3VudChuMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICBuMSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4yLnBhdGNoRmxhZyA9PT0gLTIgLyogUGF0Y2hGbGFncy5CQUlMICovKSB7XG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZyB9ID0gbjI7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUZXh0OlxuICAgICAgICAgICAgICAgIHByb2Nlc3NUZXh0KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb21tZW50OlxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3RhdGljOlxuICAgICAgICAgICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZyYWdtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLykge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRWxlbWVudChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCByZWZcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgc2V0UmVmKHJlZiwgbjEgJiYgbjEucmVmLCBwYXJlbnRTdXNwZW5zZSwgbjIgfHwgbjEsICFuMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NUZXh0ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pKSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XG4gICAgICAgICAgICBpZiAobjIuY2hpbGRyZW4gIT09IG4xLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaG9zdFNldFRleHQoZWwsIG4yLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZUNvbW1lbnQobjIuY2hpbGRyZW4gfHwgJycpKSwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBzdXBwb3J0IGZvciBkeW5hbWljIGNvbW1lbnRzXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xuICAgICAgICBbbjIuZWwsIG4yLmFuY2hvcl0gPSBob3N0SW5zZXJ0U3RhdGljQ29udGVudChuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBuMi5lbCwgbjIuYW5jaG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERldiAvIEhNUiBvbmx5XG4gICAgICovXG4gICAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xuICAgICAgICAvLyBzdGF0aWMgbm9kZXMgYXJlIG9ubHkgcGF0Y2hlZCBkdXJpbmcgZGV2IGZvciBITVJcbiAgICAgICAgaWYgKG4yLmNoaWxkcmVuICE9PSBuMS5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUobjEpO1xuICAgICAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICAgICAgbjIuYW5jaG9yID0gbjEuYW5jaG9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSwgY29udGFpbmVyLCBuZXh0U2libGluZykgPT4ge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICBlbCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdEluc2VydChhbmNob3IsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlU3RhdGljTm9kZSA9ICh7IGVsLCBhbmNob3IgfSkgPT4ge1xuICAgICAgICBsZXQgbmV4dDtcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcbiAgICAgICAgICAgIG5leHQgPSBob3N0TmV4dFNpYmxpbmcoZWwpO1xuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XG4gICAgICAgICAgICBlbCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgbjIudHlwZSA9PT0gJ3N2Zyc7XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtb3VudEVsZW1lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hFbGVtZW50KG4xLCBuMiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW91bnRFbGVtZW50ID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGxldCBlbDtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgc2hhcGVGbGFnLCB0cmFuc2l0aW9uLCBkaXJzIH0gPSB2bm9kZTtcbiAgICAgICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KHZub2RlLnR5cGUsIGlzU1ZHLCBwcm9wcyAmJiBwcm9wcy5pcywgcHJvcHMpO1xuICAgICAgICAvLyBtb3VudCBjaGlsZHJlbiBmaXJzdCwgc2luY2Ugc29tZSBwcm9wcyBtYXkgcmVseSBvbiBjaGlsZCBjb250ZW50XG4gICAgICAgIC8vIGJlaW5nIGFscmVhZHkgcmVuZGVyZWQsIGUuZy4gYDxzZWxlY3QgdmFsdWU+YFxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgdm5vZGUuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4odm5vZGUuY2hpbGRyZW4sIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyAmJiB0eXBlICE9PSAnZm9yZWlnbk9iamVjdCcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlycykge1xuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNjb3BlSWRcbiAgICAgICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd2YWx1ZScgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UgZm9yIHNldHRpbmcgdmFsdWUgb24gRE9NIGVsZW1lbnRzOlxuICAgICAgICAgICAgICogLSBpdCBjYW4gYmUgb3JkZXItc2Vuc2l0aXZlIChlLmcuIHNob3VsZCBiZSBzZXQgKmFmdGVyKiBtaW4vbWF4LCAjMjMyNSwgIzQwMjQpXG4gICAgICAgICAgICAgKiAtIGl0IG5lZWRzIHRvIGJlIGZvcmNlZCAoIzE0NzEpXG4gICAgICAgICAgICAgKiAjMjM1MyBwcm9wb3NlcyBhZGRpbmcgYW5vdGhlciByZW5kZXJlciBvcHRpb24gdG8gY29uZmlndXJlIHRoaXMsIGJ1dFxuICAgICAgICAgICAgICogdGhlIHByb3BlcnRpZXMgYWZmZWN0cyBhcmUgc28gZmluaXRlIGl0IGlzIHdvcnRoIHNwZWNpYWwgY2FzaW5nIGl0XG4gICAgICAgICAgICAgKiBoZXJlIHRvIHJlZHVjZSB0aGUgY29tcGxleGl0eS4gKFNwZWNpYWwgY2FzaW5nIGl0IGFsc28gc2hvdWxkIG5vdFxuICAgICAgICAgICAgICogYWZmZWN0IG5vbi1ET00gcmVuZGVyZXJzKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICd2YWx1ZScsIG51bGwsIHByb3BzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xuICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Zub2RlJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyZW50Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlycykge1xuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAjMTU4MyBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2Ugbm90IHJlc29sdmVkIGNhc2UsIGVudGVyIGhvb2sgc2hvdWxkIGNhbGwgd2hlbiBzdXNwZW5zZSByZXNvbHZlZFxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XG4gICAgICAgIGNvbnN0IG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzID0gKCFwYXJlbnRTdXNwZW5zZSB8fCAocGFyZW50U3VzcGVuc2UgJiYgIXBhcmVudFN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpKSAmJlxuICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xuICAgICAgICBpZiAobmVlZENhbGxUcmFuc2l0aW9uSG9va3MpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHxcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XG4gICAgICAgICAgICBkaXJzKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICBuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcyAmJiB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ21vdW50ZWQnKTtcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XG4gICAgICAgIGlmIChzY29wZUlkKSB7XG4gICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2NvcGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsb3RTY29wZUlkcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbG90U2NvcGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBsZXQgc3ViVHJlZSA9IHBhcmVudENvbXBvbmVudC5zdWJUcmVlO1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJlxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnICYgMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgc3ViVHJlZSA9XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclNpbmdsZVJvb3Qoc3ViVHJlZS5jaGlsZHJlbikgfHwgc3ViVHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2bm9kZSA9PT0gc3ViVHJlZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFZOb2RlID0gcGFyZW50Q29tcG9uZW50LnZub2RlO1xuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudFZOb2RlLCBwYXJlbnRWTm9kZS5zY29wZUlkLCBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBzdGFydCA9IDApID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gKGNoaWxkcmVuW2ldID0gb3B0aW1pemVkXG4gICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjaGlsZHJlbltpXSlcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICBwYXRjaChudWxsLCBjaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IChuMi5lbCA9IG4xLmVsKTtcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIGRpcnMgfSA9IG4yO1xuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXG4gICAgICAgIC8vIGNvbXBpbGVyLWdlbmVyYXRlZCB2bm9kZSwgd2hpY2ggZGUtb3B0cyB0byBGVUxMX1BST1BTXG4gICAgICAgIHBhdGNoRmxhZyB8PSBuMS5wYXRjaEZsYWcgJiAxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi87XG4gICAgICAgIGNvbnN0IG9sZFByb3BzID0gbjEucHJvcHMgfHwgRU1QVFlfT0JKO1xuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgLy8gZGlzYWJsZSByZWN1cnNlIGluIGJlZm9yZVVwZGF0ZSBob29rc1xuICAgICAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlQmVmb3JlVXBkYXRlKSkge1xuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJzKSB7XG4gICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKG4yLCBuMSwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50Q29tcG9uZW50ICYmIHRvZ2dsZVJlY3Vyc2UocGFyZW50Q29tcG9uZW50LCB0cnVlKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZUNoaWxkcmVuU1ZHID0gaXNTVkcgJiYgbjIudHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGVsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzKTtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xuICAgICAgICAgICAgLy8gZnVsbCBkaWZmXG4gICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2hGbGFnID4gMCkge1xuICAgICAgICAgICAgLy8gdGhlIHByZXNlbmNlIG9mIGEgcGF0Y2hGbGFnIG1lYW5zIHRoaXMgZWxlbWVudCdzIHJlbmRlciBjb2RlIHdhc1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciBhbmQgY2FuIHRha2UgdGhlIGZhc3QgcGF0aC5cbiAgICAgICAgICAgIC8vIGluIHRoaXMgcGF0aCBvbGQgbm9kZSBhbmQgbmV3IG5vZGUgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVxuICAgICAgICAgICAgLy8gKGkuZS4gYXQgdGhlIGV4YWN0IHNhbWUgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSB0ZW1wbGF0ZSlcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHByb3BzIGNvbnRhaW4gZHluYW1pYyBrZXlzLCBmdWxsIGRpZmYgbmVlZGVkXG4gICAgICAgICAgICAgICAgcGF0Y2hQcm9wcyhlbCwgbjIsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2xhc3NcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIGNsYXNzIGJpbmRpbmdzLlxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAyIC8qIFBhdGNoRmxhZ3MuQ0xBU1MgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ2NsYXNzJywgbnVsbCwgbmV3UHJvcHMuY2xhc3MsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzdHlsZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgc3R5bGUgYmluZGluZ3NcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCAvKiBQYXRjaEZsYWdzLlNUWUxFICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICdzdHlsZScsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgaXNTVkcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwcm9wc1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgcHJvcC9hdHRyIGJpbmRpbmdzXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgdGhhbiBjbGFzcyBhbmQgc3R5bGUuIFRoZSBrZXlzIG9mIGR5bmFtaWMgcHJvcC9hdHRycyBhcmUgc2F2ZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gZmFzdGVyIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIGR5bmFtaWMga2V5cyBsaWtlIDpbZm9vXT1cImJhclwiIHdpbGwgY2F1c2UgdGhpcyBvcHRpbWl6YXRpb24gdG9cbiAgICAgICAgICAgICAgICAvLyBiYWlsIG91dCBhbmQgZ28gdGhyb3VnaCBhIGZ1bGwgZGlmZiBiZWNhdXNlIHdlIG5lZWQgdG8gdW5zZXQgdGhlIG9sZCBrZXlcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQYXRjaEZsYWdzLlBST1BTICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmbGFnIGlzIHByZXNlbnQgdGhlbiBkeW5hbWljUHJvcHMgbXVzdCBiZSBub24tbnVsbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BzVG9VcGRhdGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzE0NzEgZm9yY2UgcGF0Y2ggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8IGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIG4xLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGV4dFxuICAgICAgICAgICAgLy8gVGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgb25seSBkeW5hbWljIHRleHQgY2hpbGRyZW4uXG4gICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobjEuY2hpbGRyZW4gIT09IG4yLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3B0aW1pemVkICYmIGR5bmFtaWNDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB1bm9wdGltaXplZCwgZnVsbCBkaWZmXG4gICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXdQcm9wcy5vblZub2RlVXBkYXRlZCkgfHwgZGlycykge1xuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2bm9kZUhvb2sgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCBuMiwgbjEpO1xuICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ3VwZGF0ZWQnKTtcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gVGhlIGZhc3QgcGF0aCBmb3IgYmxvY2tzLlxuICAgIGNvbnN0IHBhdGNoQmxvY2tDaGlsZHJlbiA9IChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4sIGZhbGxiYWNrQ29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG4gICAgICAgICAgICBjb25zdCBuZXdWTm9kZSA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjb250YWluZXIgKHBhcmVudCBlbGVtZW50KSBmb3IgdGhlIHBhdGNoLlxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gXG4gICAgICAgICAgICAvLyBvbGRWTm9kZSBtYXkgYmUgYW4gZXJyb3JlZCBhc3luYyBzZXR1cCgpIGNvbXBvbmVudCBpbnNpZGUgU3VzcGVuc2VcbiAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgbm90IGhhdmUgYSBtb3VudGVkIGVsZW1lbnRcbiAgICAgICAgICAgIG9sZFZOb2RlLmVsICYmXG4gICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcbiAgICAgICAgICAgICAgICAvLyBvZiB0aGUgRnJhZ21lbnQgaXRzZWxmIHNvIGl0IGNhbiBtb3ZlIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBJbiB0aGUgY2FzZSBvZiBkaWZmZXJlbnQgbm9kZXMsIHRoZXJlIGlzIGdvaW5nIHRvIGJlIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggYWxzbyByZXF1aXJlcyB0aGUgY29ycmVjdCBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgY29tcG9uZW50LCBpdCBjb3VsZCBjb250YWluIGFueXRoaW5nLlxuICAgICAgICAgICAgICAgICAgICBvbGRWTm9kZS5zaGFwZUZsYWcgJiAoNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLyB8IDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pKVxuICAgICAgICAgICAgICAgID8gaG9zdFBhcmVudE5vZGUob2xkVk5vZGUuZWwpXG4gICAgICAgICAgICAgICAgOiAvLyBJbiBvdGhlciBjYXNlcywgdGhlIHBhcmVudCBjb250YWluZXIgaXMgbm90IGFjdHVhbGx5IHVzZWQgc28gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0NvbnRhaW5lcjtcbiAgICAgICAgICAgIHBhdGNoKG9sZFZOb2RlLCBuZXdWTm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcGF0Y2hQcm9wcyA9IChlbCwgdm5vZGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpID0+IHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVzZXJ2ZWRQcm9wKGtleSkgJiYgIShrZXkgaW4gbmV3UHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG9sZFByb3BzW2tleV0sIG51bGwsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCB2YWxpZCBwcm9wXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBvbGRQcm9wc1trZXldO1xuICAgICAgICAgICAgICAgIC8vIGRlZmVyIHBhdGNoaW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsIGtleSwgcHJldiwgbmV4dCwgaXNTVkcsIHZub2RlLmNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwgJ3ZhbHVlJywgb2xkUHJvcHMudmFsdWUsIG5ld1Byb3BzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBmcmFnbWVudFN0YXJ0QW5jaG9yID0gKG4yLmVsID0gbjEgPyBuMS5lbCA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50RW5kQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xID8gbjEuYW5jaG9yIDogaG9zdENyZWF0ZVRleHQoJycpKTtcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAvLyAjNTUyMyBkZXYgcm9vdCBmcmFnbWVudCBtYXkgaW5oZXJpdCBkaXJlY3RpdmVzXG4gICAgICAgICAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8pKSB7XG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCAvIERldiByb290IGZyYWdtZW50ICh3LyBjb21tZW50cyksIGZvcmNlIGZ1bGwgZGlmZlxuICAgICAgICAgICAgcGF0Y2hGbGFnID0gMDtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGEgc2xvdCBmcmFnbWVudCB3aXRoIDpzbG90dGVkIHNjb3BlIGlkc1xuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcbiAgICAgICAgICAgIHNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkc1xuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZnJhZ21lbnRFbmRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIC8vIGEgZnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBhcnJheSBjaGlsZHJlblxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgZWl0aGVyIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIsIG9yIGltcGxpY2l0bHkgY3JlYXRlZFxuICAgICAgICAgICAgLy8gZnJvbSBhcnJheXMuXG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDAgJiZcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqLyAmJlxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgICAgICAgICAgICAgIC8vIG9mIHJlbmRlclNsb3QoKSB3aXRoIG5vIHZhbGlkIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBzdGFibGUgZnJhZ21lbnQgKHRlbXBsYXRlIHJvb3Qgb3IgPHRlbXBsYXRlIHYtZm9yPikgZG9lc24ndCBuZWVkIHRvXG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggY2hpbGRyZW4gb3JkZXIsIGJ1dCBpdCBtYXkgY29udGFpbiBkeW5hbWljQ2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcGFyZW50Q29tcG9uZW50ICYmIHBhcmVudENvbXBvbmVudC50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyAjMjA4MCBpZiB0aGUgc3RhYmxlIGZyYWdtZW50IGhhcyBhIGtleSwgaXQncyBhIDx0ZW1wbGF0ZSB2LWZvcj4gdGhhdCBtYXlcbiAgICAgICAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxuICAgICAgICAgICAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaXMgYmVpbmcgbW92ZWQuXG4gICAgICAgICAgICAgICAgbjIua2V5ICE9IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudENvbXBvbmVudCAmJiBuMiA9PT0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlIC8qIHNoYWxsb3cgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGtleWVkIC8gdW5rZXllZCwgb3IgbWFudWFsIGZyYWdtZW50cy5cbiAgICAgICAgICAgICAgICAvLyBmb3Iga2V5ZWQgJiB1bmtleWVkLCBzaW5jZSB0aGV5IGFyZSBjb21waWxlciBnZW5lcmF0ZWQgZnJvbSB2LWZvcixcbiAgICAgICAgICAgICAgICAvLyBlYWNoIGNoaWxkIGlzIGd1YXJhbnRlZWQgdG8gYmUgYSBibG9jayBzbyB0aGUgZnJhZ21lbnQgd2lsbCBuZXZlclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgZHluYW1pY0NoaWxkcmVuLlxuICAgICAgICAgICAgICAgIHBhdGNoQ2hpbGRyZW4objEsIG4yLCBjb250YWluZXIsIGZyYWdtZW50RW5kQW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwcm9jZXNzQ29tcG9uZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobjIuc2hhcGVGbGFnICYgNTEyIC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi8pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb21wb25lbnQuY3R4LmFjdGl2YXRlKG4yLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb3VudENvbXBvbmVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoaW5pdGlhbFZOb2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKSk7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UudHlwZS5fX2htcklkKSB7XG4gICAgICAgICAgICByZWdpc3RlckhNUihpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGluaXRpYWxWTm9kZSk7XG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluamVjdCByZW5kZXJlciBpbnRlcm5hbHMgZm9yIGtlZXBBbGl2ZVxuICAgICAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY3R4LnJlbmRlcmVyID0gaW50ZXJuYWxzO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc29sdmUgcHJvcHMgYW5kIHNsb3RzIGZvciBzZXR1cCBjb250ZXh0XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBpbml0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCgpIGlzIGFzeW5jLiBUaGlzIGNvbXBvbmVudCByZWxpZXMgb24gYXN5bmMgbG9naWMgdG8gYmUgcmVzb2x2ZWRcbiAgICAgICAgLy8gYmVmb3JlIHByb2NlZWRpbmdcbiAgICAgICAgaWYgKGluc3RhbmNlLmFzeW5jRGVwKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIHBsYWNlaG9sZGVyIGlmIHRoaXMgaXMgbm90IGh5ZHJhdGlvblxuICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgc2VsZi1kZWZpbmVkIGZhbGxiYWNrXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKGluc3RhbmNlLnN1YlRyZWUgPSBjcmVhdGVWTm9kZShDb21tZW50KSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbW1lbnROb2RlKG51bGwsIHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSAobjIuY29tcG9uZW50ID0gbjEuY29tcG9uZW50KTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUNvbXBvbmVudChuMSwgbjIsIG9wdGltaXplZCkpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJlxuICAgICAgICAgICAgICAgICFpbnN0YW5jZS5hc3luY1Jlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gYXN5bmMgJiBzdGlsbCBwZW5kaW5nIC0ganVzdCB1cGRhdGUgcHJvcHMgYW5kIHNsb3RzXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNvbXBvbmVudCdzIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyIGlzbid0IHNldC11cCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudFByZVJlbmRlcihpbnN0YW5jZSwgbjIsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWwgdXBkYXRlXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBhbHNvIHF1ZXVlZCwgcmVtb3ZlIGl0IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlIHVwZGF0aW5nIHRoZSBzYW1lIGNoaWxkIGNvbXBvbmVudCBpbiB0aGUgc2FtZSBmbHVzaC5cbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UudXBkYXRlIGlzIHRoZSByZWFjdGl2ZSBlZmZlY3QuXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBubyB1cGRhdGUgbmVlZGVkLiBqdXN0IGNvcHkgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xuICAgICAgICAgICAgaW5zdGFuY2Uudm5vZGUgPSBuMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2V0dXBSZW5kZXJFZmZlY3QgPSAoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnN0YW5jZS5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBibSwgbSwgcGFyZW50IH0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0FzeW5jV3JhcHBlclZOb2RlID0gaXNBc3luY1dyYXBwZXIoaW5pdGlhbFZOb2RlKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlTW91bnQgaG9va1xuICAgICAgICAgICAgICAgIGlmIChibSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9uVm5vZGVCZWZvcmVNb3VudFxuICAgICAgICAgICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIGluaXRpYWxWTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiBoeWRyYXRlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBoYXMgYWRvcHRlZCBob3N0IG5vZGUgLSBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0ZU5vZGUoZWwsIGluc3RhbmNlLnN1YlRyZWUsIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGh5ZHJhdGVgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyVk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZS50eXBlLl9fYXN5bmNMb2FkZXIoKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIG1vdmluZyB0aGUgcmVuZGVyIGNhbGwgaW50byBhbiBhc3luYyBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IHdvbid0IHRyYWNrIGRlcGVuZGVuY2llcyAtIGJ1dCBpdCdzIG9rIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgc2VydmVyLXJlbmRlcmVkIGFzeW5jIHdyYXBwZXIgaXMgYWxyZWFkeSBpbiByZXNvbHZlZCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGl0IHdpbGwgbmV2ZXIgbmVlZCB0byBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiAhaW5zdGFuY2UuaXNVbm1vdW50ZWQgJiYgaHlkcmF0ZVN1YlRyZWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlU3ViVHJlZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gKGluc3RhbmNlLnN1YlRyZWUgPSByZW5kZXJDb21wb25lbnRSb290KGluc3RhbmNlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZOb2RlLmVsID0gc3ViVHJlZS5lbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KG0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZU1vdW50ZWRcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXN5bmNXcmFwcGVyVk5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY29wZWRJbml0aWFsVk5vZGUgPSBpbml0aWFsVk5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIHNjb3BlZEluaXRpYWxWTm9kZSksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYWN0aXZhdGVkIGhvb2sgZm9yIGtlZXAtYWxpdmUgcm9vdHMuXG4gICAgICAgICAgICAgICAgLy8gIzE3NDIgYWN0aXZhdGVkIGhvb2sgbXVzdCBiZSBhY2Nlc3NlZCBhZnRlciBmaXJzdCByZW5kZXJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWTm9kZS5zaGFwZUZsYWcgJiAyNTYgLyogU2hhcGVGbGFncy5DT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luY1dyYXBwZXIocGFyZW50LnZub2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAjMjQ1ODogZGVmZXJlbmNlIG1vdW50LW9ubHkgb2JqZWN0IHBhcmFtZXRlcnMgdG8gcHJldmVudCBtZW1sZWFrc1xuICAgICAgICAgICAgICAgIGluaXRpYWxWTm9kZSA9IGNvbnRhaW5lciA9IGFuY2hvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVDb21wb25lbnRcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXG4gICAgICAgICAgICAgICAgLy8gT1IgcGFyZW50IGNhbGxpbmcgcHJvY2Vzc0NvbXBvbmVudCAobmV4dDogVk5vZGUpXG4gICAgICAgICAgICAgICAgbGV0IHsgbmV4dCwgYnUsIHUsIHBhcmVudCwgdm5vZGUgfSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICBsZXQgdm5vZGVIb29rO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEaXNhbGxvdyBjb21wb25lbnQgZWZmZWN0IHJlY3Vyc2lvbiBkdXJpbmcgcHJlLWxpZmVjeWNsZSBob29rcy5cbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5lbCA9IHZub2RlLmVsO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZVVwZGF0ZSBob29rXG4gICAgICAgICAgICAgICAgaWYgKGJ1KSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudCwgbmV4dCwgdm5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2VHJlZSA9IGluc3RhbmNlLnN1YlRyZWU7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0Y2gocHJldlRyZWUsIG5leHRUcmVlLCBcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciBtYXkgaGF2ZSBjaGFuZ2VkIGlmIGl0J3MgaW4gYSBmcmFnbWVudFxuICAgICAgICAgICAgICAgIGdldE5leHRIb3N0Tm9kZShwcmV2VHJlZSksIGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luTmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWxmLXRyaWdnZXJlZCB1cGRhdGUuIEluIGNhc2Ugb2YgSE9DLCB1cGRhdGUgcGFyZW50IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGNoaWxkIGNvbXBvbmVudCdzIHZub2RlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUhPQ0hvc3RFbChpbnN0YW5jZSwgbmV4dFRyZWUuZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVkIGhvb2tcbiAgICAgICAgICAgICAgICBpZiAodSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvblZub2RlVXBkYXRlZFxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBuZXh0LCB2bm9kZSksIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRVcGRhdGVkKGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3JlYXRlIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyaW5nXG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IChpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoY29tcG9uZW50VXBkYXRlRm4sICgpID0+IHF1ZXVlSm9iKHVwZGF0ZSksIGluc3RhbmNlLnNjb3BlIC8vIHRyYWNrIGl0IGluIGNvbXBvbmVudCdzIGVmZmVjdCBzY29wZVxuICAgICAgICApKTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gKGluc3RhbmNlLnVwZGF0ZSA9ICgpID0+IGVmZmVjdC5ydW4oKSk7XG4gICAgICAgIHVwZGF0ZS5pZCA9IGluc3RhbmNlLnVpZDtcbiAgICAgICAgLy8gYWxsb3dSZWN1cnNlXG4gICAgICAgIC8vICMxODAxLCAjMjA0MyBjb21wb25lbnQgcmVuZGVyIGVmZmVjdHMgc2hvdWxkIGFsbG93IHJlY3Vyc2l2ZSB1cGRhdGVzXG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICBlZmZlY3Qub25UcmFjayA9IGluc3RhbmNlLnJ0Y1xuICAgICAgICAgICAgICAgID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyID0gaW5zdGFuY2UucnRnXG4gICAgICAgICAgICAgICAgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSlcbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgICAgIHVwZGF0ZS5vd25lckluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKCk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XG4gICAgICAgIG5leHRWTm9kZS5jb21wb25lbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHM7XG4gICAgICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xuICAgICAgICBpbnN0YW5jZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgdXBkYXRlUHJvcHMoaW5zdGFuY2UsIG5leHRWTm9kZS5wcm9wcywgcHJldlByb3BzLCBvcHRpbWl6ZWQpO1xuICAgICAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XG4gICAgICAgIC8vIHByb3BzIHVwZGF0ZSBtYXkgaGF2ZSB0cmlnZ2VyZWQgcHJlLWZsdXNoIHdhdGNoZXJzLlxuICAgICAgICAvLyBmbHVzaCB0aGVtIGJlZm9yZSB0aGUgcmVuZGVyIHVwZGF0ZS5cbiAgICAgICAgZmx1c2hQcmVGbHVzaENicygpO1xuICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgfTtcbiAgICBjb25zdCBwYXRjaENoaWxkcmVuID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHByZXZTaGFwZUZsYWcgPSBuMSA/IG4xLnNoYXBlRmxhZyA6IDA7XG4gICAgICAgIGNvbnN0IGMyID0gbjIuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xuICAgICAgICAvLyBmYXN0IHBhdGhcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA+IDApIHtcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjggLyogUGF0Y2hGbGFncy5LRVlFRF9GUkFHTUVOVCAqLykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgZWl0aGVyIGZ1bGx5LWtleWVkIG9yIG1peGVkIChzb21lIGtleWVkIHNvbWUgbm90KVxuICAgICAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHBhdGNoRmxhZyBtZWFucyBjaGlsZHJlbiBhcmUgZ3VhcmFudGVlZCB0byBiZSBhcnJheXNcbiAgICAgICAgICAgICAgICBwYXRjaEtleWVkQ2hpbGRyZW4oYzEsIGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXRjaEZsYWcgJiAyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5rZXllZFxuICAgICAgICAgICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoaWxkcmVuIGhhcyAzIHBvc3NpYmlsaXRpZXM6IHRleHQsIGFycmF5IG9yIG5vIGNoaWxkcmVuLlxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIC8vIHRleHQgY2hpbGRyZW4gZmFzdCBwYXRoXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMyICE9PSBjMSkge1xuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGFycmF5cywgY2Fubm90IGFzc3VtZSBhbnl0aGluZywgZG8gZnVsbCBkaWZmXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkcmVuLCBqdXN0IHVubW91bnQgb2xkXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjMSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgdGV4dCBPUiBudWxsXG4gICAgICAgICAgICAgICAgLy8gbmV3IGNoaWxkcmVuIGlzIGFycmF5IE9SIG51bGxcbiAgICAgICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDggLyogU2hhcGVGbGFncy5URVhUX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3IGlmIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbihjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcbiAgICAgICAgYzEgPSBjMSB8fCBFTVBUWV9BUlI7XG4gICAgICAgIGMyID0gYzIgfHwgRU1QVFlfQVJSO1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGMyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY29tbW9uTGVuZ3RoID0gTWF0aC5taW4ob2xkTGVuZ3RoLCBuZXdMZW5ndGgpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbW1vbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcbiAgICAgICAgICAgIHBhdGNoKGMxW2ldLCBuZXh0Q2hpbGQsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkTGVuZ3RoID4gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsIGZhbHNlLCBjb21tb25MZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbW91bnQgbmV3XG4gICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBjb21tb25MZW5ndGgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBjYW4gYmUgYWxsLWtleWVkIG9yIG1peGVkXG4gICAgY29uc3QgcGF0Y2hLZXllZENoaWxkcmVuID0gKGMxLCBjMiwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGNvbnN0IGwyID0gYzIubGVuZ3RoO1xuICAgICAgICBsZXQgZTEgPSBjMS5sZW5ndGggLSAxOyAvLyBwcmV2IGVuZGluZyBpbmRleFxuICAgICAgICBsZXQgZTIgPSBsMiAtIDE7IC8vIG5leHQgZW5kaW5nIGluZGV4XG4gICAgICAgIC8vIDEuIHN5bmMgZnJvbSBzdGFydFxuICAgICAgICAvLyAoYSBiKSBjXG4gICAgICAgIC8vIChhIGIpIGQgZVxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2ldO1xuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbaV0pKTtcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xuICAgICAgICAgICAgICAgIHBhdGNoKG4xLCBuMiwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMi4gc3luYyBmcm9tIGVuZFxuICAgICAgICAvLyBhIChiIGMpXG4gICAgICAgIC8vIGQgZSAoYiBjKVxuICAgICAgICB3aGlsZSAoaSA8PSBlMSAmJiBpIDw9IGUyKSB7XG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2UxXTtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gKGMyW2UyXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbZTJdKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKSk7XG4gICAgICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikpIHtcbiAgICAgICAgICAgICAgICBwYXRjaChuMSwgbjIsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZTEtLTtcbiAgICAgICAgICAgIGUyLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gY29tbW9uIHNlcXVlbmNlICsgbW91bnRcbiAgICAgICAgLy8gKGEgYilcbiAgICAgICAgLy8gKGEgYikgY1xuICAgICAgICAvLyBpID0gMiwgZTEgPSAxLCBlMiA9IDJcbiAgICAgICAgLy8gKGEgYilcbiAgICAgICAgLy8gYyAoYSBiKVxuICAgICAgICAvLyBpID0gMCwgZTEgPSAtMSwgZTIgPSAwXG4gICAgICAgIGlmIChpID4gZTEpIHtcbiAgICAgICAgICAgIGlmIChpIDw9IGUyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvcyA9IGUyICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0UG9zIDwgbDIgPyBjMltuZXh0UG9zXS5lbCA6IHBhcmVudEFuY2hvcjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaChudWxsLCAoYzJbaV0gPSBvcHRpbWl6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSksIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDQuIGNvbW1vbiBzZXF1ZW5jZSArIHVubW91bnRcbiAgICAgICAgLy8gKGEgYikgY1xuICAgICAgICAvLyAoYSBiKVxuICAgICAgICAvLyBpID0gMiwgZTEgPSAyLCBlMiA9IDFcbiAgICAgICAgLy8gYSAoYiBjKVxuICAgICAgICAvLyAoYiBjKVxuICAgICAgICAvLyBpID0gMCwgZTEgPSAwLCBlMiA9IC0xXG4gICAgICAgIGVsc2UgaWYgKGkgPiBlMikge1xuICAgICAgICAgICAgd2hpbGUgKGkgPD0gZTEpIHtcbiAgICAgICAgICAgICAgICB1bm1vdW50KGMxW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gNS4gdW5rbm93biBzZXF1ZW5jZVxuICAgICAgICAvLyBbaSAuLi4gZTEgKyAxXTogYSBiIFtjIGQgZV0gZiBnXG4gICAgICAgIC8vIFtpIC4uLiBlMiArIDFdOiBhIGIgW2UgZCBjIGhdIGYgZ1xuICAgICAgICAvLyBpID0gMiwgZTEgPSA0LCBlMiA9IDVcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzMSA9IGk7IC8vIHByZXYgc3RhcnRpbmcgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IHMyID0gaTsgLy8gbmV4dCBzdGFydGluZyBpbmRleFxuICAgICAgICAgICAgLy8gNS4xIGJ1aWxkIGtleTppbmRleCBtYXAgZm9yIG5ld0NoaWxkcmVuXG4gICAgICAgICAgICBjb25zdCBrZXlUb05ld0luZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IChjMltpXSA9IG9wdGltaXplZFxuICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleVRvTmV3SW5kZXhNYXAuaGFzKG5leHRDaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOmAsIEpTT04uc3RyaW5naWZ5KG5leHRDaGlsZC5rZXkpLCBgTWFrZSBzdXJlIGtleXMgYXJlIHVuaXF1ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA1LjIgbG9vcCB0aHJvdWdoIG9sZCBjaGlsZHJlbiBsZWZ0IHRvIGJlIHBhdGNoZWQgYW5kIHRyeSB0byBwYXRjaFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgbm9kZXMgJiByZW1vdmUgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnRcbiAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgbGV0IHBhdGNoZWQgPSAwO1xuICAgICAgICAgICAgY29uc3QgdG9CZVBhdGNoZWQgPSBlMiAtIHMyICsgMTtcbiAgICAgICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBub2RlIGhhcyBtb3ZlZFxuICAgICAgICAgICAgbGV0IG1heE5ld0luZGV4U29GYXIgPSAwO1xuICAgICAgICAgICAgLy8gd29ya3MgYXMgTWFwPG5ld0luZGV4LCBvbGRJbmRleD5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbGRJbmRleCBpcyBvZmZzZXQgYnkgKzFcbiAgICAgICAgICAgIC8vIGFuZCBvbGRJbmRleCA9IDAgaXMgYSBzcGVjaWFsIHZhbHVlIGluZGljYXRpbmcgdGhlIG5ldyBub2RlIGhhc1xuICAgICAgICAgICAgLy8gbm8gY29ycmVzcG9uZGluZyBvbGQgbm9kZS5cbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIGRldGVybWluaW5nIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleFRvT2xkSW5kZXhNYXAgPSBuZXcgQXJyYXkodG9CZVBhdGNoZWQpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvQmVQYXRjaGVkOyBpKyspXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IHMxOyBpIDw9IGUxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBjMVtpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbmV3IGNoaWxkcmVuIGhhdmUgYmVlbiBwYXRjaGVkIHNvIHRoaXMgY2FuIG9ubHkgYmUgYSByZW1vdmFsXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQocHJldkNoaWxkLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXdJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0ga2V5VG9OZXdJbmRleE1hcC5nZXQocHJldkNoaWxkLmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZXktbGVzcyBub2RlLCB0cnkgdG8gbG9jYXRlIGEga2V5LWxlc3Mgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IHMyOyBqIDw9IGUyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2FtZVZOb2RlVHlwZShwcmV2Q2hpbGQsIGMyW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleFRvT2xkSW5kZXhNYXBbbmV3SW5kZXggLSBzMl0gPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heE5ld0luZGV4U29GYXIgPSBuZXdJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXRjaChwcmV2Q2hpbGQsIGMyW25ld0luZGV4XSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgICAgICBwYXRjaGVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNS4zIG1vdmUgYW5kIG1vdW50XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBsb25nZXN0IHN0YWJsZSBzdWJzZXF1ZW5jZSBvbmx5IHdoZW4gbm9kZXMgaGF2ZSBtb3ZlZFxuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZFxuICAgICAgICAgICAgICAgID8gZ2V0U2VxdWVuY2UobmV3SW5kZXhUb09sZEluZGV4TWFwKVxuICAgICAgICAgICAgICAgIDogRU1QVFlfQVJSO1xuICAgICAgICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAvLyBsb29waW5nIGJhY2t3YXJkcyBzbyB0aGF0IHdlIGNhbiB1c2UgbGFzdCBwYXRjaGVkIG5vZGUgYXMgYW5jaG9yXG4gICAgICAgICAgICBmb3IgKGkgPSB0b0JlUGF0Y2hlZCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGMyW25leHRJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dEluZGV4ICsgMSA8IGwyID8gYzJbbmV4dEluZGV4ICsgMV0uZWwgOiBwYXJlbnRBbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3VudCBuZXdcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2gobnVsbCwgbmV4dENoaWxkLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpZjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc3RhYmxlIHN1YnNlcXVlbmNlIChlLmcuIGEgcmV2ZXJzZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gT1IgY3VycmVudCBub2RlIGlzIG5vdCBhbW9uZyB0aGUgc3RhYmxlIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBpICE9PSBpbmNyZWFzaW5nTmV3SW5kZXhTZXF1ZW5jZVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyIC8qIE1vdmVUeXBlLlJFT1JERVIgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xuICAgICAgICBjb25zdCB7IGVsLCB0eXBlLCB0cmFuc2l0aW9uLCBjaGlsZHJlbiwgc2hhcGVGbGFnIH0gPSB2bm9kZTtcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgIG1vdmUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICB2bm9kZS5zdXNwZW5zZS5tb3ZlKGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pIHtcbiAgICAgICAgICAgIHR5cGUubW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIGludGVybmFscyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbW92ZShjaGlsZHJlbltpXSwgY29udGFpbmVyLCBhbmNob3IsIG1vdmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvc3RJbnNlcnQodm5vZGUuYW5jaG9yLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFN0YXRpYykge1xuICAgICAgICAgICAgbW92ZVN0YXRpY05vZGUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaW5nbGUgbm9kZXNcbiAgICAgICAgY29uc3QgbmVlZFRyYW5zaXRpb24gPSBtb3ZlVHlwZSAhPT0gMiAvKiBNb3ZlVHlwZS5SRU9SREVSICovICYmXG4gICAgICAgICAgICBzaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyAmJlxuICAgICAgICAgICAgdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKG5lZWRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogTW92ZVR5cGUuRU5URVIgKi8pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9ICgpID0+IGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5tb3VudCA9ICh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBzaGFwZUZsYWcsIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XG4gICAgICAgIC8vIHVuc2V0IHJlZlxuICAgICAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDI1NiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xuICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5kZWFjdGl2YXRlKHZub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRJbnZva2VEaXJzID0gc2hhcGVGbGFnICYgMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8gJiYgZGlycztcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52b2tlVm5vZGVIb29rID0gIWlzQXN5bmNXcmFwcGVyKHZub2RlKTtcbiAgICAgICAgbGV0IHZub2RlSG9vaztcbiAgICAgICAgaWYgKHNob3VsZEludm9rZVZub2RlSG9vayAmJlxuICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVVbm1vdW50KSkge1xuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgIHVubW91bnRDb21wb25lbnQodm5vZGUuY29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UudW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVW5tb3VudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pIHtcbiAgICAgICAgICAgICAgICB2bm9kZS50eXBlLnJlbW92ZSh2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgb3B0aW1pemVkLCBpbnRlcm5hbHMsIGRvUmVtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIC8vICMxMTUzOiBmYXN0IHBhdGggc2hvdWxkIG5vdCBiZSB0YWtlbiBmb3Igbm9uLXN0YWJsZSAodi1mb3IpIGZyYWdtZW50c1xuICAgICAgICAgICAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fFxuICAgICAgICAgICAgICAgICAgICAocGF0Y2hGbGFnID4gMCAmJiBwYXRjaEZsYWcgJiA2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqLykpKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIGZvciBibG9jayBub2Rlczogb25seSBuZWVkIHRvIHVubW91bnQgZHluYW1pYyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oZHluYW1pY0NoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9PT0gRnJhZ21lbnQgJiZcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJlxuICAgICAgICAgICAgICAgICAgICAoMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi8gfCAyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovKSkgfHxcbiAgICAgICAgICAgICAgICAoIW9wdGltaXplZCAmJiBzaGFwZUZsYWcgJiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovKSkge1xuICAgICAgICAgICAgICAgIHVubW91bnRDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUodm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmXG4gICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkpIHx8XG4gICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcbiAgICAgICAgICAgICAgICBzaG91bGRJbnZva2VEaXJzICYmXG4gICAgICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ3VubW91bnRlZCcpO1xuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZWwsIGFuY2hvciwgdHJhbnNpdGlvbiB9ID0gdm5vZGU7XG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyA+IDAgJiZcbiAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi8gJiZcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZUZyYWdtZW50KGVsLCBhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcbiAgICAgICAgICAgIHJlbW92ZVN0YXRpY05vZGUodm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBlcmZvcm1SZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBob3N0UmVtb3ZlKGVsKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmFmdGVyTGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovICYmXG4gICAgICAgICAgICB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAhdHJhbnNpdGlvbi5wZXJzaXN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiBsZWF2ZShlbCwgcGVyZm9ybVJlbW92ZSk7XG4gICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1SZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlRnJhZ21lbnQgPSAoY3VyLCBlbmQpID0+IHtcbiAgICAgICAgLy8gRm9yIGZyYWdtZW50cywgZGlyZWN0bHkgcmVtb3ZlIGFsbCBjb250YWluZWQgRE9NIG5vZGVzLlxuICAgICAgICAvLyAoZnJhZ21lbnQgY2hpbGQgbm9kZXMgY2Fubm90IGhhdmUgdHJhbnNpdGlvbilcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIHdoaWxlIChjdXIgIT09IGVuZCkge1xuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xuICAgICAgICAgICAgaG9zdFJlbW92ZShjdXIpO1xuICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBob3N0UmVtb3ZlKGVuZCk7XG4gICAgfTtcbiAgICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYnVtLCBzY29wZSwgdXBkYXRlLCBzdWJUcmVlLCB1bSB9ID0gaW5zdGFuY2U7XG4gICAgICAgIC8vIGJlZm9yZVVubW91bnQgaG9va1xuICAgICAgICBpZiAoYnVtKSB7XG4gICAgICAgICAgICBpbnZva2VBcnJheUZucyhidW0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3AgZWZmZWN0cyBpbiBjb21wb25lbnQgc2NvcGVcbiAgICAgICAgc2NvcGUuc3RvcCgpO1xuICAgICAgICAvLyB1cGRhdGUgbWF5IGJlIG51bGwgaWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBpdHMgYXN5bmNcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBzbyB0aGF0IHNjaGVkdWxlciB3aWxsIG5vIGxvbmdlciBpbnZva2UgaXRcbiAgICAgICAgICAgIHVwZGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHVubW91bnQoc3ViVHJlZSwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdW5tb3VudGVkIGhvb2tcbiAgICAgICAgaWYgKHVtKSB7XG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodW0sIHBhcmVudFN1c3BlbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIC8vIEEgY29tcG9uZW50IHdpdGggYXN5bmMgZGVwIGluc2lkZSBhIHBlbmRpbmcgc3VzcGVuc2UgaXMgdW5tb3VudGVkIGJlZm9yZVxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXG4gICAgICAgIC8vIGNhdXNlIHRoZSBzdXNwZW5zZSB0byByZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoYXQgd2FzIHRoZSBsYXN0IGRlcC5cbiAgICAgICAgaWYgKHBhcmVudFN1c3BlbnNlICYmXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXG4gICAgICAgICAgICAhcGFyZW50U3VzcGVuc2UuaXNVbm1vdW50ZWQgJiZcbiAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwICYmXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxuICAgICAgICAgICAgaW5zdGFuY2Uuc3VzcGVuc2VJZCA9PT0gcGFyZW50U3VzcGVuc2UucGVuZGluZ0lkKSB7XG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5kZXBzLS07XG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBhcmVudFN1c3BlbnNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xuICAgICAgICAgICAgZGV2dG9vbHNDb21wb25lbnRSZW1vdmVkKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5tb3VudENoaWxkcmVuID0gKGNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSA9IGZhbHNlLCBvcHRpbWl6ZWQgPSBmYWxzZSwgc3RhcnQgPSAwKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB1bm1vdW50KGNoaWxkcmVuW2ldLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBkb1JlbW92ZSwgb3B0aW1pemVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0TmV4dEhvc3ROb2RlID0gdm5vZGUgPT4ge1xuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGdldE5leHRIb3N0Tm9kZSh2bm9kZS5jb21wb25lbnQuc3ViVHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTaGFwZUZsYWdzLlNVU1BFTlNFICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdm5vZGUuc3VzcGVuc2UubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xuICAgIH07XG4gICAgY29uc3QgcmVuZGVyID0gKHZub2RlLCBjb250YWluZXIsIGlzU1ZHKSA9PiB7XG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLl92bm9kZSkge1xuICAgICAgICAgICAgICAgIHVubW91bnQoY29udGFpbmVyLl92bm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKCk7XG4gICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XG4gICAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFscyA9IHtcbiAgICAgICAgcDogcGF0Y2gsXG4gICAgICAgIHVtOiB1bm1vdW50LFxuICAgICAgICBtOiBtb3ZlLFxuICAgICAgICByOiByZW1vdmUsXG4gICAgICAgIG10OiBtb3VudENvbXBvbmVudCxcbiAgICAgICAgbWM6IG1vdW50Q2hpbGRyZW4sXG4gICAgICAgIHBjOiBwYXRjaENoaWxkcmVuLFxuICAgICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcbiAgICAgICAgbjogZ2V0TmV4dEhvc3ROb2RlLFxuICAgICAgICBvOiBvcHRpb25zXG4gICAgfTtcbiAgICBsZXQgaHlkcmF0ZTtcbiAgICBsZXQgaHlkcmF0ZU5vZGU7XG4gICAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xuICAgICAgICBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdID0gY3JlYXRlSHlkcmF0aW9uRm5zKGludGVybmFscyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcixcbiAgICAgICAgaHlkcmF0ZSxcbiAgICAgICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCB1cGRhdGUgfSwgYWxsb3dlZCkge1xuICAgIGVmZmVjdC5hbGxvd1JlY3Vyc2UgPSB1cGRhdGUuYWxsb3dSZWN1cnNlID0gYWxsb3dlZDtcbn1cbi8qKlxuICogIzExNTZcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgSE1SLWVuYWJsZWQsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHN0YXRpYyBub2Rlc1xuICogaW5zaWRlIGEgYmxvY2sgYWxzbyBpbmhlcml0IHRoZSBET00gZWxlbWVudCBmcm9tIHRoZSBwcmV2aW91cyB0cmVlIHNvIHRoYXRcbiAqIEhNUiB1cGRhdGVzICh3aGljaCBhcmUgZnVsbCB1cGRhdGVzKSBjYW4gcmV0cmlldmUgdGhlIGVsZW1lbnQgZm9yIHBhdGNoaW5nLlxuICpcbiAqICMyMDgwXG4gKiBJbnNpZGUga2V5ZWQgYHRlbXBsYXRlYCBmcmFnbWVudCBzdGF0aWMgY2hpbGRyZW4sIGlmIGEgZnJhZ21lbnQgaXMgbW92ZWQsXG4gKiB0aGUgY2hpbGRyZW4gd2lsbCBhbHdheXMgYmUgbW92ZWQuIFRoZXJlZm9yZSwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvcnJlY3QgbW92ZVxuICogcG9zaXRpb24sIGVsIHNob3VsZCBiZSBpbmhlcml0ZWQgZnJvbSBwcmV2aW91cyBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihuMSwgbjIsIHNoYWxsb3cgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xuICAgIGNvbnN0IGNoMiA9IG4yLmNoaWxkcmVuO1xuICAgIGlmIChpc0FycmF5KGNoMSkgJiYgaXNBcnJheShjaDIpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9ubHkgY2FsbGVkIGluIHRoZSBvcHRpbWl6ZWQgcGF0aCBzbyBhcnJheSBjaGlsZHJlbiBhcmVcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZWQgdG8gYmUgdm5vZGVzXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNoMVtpXTtcbiAgICAgICAgICAgIGxldCBjMiA9IGNoMltpXTtcbiAgICAgICAgICAgIGlmIChjMi5zaGFwZUZsYWcgJiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLyAmJiAhYzIuZHluYW1pY0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMyLnBhdGNoRmxhZyA8PSAwIHx8IGMyLnBhdGNoRmxhZyA9PT0gMzIgLyogUGF0Y2hGbGFncy5IWURSQVRFX0VWRU5UUyAqLykge1xuICAgICAgICAgICAgICAgICAgICBjMiA9IGNoMltpXSA9IGNsb25lSWZNb3VudGVkKGNoMltpXSk7XG4gICAgICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2hhbGxvdylcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gIzY4NTIgYWxzbyBpbmhlcml0IGZvciB0ZXh0IG5vZGVzXG4gICAgICAgICAgICBpZiAoYzIudHlwZSA9PT0gVGV4dCkge1xuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbHNvIGluaGVyaXQgZm9yIGNvbW1lbnQgbm9kZXMsIGJ1dCBub3QgcGxhY2Vob2xkZXJzIChlLmcuIHYtaWYgd2hpY2hcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUgcmVjZWl2ZWQgLmVsIGR1cmluZyBibG9jayBwYXRjaClcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcbiAgICAgICAgICAgICAgICBjMi5lbCA9IGMxLmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXG5mdW5jdGlvbiBnZXRTZXF1ZW5jZShhcnIpIHtcbiAgICBjb25zdCBwID0gYXJyLnNsaWNlKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xuICAgIGxldCBpLCBqLCB1LCB2LCBjO1xuICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyckkgPSBhcnJbaV07XG4gICAgICAgIGlmIChhcnJJICE9PSAwKSB7XG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChhcnJbal0gPCBhcnJJKSB7XG4gICAgICAgICAgICAgICAgcFtpXSA9IGo7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1ID0gMDtcbiAgICAgICAgICAgIHYgPSByZXN1bHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlICh1IDwgdikge1xuICAgICAgICAgICAgICAgIGMgPSAodSArIHYpID4+IDE7XG4gICAgICAgICAgICAgICAgaWYgKGFycltyZXN1bHRbY11dIDwgYXJySSkge1xuICAgICAgICAgICAgICAgICAgICB1ID0gYyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2ID0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJySSA8IGFycltyZXN1bHRbdV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbaV0gPSByZXN1bHRbdSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHUgPSByZXN1bHQubGVuZ3RoO1xuICAgIHYgPSByZXN1bHRbdSAtIDFdO1xuICAgIHdoaWxlICh1LS0gPiAwKSB7XG4gICAgICAgIHJlc3VsdFt1XSA9IHY7XG4gICAgICAgIHYgPSBwW3ZdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBpc1RlbGVwb3J0ID0gKHR5cGUpID0+IHR5cGUuX19pc1RlbGVwb3J0O1xuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcbmNvbnN0IGlzVGFyZ2V0U1ZHID0gKHRhcmdldCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG5jb25zdCByZXNvbHZlVGFyZ2V0ID0gKHByb3BzLCBzZWxlY3QpID0+IHtcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xuICAgIGlmIChpc1N0cmluZyh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICAgICAgaWYgKCFzZWxlY3QpIHtcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgIHdhcm4oYEN1cnJlbnQgcmVuZGVyZXIgZG9lcyBub3Qgc3VwcG9ydCBzdHJpbmcgdGFyZ2V0IGZvciBUZWxlcG9ydHMuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHNlbGVjdCh0YXJnZXRTZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICB3YXJuKGBGYWlsZWQgdG8gbG9jYXRlIFRlbGVwb3J0IHRhcmdldCB3aXRoIHNlbGVjdG9yIFwiJHt0YXJnZXRTZWxlY3Rvcn1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgaS5lLiB0aGUgdGFyZ2V0IGNhbm5vdCBiZSByZW5kZXJlZCBieSB0aGUgY29tcG9uZW50IGl0c2VsZiwgYW5kIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGlkZWFsbHkgc2hvdWxkIGJlIG91dHNpZGUgb2YgdGhlIGVudGlyZSBWdWUgY29tcG9uZW50IHRyZWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0YXJnZXRTZWxlY3RvciAmJiAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICAgICAgd2FybihgSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQ6ICR7dGFyZ2V0U2VsZWN0b3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xuICAgIH1cbn07XG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XG4gICAgX19pc1RlbGVwb3J0OiB0cnVlLFxuICAgIHByb2Nlc3MobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCBpbnRlcm5hbHMpIHtcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkID0gaXNUZWxlcG9ydERpc2FibGVkKG4yLnByb3BzKTtcbiAgICAgICAgbGV0IHsgc2hhcGVGbGFnLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuIH0gPSBuMjtcbiAgICAgICAgLy8gIzMzMDJcbiAgICAgICAgLy8gSE1SIHVwZGF0ZWQsIGZvcmNlIGZ1bGwgZGlmZlxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzSG1yVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuY2hvcnMgaW4gdGhlIG1haW4gdmlld1xuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAobjIuZWwgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZVRleHQoJycpKTtcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xuICAgICAgICAgICAgaW5zZXJ0KHBsYWNlaG9sZGVyLCBjb250YWluZXIsIGFuY2hvcik7XG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBjcmVhdGVUZXh0KCcnKSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0KHRhcmdldEFuY2hvciwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAvLyAjMjY1MiB3ZSBjb3VsZCBiZSB0ZWxlcG9ydGluZyBmcm9tIGEgbm9uLVNWRyB0cmVlIGludG8gYW4gU1ZHIHRyZWVcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gbW91bnQ6JywgdGFyZ2V0LCBgKCR7dHlwZW9mIHRhcmdldH0pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIsIGFuY2hvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRlbGVwb3J0ICphbHdheXMqIGhhcyBBcnJheSBjaGlsZHJlbi4gVGhpcyBpcyBlbmZvcmNlZCBpbiBib3RoIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVyIGFuZCB2bm9kZSBjaGlsZHJlbiBub3JtYWxpemF0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBtb3VudChjb250YWluZXIsIG1haW5BbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbW91bnQodGFyZ2V0LCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IG4xLmFuY2hvcik7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gbjEudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgY29uc3Qgd2FzRGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjEucHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbnRhaW5lciA9IHdhc0Rpc2FibGVkID8gY29udGFpbmVyIDogdGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcbiAgICAgICAgICAgIGlzU1ZHID0gaXNTVkcgfHwgaXNUYXJnZXRTVkcodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChkeW5hbWljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggd2hlbiB0aGUgdGVsZXBvcnQgaGFwcGVucyB0byBiZSBhIGJsb2NrIHJvb3RcbiAgICAgICAgICAgICAgICBwYXRjaEJsb2NrQ2hpbGRyZW4objEuZHluYW1pY0NoaWxkcmVuLCBkeW5hbWljQ2hpbGRyZW4sIGN1cnJlbnRDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaW4gYmxvY2sgdHJlZSBtb2RlIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCByb290LWxldmVsIG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHRlbGVwb3J0IGluaGVyaXQgcHJldmlvdXMgRE9NIHJlZmVyZW5jZXMgc28gdGhhdCB0aGV5IGNhblxuICAgICAgICAgICAgICAgIC8vIGJlIG1vdmVkIGluIGZ1dHVyZSBwYXRjaGVzLlxuICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICBwYXRjaENoaWxkcmVuKG4xLCBuMiwgY3VycmVudENvbnRhaW5lciwgY3VycmVudEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmFibGVkIC0+IGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaW50byBtYWluIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIGNvbnRhaW5lciwgbWFpbkFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRPR0dMRSAqLyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGNoYW5nZWRcbiAgICAgICAgICAgICAgICBpZiAoKG4yLnByb3BzICYmIG4yLnByb3BzLnRvKSAhPT0gKG4xLnByb3BzICYmIG4xLnByb3BzLnRvKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gKG4yLnRhcmdldCA9IHJlc29sdmVUYXJnZXQobjIucHJvcHMsIHF1ZXJ5U2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVUZWxlcG9ydChuMiwgbmV4dFRhcmdldCwgbnVsbCwgaW50ZXJuYWxzLCAwIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRBUkdFVF9DSEFOR0UgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybignSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOicsIHRhcmdldCwgYCgke3R5cGVvZiB0YXJnZXR9KWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIC0+IGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpbnRvIHRlbGVwb3J0IHRhcmdldFxuICAgICAgICAgICAgICAgICAgICBtb3ZlVGVsZXBvcnQobjIsIHRhcmdldCwgdGFyZ2V0QW5jaG9yLCBpbnRlcm5hbHMsIDEgLyogVGVsZXBvcnRNb3ZlVHlwZXMuVE9HR0xFICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ3NzVmFycyhuMik7XG4gICAgfSxcbiAgICByZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgeyB1bTogdW5tb3VudCwgbzogeyByZW1vdmU6IGhvc3RSZW1vdmUgfSB9LCBkb1JlbW92ZSkge1xuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciwgdGFyZ2V0QW5jaG9yLCB0YXJnZXQsIHByb3BzIH0gPSB2bm9kZTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZSh0YXJnZXRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuIHVubW91bnRlZCB0ZWxlcG9ydCBzaG91bGQgYWx3YXlzIHJlbW92ZSBpdHMgY2hpbGRyZW4gaWYgbm90IGRpc2FibGVkXG4gICAgICAgIGlmIChkb1JlbW92ZSB8fCAhaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xuICAgICAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoY2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdmU6IG1vdmVUZWxlcG9ydCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcbn07XG5mdW5jdGlvbiBtb3ZlVGVsZXBvcnQodm5vZGUsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCB7IG86IHsgaW5zZXJ0IH0sIG06IG1vdmUgfSwgbW92ZVR5cGUgPSAyIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlJFT1JERVIgKi8pIHtcbiAgICAvLyBtb3ZlIHRhcmdldCBhbmNob3IgaWYgdGhpcyBpcyBhIHRhcmdldCBjaGFuZ2UuXG4gICAgaWYgKG1vdmVUeXBlID09PSAwIC8qIFRlbGVwb3J0TW92ZVR5cGVzLlRBUkdFVF9DSEFOR0UgKi8pIHtcbiAgICAgICAgaW5zZXJ0KHZub2RlLnRhcmdldEFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICAgIH1cbiAgICBjb25zdCB7IGVsLCBhbmNob3IsIHNoYXBlRmxhZywgY2hpbGRyZW4sIHByb3BzIH0gPSB2bm9kZTtcbiAgICBjb25zdCBpc1Jlb3JkZXIgPSBtb3ZlVHlwZSA9PT0gMiAvKiBUZWxlcG9ydE1vdmVUeXBlcy5SRU9SREVSICovO1xuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXG4gICAgaWYgKGlzUmVvcmRlcikge1xuICAgICAgICBpbnNlcnQoZWwsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcbiAgICB9XG4gICAgLy8gaWYgdGhpcyBpcyBhIHJlLW9yZGVyIGFuZCB0ZWxlcG9ydCBpcyBlbmFibGVkIChjb250ZW50IGlzIGluIHRhcmdldClcbiAgICAvLyBkbyBub3QgbW92ZSBjaGlsZHJlbi4gU28gdGhlIG9wcG9zaXRlIGlzOiBvbmx5IG1vdmUgY2hpbGRyZW4gaWYgdGhpc1xuICAgIC8vIGlzIG5vdCBhIHJlb3JkZXIsIG9yIHRoZSB0ZWxlcG9ydCBpcyBkaXNhYmxlZFxuICAgIGlmICghaXNSZW9yZGVyIHx8IGlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcbiAgICAgICAgLy8gVGVsZXBvcnQgaGFzIGVpdGhlciBBcnJheSBjaGlsZHJlbiBvciBubyBjaGlsZHJlbi5cbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIFNoYXBlRmxhZ3MuQVJSQVlfQ0hJTERSRU4gKi8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtb3ZlKGNoaWxkcmVuW2ldLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgMiAvKiBNb3ZlVHlwZS5SRU9SREVSICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtb3ZlIG1haW4gdmlldyBhbmNob3IgaWYgdGhpcyBpcyBhIHJlLW9yZGVyLlxuICAgIGlmIChpc1Jlb3JkZXIpIHtcbiAgICAgICAgaW5zZXJ0KGFuY2hvciwgY29udGFpbmVyLCBwYXJlbnRBbmNob3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGVUZWxlcG9ydChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHsgbzogeyBuZXh0U2libGluZywgcGFyZW50Tm9kZSwgcXVlcnlTZWxlY3RvciB9IH0sIGh5ZHJhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHRhcmdldCA9ICh2bm9kZS50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KHZub2RlLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICAvLyBpZiBtdWx0aXBsZSB0ZWxlcG9ydHMgcmVuZGVyZWQgdG8gdGhlIHNhbWUgdGFyZ2V0IGVsZW1lbnQsIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcGljayB1cCBmcm9tIHdoZXJlIHRoZSBsYXN0IHRlbGVwb3J0IGZpbmlzaGVkIGluc3RlYWQgb2YgdGhlIGZpcnN0IG5vZGVcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLykge1xuICAgICAgICAgICAgaWYgKGlzVGVsZXBvcnREaXNhYmxlZCh2bm9kZS5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5hbmNob3IgPSBoeWRyYXRlQ2hpbGRyZW4obmV4dFNpYmxpbmcobm9kZSksIHZub2RlLCBwYXJlbnROb2RlKG5vZGUpLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XG4gICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIGxvb2thaGVhZCB1bnRpbCB3ZSBmaW5kIHRoZSB0YXJnZXQgYW5jaG9yXG4gICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHJlbHkgb24gcmV0dXJuIHZhbHVlIG9mIGh5ZHJhdGVDaGlsZHJlbigpIGJlY2F1c2UgdGhlcmVcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBuZXN0ZWQgdGVsZXBvcnRzXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldEFuY2hvciA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldEFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0QW5jaG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3Iubm9kZVR5cGUgPT09IDggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvci5kYXRhID09PSAndGVsZXBvcnQgYW5jaG9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Ll9scGEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHlkcmF0ZUNoaWxkcmVuKHRhcmdldE5vZGUsIHZub2RlLCB0YXJnZXQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDc3NWYXJzKHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xufVxuLy8gRm9yY2UtY2FzdGVkIHB1YmxpYyB0eXBpbmcgZm9yIGggYW5kIFRTWCBwcm9wcyBpbmZlcmVuY2VcbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuZnVuY3Rpb24gdXBkYXRlQ3NzVmFycyh2bm9kZSkge1xuICAgIC8vIHByZXNlbmNlIG9mIC51dCBtZXRob2QgaW5kaWNhdGVzIG93bmVyIGNvbXBvbmVudCB1c2VzIGNzcyB2YXJzLlxuICAgIC8vIGNvZGUgcGF0aCBoZXJlIGNhbiBhc3N1bWUgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICBjb25zdCBjdHggPSB2bm9kZS5jdHg7XG4gICAgaWYgKGN0eCAmJiBjdHgudXQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB2bm9kZS5jaGlsZHJlblswXS5lbDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IHZub2RlLnRhcmdldEFuY2hvcikge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdi1vd25lcicsIGN0eC51aWQpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnV0KCk7XG4gICAgfVxufVxuXG5jb25zdCBGcmFnbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnRnJhZ21lbnQnIDogdW5kZWZpbmVkKTtcbmNvbnN0IFRleHQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1RleHQnIDogdW5kZWZpbmVkKTtcbmNvbnN0IENvbW1lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0NvbW1lbnQnIDogdW5kZWZpbmVkKTtcbmNvbnN0IFN0YXRpYyA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnU3RhdGljJyA6IHVuZGVmaW5lZCk7XG4vLyBTaW5jZSB2LWlmIGFuZCB2LWZvciBhcmUgdGhlIHR3byBwb3NzaWJsZSB3YXlzIG5vZGUgc3RydWN0dXJlIGNhbiBkeW5hbWljYWxseVxuLy8gY2hhbmdlLCBvbmNlIHdlIGNvbnNpZGVyIHYtaWYgYnJhbmNoZXMgYW5kIGVhY2ggdi1mb3IgZnJhZ21lbnQgYSBibG9jaywgd2Vcbi8vIGNhbiBkaXZpZGUgYSB0ZW1wbGF0ZSBpbnRvIG5lc3RlZCBibG9ja3MsIGFuZCB3aXRoaW4gZWFjaCBibG9jayB0aGUgbm9kZVxuLy8gc3RydWN0dXJlIHdvdWxkIGJlIHN0YWJsZS4gVGhpcyBhbGxvd3MgdXMgdG8gc2tpcCBtb3N0IGNoaWxkcmVuIGRpZmZpbmdcbi8vIGFuZCBvbmx5IHdvcnJ5IGFib3V0IHRoZSBkeW5hbWljIG5vZGVzIChpbmRpY2F0ZWQgYnkgcGF0Y2ggZmxhZ3MpLlxuY29uc3QgYmxvY2tTdGFjayA9IFtdO1xubGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XG4vKipcbiAqIE9wZW4gYSBibG9jay5cbiAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBjcmVhdGVCbG9ja2AuIEl0IGNhbm5vdCBiZSBwYXJ0IG9mIGBjcmVhdGVCbG9ja2BcbiAqIGJlY2F1c2UgdGhlIGNoaWxkcmVuIG9mIHRoZSBibG9jayBhcmUgZXZhbHVhdGVkIGJlZm9yZSBgY3JlYXRlQmxvY2tgIGl0c2VsZlxuICogaXMgY2FsbGVkLiBUaGUgZ2VuZXJhdGVkIGNvZGUgdHlwaWNhbGx5IGxvb2tzIGxpa2UgdGhpczpcbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gcmVuZGVyKCkge1xuICogICByZXR1cm4gKG9wZW5CbG9jaygpLGNyZWF0ZUJsb2NrKCdkaXYnLCBudWxsLCBbLi4uXSkpXG4gKiB9XG4gKiBgYGBcbiAqIGRpc2FibGVUcmFja2luZyBpcyB0cnVlIHdoZW4gY3JlYXRpbmcgYSB2LWZvciBmcmFnbWVudCBibG9jaywgc2luY2UgYSB2LWZvclxuICogZnJhZ21lbnQgYWx3YXlzIGRpZmZzIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBvcGVuQmxvY2soZGlzYWJsZVRyYWNraW5nID0gZmFsc2UpIHtcbiAgICBibG9ja1N0YWNrLnB1c2goKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSkpO1xufVxuZnVuY3Rpb24gY2xvc2VCbG9jaygpIHtcbiAgICBibG9ja1N0YWNrLnBvcCgpO1xuICAgIGN1cnJlbnRCbG9jayA9IGJsb2NrU3RhY2tbYmxvY2tTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuLy8gV2hldGhlciB3ZSBzaG91bGQgYmUgdHJhY2tpbmcgZHluYW1pYyBjaGlsZCBub2RlcyBpbnNpZGUgYSBibG9jay5cbi8vIE9ubHkgdHJhY2tzIHdoZW4gdGhpcyB2YWx1ZSBpcyA+IDBcbi8vIFdlIGFyZSBub3QgdXNpbmcgYSBzaW1wbGUgYm9vbGVhbiBiZWNhdXNlIHRoaXMgdmFsdWUgbWF5IG5lZWQgdG8gYmVcbi8vIGluY3JlbWVudGVkL2RlY3JlbWVudGVkIGJ5IG5lc3RlZCB1c2FnZSBvZiB2LW9uY2UgKHNlZSBiZWxvdylcbmxldCBpc0Jsb2NrVHJlZUVuYWJsZWQgPSAxO1xuLyoqXG4gKiBCbG9jayB0cmFja2luZyBzb21ldGltZXMgbmVlZHMgdG8gYmUgZGlzYWJsZWQsIGZvciBleGFtcGxlIGR1cmluZyB0aGVcbiAqIGNyZWF0aW9uIG9mIGEgdHJlZSB0aGF0IG5lZWRzIHRvIGJlIGNhY2hlZCBieSB2LW9uY2UuIFRoZSBjb21waWxlciBnZW5lcmF0ZXNcbiAqIGNvZGUgbGlrZSB0aGlzOlxuICpcbiAqIGBgYCBqc1xuICogX2NhY2hlWzFdIHx8IChcbiAqICAgc2V0QmxvY2tUcmFja2luZygtMSksXG4gKiAgIF9jYWNoZVsxXSA9IGNyZWF0ZVZOb2RlKC4uLiksXG4gKiAgIHNldEJsb2NrVHJhY2tpbmcoMSksXG4gKiAgIF9jYWNoZVsxXVxuICogKVxuICogYGBgXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0QmxvY2tUcmFja2luZyh2YWx1ZSkge1xuICAgIGlzQmxvY2tUcmVlRW5hYmxlZCArPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcbiAgICAvLyBzYXZlIGN1cnJlbnQgYmxvY2sgY2hpbGRyZW4gb24gdGhlIGJsb2NrIHZub2RlXG4gICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID1cbiAgICAgICAgaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xuICAgIC8vIGNsb3NlIGJsb2NrXG4gICAgY2xvc2VCbG9jaygpO1xuICAgIC8vIGEgYmxvY2sgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIHBhdGNoZWQsIHNvIHRyYWNrIGl0IGFzIGEgY2hpbGQgb2YgaXRzXG4gICAgLy8gcGFyZW50IGJsb2NrXG4gICAgaWYgKGlzQmxvY2tUcmVlRW5hYmxlZCA+IDAgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50QmxvY2sodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnKSB7XG4gICAgcmV0dXJuIHNldHVwQmxvY2soY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgdHJ1ZSAvKiBpc0Jsb2NrICovKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIGJsb2NrIHJvb3Qgdm5vZGUuIFRha2VzIHRoZSBzYW1lIGV4YWN0IGFyZ3VtZW50cyBhcyBgY3JlYXRlVk5vZGVgLlxuICogQSBibG9jayByb290IGtlZXBzIHRyYWNrIG9mIGR5bmFtaWMgbm9kZXMgd2l0aGluIHRoZSBibG9jayBpbiB0aGVcbiAqIGBkeW5hbWljQ2hpbGRyZW5gIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gc2V0dXBCbG9jayhjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCB0cnVlIC8qIGlzQmxvY2s6IHByZXZlbnQgYSBibG9jayBmcm9tIHRyYWNraW5nIGl0c2VsZiAqLykpO1xufVxuZnVuY3Rpb24gaXNWTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICBuMi5zaGFwZUZsYWcgJiA2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UICovICYmXG4gICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5oYXMobjIudHlwZSkpIHtcbiAgICAgICAgLy8gIzcwNDIsIGVuc3VyZSB0aGUgdm5vZGUgYmVpbmcgdW5tb3VudGVkIGR1cmluZyBITVJcbiAgICAgICAgLy8gYml0d2lzZSBvcGVyYXRpb25zIHRvIHJlbW92ZSBrZWVwIGFsaXZlIGZsYWdzXG4gICAgICAgIG4xLnNoYXBlRmxhZyAmPSB+MjU2IC8qIFNoYXBlRmxhZ3MuQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xuICAgICAgICBuMi5zaGFwZUZsYWcgJj0gfjUxMiAvKiBTaGFwZUZsYWdzLkNPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xuICAgICAgICAvLyBITVIgb25seTogaWYgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBob3QtdXBkYXRlZCwgZm9yY2UgYSByZWxvYWQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG4xLnR5cGUgPT09IG4yLnR5cGUgJiYgbjEua2V5ID09PSBuMi5rZXk7XG59XG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XG4vKipcbiAqIEludGVybmFsIEFQSSBmb3IgcmVnaXN0ZXJpbmcgYW4gYXJndW1lbnRzIHRyYW5zZm9ybSBmb3IgY3JlYXRlVk5vZGVcbiAqIHVzZWQgZm9yIGNyZWF0aW5nIHN0dWJzIGluIHRoZSB0ZXN0LXV0aWxzXG4gKiBJdCBpcyAqaW50ZXJuYWwqIGJ1dCBuZWVkcyB0byBiZSBleHBvc2VkIGZvciB0ZXN0LXV0aWxzIHRvIHBpY2sgdXAgcHJvcGVyXG4gKiB0eXBpbmdzXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVZOb2RlQXJncyh0cmFuc2Zvcm1lcikge1xuICAgIHZub2RlQXJnc1RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXI7XG59XG5jb25zdCBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtID0gKC4uLmFyZ3MpID0+IHtcbiAgICByZXR1cm4gX2NyZWF0ZVZOb2RlKC4uLih2bm9kZUFyZ3NUcmFuc2Zvcm1lclxuICAgICAgICA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSlcbiAgICAgICAgOiBhcmdzKSk7XG59O1xuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xuY29uc3Qgbm9ybWFsaXplS2V5ID0gKHsga2V5IH0pID0+IGtleSAhPSBudWxsID8ga2V5IDogbnVsbDtcbmNvbnN0IG5vcm1hbGl6ZVJlZiA9ICh7IHJlZiwgcmVmX2tleSwgcmVmX2ZvciB9KSA9PiB7XG4gICAgcmV0dXJuIChyZWYgIT0gbnVsbFxuICAgICAgICA/IGlzU3RyaW5nKHJlZikgfHwgaXNSZWYocmVmKSB8fCBpc0Z1bmN0aW9uKHJlZilcbiAgICAgICAgICAgID8geyBpOiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIHI6IHJlZiwgazogcmVmX2tleSwgZjogISFyZWZfZm9yIH1cbiAgICAgICAgICAgIDogcmVmXG4gICAgICAgIDogbnVsbCk7XG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBzaGFwZUZsYWcgPSB0eXBlID09PSBGcmFnbWVudCA/IDAgOiAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqLywgaXNCbG9ja05vZGUgPSBmYWxzZSwgbmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24gPSBmYWxzZSkge1xuICAgIGNvbnN0IHZub2RlID0ge1xuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICAgICAgX192X3NraXA6IHRydWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBrZXk6IHByb3BzICYmIG5vcm1hbGl6ZUtleShwcm9wcyksXG4gICAgICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcbiAgICAgICAgc2NvcGVJZDogY3VycmVudFNjb3BlSWQsXG4gICAgICAgIHNsb3RTY29wZUlkczogbnVsbCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICAgICAgc3VzcGVuc2U6IG51bGwsXG4gICAgICAgIHNzQ29udGVudDogbnVsbCxcbiAgICAgICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICAgICAgZGlyczogbnVsbCxcbiAgICAgICAgdHJhbnNpdGlvbjogbnVsbCxcbiAgICAgICAgZWw6IG51bGwsXG4gICAgICAgIGFuY2hvcjogbnVsbCxcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgICAgIHN0YXRpY0NvdW50OiAwLFxuICAgICAgICBzaGFwZUZsYWcsXG4gICAgICAgIHBhdGNoRmxhZyxcbiAgICAgICAgZHluYW1pY1Byb3BzLFxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXG4gICAgICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgICAgIGN0eDogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlXG4gICAgfTtcbiAgICBpZiAobmVlZEZ1bGxDaGlsZHJlbk5vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuKTtcbiAgICAgICAgLy8gbm9ybWFsaXplIHN1c3BlbnNlIGNoaWxkcmVuXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU2hhcGVGbGFncy5TVVNQRU5TRSAqLykge1xuICAgICAgICAgICAgdHlwZS5ub3JtYWxpemUodm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIGNvbXBpbGVkIGVsZW1lbnQgdm5vZGUgLSBpZiBjaGlsZHJlbiBpcyBwYXNzZWQsIG9ubHkgcG9zc2libGUgdHlwZXMgYXJlXG4gICAgICAgIC8vIHN0cmluZyBvciBBcnJheS5cbiAgICAgICAgdm5vZGUuc2hhcGVGbGFnIHw9IGlzU3RyaW5nKGNoaWxkcmVuKVxuICAgICAgICAgICAgPyA4IC8qIFNoYXBlRmxhZ3MuVEVYVF9DSElMRFJFTiAqL1xuICAgICAgICAgICAgOiAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSBrZXlcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHZub2RlLmtleSAhPT0gdm5vZGUua2V5KSB7XG4gICAgICAgIHdhcm4oYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcbiAgICB9XG4gICAgLy8gdHJhY2sgdm5vZGUgZm9yIGJsb2NrIHRyZWVcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJlxuICAgICAgICAvLyBhdm9pZCBhIGJsb2NrIG5vZGUgZnJvbSB0cmFja2luZyBpdHNlbGZcbiAgICAgICAgIWlzQmxvY2tOb2RlICYmXG4gICAgICAgIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xuICAgICAgICBjdXJyZW50QmxvY2sgJiZcbiAgICAgICAgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cbiAgICAgICAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xuICAgICAgICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXG4gICAgICAgICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pICYmXG4gICAgICAgIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxuICAgICAgICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxuICAgICAgICB2bm9kZS5wYXRjaEZsYWcgIT09IDMyIC8qIFBhdGNoRmxhZ3MuSFlEUkFURV9FVkVOVFMgKi8pIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2godm5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGU7XG59XG5jb25zdCBjcmVhdGVWTm9kZSA9ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBjcmVhdGVWTm9kZVdpdGhBcmdzVHJhbnNmb3JtIDogX2NyZWF0ZVZOb2RlKTtcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xuICAgIGlmICghdHlwZSB8fCB0eXBlID09PSBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXR5cGUpIHtcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R5cGV9LmApO1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBDb21tZW50O1xuICAgIH1cbiAgICBpZiAoaXNWTm9kZSh0eXBlKSkge1xuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgIC8vIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIi8+XG4gICAgICAgIC8vICMyMDc4IG1ha2Ugc3VyZSB0byBtZXJnZSByZWZzIGR1cmluZyB0aGUgY2xvbmUgaW5zdGVhZCBvZiBvdmVyd3JpdGluZyBpdFxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbihjbG9uZWQsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiAhaXNCbG9ja05vZGUgJiYgY3VycmVudEJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoY2xvbmVkLnNoYXBlRmxhZyAmIDYgLyogU2hhcGVGbGFncy5DT01QT05FTlQgKi8pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tbY3VycmVudEJsb2NrLmluZGV4T2YodHlwZSldID0gY2xvbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2xvbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbG9uZWQucGF0Y2hGbGFnIHw9IC0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqLztcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gICAgLy8gY2xhc3MgY29tcG9uZW50IG5vcm1hbGl6YXRpb24uXG4gICAgaWYgKGlzQ2xhc3NDb21wb25lbnQodHlwZSkpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xuICAgIH1cbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIC8vIGZvciByZWFjdGl2ZSBvciBwcm94eSBvYmplY3RzLCB3ZSBuZWVkIHRvIGNsb25lIGl0IHRvIGVuYWJsZSBtdXRhdGlvbi5cbiAgICAgICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xuICAgICAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09iamVjdChzdHlsZSkpIHtcbiAgICAgICAgICAgIC8vIHJlYWN0aXZlIHN0YXRlIG9iamVjdHMgbmVlZCB0byBiZSBjbG9uZWQgc2luY2UgdGhleSBhcmUgbGlrZWx5IHRvIGJlXG4gICAgICAgICAgICAvLyBtdXRhdGVkXG4gICAgICAgICAgICBpZiAoaXNQcm94eShzdHlsZSkgJiYgIWlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVuY29kZSB0aGUgdm5vZGUgdHlwZSBpbmZvcm1hdGlvbiBpbnRvIGEgYml0bWFwXG4gICAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSlcbiAgICAgICAgPyAxIC8qIFNoYXBlRmxhZ3MuRUxFTUVOVCAqL1xuICAgICAgICA6IGlzU3VzcGVuc2UodHlwZSlcbiAgICAgICAgICAgID8gMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi9cbiAgICAgICAgICAgIDogaXNUZWxlcG9ydCh0eXBlKVxuICAgICAgICAgICAgICAgID8gNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqL1xuICAgICAgICAgICAgICAgIDogaXNPYmplY3QodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgPyA0IC8qIFNoYXBlRmxhZ3MuU1RBVEVGVUxfQ09NUE9ORU5UICovXG4gICAgICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbih0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAyIC8qIFNoYXBlRmxhZ3MuRlVOQ1RJT05BTF9DT01QT05FTlQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU2hhcGVGbGFncy5TVEFURUZVTF9DT01QT05FTlQgKi8gJiYgaXNQcm94eSh0eXBlKSkge1xuICAgICAgICB0eXBlID0gdG9SYXcodHlwZSk7XG4gICAgICAgIHdhcm4oYFZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB3aGljaCB3YXMgbWFkZSBhIHJlYWN0aXZlIG9iamVjdC4gVGhpcyBjYW4gYCArXG4gICAgICAgICAgICBgbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCwgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IGAgK1xuICAgICAgICAgICAgYG1hcmtpbmcgdGhlIGNvbXBvbmVudCB3aXRoIFxcYG1hcmtSYXdcXGAgb3IgdXNpbmcgXFxgc2hhbGxvd1JlZlxcYCBgICtcbiAgICAgICAgICAgIGBpbnN0ZWFkIG9mIFxcYHJlZlxcYC5gLCBgXFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgcGF0Y2hGbGFnLCBkeW5hbWljUHJvcHMsIHNoYXBlRmxhZywgaXNCbG9ja05vZGUsIHRydWUpO1xufVxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzXG4gICAgICAgID8gZXh0ZW5kKHt9LCBwcm9wcylcbiAgICAgICAgOiBwcm9wcztcbn1cbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUsIGV4dHJhUHJvcHMsIG1lcmdlUmVmID0gZmFsc2UpIHtcbiAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgTk9UIHVzaW5nIHNwcmVhZCBvciBleHRlbmQgdG8gYXZvaWQgdGhlIHJ1bnRpbWVcbiAgICAvLyBrZXkgZW51bWVyYXRpb24gY29zdC5cbiAgICBjb25zdCB7IHByb3BzLCByZWYsIHBhdGNoRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xuICAgIGNvbnN0IG1lcmdlZFByb3BzID0gZXh0cmFQcm9wcyA/IG1lcmdlUHJvcHMocHJvcHMgfHwge30sIGV4dHJhUHJvcHMpIDogcHJvcHM7XG4gICAgY29uc3QgY2xvbmVkID0ge1xuICAgICAgICBfX3ZfaXNWTm9kZTogdHJ1ZSxcbiAgICAgICAgX192X3NraXA6IHRydWUsXG4gICAgICAgIHR5cGU6IHZub2RlLnR5cGUsXG4gICAgICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICAgICAga2V5OiBtZXJnZWRQcm9wcyAmJiBub3JtYWxpemVLZXkobWVyZ2VkUHJvcHMpLFxuICAgICAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWZcbiAgICAgICAgICAgID8gLy8gIzIwNzggaW4gdGhlIGNhc2Ugb2YgPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiIHJlZj1cImV4dHJhXCIvPlxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcbiAgICAgICAgICAgICAgICBtZXJnZVJlZiAmJiByZWZcbiAgICAgICAgICAgICAgICAgICAgPyBpc0FycmF5KHJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtyZWYsIG5vcm1hbGl6ZVJlZihleHRyYVByb3BzKV1cbiAgICAgICAgICAgICAgICAgICAgOiBub3JtYWxpemVSZWYoZXh0cmFQcm9wcylcbiAgICAgICAgICAgIDogcmVmLFxuICAgICAgICBzY29wZUlkOiB2bm9kZS5zY29wZUlkLFxuICAgICAgICBzbG90U2NvcGVJZHM6IHZub2RlLnNsb3RTY29wZUlkcyxcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqLyAmJiBpc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICAgICAgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpXG4gICAgICAgICAgICA6IGNoaWxkcmVuLFxuICAgICAgICB0YXJnZXQ6IHZub2RlLnRhcmdldCxcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXG4gICAgICAgIHN0YXRpY0NvdW50OiB2bm9kZS5zdGF0aWNDb3VudCxcbiAgICAgICAgc2hhcGVGbGFnOiB2bm9kZS5zaGFwZUZsYWcsXG4gICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXG4gICAgICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXG4gICAgICAgIC8vIG5vdGU6IHByZXNlcnZlIGZsYWcgZm9yIGZyYWdtZW50cyBzaW5jZSB0aGV5IHVzZSB0aGUgZmxhZyBmb3IgY2hpbGRyZW5cbiAgICAgICAgLy8gZmFzdCBwYXRocyBvbmx5LlxuICAgICAgICBwYXRjaEZsYWc6IGV4dHJhUHJvcHMgJiYgdm5vZGUudHlwZSAhPT0gRnJhZ21lbnRcbiAgICAgICAgICAgID8gcGF0Y2hGbGFnID09PSAtMSAvLyBob2lzdGVkIG5vZGVcbiAgICAgICAgICAgICAgICA/IDE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqL1xuICAgICAgICAgICAgICAgIDogcGF0Y2hGbGFnIHwgMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovXG4gICAgICAgICAgICA6IHBhdGNoRmxhZyxcbiAgICAgICAgZHluYW1pY1Byb3BzOiB2bm9kZS5keW5hbWljUHJvcHMsXG4gICAgICAgIGR5bmFtaWNDaGlsZHJlbjogdm5vZGUuZHluYW1pY0NoaWxkcmVuLFxuICAgICAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxuICAgICAgICBkaXJzOiB2bm9kZS5kaXJzLFxuICAgICAgICB0cmFuc2l0aW9uOiB2bm9kZS50cmFuc2l0aW9uLFxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcbiAgICAgICAgLy8gdGhleSAqc2hvdWxkKiBiZSBjb3BpZWQgZm9yIGtlcHQtYWxpdmUgdm5vZGVzLiBTbyB3ZSBqdXN0IGFsd2F5cyBjb3B5XG4gICAgICAgIC8vIHRoZW0gc2luY2UgdGhlbSBiZWluZyBub24tbnVsbCBkdXJpbmcgYSBtb3VudCBkb2Vzbid0IGFmZmVjdCB0aGUgbG9naWMgYXNcbiAgICAgICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgICAgY29tcG9uZW50OiB2bm9kZS5jb21wb25lbnQsXG4gICAgICAgIHN1c3BlbnNlOiB2bm9kZS5zdXNwZW5zZSxcbiAgICAgICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxuICAgICAgICBzc0ZhbGxiYWNrOiB2bm9kZS5zc0ZhbGxiYWNrICYmIGNsb25lVk5vZGUodm5vZGUuc3NGYWxsYmFjayksXG4gICAgICAgIGVsOiB2bm9kZS5lbCxcbiAgICAgICAgYW5jaG9yOiB2bm9kZS5hbmNob3IsXG4gICAgICAgIGN0eDogdm5vZGUuY3R4LFxuICAgICAgICBjZTogdm5vZGUuY2VcbiAgICB9O1xuICAgIHJldHVybiBjbG9uZWQ7XG59XG4vKipcbiAqIERldiBvbmx5LCBmb3IgSE1SIG9mIGhvaXN0ZWQgdm5vZGVzIHJldXNlZCBpbiB2LWZvclxuICogaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy8yMDIyXG4gKi9cbmZ1bmN0aW9uIGRlZXBDbG9uZVZOb2RlKHZub2RlKSB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgaWYgKGlzQXJyYXkodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGNsb25lZC5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLm1hcChkZWVwQ2xvbmVWTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gJyAnLCBmbGFnID0gMCkge1xuICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCB0ZXh0LCBmbGFnKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xuICAgIC8vIEEgc3RhdGljIHZub2RlIGNhbiBjb250YWluIG11bHRpcGxlIHN0cmluZ2lmaWVkIGVsZW1lbnRzLCBhbmQgdGhlIG51bWJlclxuICAgIC8vIG9mIGVsZW1lbnRzIGlzIG5lY2Vzc2FyeSBmb3IgaHlkcmF0aW9uLlxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcbiAgICB2bm9kZS5zdGF0aWNDb3VudCA9IG51bWJlck9mTm9kZXM7XG4gICAgcmV0dXJuIHZub2RlO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50Vk5vZGUodGV4dCA9ICcnLCBcbi8vIHdoZW4gdXNlZCBhcyB0aGUgdi1lbHNlIGJyYW5jaCwgdGhlIGNvbW1lbnQgbm9kZSBtdXN0IGJlIGNyZWF0ZWQgYXMgYVxuLy8gYmxvY2sgdG8gZW5zdXJlIGNvcnJlY3QgdXBkYXRlcy5cbmFzQmxvY2sgPSBmYWxzZSkge1xuICAgIHJldHVybiBhc0Jsb2NrXG4gICAgICAgID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50LCBudWxsLCB0ZXh0KSlcbiAgICAgICAgOiBjcmVhdGVWTm9kZShDb21tZW50LCBudWxsLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwgfHwgdHlwZW9mIGNoaWxkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgLy8gZW1wdHkgcGxhY2Vob2xkZXJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAvLyBmcmFnbWVudFxuICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoRnJhZ21lbnQsIG51bGwsIFxuICAgICAgICAvLyAjMzY2NiwgYXZvaWQgcmVmZXJlbmNlIHBvbGx1dGlvbiB3aGVuIHJldXNpbmcgdm5vZGVcbiAgICAgICAgY2hpbGQuc2xpY2UoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gYWxyZWFkeSB2bm9kZSwgdGhpcyBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHNpbmNlIGNvbXBpbGVkIHRlbXBsYXRlc1xuICAgICAgICAvLyBhbHdheXMgcHJvZHVjZSBhbGwtdm5vZGUgY2hpbGRyZW4gYXJyYXlzXG4gICAgICAgIHJldHVybiBjbG9uZUlmTW91bnRlZChjaGlsZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzdHJpbmdzIGFuZCBudW1iZXJzXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcbiAgICB9XG59XG4vLyBvcHRpbWl6ZWQgbm9ybWFsaXphdGlvbiBmb3IgdGVtcGxhdGUtY29tcGlsZWQgcmVuZGVyIGZuc1xuZnVuY3Rpb24gY2xvbmVJZk1vdW50ZWQoY2hpbGQpIHtcbiAgICByZXR1cm4gKGNoaWxkLmVsID09PSBudWxsICYmIGNoaWxkLnBhdGNoRmxhZyAhPT0gLTEgLyogUGF0Y2hGbGFncy5IT0lTVEVEICovKSB8fFxuICAgICAgICBjaGlsZC5tZW1vXG4gICAgICAgID8gY2hpbGRcbiAgICAgICAgOiBjbG9uZVZOb2RlKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbikge1xuICAgIGxldCB0eXBlID0gMDtcbiAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gdm5vZGU7XG4gICAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICB0eXBlID0gMTYgLyogU2hhcGVGbGFncy5BUlJBWV9DSElMRFJFTiAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoc2hhcGVGbGFnICYgKDEgLyogU2hhcGVGbGFncy5FTEVNRU5UICovIHwgNjQgLyogU2hhcGVGbGFncy5URUxFUE9SVCAqLykpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBzbG90IHRvIHBsYWluIGNoaWxkcmVuIGZvciBwbGFpbiBlbGVtZW50IGFuZCBUZWxlcG9ydFxuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XG4gICAgICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgICAgIC8vIF9jIG1hcmtlciBpcyBhZGRlZCBieSB3aXRoQ3R4KCkgaW5kaWNhdGluZyB0aGlzIGlzIGEgY29tcGlsZWQgc2xvdFxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUsIHNsb3QoKSk7XG4gICAgICAgICAgICAgICAgc2xvdC5fYyAmJiAoc2xvdC5fZCA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IDMyIC8qIFNoYXBlRmxhZ3MuU0xPVFNfQ0hJTERSRU4gKi87XG4gICAgICAgICAgICBjb25zdCBzbG90RmxhZyA9IGNoaWxkcmVuLl87XG4gICAgICAgICAgICBpZiAoIXNsb3RGbGFnICYmICEoSW50ZXJuYWxPYmplY3RLZXkgaW4gY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNsb3RGbGFnID09PSAzIC8qIFNsb3RGbGFncy5GT1JXQVJERUQgKi8gJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gYSBjaGlsZCBjb21wb25lbnQgcmVjZWl2ZXMgZm9yd2FyZGVkIHNsb3RzIGZyb20gdGhlIHBhcmVudC5cbiAgICAgICAgICAgICAgICAvLyBpdHMgc2xvdCB0eXBlIGlzIGRldGVybWluZWQgYnkgaXRzIHBhcmVudCdzIHNsb3QgdHlwZS5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnNsb3RzLl8gPT09IDEgLyogU2xvdEZsYWdzLlNUQUJMRSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fID0gMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDIgLyogU2xvdEZsYWdzLkRZTkFNSUMgKi87XG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnBhdGNoRmxhZyB8PSAxMDI0IC8qIFBhdGNoRmxhZ3MuRFlOQU1JQ19TTE9UUyAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSB7IGRlZmF1bHQ6IGNoaWxkcmVuLCBfY3R4OiBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgfTtcbiAgICAgICAgdHlwZSA9IDMyIC8qIFNoYXBlRmxhZ3MuU0xPVFNfQ0hJTERSRU4gKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAgIC8vIGZvcmNlIHRlbGVwb3J0IGNoaWxkcmVuIHRvIGFycmF5IHNvIGl0IGNhbiBiZSBtb3ZlZCBhcm91bmRcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFNoYXBlRmxhZ3MuVEVMRVBPUlQgKi8pIHtcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBTaGFwZUZsYWdzLkFSUkFZX0NISUxEUkVOICovO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0eXBlID0gOCAvKiBTaGFwZUZsYWdzLlRFWFRfQ0hJTERSRU4gKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvcHMoLi4uYXJncykge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b01lcmdlID0gYXJnc1tpXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIGlmIChyZXQuY2xhc3MgIT09IHRvTWVyZ2UuY2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmNsYXNzID0gbm9ybWFsaXplQ2xhc3MoW3JldC5jbGFzcywgdG9NZXJnZS5jbGFzc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIHJldC5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKFtyZXQuc3R5bGUsIHRvTWVyZ2Uuc3R5bGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmV0W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgaW5jb21pbmcgPSB0b01lcmdlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGluY29taW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nICE9PSBpbmNvbWluZyAmJlxuICAgICAgICAgICAgICAgICAgICAhKGlzQXJyYXkoZXhpc3RpbmcpICYmIGV4aXN0aW5nLmluY2x1ZGVzKGluY29taW5nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGluY29taW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbmNvbWluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcbiAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgNyAvKiBFcnJvckNvZGVzLlZOT0RFX0hPT0sgKi8sIFtcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIHByZXZWTm9kZVxuICAgIF0pO1xufVxuXG5jb25zdCBlbXB0eUFwcENvbnRleHQgPSBjcmVhdGVBcHBDb250ZXh0KCk7XG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlKHZub2RlLCBwYXJlbnQsIHN1c3BlbnNlKSB7XG4gICAgY29uc3QgdHlwZSA9IHZub2RlLnR5cGU7XG4gICAgLy8gaW5oZXJpdCBwYXJlbnQgYXBwIGNvbnRleHQgLSBvciAtIGlmIHJvb3QsIGFkb3B0IGZyb20gcm9vdCB2bm9kZVxuICAgIGNvbnN0IGFwcENvbnRleHQgPSAocGFyZW50ID8gcGFyZW50LmFwcENvbnRleHQgOiB2bm9kZS5hcHBDb250ZXh0KSB8fCBlbXB0eUFwcENvbnRleHQ7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB7XG4gICAgICAgIHVpZDogdWlkKyssXG4gICAgICAgIHZub2RlLFxuICAgICAgICB0eXBlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGFwcENvbnRleHQsXG4gICAgICAgIHJvb3Q6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHN1YlRyZWU6IG51bGwsXG4gICAgICAgIGVmZmVjdDogbnVsbCxcbiAgICAgICAgdXBkYXRlOiBudWxsLFxuICAgICAgICBzY29wZTogbmV3IEVmZmVjdFNjb3BlKHRydWUgLyogZGV0YWNoZWQgKi8pLFxuICAgICAgICByZW5kZXI6IG51bGwsXG4gICAgICAgIHByb3h5OiBudWxsLFxuICAgICAgICBleHBvc2VkOiBudWxsLFxuICAgICAgICBleHBvc2VQcm94eTogbnVsbCxcbiAgICAgICAgd2l0aFByb3h5OiBudWxsLFxuICAgICAgICBwcm92aWRlczogcGFyZW50ID8gcGFyZW50LnByb3ZpZGVzIDogT2JqZWN0LmNyZWF0ZShhcHBDb250ZXh0LnByb3ZpZGVzKSxcbiAgICAgICAgYWNjZXNzQ2FjaGU6IG51bGwsXG4gICAgICAgIHJlbmRlckNhY2hlOiBbXSxcbiAgICAgICAgLy8gbG9jYWwgcmVzb2x2ZWQgYXNzZXRzXG4gICAgICAgIGNvbXBvbmVudHM6IG51bGwsXG4gICAgICAgIGRpcmVjdGl2ZXM6IG51bGwsXG4gICAgICAgIC8vIHJlc29sdmVkIHByb3BzIGFuZCBlbWl0cyBvcHRpb25zXG4gICAgICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxuICAgICAgICBlbWl0c09wdGlvbnM6IG5vcm1hbGl6ZUVtaXRzT3B0aW9ucyh0eXBlLCBhcHBDb250ZXh0KSxcbiAgICAgICAgLy8gZW1pdFxuICAgICAgICBlbWl0OiBudWxsLFxuICAgICAgICBlbWl0dGVkOiBudWxsLFxuICAgICAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXG4gICAgICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcbiAgICAgICAgLy8gaW5oZXJpdEF0dHJzXG4gICAgICAgIGluaGVyaXRBdHRyczogdHlwZS5pbmhlcml0QXR0cnMsXG4gICAgICAgIC8vIHN0YXRlXG4gICAgICAgIGN0eDogRU1QVFlfT0JKLFxuICAgICAgICBkYXRhOiBFTVBUWV9PQkosXG4gICAgICAgIHByb3BzOiBFTVBUWV9PQkosXG4gICAgICAgIGF0dHJzOiBFTVBUWV9PQkosXG4gICAgICAgIHNsb3RzOiBFTVBUWV9PQkosXG4gICAgICAgIHJlZnM6IEVNUFRZX09CSixcbiAgICAgICAgc2V0dXBTdGF0ZTogRU1QVFlfT0JKLFxuICAgICAgICBzZXR1cENvbnRleHQ6IG51bGwsXG4gICAgICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcbiAgICAgICAgc3VzcGVuc2UsXG4gICAgICAgIHN1c3BlbnNlSWQ6IHN1c3BlbnNlID8gc3VzcGVuc2UucGVuZGluZ0lkIDogMCxcbiAgICAgICAgYXN5bmNEZXA6IG51bGwsXG4gICAgICAgIGFzeW5jUmVzb2x2ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBsaWZlY3ljbGUgaG9va3NcbiAgICAgICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAgICAgaXNVbm1vdW50ZWQ6IGZhbHNlLFxuICAgICAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcbiAgICAgICAgYmM6IG51bGwsXG4gICAgICAgIGM6IG51bGwsXG4gICAgICAgIGJtOiBudWxsLFxuICAgICAgICBtOiBudWxsLFxuICAgICAgICBidTogbnVsbCxcbiAgICAgICAgdTogbnVsbCxcbiAgICAgICAgdW06IG51bGwsXG4gICAgICAgIGJ1bTogbnVsbCxcbiAgICAgICAgZGE6IG51bGwsXG4gICAgICAgIGE6IG51bGwsXG4gICAgICAgIHJ0ZzogbnVsbCxcbiAgICAgICAgcnRjOiBudWxsLFxuICAgICAgICBlYzogbnVsbCxcbiAgICAgICAgc3A6IG51bGxcbiAgICB9O1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgaW5zdGFuY2UuY3R4ID0gY3JlYXRlRGV2UmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5jdHggPSB7IF86IGluc3RhbmNlIH07XG4gICAgfVxuICAgIGluc3RhbmNlLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCA6IGluc3RhbmNlO1xuICAgIGluc3RhbmNlLmVtaXQgPSBlbWl0LmJpbmQobnVsbCwgaW5zdGFuY2UpO1xuICAgIC8vIGFwcGx5IGN1c3RvbSBlbGVtZW50IHNwZWNpYWwgaGFuZGxpbmdcbiAgICBpZiAodm5vZGUuY2UpIHtcbiAgICAgICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5sZXQgY3VycmVudEluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGdldEN1cnJlbnRJbnN0YW5jZSA9ICgpID0+IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBpbnN0YW5jZS5zY29wZS5vbigpO1xufTtcbmNvbnN0IHVuc2V0Q3VycmVudEluc3RhbmNlID0gKCkgPT4ge1xuICAgIGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2Uuc2NvcGUub2ZmKCk7XG4gICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcbn07XG5jb25zdCBpc0J1aWx0SW5UYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50Jyk7XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29uZmlnKSB7XG4gICAgY29uc3QgYXBwSXNOYXRpdmVUYWcgPSBjb25maWcuaXNOYXRpdmVUYWcgfHwgTk87XG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBhcHBJc05hdGl2ZVRhZyhuYW1lKSkge1xuICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50IGlkOiAnICsgbmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZS52bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNoYXBlRmxhZ3MuU1RBVEVGVUxfQ09NUE9ORU5UICovO1xufVxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBDb21wb25lbnQoaW5zdGFuY2UsIGlzU1NSID0gZmFsc2UpIHtcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBpc1NTUjtcbiAgICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XG4gICAgY29uc3QgaXNTdGF0ZWZ1bCA9IGlzU3RhdGVmdWxDb21wb25lbnQoaW5zdGFuY2UpO1xuICAgIGluaXRQcm9wcyhpbnN0YW5jZSwgcHJvcHMsIGlzU3RhdGVmdWwsIGlzU1NSKTtcbiAgICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcbiAgICBjb25zdCBzZXR1cFJlc3VsdCA9IGlzU3RhdGVmdWxcbiAgICAgICAgPyBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUilcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHNldHVwUmVzdWx0O1xufVxuZnVuY3Rpb24gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGlmIChDb21wb25lbnQubmFtZSkge1xuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZXNbaV0sIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29tcG9uZW50LmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlRGlyZWN0aXZlTmFtZShuYW1lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbXBvbmVudC5jb21waWxlck9wdGlvbnMgJiYgaXNSdW50aW1lT25seSgpKSB7XG4gICAgICAgICAgICB3YXJuKGBcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBgICtcbiAgICAgICAgICAgICAgICBgaW5jbHVkZXMgdGhlIHJ1bnRpbWUgY29tcGlsZXIuIFNpbmNlIHlvdSBhcmUgdXNpbmcgYSBydW50aW1lLW9ubHkgYCArXG4gICAgICAgICAgICAgICAgYGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMC4gY3JlYXRlIHJlbmRlciBwcm94eSBwcm9wZXJ0eSBhY2Nlc3MgY2FjaGVcbiAgICBpbnN0YW5jZS5hY2Nlc3NDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gMS4gY3JlYXRlIHB1YmxpYyBpbnN0YW5jZSAvIHJlbmRlciBwcm94eVxuICAgIC8vIGFsc28gbWFyayBpdCByYXcgc28gaXQncyBuZXZlciBvYnNlcnZlZFxuICAgIGluc3RhbmNlLnByb3h5ID0gbWFya1JhdyhuZXcgUHJveHkoaW5zdGFuY2UuY3R4LCBQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMpKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcbiAgICB9XG4gICAgLy8gMi4gY2FsbCBzZXR1cCgpXG4gICAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xuICAgIGlmIChzZXR1cCkge1xuICAgICAgICBjb25zdCBzZXR1cENvbnRleHQgPSAoaW5zdGFuY2Uuc2V0dXBDb250ZXh0ID1cbiAgICAgICAgICAgIHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbCk7XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIEVycm9yQ29kZXMuU0VUVVBfRlVOQ1RJT04gKi8sIFsocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2UucHJvcHMpIDogaW5zdGFuY2UucHJvcHMsIHNldHVwQ29udGV4dF0pO1xuICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgICAgIGlmIChpc1Byb21pc2Uoc2V0dXBSZXN1bHQpKSB7XG4gICAgICAgICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAoaXNTU1IpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHByb21pc2Ugc28gc2VydmVyLXJlbmRlcmVyIGNhbiB3YWl0IG9uIGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXNvbHZlZFJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgcmVzb2x2ZWRSZXN1bHQsIGlzU1NSKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGluc3RhbmNlLCAwIC8qIEVycm9yQ29kZXMuU0VUVVBfRlVOQ1RJT04gKi8pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXN5bmMgc2V0dXAgcmV0dXJuZWQgUHJvbWlzZS5cbiAgICAgICAgICAgICAgICAvLyBiYWlsIGhlcmUgYW5kIHdhaXQgZm9yIHJlLWVudHJ5LlxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmFzeW5jRGVwID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaW5zdGFuY2Uuc3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IChfYSA9IENvbXBvbmVudC5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnQW5vbnltb3VzJztcbiAgICAgICAgICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IDwke25hbWV9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgc2V0dXBSZXN1bHQsIGlzU1NSKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XG4gICAgICAgIC8vIHNldHVwIHJldHVybmVkIGFuIGlubGluZSByZW5kZXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUuX19zc3JJbmxpbmVSZW5kZXIpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGZ1bmN0aW9uJ3MgbmFtZSBpcyBgc3NyUmVuZGVyYCAoY29tcGlsZWQgYnkgU0ZDIGlubGluZSBtb2RlKSxcbiAgICAgICAgICAgIC8vIHNldCBpdCBhcyBzc3JSZW5kZXIgaW5zdGVhZC5cbiAgICAgICAgICAgIGluc3RhbmNlLnNzclJlbmRlciA9IHNldHVwUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcbiAgICAgICAgICAgIHdhcm4oYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gYCArXG4gICAgICAgICAgICAgICAgYHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIHJldHVybmVkIGJpbmRpbmdzLlxuICAgICAgICAvLyBhc3N1bWluZyBhIHJlbmRlciBmdW5jdGlvbiBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGlzIHByZXNlbnQuXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBzZXR1cFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5zZXR1cFN0YXRlID0gcHJveHlSZWZzKHNldHVwUmVzdWx0KTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2Fybihgc2V0dXAoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4gUmVjZWl2ZWQ6ICR7c2V0dXBSZXN1bHQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygc2V0dXBSZXN1bHR9YCk7XG4gICAgfVxuICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XG59XG5sZXQgY29tcGlsZTtcbmxldCBpbnN0YWxsV2l0aFByb3h5O1xuLyoqXG4gKiBGb3IgcnVudGltZS1kb20gdG8gcmVnaXN0ZXIgdGhlIGNvbXBpbGVyLlxuICogTm90ZSB0aGUgZXhwb3J0ZWQgbWV0aG9kIHVzZXMgYW55IHRvIGF2b2lkIGQudHMgcmVseWluZyBvbiB0aGUgY29tcGlsZXIgdHlwZXMuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XG4gICAgY29tcGlsZSA9IF9jb21waWxlO1xuICAgIGluc3RhbGxXaXRoUHJveHkgPSBpID0+IHtcbiAgICAgICAgaWYgKGkucmVuZGVyLl9yYykge1xuICAgICAgICAgICAgaS53aXRoUHJveHkgPSBuZXcgUHJveHkoaS5jdHgsIFJ1bnRpbWVDb21waWxlZFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8gZGV2IG9ubHlcbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcbmZ1bmN0aW9uIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUiwgc2tpcE9wdGlvbnMpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xuICAgIC8vIHRlbXBsYXRlIC8gcmVuZGVyIGZ1bmN0aW9uIG5vcm1hbGl6YXRpb25cbiAgICAvLyBjb3VsZCBiZSBhbHJlYWR5IHNldCB3aGVuIHJldHVybmVkIGZyb20gc2V0dXAoKVxuICAgIGlmICghaW5zdGFuY2UucmVuZGVyKSB7XG4gICAgICAgIC8vIG9ubHkgZG8gb24tdGhlLWZseSBjb21waWxlIGlmIG5vdCBpbiBTU1IgLSBTU1Igb24tdGhlLWZseSBjb21waWxhdGlvblxuICAgICAgICAvLyBpcyBkb25lIGJ5IHNlcnZlci1yZW5kZXJlclxuICAgICAgICBpZiAoIWlzU1NSICYmIGNvbXBpbGUgJiYgIUNvbXBvbmVudC5yZW5kZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gQ29tcG9uZW50LnRlbXBsYXRlIHx8XG4gICAgICAgICAgICAgICAgcmVzb2x2ZU1lcmdlZE9wdGlvbnMoaW5zdGFuY2UpLnRlbXBsYXRlO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNDdXN0b21FbGVtZW50LCBjb21waWxlck9wdGlvbnMgfSA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbENvbXBpbGVyT3B0aW9ucyA9IGV4dGVuZChleHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBpc0N1c3RvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlcnNcbiAgICAgICAgICAgICAgICB9LCBjb21waWxlck9wdGlvbnMpLCBjb21wb25lbnRDb21waWxlck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5yZW5kZXIgPSBjb21waWxlKHRlbXBsYXRlLCBmaW5hbENvbXBpbGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSAoQ29tcG9uZW50LnJlbmRlciB8fCBOT09QKTtcbiAgICAgICAgLy8gZm9yIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2tzLCB0aGUgcmVuZGVyXG4gICAgICAgIC8vIHByb3h5IHVzZWQgbmVlZHMgYSBkaWZmZXJlbnQgYGhhc2AgaGFuZGxlciB3aGljaCBpcyBtb3JlIHBlcmZvcm1hbnQgYW5kXG4gICAgICAgIC8vIGFsc28gb25seSBhbGxvd3MgYSB3aGl0ZWxpc3Qgb2YgZ2xvYmFscyB0byBmYWxsdGhyb3VnaC5cbiAgICAgICAgaWYgKGluc3RhbGxXaXRoUHJveHkpIHtcbiAgICAgICAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHN1cHBvcnQgZm9yIDIueCBvcHRpb25zXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIShmYWxzZSApKSB7XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgYXBwbHlPcHRpb25zKGluc3RhbmNlKTtcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xuICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIH1cbiAgICAvLyB3YXJuIG1pc3NpbmcgdGVtcGxhdGUvcmVuZGVyXG4gICAgLy8gdGhlIHJ1bnRpbWUgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgaW4gU1NSIGlzIGRvbmUgYnkgc2VydmVyLXJlbmRlclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIUNvbXBvbmVudC5yZW5kZXIgJiYgaW5zdGFuY2UucmVuZGVyID09PSBOT09QICYmICFpc1NTUikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjb21waWxlICYmIENvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgYCArXG4gICAgICAgICAgICAgICAgYHJ1bnRpbWUgY29tcGlsYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIFZ1ZS5gICtcbiAgICAgICAgICAgICAgICAoYCBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi5gXG4gICAgICAgICAgICAgICAgICAgICkgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybihgQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXR0cnNQcm94eShpbnN0YW5jZSkge1xuICAgIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywgJyRhdHRycycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICAgICAgd2Fybihgc2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywgJyRhdHRycycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBleHBvc2UgPSBleHBvc2VkID0+IHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZSBwZXIgc2V0dXAoKS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBvc2VkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXhwb3NlZFR5cGUgPSB0eXBlb2YgZXhwb3NlZDtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3NlZFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGV4cG9zZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VkVHlwZSA9ICdhcnJheSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYoZXhwb3NlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZWRUeXBlID0gJ3JlZic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9zZWRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBleHBvc2UoKSBzaG91bGQgYmUgcGFzc2VkIGEgcGxhaW4gb2JqZWN0LCByZWNlaXZlZCAke2V4cG9zZWRUeXBlfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuZXhwb3NlZCA9IGV4cG9zZWQgfHwge307XG4gICAgfTtcbiAgICBsZXQgYXR0cnM7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAvLyBXZSB1c2UgZ2V0dGVycyBpbiBkZXYgaW4gY2FzZSBsaWJzIGxpa2UgdGVzdC11dGlscyBvdmVyd3JpdGUgaW5zdGFuY2VcbiAgICAgICAgLy8gcHJvcGVydGllcyAob3ZlcndyaXRlcyBzaG91bGQgbm90IGJlIGRvbmUgaW4gcHJvZClcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycyB8fCAoYXR0cnMgPSBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2Uuc2xvdHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBlbWl0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4cG9zZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQgYXR0cnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzIHx8IChhdHRycyA9IGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90czogaW5zdGFuY2Uuc2xvdHMsXG4gICAgICAgICAgICBlbWl0OiBpbnN0YW5jZS5lbWl0LFxuICAgICAgICAgICAgZXhwb3NlXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RXhwb3NlUHJveHkoaW5zdGFuY2UpIHtcbiAgICBpZiAoaW5zdGFuY2UuZXhwb3NlZCkge1xuICAgICAgICByZXR1cm4gKGluc3RhbmNlLmV4cG9zZVByb3h5IHx8XG4gICAgICAgICAgICAoaW5zdGFuY2UuZXhwb3NlUHJveHkgPSBuZXcgUHJveHkocHJveHlSZWZzKG1hcmtSYXcoaW5zdGFuY2UuZXhwb3NlZCkpLCB7XG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNQcm9wZXJ0aWVzTWFwW2tleV0oaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleSBpbiB0YXJnZXQgfHwga2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG59XG5jb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuY29uc3QgY2xhc3NpZnkgPSAoc3RyKSA9PiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSkucmVwbGFjZSgvWy1fXS9nLCAnJyk7XG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCwgaW5jbHVkZUluZmVycmVkID0gdHJ1ZSkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKENvbXBvbmVudClcbiAgICAgICAgPyBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWVcbiAgICAgICAgOiBDb21wb25lbnQubmFtZSB8fCAoaW5jbHVkZUluZmVycmVkICYmIENvbXBvbmVudC5fX25hbWUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcbiAgICBsZXQgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KTtcbiAgICBpZiAoIW5hbWUgJiYgQ29tcG9uZW50Ll9fZmlsZSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuYW1lICYmIGluc3RhbmNlICYmIGluc3RhbmNlLnBhcmVudCkge1xuICAgICAgICAvLyB0cnkgdG8gaW5mZXIgdGhlIG5hbWUgYmFzZWQgb24gcmV2ZXJzZSByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IGluZmVyRnJvbVJlZ2lzdHJ5ID0gKHJlZ2lzdHJ5KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZWdpc3RyeSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG5hbWUgPVxuICAgICAgICAgICAgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuY29tcG9uZW50cyB8fFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudC50eXBlLmNvbXBvbmVudHMpIHx8IGluZmVyRnJvbVJlZ2lzdHJ5KGluc3RhbmNlLmFwcENvbnRleHQuY29tcG9uZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudCh2YWx1ZSkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiAnX192Y2NPcHRzJyBpbiB2YWx1ZTtcbn1cblxuY29uc3QgY29tcHV0ZWQgPSAoKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBjb21wdXRlZCQxKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xufSk7XG5cbi8vIGRldiBvbmx5XG5jb25zdCB3YXJuUnVudGltZVVzYWdlID0gKG1ldGhvZCkgPT4gd2FybihgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcbiAgICBgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGAgK1xuICAgIGBjb21waWxlZCBhd2F5IGFuZCBwYXNzaW5nIGl0IGF0IHJ1bnRpbWUgaGFzIG5vIGVmZmVjdC5gKTtcbi8vIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBkZWZpbmVQcm9wcygpIHtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGRlZmluZUVtaXRzKCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRW1pdHNgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBkZWNsYXJpbmcgYSBjb21wb25lbnQncyBleHBvc2VkXG4gKiBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gaXQgaXMgYWNjZXNzZWQgYnkgYSBwYXJlbnQgY29tcG9uZW50IHZpYSB0ZW1wbGF0ZVxuICogcmVmcy5cbiAqXG4gKiBgPHNjcmlwdCBzZXR1cD5gIGNvbXBvbmVudHMgYXJlIGNsb3NlZCBieSBkZWZhdWx0IC0gaS5lLiB2YXJpYWJsZXMgaW5zaWRlXG4gKiB0aGUgYDxzY3JpcHQgc2V0dXA+YCBzY29wZSBpcyBub3QgZXhwb3NlZCB0byBwYXJlbnQgdW5sZXNzIGV4cGxpY2l0bHkgZXhwb3NlZFxuICogdmlhIGBkZWZpbmVFeHBvc2VgLlxuICpcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlXG4gKiBvdXRwdXQgYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxuICovXG5mdW5jdGlvbiBkZWZpbmVFeHBvc2UoZXhwb3NlZCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgd2FyblJ1bnRpbWVVc2FnZShgZGVmaW5lRXhwb3NlYCk7XG4gICAgfVxufVxuLyoqXG4gKiBWdWUgYDxzY3JpcHQgc2V0dXA+YCBjb21waWxlciBtYWNybyBmb3IgcHJvdmlkaW5nIHByb3BzIGRlZmF1bHQgdmFsdWVzIHdoZW5cbiAqIHVzaW5nIHR5cGUtYmFzZWQgYGRlZmluZVByb3BzYCBkZWNsYXJhdGlvbi5cbiAqXG4gKiBFeGFtcGxlIHVzYWdlOlxuICogYGBgdHNcbiAqIHdpdGhEZWZhdWx0cyhkZWZpbmVQcm9wczx7XG4gKiAgIHNpemU/OiBudW1iZXJcbiAqICAgbGFiZWxzPzogc3RyaW5nW11cbiAqIH0+KCksIHtcbiAqICAgc2l6ZTogMyxcbiAqICAgbGFiZWxzOiAoKSA9PiBbJ2RlZmF1bHQgbGFiZWwnXVxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoaXMgaXMgb25seSB1c2FibGUgaW5zaWRlIGA8c2NyaXB0IHNldHVwPmAsIGlzIGNvbXBpbGVkIGF3YXkgaW4gdGhlIG91dHB1dFxuICogYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxuICovXG5mdW5jdGlvbiB3aXRoRGVmYXVsdHMocHJvcHMsIGRlZmF1bHRzKSB7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1c2VTbG90cygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xufVxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5hdHRycztcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgY29uc3QgaSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWkpIHtcbiAgICAgICAgd2FybihgdXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGkuc2V0dXBDb250ZXh0IHx8IChpLnNldHVwQ29udGV4dCA9IGNyZWF0ZVNldHVwQ29udGV4dChpKSk7XG59XG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIGRlZmF1bHQgZGVjbGFyYXRpb25zLiBJbXBvcnRlZCBieSBjb21waWxlZCBjb2RlXG4gKiBvbmx5LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHByb3BzID0gaXNBcnJheShyYXcpXG4gICAgICAgID8gcmF3LnJlZHVjZSgobm9ybWFsaXplZCwgcCkgPT4gKChub3JtYWxpemVkW3BdID0ge30pLCBub3JtYWxpemVkKSwge30pXG4gICAgICAgIDogcmF3O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cbi8qKlxuICogVXNlZCB0byBjcmVhdGUgYSBwcm94eSBmb3IgdGhlIHJlc3QgZWxlbWVudCB3aGVuIGRlc3RydWN0dXJpbmcgcHJvcHMgd2l0aFxuICogZGVmaW5lUHJvcHMoKS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9wc1Jlc3RQcm94eShwcm9wcywgZXhjbHVkZWRLZXlzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKCFleGNsdWRlZEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJldCwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHByb3BzW2tleV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vKipcbiAqIGA8c2NyaXB0IHNldHVwPmAgaGVscGVyIGZvciBwZXJzaXN0aW5nIHRoZSBjdXJyZW50IGluc3RhbmNlIGNvbnRleHQgb3ZlclxuICogYXN5bmMvYXdhaXQgZmxvd3MuXG4gKlxuICogYEB2dWUvY29tcGlsZXItc2ZjYCBjb252ZXJ0cyB0aGUgZm9sbG93aW5nOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCB4ID0gYXdhaXQgZm9vKClcbiAqIGBgYFxuICpcbiAqIGludG86XG4gKlxuICogYGBgdHNcbiAqIGxldCBfX3RlbXAsIF9fcmVzdG9yZVxuICogY29uc3QgeCA9ICgoW19fdGVtcCwgX19yZXN0b3JlXSA9IHdpdGhBc3luY0NvbnRleHQoKCkgPT4gZm9vKCkpKSxfX3RlbXA9YXdhaXQgX190ZW1wLF9fcmVzdG9yZSgpLF9fdGVtcClcbiAqIGBgYFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHdpdGhBc3luY0NvbnRleHQoZ2V0QXdhaXRhYmxlKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY3R4KSB7XG4gICAgICAgIHdhcm4oYHdpdGhBc3luY0NvbnRleHQgY2FsbGVkIHdpdGhvdXQgYWN0aXZlIGN1cnJlbnQgaW5zdGFuY2UuIGAgK1xuICAgICAgICAgICAgYFRoaXMgaXMgbGlrZWx5IGEgYnVnLmApO1xuICAgIH1cbiAgICBsZXQgYXdhaXRhYmxlID0gZ2V0QXdhaXRhYmxlKCk7XG4gICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICBpZiAoaXNQcm9taXNlKGF3YWl0YWJsZSkpIHtcbiAgICAgICAgYXdhaXRhYmxlID0gYXdhaXRhYmxlLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFthd2FpdGFibGUsICgpID0+IHNldEN1cnJlbnRJbnN0YW5jZShjdHgpXTtcbn1cblxuLy8gQWN0dWFsIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMikge1xuICAgICAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAvLyBzaW5nbGUgdm5vZGUgd2l0aG91dCBwcm9wc1xuICAgICAgICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9wcyB3aXRob3V0IGNoaWxkcmVuXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9taXQgcHJvcHNcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBwcm9wc09yQ2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobCA+IDMpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsID09PSAzICYmIGlzVk5vZGUoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pO1xuICAgIH1cbn1cblxuY29uc3Qgc3NyQ29udGV4dEtleSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBgc3NyQ29udGV4dGAgOiBgYCk7XG5jb25zdCB1c2VTU1JDb250ZXh0ID0gKCkgPT4ge1xuICAgIHtcbiAgICAgICAgY29uc3QgY3R4ID0gaW5qZWN0KHNzckNvbnRleHRLZXkpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgU2VydmVyIHJlbmRlcmluZyBjb250ZXh0IG5vdCBwcm92aWRlZC4gTWFrZSBzdXJlIHRvIG9ubHkgY2FsbCBgICtcbiAgICAgICAgICAgICAgICAgICAgYHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovXSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG4gICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2dWVTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojM2JhNzc2JyB9O1xuICAgIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMwYjFiYzknIH07XG4gICAgY29uc3Qgc3RyaW5nU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6I2I2MmUyNCcgfTtcbiAgICBjb25zdCBrZXl3b3JkU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzlkMjg4YycgfTtcbiAgICAvLyBjdXN0b20gZm9ybWF0dGVyIGZvciBDaHJvbWVcbiAgICAvLyBodHRwczovL3d3dy5tYXR0emV1bmVydC5jb20vMjAxNi8wMi8xOS9jdXN0b20tY2hyb21lLWRldnRvb2xzLW9iamVjdC1mb3JtYXR0ZXJzLmh0bWxcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSB7XG4gICAgICAgIGhlYWRlcihvYmopIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYWxzbyBmb3JtYXQgQ29tcG9uZW50UHVibGljSW5zdGFuY2UgJiBjdHguc2xvdHMvYXR0cnMgaW4gc2V0dXBcbiAgICAgICAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5fX2lzVnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXG4gICAgICAgICAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgYD5gXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gJ1NoYWxsb3dSZWFjdGl2ZScgOiAnUmVhY3RpdmUnXSxcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxuICAgICAgICAgICAgICAgICAgICBgPiR7aXNSZWFkb25seShvYmopID8gYCAocmVhZG9ubHkpYCA6IGBgfWBcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFkb25seShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyAnU2hhbGxvd1JlYWRvbmx5JyA6ICdSZWFkb25seSddLFxuICAgICAgICAgICAgICAgICAgICAnPCcsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iaiksXG4gICAgICAgICAgICAgICAgICAgICc+J1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQm9keShvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgb2JqLl9faXNWdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGJvZHkob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2lzVnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmb3JtYXRJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgaWYgKGluc3RhbmNlLnR5cGUucHJvcHMgJiYgaW5zdGFuY2UucHJvcHMpIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3Byb3BzJywgdG9SYXcoaW5zdGFuY2UucHJvcHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLnNldHVwU3RhdGUgIT09IEVNUFRZX09CSikge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnc2V0dXAnLCBpbnN0YW5jZS5zZXR1cFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbmNlLmRhdGEgIT09IEVNUFRZX09CSikge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnZGF0YScsIHRvUmF3KGluc3RhbmNlLmRhdGEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBleHRyYWN0S2V5cyhpbnN0YW5jZSwgJ2NvbXB1dGVkJyk7XG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnY29tcHV0ZWQnLCBjb21wdXRlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluamVjdGVkID0gZXh0cmFjdEtleXMoaW5zdGFuY2UsICdpbmplY3QnKTtcbiAgICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdpbmplY3RlZCcsIGluamVjdGVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2tzLnB1c2goW1xuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgJztvcGFjaXR5OjAuNjYnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJCAoaW50ZXJuYWwpOiAnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgWydvYmplY3QnLCB7IG9iamVjdDogaW5zdGFuY2UgfV1cbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBibG9ja3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQmxvY2sodHlwZSwgdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHt9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICB7IHN0eWxlOiAnbGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW0nIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOiM0NzY1ODInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdwYWRkaW5nLWxlZnQ6MS4yNWVtJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KS5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIGtleSArICc6ICddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgbnVtYmVyU3R5bGUsIHZdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHN0cmluZ1N0eWxlLCBKU09OLnN0cmluZ2lmeSh2KV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIGtleXdvcmRTdHlsZSwgdl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ29iamVjdCcsIHsgb2JqZWN0OiBhc1JhdyA/IHRvUmF3KHYpIDogdiB9XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgU3RyaW5nKHYpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBleHRyYWN0S2V5cyhpbnN0YW5jZSwgdHlwZSkge1xuICAgICAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oQ29tcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5zdGFuY2UuY3R4KSB7XG4gICAgICAgICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RlZFtrZXldID0gaW5zdGFuY2UuY3R4W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBDb21wW3R5cGVdO1xuICAgICAgICBpZiAoKGlzQXJyYXkob3B0cykgJiYgb3B0cy5pbmNsdWRlcyhrZXkpKSB8fFxuICAgICAgICAgICAgKGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKG0gPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlblJlZkZsYWcodikge1xuICAgICAgICBpZiAoaXNTaGFsbG93KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2LmVmZmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBSZWZgO1xuICAgIH1cbiAgICBpZiAod2luZG93LmRldnRvb2xzRm9ybWF0dGVycykge1xuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzLnB1c2goZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbZm9ybWF0dGVyXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHdpdGhNZW1vKG1lbW8sIHJlbmRlciwgY2FjaGUsIGluZGV4KSB7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbaW5kZXhdO1xuICAgIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHJlbmRlcigpO1xuICAgIC8vIHNoYWxsb3cgY2xvbmVcbiAgICByZXQubWVtbyA9IG1lbW8uc2xpY2UoKTtcbiAgICByZXR1cm4gKGNhY2hlW2luZGV4XSA9IHJldCk7XG59XG5mdW5jdGlvbiBpc01lbW9TYW1lKGNhY2hlZCwgbWVtbykge1xuICAgIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcbiAgICBpZiAocHJldi5sZW5ndGggIT0gbWVtby5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQocHJldltpXSwgbWVtb1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdG8gbGV0IHBhcmVudCBibG9jayB0cmFjayBpdCB3aGVuIHJldHVybmluZyBjYWNoZWRcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJiBjdXJyZW50QmxvY2spIHtcbiAgICAgICAgY3VycmVudEJsb2NrLnB1c2goY2FjaGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIENvcmUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgdmVyc2lvbiA9IFwiMy4yLjQ3XCI7XG5jb25zdCBfc3NyVXRpbHMgPSB7XG4gICAgY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UsXG4gICAgc2V0dXBDb21wb25lbnQsXG4gICAgcmVuZGVyQ29tcG9uZW50Um9vdCxcbiAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsXG4gICAgaXNWTm9kZSxcbiAgICBub3JtYWxpemVWTm9kZVxufTtcbi8qKlxuICogU1NSIHV0aWxzIGZvciBcXEB2dWUvc2VydmVyLXJlbmRlcmVyLiBPbmx5IGV4cG9zZWQgaW4gc3NyLXBvc3NpYmxlIGJ1aWxkcy5cbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBzc3JVdGlscyA9IChfc3NyVXRpbHMgKTtcbi8qKlxuICogQGludGVybmFsIG9ubHkgZXhwb3NlZCBpbiBjb21wYXQgYnVpbGRzXG4gKi9cbmNvbnN0IHJlc29sdmVGaWx0ZXIgPSBudWxsO1xuLyoqXG4gKiBAaW50ZXJuYWwgb25seSBleHBvc2VkIGluIGNvbXBhdCBidWlsZHMuXG4gKi9cbmNvbnN0IGNvbXBhdFV0aWxzID0gKG51bGwpO1xuXG5leHBvcnQgeyBCYXNlVHJhbnNpdGlvbiwgQ29tbWVudCwgRnJhZ21lbnQsIEtlZXBBbGl2ZSwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIGFzc2VydE51bWJlciwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2xvbmVWTm9kZSwgY29tcGF0VXRpbHMsIGNvbXB1dGVkLCBjcmVhdGVCbG9jaywgY3JlYXRlQ29tbWVudFZOb2RlLCBjcmVhdGVFbGVtZW50QmxvY2ssIGNyZWF0ZUJhc2VWTm9kZSBhcyBjcmVhdGVFbGVtZW50Vk5vZGUsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyLCBjcmVhdGVQcm9wc1Jlc3RQcm94eSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgZGVmaW5lQXN5bmNDb21wb25lbnQsIGRlZmluZUNvbXBvbmVudCwgZGVmaW5lRW1pdHMsIGRlZmluZUV4cG9zZSwgZGVmaW5lUHJvcHMsIGRldnRvb2xzLCBnZXRDdXJyZW50SW5zdGFuY2UsIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbiwgZ3VhcmRSZWFjdGl2ZVByb3BzLCBoLCBoYW5kbGVFcnJvciwgaW5pdEN1c3RvbUZvcm1hdHRlciwgaW5qZWN0LCBpc01lbW9TYW1lLCBpc1J1bnRpbWVPbmx5LCBpc1ZOb2RlLCBtZXJnZURlZmF1bHRzLCBtZXJnZVByb3BzLCBuZXh0VGljaywgb25BY3RpdmF0ZWQsIG9uQmVmb3JlTW91bnQsIG9uQmVmb3JlVW5tb3VudCwgb25CZWZvcmVVcGRhdGUsIG9uRGVhY3RpdmF0ZWQsIG9uRXJyb3JDYXB0dXJlZCwgb25Nb3VudGVkLCBvblJlbmRlclRyYWNrZWQsIG9uUmVuZGVyVHJpZ2dlcmVkLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHB1c2hTY29wZUlkLCBxdWV1ZVBvc3RGbHVzaENiLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyTGlzdCwgcmVuZGVyU2xvdCwgcmVzb2x2ZUNvbXBvbmVudCwgcmVzb2x2ZURpcmVjdGl2ZSwgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzc3JDb250ZXh0S2V5LCBzc3JVdGlscywgdG9IYW5kbGVycywgdHJhbnNmb3JtVk5vZGVBcmdzLCB1c2VBdHRycywgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdmVyc2lvbiwgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aE1lbW8sIHdpdGhTY29wZUlkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EffectScope\": () => (/* binding */ EffectScope),\n/* harmony export */   \"ITERATE_KEY\": () => (/* binding */ ITERATE_KEY),\n/* harmony export */   \"ReactiveEffect\": () => (/* binding */ ReactiveEffect),\n/* harmony export */   \"computed\": () => (/* binding */ computed),\n/* harmony export */   \"customRef\": () => (/* binding */ customRef),\n/* harmony export */   \"deferredComputed\": () => (/* binding */ deferredComputed),\n/* harmony export */   \"effect\": () => (/* binding */ effect),\n/* harmony export */   \"effectScope\": () => (/* binding */ effectScope),\n/* harmony export */   \"enableTracking\": () => (/* binding */ enableTracking),\n/* harmony export */   \"getCurrentScope\": () => (/* binding */ getCurrentScope),\n/* harmony export */   \"isProxy\": () => (/* binding */ isProxy),\n/* harmony export */   \"isReactive\": () => (/* binding */ isReactive),\n/* harmony export */   \"isReadonly\": () => (/* binding */ isReadonly),\n/* harmony export */   \"isRef\": () => (/* binding */ isRef),\n/* harmony export */   \"isShallow\": () => (/* binding */ isShallow),\n/* harmony export */   \"markRaw\": () => (/* binding */ markRaw),\n/* harmony export */   \"onScopeDispose\": () => (/* binding */ onScopeDispose),\n/* harmony export */   \"pauseTracking\": () => (/* binding */ pauseTracking),\n/* harmony export */   \"proxyRefs\": () => (/* binding */ proxyRefs),\n/* harmony export */   \"reactive\": () => (/* binding */ reactive),\n/* harmony export */   \"readonly\": () => (/* binding */ readonly),\n/* harmony export */   \"ref\": () => (/* binding */ ref),\n/* harmony export */   \"resetTracking\": () => (/* binding */ resetTracking),\n/* harmony export */   \"shallowReactive\": () => (/* binding */ shallowReactive),\n/* harmony export */   \"shallowReadonly\": () => (/* binding */ shallowReadonly),\n/* harmony export */   \"shallowRef\": () => (/* binding */ shallowRef),\n/* harmony export */   \"stop\": () => (/* binding */ stop),\n/* harmony export */   \"toRaw\": () => (/* binding */ toRaw),\n/* harmony export */   \"toRef\": () => (/* binding */ toRef),\n/* harmony export */   \"toRefs\": () => (/* binding */ toRefs),\n/* harmony export */   \"track\": () => (/* binding */ track),\n/* harmony export */   \"trigger\": () => (/* binding */ trigger),\n/* harmony export */   \"triggerRef\": () => (/* binding */ triggerRef),\n/* harmony export */   \"unref\": () => (/* binding */ unref)\n/* harmony export */ });\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\nfunction warn(msg, ...args) {\n    console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n    constructor(detached = false) {\n        this.detached = detached;\n        /**\n         * @internal\n         */\n        this._active = true;\n        /**\n         * @internal\n         */\n        this.effects = [];\n        /**\n         * @internal\n         */\n        this.cleanups = [];\n        this.parent = activeEffectScope;\n        if (!detached && activeEffectScope) {\n            this.index =\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n        }\n    }\n    get active() {\n        return this._active;\n    }\n    run(fn) {\n        if (this._active) {\n            const currentEffectScope = activeEffectScope;\n            try {\n                activeEffectScope = this;\n                return fn();\n            }\n            finally {\n                activeEffectScope = currentEffectScope;\n            }\n        }\n        else if ((true)) {\n            warn(`cannot run an inactive effect scope.`);\n        }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    on() {\n        activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    off() {\n        activeEffectScope = this.parent;\n    }\n    stop(fromParent) {\n        if (this._active) {\n            let i, l;\n            for (i = 0, l = this.effects.length; i < l; i++) {\n                this.effects[i].stop();\n            }\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\n                this.cleanups[i]();\n            }\n            if (this.scopes) {\n                for (i = 0, l = this.scopes.length; i < l; i++) {\n                    this.scopes[i].stop(true);\n                }\n            }\n            // nested scope, dereference from parent to avoid memory leaks\n            if (!this.detached && this.parent && !fromParent) {\n                // optimized O(1) removal\n                const last = this.parent.scopes.pop();\n                if (last && last !== this) {\n                    this.parent.scopes[this.index] = last;\n                    last.index = this.index;\n                }\n            }\n            this.parent = undefined;\n            this._active = false;\n        }\n    }\n}\nfunction effectScope(detached) {\n    return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n    if (scope && scope.active) {\n        scope.effects.push(effect);\n    }\n}\nfunction getCurrentScope() {\n    return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n    if (activeEffectScope) {\n        activeEffectScope.cleanups.push(fn);\n    }\n    else if ((true)) {\n        warn(`onScopeDispose() is called when there is no active effect scope` +\n            ` to be associated with.`);\n    }\n}\n\nconst createDep = (effects) => {\n    const dep = new Set(effects);\n    dep.w = 0;\n    dep.n = 0;\n    return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].w |= trackOpBit; // set was tracked\n        }\n    }\n};\nconst finalizeDepMarkers = (effect) => {\n    const { deps } = effect;\n    if (deps.length) {\n        let ptr = 0;\n        for (let i = 0; i < deps.length; i++) {\n            const dep = deps[i];\n            if (wasTracked(dep) && !newTracked(dep)) {\n                dep.delete(effect);\n            }\n            else {\n                deps[ptr++] = dep;\n            }\n            // clear bits\n            dep.w &= ~trackOpBit;\n            dep.n &= ~trackOpBit;\n        }\n        deps.length = ptr;\n    }\n};\n\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);\nconst MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);\nclass ReactiveEffect {\n    constructor(fn, scheduler = null, scope) {\n        this.fn = fn;\n        this.scheduler = scheduler;\n        this.active = true;\n        this.deps = [];\n        this.parent = undefined;\n        recordEffectScope(this, scope);\n    }\n    run() {\n        if (!this.active) {\n            return this.fn();\n        }\n        let parent = activeEffect;\n        let lastShouldTrack = shouldTrack;\n        while (parent) {\n            if (parent === this) {\n                return;\n            }\n            parent = parent.parent;\n        }\n        try {\n            this.parent = activeEffect;\n            activeEffect = this;\n            shouldTrack = true;\n            trackOpBit = 1 << ++effectTrackDepth;\n            if (effectTrackDepth <= maxMarkerBits) {\n                initDepMarkers(this);\n            }\n            else {\n                cleanupEffect(this);\n            }\n            return this.fn();\n        }\n        finally {\n            if (effectTrackDepth <= maxMarkerBits) {\n                finalizeDepMarkers(this);\n            }\n            trackOpBit = 1 << --effectTrackDepth;\n            activeEffect = this.parent;\n            shouldTrack = lastShouldTrack;\n            this.parent = undefined;\n            if (this.deferStop) {\n                this.stop();\n            }\n        }\n    }\n    stop() {\n        // stopped while running itself - defer the cleanup\n        if (activeEffect === this) {\n            this.deferStop = true;\n        }\n        else if (this.active) {\n            cleanupEffect(this);\n            if (this.onStop) {\n                this.onStop();\n            }\n            this.active = false;\n        }\n    }\n}\nfunction cleanupEffect(effect) {\n    const { deps } = effect;\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].delete(effect);\n        }\n        deps.length = 0;\n    }\n}\nfunction effect(fn, options) {\n    if (fn.effect) {\n        fn = fn.effect.fn;\n    }\n    const _effect = new ReactiveEffect(fn);\n    if (options) {\n        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)(_effect, options);\n        if (options.scope)\n            recordEffectScope(_effect, options.scope);\n    }\n    if (!options || !options.lazy) {\n        _effect.run();\n    }\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner;\n}\nfunction stop(runner) {\n    runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n}\nfunction enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n}\nfunction resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = createDep()));\n        }\n        const eventInfo = ( true)\n            ? { effect: activeEffect, target, type, key }\n            : 0;\n        trackEffects(dep, eventInfo);\n    }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n    let shouldTrack = false;\n    if (effectTrackDepth <= maxMarkerBits) {\n        if (!newTracked(dep)) {\n            dep.n |= trackOpBit; // set newly tracked\n            shouldTrack = !wasTracked(dep);\n        }\n    }\n    else {\n        // Full cleanup mode.\n        shouldTrack = !dep.has(activeEffect);\n    }\n    if (shouldTrack) {\n        dep.add(activeEffect);\n        activeEffect.deps.push(dep);\n        if (( true) && activeEffect.onTrack) {\n            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));\n        }\n    }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        // never been tracked\n        return;\n    }\n    let deps = [];\n    if (type === \"clear\" /* TriggerOpTypes.CLEAR */) {\n        // collection being cleared\n        // trigger all effects for target\n        deps = [...depsMap.values()];\n    }\n    else if (key === 'length' && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\n        const newLength = Number(newValue);\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || key >= newLength) {\n                deps.push(dep);\n            }\n        });\n    }\n    else {\n        // schedule runs for SET | ADD | DELETE\n        if (key !== void 0) {\n            deps.push(depsMap.get(key));\n        }\n        // also run for iteration key on ADD | DELETE | Map.SET\n        switch (type) {\n            case \"add\" /* TriggerOpTypes.ADD */:\n                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)) {\n                    // new index added to array -> length changes\n                    deps.push(depsMap.get('length'));\n                }\n                break;\n            case \"delete\" /* TriggerOpTypes.DELETE */:\n                if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                break;\n            case \"set\" /* TriggerOpTypes.SET */:\n                if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                }\n                break;\n        }\n    }\n    const eventInfo = ( true)\n        ? { target, type, key, newValue, oldValue, oldTarget }\n        : 0;\n    if (deps.length === 1) {\n        if (deps[0]) {\n            if ((true)) {\n                triggerEffects(deps[0], eventInfo);\n            }\n            else {}\n        }\n    }\n    else {\n        const effects = [];\n        for (const dep of deps) {\n            if (dep) {\n                effects.push(...dep);\n            }\n        }\n        if ((true)) {\n            triggerEffects(createDep(effects), eventInfo);\n        }\n        else {}\n    }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n    // spread into array for stabilization\n    const effects = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(dep) ? dep : [...dep];\n    for (const effect of effects) {\n        if (effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n    for (const effect of effects) {\n        if (!effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n}\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n    if (effect !== activeEffect || effect.allowRecurse) {\n        if (( true) && effect.onTrigger) {\n            effect.onTrigger((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({ effect }, debuggerEventExtraInfo));\n        }\n        if (effect.scheduler) {\n            effect.scheduler();\n        }\n        else {\n            effect.run();\n        }\n    }\n}\nfunction getDepFromReactive(object, key) {\n    var _a;\n    return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.makeMap)(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n/*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n    // function\n    .filter(key => key !== 'arguments' && key !== 'caller')\n    .map(key => Symbol[key])\n    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol));\nconst get$1 = /*#__PURE__*/ createGetter();\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n    const instrumentations = {};\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            const arr = toRaw(this);\n            for (let i = 0, l = this.length; i < l; i++) {\n                track(arr, \"get\" /* TrackOpTypes.GET */, i + '');\n            }\n            // we run the method using the original args first (which may be reactive)\n            const res = arr[key](...args);\n            if (res === -1 || res === false) {\n                // if that didn't work, run it again using raw values.\n                return arr[key](...args.map(toRaw));\n            }\n            else {\n                return res;\n            }\n        };\n    });\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            pauseTracking();\n            const res = toRaw(this)[key].apply(this, args);\n            resetTracking();\n            return res;\n        };\n    });\n    return instrumentations;\n}\nfunction hasOwnProperty(key) {\n    const obj = toRaw(this);\n    track(obj, \"has\" /* TrackOpTypes.HAS */, key);\n    return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */) {\n            return shallow;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */ &&\n            receiver ===\n                (isReadonly\n                    ? shallow\n                        ? shallowReadonlyMap\n                        : readonlyMap\n                    : shallow\n                        ? shallowReactiveMap\n                        : reactiveMap).get(target)) {\n            return target;\n        }\n        const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target);\n        if (!isReadonly) {\n            if (targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(arrayInstrumentations, key)) {\n                return Reflect.get(arrayInstrumentations, key, receiver);\n            }\n            if (key === 'hasOwnProperty') {\n                return hasOwnProperty;\n            }\n        }\n        const res = Reflect.get(target, key, receiver);\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n            return res;\n        }\n        if (!isReadonly) {\n            track(target, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        if (shallow) {\n            return res;\n        }\n        if (isRef(res)) {\n            // ref unwrapping - skip unwrap for Array + integer key.\n            return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key) ? res : res.value;\n        }\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {\n            // Convert returned value into a proxy as well. we do the isObject check\n            // here to avoid invalid value warning. Also need to lazy access readonly\n            // and reactive here to avoid circular dependency.\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n        return res;\n    };\n}\nconst set$1 = /*#__PURE__*/ createSetter();\nconst shallowSet = /*#__PURE__*/ createSetter(true);\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        let oldValue = target[key];\n        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n            return false;\n        }\n        if (!shallow) {\n            if (!isShallow(value) && !isReadonly(value)) {\n                oldValue = toRaw(oldValue);\n                value = toRaw(value);\n            }\n            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && isRef(oldValue) && !isRef(value)) {\n                oldValue.value = value;\n                return true;\n            }\n        }\n        const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isIntegerKey)(key)\n            ? Number(key) < target.length\n            : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);\n        const result = Reflect.set(target, key, value, receiver);\n        // don't trigger if target is something up in the prototype chain of original\n        if (target === toRaw(receiver)) {\n            if (!hadKey) {\n                trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n            }\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {\n                trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n            }\n        }\n        return result;\n    };\n}\nfunction deleteProperty(target, key) {\n    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction has$1(target, key) {\n    const result = Reflect.has(target, key);\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isSymbol)(key) || !builtInSymbols.has(key)) {\n        track(target, \"has\" /* TrackOpTypes.HAS */, key);\n    }\n    return result;\n}\nfunction ownKeys(target) {\n    track(target, \"iterate\" /* TrackOpTypes.ITERATE */, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(target) ? 'length' : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n    get: get$1,\n    set: set$1,\n    deleteProperty,\n    has: has$1,\n    ownKeys\n};\nconst readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n        if ((true)) {\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        if ((true)) {\n            warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.extend)({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n});\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\n    // of the value\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        track(rawTarget, \"get\" /* TrackOpTypes.GET */, rawKey);\n    }\n    const { has } = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n    }\n    else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n    }\n    else if (target !== rawTarget) {\n        // #3602 readonly(reactive(Map))\n        // ensure that the nested reactive `Map` can do tracking for itself\n        target.get(key);\n    }\n}\nfunction has(key, isReadonly = false) {\n    const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"has\" /* TrackOpTypes.HAS */, key);\n        }\n        track(rawTarget, \"has\" /* TrackOpTypes.HAS */, rawKey);\n    }\n    return key === rawKey\n        ? target.has(key)\n        : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    !isReadonly && track(toRaw(target), \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n    return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, value, value);\n    }\n    return this;\n}\nfunction set(key, value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((true)) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue)) {\n        trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n    }\n    return this;\n}\nfunction deleteEntry(key) {\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((true)) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get ? get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    const result = target.delete(key);\n    if (hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction clear() {\n    const target = toRaw(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = ( true)\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(target)\n            ? new Map(target)\n            : new Set(target)\n        : 0;\n    // forward the operation before queueing reactions\n    const result = target.clear();\n    if (hadItems) {\n        trigger(target, \"clear\" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\n    }\n    return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n    return function forEach(callback, thisArg) {\n        const observed = this;\n        const target = observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n        return target.forEach((value, key) => {\n            // important: make sure the callback is\n            // 1. invoked with the reactive map as `this` and 3rd arg\n            // 2. the value received should be a corresponding reactive/readonly.\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\n        });\n    };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n    return function (...args) {\n        const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isMap)(rawTarget);\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\n        const isKeyOnly = method === 'keys' && targetIsMap;\n        const innerIterator = target[method](...args);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly &&\n            track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n        // return a wrapped iterator which returns observed versions of the\n        // values emitted from the real iterator\n        return {\n            // iterator protocol\n            next() {\n                const { value, done } = innerIterator.next();\n                return done\n                    ? { value, done }\n                    : {\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n                        done\n                    };\n            },\n            // iterable protocol\n            [Symbol.iterator]() {\n                return this;\n            }\n        };\n    };\n}\nfunction createReadonlyMethod(type) {\n    return function (...args) {\n        if ((true)) {\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n            console.warn(`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n        }\n        return type === \"delete\" /* TriggerOpTypes.DELETE */ ? false : this;\n    };\n}\nfunction createInstrumentations() {\n    const mutableInstrumentations = {\n        get(key) {\n            return get(this, key);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, false)\n    };\n    const shallowInstrumentations = {\n        get(key) {\n            return get(this, key, false, true);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, true)\n    };\n    const readonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, false)\n    };\n    const shallowReadonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, true)\n    };\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n    iteratorMethods.forEach(method => {\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n    });\n    return [\n        mutableInstrumentations,\n        readonlyInstrumentations,\n        shallowInstrumentations,\n        shallowReadonlyInstrumentations\n    ];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n    const instrumentations = shallow\n        ? isReadonly\n            ? shallowReadonlyInstrumentations\n            : shallowInstrumentations\n        : isReadonly\n            ? readonlyInstrumentations\n            : mutableInstrumentations;\n    return (target, key, receiver) => {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */) {\n            return target;\n        }\n        return Reflect.get((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(instrumentations, key) && key in target\n            ? instrumentations\n            : target, key, receiver);\n    };\n}\nconst mutableCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n    const rawKey = toRaw(key);\n    if (rawKey !== key && has.call(target, rawKey)) {\n        const type = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(target);\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n            `which can lead to inconsistencies. ` +\n            `Avoid differentiating between the raw and reactive versions ` +\n            `of an object and only use the reactive version if possible.`);\n    }\n}\n\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return 1 /* TargetType.COMMON */;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return 2 /* TargetType.COLLECTION */;\n        default:\n            return 0 /* TargetType.INVALID */;\n    }\n}\nfunction getTargetType(value) {\n    return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value)\n        ? 0 /* TargetType.INVALID */\n        : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.toRawType)(value));\n}\nfunction reactive(target) {\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (isReadonly(target)) {\n        return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {\n        if ((true)) {\n            console.warn(`value cannot be made reactive: ${String(target)}`);\n        }\n        return target;\n    }\n    // target is already a Proxy, return it.\n    // exception: calling readonly() on a reactive object\n    if (target[\"__v_raw\" /* ReactiveFlags.RAW */] &&\n        !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\n        return target;\n    }\n    // target already has corresponding Proxy\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n        return existingProxy;\n    }\n    // only specific value types can be observed.\n    const targetType = getTargetType(target);\n    if (targetType === 0 /* TargetType.INVALID */) {\n        return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n}\nfunction isReactive(value) {\n    if (isReadonly(value)) {\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n    }\n    return !!(value && value[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */]);\n}\nfunction isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);\n}\nfunction isShallow(value) {\n    return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\nfunction isProxy(value) {\n    return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.def)(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n    return value;\n}\nconst toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? reactive(value) : value;\nconst toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n        if ((true)) {\n            trackEffects(ref.dep || (ref.dep = createDep()), {\n                target: ref,\n                type: \"get\" /* TrackOpTypes.GET */,\n                key: 'value'\n            });\n        }\n        else {}\n    }\n}\nfunction triggerRefValue(ref, newVal) {\n    ref = toRaw(ref);\n    const dep = ref.dep;\n    if (dep) {\n        if ((true)) {\n            triggerEffects(dep, {\n                target: ref,\n                type: \"set\" /* TriggerOpTypes.SET */,\n                key: 'value',\n                newValue: newVal\n            });\n        }\n        else {}\n    }\n}\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n    return createRef(value, false);\n}\nfunction shallowRef(value) {\n    return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n        this.__v_isShallow = __v_isShallow;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n    get value() {\n        trackRefValue(this);\n        return this._value;\n    }\n    set value(newVal) {\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n        newVal = useDirectValue ? newVal : toRaw(newVal);\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n            this._value = useDirectValue ? newVal : toReactive(newVal);\n            triggerRefValue(this, newVal);\n        }\n    }\n}\nfunction triggerRef(ref) {\n    triggerRefValue(ref, ( true) ? ref.value : 0);\n}\nfunction unref(ref) {\n    return isRef(ref) ? ref.value : ref;\n}\nconst shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n        const oldValue = target[key];\n        if (isRef(oldValue) && !isRef(value)) {\n            oldValue.value = value;\n            return true;\n        }\n        else {\n            return Reflect.set(target, key, value, receiver);\n        }\n    }\n};\nfunction proxyRefs(objectWithRefs) {\n    return isReactive(objectWithRefs)\n        ? objectWithRefs\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n    constructor(factory) {\n        this.dep = undefined;\n        this.__v_isRef = true;\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n        this._get = get;\n        this._set = set;\n    }\n    get value() {\n        return this._get();\n    }\n    set value(newVal) {\n        this._set(newVal);\n    }\n}\nfunction customRef(factory) {\n    return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n    if (( true) && !isProxy(object)) {\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isArray)(object) ? new Array(object.length) : {};\n    for (const key in object) {\n        ret[key] = toRef(object, key);\n    }\n    return ret;\n}\nclass ObjectRefImpl {\n    constructor(_object, _key, _defaultValue) {\n        this._object = _object;\n        this._key = _key;\n        this._defaultValue = _defaultValue;\n        this.__v_isRef = true;\n    }\n    get value() {\n        const val = this._object[this._key];\n        return val === undefined ? this._defaultValue : val;\n    }\n    set value(newVal) {\n        this._object[this._key] = newVal;\n    }\n    get dep() {\n        return getDepFromReactive(toRaw(this._object), this._key);\n    }\n}\nfunction toRef(object, key, defaultValue) {\n    const val = object[key];\n    return isRef(val)\n        ? val\n        : new ObjectRefImpl(object, key, defaultValue);\n}\n\nvar _a$1;\nclass ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        this._setter = _setter;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this[_a$1] = false;\n        this._dirty = true;\n        this.effect = new ReactiveEffect(getter, () => {\n            if (!this._dirty) {\n                this._dirty = true;\n                triggerRefValue(this);\n            }\n        });\n        this.effect.computed = this;\n        this.effect.active = this._cacheable = !isSSR;\n        this[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */] = isReadonly;\n    }\n    get value() {\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        const self = toRaw(this);\n        trackRefValue(self);\n        if (self._dirty || !self._cacheable) {\n            self._dirty = false;\n            self._value = self.effect.run();\n        }\n        return self._value;\n    }\n    set value(newValue) {\n        this._setter(newValue);\n    }\n}\n_a$1 = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    const onlyGetter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions);\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = ( true)\n            ? () => {\n                console.warn('Write operation failed: computed value is readonly');\n            }\n            : 0;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n    if (( true) && debugOptions && !isSSR) {\n        cRef.effect.onTrack = debugOptions.onTrack;\n        cRef.effect.onTrigger = debugOptions.onTrigger;\n    }\n    return cRef;\n}\n\nvar _a;\nconst tick = /*#__PURE__*/ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n    queue.push(fn);\n    if (!queued) {\n        queued = true;\n        tick.then(flush);\n    }\n};\nconst flush = () => {\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]();\n    }\n    queue.length = 0;\n    queued = false;\n};\nclass DeferredComputedRefImpl {\n    constructor(getter) {\n        this.dep = undefined;\n        this._dirty = true;\n        this.__v_isRef = true;\n        this[_a] = true;\n        let compareTarget;\n        let hasCompareTarget = false;\n        let scheduled = false;\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n            if (this.dep) {\n                if (computedTrigger) {\n                    compareTarget = this._value;\n                    hasCompareTarget = true;\n                }\n                else if (!scheduled) {\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n                    scheduled = true;\n                    hasCompareTarget = false;\n                    scheduler(() => {\n                        if (this.effect.active && this._get() !== valueToCompare) {\n                            triggerRefValue(this);\n                        }\n                        scheduled = false;\n                    });\n                }\n                // chained upstream computeds are notified synchronously to ensure\n                // value invalidation in case of sync access; normal effects are\n                // deferred to be triggered in scheduler.\n                for (const e of this.dep) {\n                    if (e.computed instanceof DeferredComputedRefImpl) {\n                        e.scheduler(true /* computedTrigger */);\n                    }\n                }\n            }\n            this._dirty = true;\n        });\n        this.effect.computed = this;\n    }\n    _get() {\n        if (this._dirty) {\n            this._dirty = false;\n            return (this._value = this.effect.run());\n        }\n        return this._value;\n    }\n    get value() {\n        trackRefValue(this);\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        return toRaw(this)._get();\n    }\n}\n_a = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction deferredComputed(getter) {\n    return new DeferredComputedRefImpl(getter);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvbm9kZV9tb2R1bGVzL0B2dWUvcmVhY3Rpdml0eS9kaXN0L3JlYWN0aXZpdHkuZXNtLWJ1bmRsZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0s7O0FBRWxLO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQXFDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBcUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFVO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0IsS0FBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsY0FBYyxDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0WSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtY29yZS9ub2RlX21vZHVsZXMvQHZ1ZS9yZWFjdGl2aXR5L2Rpc3QvcmVhY3Rpdml0eS5lc20tYnVuZGxlci5qcz82YTc1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4dGVuZCwgaXNBcnJheSwgaXNNYXAsIGlzSW50ZWdlcktleSwgaGFzT3duLCBpc1N5bWJvbCwgaXNPYmplY3QsIGhhc0NoYW5nZWQsIG1ha2VNYXAsIGNhcGl0YWxpemUsIHRvUmF3VHlwZSwgZGVmLCBpc0Z1bmN0aW9uLCBOT09QIH0gZnJvbSAnQHZ1ZS9zaGFyZWQnO1xuXG5mdW5jdGlvbiB3YXJuKG1zZywgLi4uYXJncykge1xuICAgIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcbn1cblxubGV0IGFjdGl2ZUVmZmVjdFNjb3BlO1xuY2xhc3MgRWZmZWN0U2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IGFjdGl2ZUVmZmVjdFNjb3BlO1xuICAgICAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID1cbiAgICAgICAgICAgICAgICAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2godGhpcykgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfVxuICAgIHJ1bihmbikge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSBjdXJyZW50RWZmZWN0U2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgb24oKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9mZigpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcbiAgICB9XG4gICAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgIGxldCBpLCBsO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5lc3RlZCBzY29wZSwgZGVyZWZlcmVuY2UgZnJvbSBwYXJlbnQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgTygxKSByZW1vdmFsXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBlZmZlY3RTY29wZShkZXRhY2hlZCkge1xuICAgIHJldHVybiBuZXcgRWZmZWN0U2NvcGUoZGV0YWNoZWQpO1xufVxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0U2NvcGUoZWZmZWN0LCBzY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlKSB7XG4gICAgaWYgKHNjb3BlICYmIHNjb3BlLmFjdGl2ZSkge1xuICAgICAgICBzY29wZS5lZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xufVxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4pIHtcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUuY2xlYW51cHMucHVzaChmbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICB3YXJuKGBvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGVgICtcbiAgICAgICAgICAgIGAgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmApO1xuICAgIH1cbn1cblxuY29uc3QgY3JlYXRlRGVwID0gKGVmZmVjdHMpID0+IHtcbiAgICBjb25zdCBkZXAgPSBuZXcgU2V0KGVmZmVjdHMpO1xuICAgIGRlcC53ID0gMDtcbiAgICBkZXAubiA9IDA7XG4gICAgcmV0dXJuIGRlcDtcbn07XG5jb25zdCB3YXNUcmFja2VkID0gKGRlcCkgPT4gKGRlcC53ICYgdHJhY2tPcEJpdCkgPiAwO1xuY29uc3QgbmV3VHJhY2tlZCA9IChkZXApID0+IChkZXAubiAmIHRyYWNrT3BCaXQpID4gMDtcbmNvbnN0IGluaXREZXBNYXJrZXJzID0gKHsgZGVwcyB9KSA9PiB7XG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVwc1tpXS53IHw9IHRyYWNrT3BCaXQ7IC8vIHNldCB3YXMgdHJhY2tlZFxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGZpbmFsaXplRGVwTWFya2VycyA9IChlZmZlY3QpID0+IHtcbiAgICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDtcbiAgICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHB0ciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGVwID0gZGVwc1tpXTtcbiAgICAgICAgICAgIGlmICh3YXNUcmFja2VkKGRlcCkgJiYgIW5ld1RyYWNrZWQoZGVwKSkge1xuICAgICAgICAgICAgICAgIGRlcC5kZWxldGUoZWZmZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHNbcHRyKytdID0gZGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xlYXIgYml0c1xuICAgICAgICAgICAgZGVwLncgJj0gfnRyYWNrT3BCaXQ7XG4gICAgICAgICAgICBkZXAubiAmPSB+dHJhY2tPcEJpdDtcbiAgICAgICAgfVxuICAgICAgICBkZXBzLmxlbmd0aCA9IHB0cjtcbiAgICB9XG59O1xuXG5jb25zdCB0YXJnZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuLy8gVGhlIG51bWJlciBvZiBlZmZlY3RzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkIHJlY3Vyc2l2ZWx5LlxubGV0IGVmZmVjdFRyYWNrRGVwdGggPSAwO1xubGV0IHRyYWNrT3BCaXQgPSAxO1xuLyoqXG4gKiBUaGUgYml0d2lzZSB0cmFjayBtYXJrZXJzIHN1cHBvcnQgYXQgbW9zdCAzMCBsZXZlbHMgb2YgcmVjdXJzaW9uLlxuICogVGhpcyB2YWx1ZSBpcyBjaG9zZW4gdG8gZW5hYmxlIG1vZGVybiBKUyBlbmdpbmVzIHRvIHVzZSBhIFNNSSBvbiBhbGwgcGxhdGZvcm1zLlxuICogV2hlbiByZWN1cnNpb24gZGVwdGggaXMgZ3JlYXRlciwgZmFsbCBiYWNrIHRvIHVzaW5nIGEgZnVsbCBjbGVhbnVwLlxuICovXG5jb25zdCBtYXhNYXJrZXJCaXRzID0gMzA7XG5sZXQgYWN0aXZlRWZmZWN0O1xuY29uc3QgSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ2l0ZXJhdGUnIDogJycpO1xuY29uc3QgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnTWFwIGtleSBpdGVyYXRlJyA6ICcnKTtcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihmbiwgc2NoZWR1bGVyID0gbnVsbCwgc2NvcGUpIHtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XG4gICAgICAgIGxldCBsYXN0U2hvdWxkVHJhY2sgPSBzaG91bGRUcmFjaztcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0O1xuICAgICAgICAgICAgYWN0aXZlRWZmZWN0ID0gdGhpcztcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8ICsrZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgICAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcbiAgICAgICAgICAgICAgICBpbml0RGVwTWFya2Vycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICAgICAgICAgIGZpbmFsaXplRGVwTWFya2Vycyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrT3BCaXQgPSAxIDw8IC0tZWZmZWN0VHJhY2tEZXB0aDtcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBsYXN0U2hvdWxkVHJhY2s7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmVyU3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIC8vIHN0b3BwZWQgd2hpbGUgcnVubmluZyBpdHNlbGYgLSBkZWZlciB0aGUgY2xlYW51cFxuICAgICAgICBpZiAoYWN0aXZlRWZmZWN0ID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVyU3RvcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vblN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZlY3QoZWZmZWN0KSB7XG4gICAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3Q7XG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVwc1tpXS5kZWxldGUoZWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBkZXBzLmxlbmd0aCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gZWZmZWN0KGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKGZuLmVmZmVjdCkge1xuICAgICAgICBmbiA9IGZuLmVmZmVjdC5mbjtcbiAgICB9XG4gICAgY29uc3QgX2VmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChmbik7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKF9lZmZlY3QsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5zY29wZSlcbiAgICAgICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKF9lZmZlY3QsIG9wdGlvbnMuc2NvcGUpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubGF6eSkge1xuICAgICAgICBfZWZmZWN0LnJ1bigpO1xuICAgIH1cbiAgICBjb25zdCBydW5uZXIgPSBfZWZmZWN0LnJ1bi5iaW5kKF9lZmZlY3QpO1xuICAgIHJ1bm5lci5lZmZlY3QgPSBfZWZmZWN0O1xuICAgIHJldHVybiBydW5uZXI7XG59XG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xuICAgIHJ1bm5lci5lZmZlY3Quc3RvcCgpO1xufVxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcbmNvbnN0IHRyYWNrU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHBhdXNlVHJhY2tpbmcoKSB7XG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgICBzaG91bGRUcmFjayA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZW5hYmxlVHJhY2tpbmcoKSB7XG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgICBzaG91bGRUcmFjayA9IHRydWU7XG59XG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xuICAgIHNob3VsZFRyYWNrID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGxhc3Q7XG59XG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xuICAgIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVFZmZlY3QpIHtcbiAgICAgICAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghZGVwc01hcCkge1xuICAgICAgICAgICAgdGFyZ2V0TWFwLnNldCh0YXJnZXQsIChkZXBzTWFwID0gbmV3IE1hcCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghZGVwKSB7XG4gICAgICAgICAgICBkZXBzTWFwLnNldChrZXksIChkZXAgPSBjcmVhdGVEZXAoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50SW5mbyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgICAgICAgICAgPyB7IGVmZmVjdDogYWN0aXZlRWZmZWN0LCB0YXJnZXQsIHR5cGUsIGtleSB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgdHJhY2tFZmZlY3RzKGRlcCwgZXZlbnRJbmZvKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFja0VmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gICAgbGV0IHNob3VsZFRyYWNrID0gZmFsc2U7XG4gICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xuICAgICAgICBpZiAoIW5ld1RyYWNrZWQoZGVwKSkge1xuICAgICAgICAgICAgZGVwLm4gfD0gdHJhY2tPcEJpdDsgLy8gc2V0IG5ld2x5IHRyYWNrZWRcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gIXdhc1RyYWNrZWQoZGVwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRnVsbCBjbGVhbnVwIG1vZGUuXG4gICAgICAgIHNob3VsZFRyYWNrID0gIWRlcC5oYXMoYWN0aXZlRWZmZWN0KTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFRyYWNrKSB7XG4gICAgICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcbiAgICAgICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGFjdGl2ZUVmZmVjdC5vblRyYWNrKSB7XG4gICAgICAgICAgICBhY3RpdmVFZmZlY3Qub25UcmFjayhPYmplY3QuYXNzaWduKHsgZWZmZWN0OiBhY3RpdmVFZmZlY3QgfSwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgICBjb25zdCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmICghZGVwc01hcCkge1xuICAgICAgICAvLyBuZXZlciBiZWVuIHRyYWNrZWRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVwcyA9IFtdO1xuICAgIGlmICh0eXBlID09PSBcImNsZWFyXCIgLyogVHJpZ2dlck9wVHlwZXMuQ0xFQVIgKi8pIHtcbiAgICAgICAgLy8gY29sbGVjdGlvbiBiZWluZyBjbGVhcmVkXG4gICAgICAgIC8vIHRyaWdnZXIgYWxsIGVmZmVjdHMgZm9yIHRhcmdldFxuICAgICAgICBkZXBzID0gWy4uLmRlcHNNYXAudmFsdWVzKCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBuZXdMZW5ndGggPSBOdW1iZXIobmV3VmFsdWUpO1xuICAgICAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbGVuZ3RoJyB8fCBrZXkgPj0gbmV3TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc2NoZWR1bGUgcnVucyBmb3IgU0VUIHwgQUREIHwgREVMRVRFXG4gICAgICAgIGlmIChrZXkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsc28gcnVuIGZvciBpdGVyYXRpb24ga2V5IG9uIEFERCB8IERFTEVURSB8IE1hcC5TRVRcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkXCIgLyogVHJpZ2dlck9wVHlwZXMuQUREICovOlxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgaW5kZXggYWRkZWQgdG8gYXJyYXkgLT4gbGVuZ3RoIGNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KCdsZW5ndGgnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLzpcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2V0XCIgLyogVHJpZ2dlck9wVHlwZXMuU0VUICovOlxuICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChJVEVSQVRFX0tFWSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBldmVudEluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgPyB7IHRhcmdldCwgdHlwZSwga2V5LCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG9sZFRhcmdldCB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoZGVwc1swXSkge1xuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0sIGV2ZW50SW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZWZmZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XG4gICAgICAgICAgICBpZiAoZGVwKSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKC4uLmRlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpLCBldmVudEluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3RzKGRlcCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbykge1xuICAgIC8vIHNwcmVhZCBpbnRvIGFycmF5IGZvciBzdGFiaWxpemF0aW9uXG4gICAgY29uc3QgZWZmZWN0cyA9IGlzQXJyYXkoZGVwKSA/IGRlcCA6IFsuLi5kZXBdO1xuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgaWYgKGVmZmVjdC5jb21wdXRlZCkge1xuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgaWYgKCFlZmZlY3QuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3QoZWZmZWN0LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3QoZWZmZWN0LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XG4gICAgaWYgKGVmZmVjdCAhPT0gYWN0aXZlRWZmZWN0IHx8IGVmZmVjdC5hbGxvd1JlY3Vyc2UpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBlZmZlY3Qub25UcmlnZ2VyKSB7XG4gICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyKGV4dGVuZCh7IGVmZmVjdCB9LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC5zY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIGVmZmVjdC5zY2hlZHVsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVmZmVjdC5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldERlcEZyb21SZWFjdGl2ZShvYmplY3QsIGtleSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGFyZ2V0TWFwLmdldChvYmplY3QpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGtleSk7XG59XG5cbmNvbnN0IGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgX19wcm90b19fLF9fdl9pc1JlZixfX2lzVnVlYCk7XG5jb25zdCBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoXG4vKiNfX1BVUkVfXyovXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpXG4gICAgLy8gaW9zMTAueCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpIGNhbiBlbnVtZXJhdGUgJ2FyZ3VtZW50cycgYW5kICdjYWxsZXInXG4gICAgLy8gYnV0IGFjY2Vzc2luZyB0aGVtIG9uIFN5bWJvbCBsZWFkcyB0byBUeXBlRXJyb3IgYmVjYXVzZSBTeW1ib2wgaXMgYSBzdHJpY3QgbW9kZVxuICAgIC8vIGZ1bmN0aW9uXG4gICAgLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAnYXJndW1lbnRzJyAmJiBrZXkgIT09ICdjYWxsZXInKVxuICAgIC5tYXAoa2V5ID0+IFN5bWJvbFtrZXldKVxuICAgIC5maWx0ZXIoaXNTeW1ib2wpKTtcbmNvbnN0IGdldCQxID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoKTtcbmNvbnN0IHNoYWxsb3dHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcihmYWxzZSwgdHJ1ZSk7XG5jb25zdCByZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIodHJ1ZSwgdHJ1ZSk7XG5jb25zdCBhcnJheUluc3RydW1lbnRhdGlvbnMgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpO1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCkge1xuICAgIGNvbnN0IGluc3RydW1lbnRhdGlvbnMgPSB7fTtcbiAgICBbJ2luY2x1ZGVzJywgJ2luZGV4T2YnLCAnbGFzdEluZGV4T2YnXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywgaSArICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIHJ1biB0aGUgbWV0aG9kIHVzaW5nIHRoZSBvcmlnaW5hbCBhcmdzIGZpcnN0ICh3aGljaCBtYXkgYmUgcmVhY3RpdmUpXG4gICAgICAgICAgICBjb25zdCByZXMgPSBhcnJba2V5XSguLi5hcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGF0IGRpZG4ndCB3b3JrLCBydW4gaXQgYWdhaW4gdXNpbmcgcmF3IHZhbHVlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyW2tleV0oLi4uYXJncy5tYXAodG9SYXcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICd1bnNoaWZ0JywgJ3NwbGljZSddLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRvUmF3KHRoaXMpW2tleV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBpbnN0cnVtZW50YXRpb25zO1xufVxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkoa2V5KSB7XG4gICAgY29uc3Qgb2JqID0gdG9SYXcodGhpcyk7XG4gICAgdHJhY2sob2JqLCBcImhhc1wiIC8qIFRyYWNrT3BUeXBlcy5IQVMgKi8sIGtleSk7XG4gICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpO1xufVxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBQ1RJVkUgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNSZWFkb25seTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1JFQURPTkxZICovKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfU0hBTExPVyAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqLyAmJlxuICAgICAgICAgICAgcmVjZWl2ZXIgPT09XG4gICAgICAgICAgICAgICAgKGlzUmVhZG9ubHlcbiAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dSZWFkb25seU1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFkb25seU1hcFxuICAgICAgICAgICAgICAgICAgICA6IHNoYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2hhbGxvd1JlYWN0aXZlTWFwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xuICAgICAgICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdoYXNPd25Qcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgaWYgKGlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNSZWFkb25seSkge1xuICAgICAgICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgICAgICAgIC8vIHJlZiB1bndyYXBwaW5nIC0gc2tpcCB1bndyYXAgZm9yIEFycmF5ICsgaW50ZWdlciBrZXkuXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCByZXR1cm5lZCB2YWx1ZSBpbnRvIGEgcHJveHkgYXMgd2VsbC4gd2UgZG8gdGhlIGlzT2JqZWN0IGNoZWNrXG4gICAgICAgICAgICAvLyBoZXJlIHRvIGF2b2lkIGludmFsaWQgdmFsdWUgd2FybmluZy4gQWxzbyBuZWVkIHRvIGxhenkgYWNjZXNzIHJlYWRvbmx5XG4gICAgICAgICAgICAvLyBhbmQgcmVhY3RpdmUgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5jb25zdCBzZXQkMSA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKCk7XG5jb25zdCBzaGFsbG93U2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIodHJ1ZSk7XG5mdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoaXNSZWFkb25seShvbGRWYWx1ZSkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSAmJiAhaXNSZWFkb25seSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpICYmIGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYWRLZXkgPSBpc0FycmF5KHRhcmdldCkgJiYgaXNJbnRlZ2VyS2V5KGtleSlcbiAgICAgICAgICAgID8gTnVtYmVyKGtleSkgPCB0YXJnZXQubGVuZ3RoXG4gICAgICAgICAgICA6IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICAvLyBkb24ndCB0cmlnZ2VyIGlmIHRhcmdldCBpcyBzb21ldGhpbmcgdXAgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvZiBvcmlnaW5hbFxuICAgICAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcbiAgICAgICAgICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogVHJpZ2dlck9wVHlwZXMuQUREICovLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLywga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImRlbGV0ZVwiIC8qIFRyaWdnZXJPcFR5cGVzLkRFTEVURSAqLywga2V5LCB1bmRlZmluZWQsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhcyQxKHRhcmdldCwga2V5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5oYXModGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcbiAgICAgICAgdHJhY2sodGFyZ2V0LCBcImhhc1wiIC8qIFRyYWNrT3BUeXBlcy5IQVMgKi8sIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICAgIHRyYWNrKHRhcmdldCwgXCJpdGVyYXRlXCIgLyogVHJhY2tPcFR5cGVzLklURVJBVEUgKi8sIGlzQXJyYXkodGFyZ2V0KSA/ICdsZW5ndGgnIDogSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbn1cbmNvbnN0IG11dGFibGVIYW5kbGVycyA9IHtcbiAgICBnZXQ6IGdldCQxLFxuICAgIHNldDogc2V0JDEsXG4gICAgZGVsZXRlUHJvcGVydHksXG4gICAgaGFzOiBoYXMkMSxcbiAgICBvd25LZXlzXG59O1xuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcbiAgICBnZXQ6IHJlYWRvbmx5R2V0LFxuICAgIHNldCh0YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB3YXJuKGBTZXQgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHdhcm4oYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcbiAgICBnZXQ6IHNoYWxsb3dHZXQsXG4gICAgc2V0OiBzaGFsbG93U2V0XG59KTtcbi8vIFByb3BzIGhhbmRsZXJzIGFyZSBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNob3VsZCBub3QgdW53cmFwIHRvcC1sZXZlbFxuLy8gcmVmcyAoaW4gb3JkZXIgdG8gYWxsb3cgcmVmcyB0byBiZSBleHBsaWNpdGx5IHBhc3NlZCBkb3duKSwgYnV0IHNob3VsZFxuLy8gcmV0YWluIHRoZSByZWFjdGl2aXR5IG9mIHRoZSBub3JtYWwgcmVhZG9ubHkgb2JqZWN0LlxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgcmVhZG9ubHlIYW5kbGVycywge1xuICAgIGdldDogc2hhbGxvd1JlYWRvbmx5R2V0XG59KTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmNvbnN0IGdldFByb3RvID0gKHYpID0+IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yodik7XG5mdW5jdGlvbiBnZXQodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcbiAgICAvLyAjMTc3MjogcmVhZG9ubHkocmVhY3RpdmUoTWFwKSkgc2hvdWxkIHJldHVybiByZWFkb25seSArIHJlYWN0aXZlIHZlcnNpb25cbiAgICAvLyBvZiB0aGUgdmFsdWVcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIgLyogVHJhY2tPcFR5cGVzLkdFVCAqLywgcmF3S2V5KTtcbiAgICB9XG4gICAgY29uc3QgeyBoYXMgfSA9IGdldFByb3RvKHJhd1RhcmdldCk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQoa2V5KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xuICAgICAgICAvLyAjMzYwMiByZWFkb25seShyZWFjdGl2ZShNYXApKVxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgbmVzdGVkIHJlYWN0aXZlIGBNYXBgIGNhbiBkbyB0cmFja2luZyBmb3IgaXRzZWxmXG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gICAgaWYgKCFpc1JlYWRvbmx5KSB7XG4gICAgICAgIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIFRyYWNrT3BUeXBlcy5IQVMgKi8sIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIFRyYWNrT3BUeXBlcy5IQVMgKi8sIHJhd0tleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXkgPT09IHJhd0tleVxuICAgICAgICA/IHRhcmdldC5oYXMoa2V5KVxuICAgICAgICA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG59XG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiAvKiBUcmFja09wVHlwZXMuSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsICdzaXplJywgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBjb25zdCBoYWRLZXkgPSBwcm90by5oYXMuY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIgLyogVHJpZ2dlck9wVHlwZXMuQUREICovLCB2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgICBsZXQgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XG4gICAgICAgIGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpO1xuICAgIH1cbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcbiAgICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICAgIGlmICghaGFkS2V5KSB7XG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBkZWxldGVFbnRyeShrZXkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XG4gICAgaWYgKCFoYWRLZXkpIHtcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdW5kZWZpbmVkO1xuICAgIC8vIGZvcndhcmQgdGhlIG9wZXJhdGlvbiBiZWZvcmUgcXVldWVpbmcgcmVhY3Rpb25zXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmRlbGV0ZShrZXkpO1xuICAgIGlmIChoYWRLZXkpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gICAgY29uc3QgaGFkSXRlbXMgPSB0YXJnZXQuc2l6ZSAhPT0gMDtcbiAgICBjb25zdCBvbGRUYXJnZXQgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgPyBpc01hcCh0YXJnZXQpXG4gICAgICAgICAgICA/IG5ldyBNYXAodGFyZ2V0KVxuICAgICAgICAgICAgOiBuZXcgU2V0KHRhcmdldClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcbiAgICBjb25zdCByZXN1bHQgPSB0YXJnZXQuY2xlYXIoKTtcbiAgICBpZiAoaGFkSXRlbXMpIHtcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiY2xlYXJcIiAvKiBUcmlnZ2VyT3BUeXBlcy5DTEVBUiAqLywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9sZFRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgICAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xuICAgICAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIFRyYWNrT3BUeXBlcy5JVEVSQVRFICovLCBJVEVSQVRFX0tFWSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gaW1wb3J0YW50OiBtYWtlIHN1cmUgdGhlIGNhbGxiYWNrIGlzXG4gICAgICAgICAgICAvLyAxLiBpbnZva2VkIHdpdGggdGhlIHJlYWN0aXZlIG1hcCBhcyBgdGhpc2AgYW5kIDNyZCBhcmdcbiAgICAgICAgICAgIC8vIDIuIHRoZSB2YWx1ZSByZWNlaXZlZCBzaG91bGQgYmUgYSBjb3JyZXNwb25kaW5nIHJlYWN0aXZlL3JlYWRvbmx5LlxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgd3JhcCh2YWx1ZSksIHdyYXAoa2V5KSwgb2JzZXJ2ZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL107XG4gICAgICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSAnZW50cmllcycgfHwgKG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwKTtcbiAgICAgICAgY29uc3QgaXNLZXlPbmx5ID0gbWV0aG9kID09PSAna2V5cycgJiYgdGFyZ2V0SXNNYXA7XG4gICAgICAgIGNvbnN0IGlubmVySXRlcmF0b3IgPSB0YXJnZXRbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAgICAgIWlzUmVhZG9ubHkgJiZcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogVHJhY2tPcFR5cGVzLklURVJBVEUgKi8sIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWSk7XG4gICAgICAgIC8vIHJldHVybiBhIHdyYXBwZWQgaXRlcmF0b3Igd2hpY2ggcmV0dXJucyBvYnNlcnZlZCB2ZXJzaW9ucyBvZiB0aGVcbiAgICAgICAgLy8gdmFsdWVzIGVtaXR0ZWQgZnJvbSB0aGUgcmVhbCBpdGVyYXRvclxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlLCBkb25lIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBpdGVyYWJsZSBwcm90b2NvbFxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NhcGl0YWxpemUodHlwZSl9IG9wZXJhdGlvbiAke2tleX1mYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0b1Jhdyh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovID8gZmFsc2UgOiB0aGlzO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCkge1xuICAgIGNvbnN0IG11dGFibGVJbnN0cnVtZW50YXRpb25zID0ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyxcbiAgICAgICAgYWRkLFxuICAgICAgICBzZXQsXG4gICAgICAgIGRlbGV0ZTogZGVsZXRlRW50cnksXG4gICAgICAgIGNsZWFyLFxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcbiAgICB9O1xuICAgIGNvbnN0IHNoYWxsb3dJbnN0cnVtZW50YXRpb25zID0ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMsXG4gICAgICAgIGFkZCxcbiAgICAgICAgc2V0LFxuICAgICAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgICAgICBjbGVhcixcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaChmYWxzZSwgdHJ1ZSlcbiAgICB9O1xuICAgIGNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzLmNhbGwodGhpcywga2V5LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLyksXG4gICAgICAgIHNldDogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8pLFxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogVHJpZ2dlck9wVHlwZXMuREVMRVRFICovKSxcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBUcmlnZ2VyT3BUeXBlcy5DTEVBUiAqLyksXG4gICAgICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2godHJ1ZSwgZmFsc2UpXG4gICAgfTtcbiAgICBjb25zdCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xuICAgICAgICBnZXQoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzaXplKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyhrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogVHJpZ2dlck9wVHlwZXMuQUREICovKSxcbiAgICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLyksXG4gICAgICAgIGRlbGV0ZTogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8pLFxuICAgICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIFRyaWdnZXJPcFR5cGVzLkNMRUFSICovKSxcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxuICAgIH07XG4gICAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gWydrZXlzJywgJ3ZhbHVlcycsICdlbnRyaWVzJywgU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpdGVyYXRvck1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgICBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1ttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMsXG4gICAgICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyxcbiAgICAgICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMsXG4gICAgICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcbiAgICBdO1xufVxuY29uc3QgW211dGFibGVJbnN0cnVtZW50YXRpb25zLCByZWFkb25seUluc3RydW1lbnRhdGlvbnMsIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXSA9IC8qICNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbnMoKTtcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHNoYWxsb3dcbiAgICAgICAgPyBpc1JlYWRvbmx5XG4gICAgICAgICAgICA/IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcbiAgICAgICAgICAgIDogc2hhbGxvd0luc3RydW1lbnRhdGlvbnNcbiAgICAgICAgOiBpc1JlYWRvbmx5XG4gICAgICAgICAgICA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xuICAgICAgICAgICAgOiBtdXRhYmxlSW5zdHJ1bWVudGF0aW9ucztcbiAgICByZXR1cm4gKHRhcmdldCwga2V5LCByZWNlaXZlcikgPT4ge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFDVElWRSAqLykge1xuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICAgICAgID8gaW5zdHJ1bWVudGF0aW9uc1xuICAgICAgICAgICAgOiB0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICAgIH07XG59XG5jb25zdCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcbn07XG5jb25zdCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxufTtcbmNvbnN0IHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSkge1xuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gICAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhcy5jYWxsKHRhcmdldCwgcmF3S2V5KSkge1xuICAgICAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIGAgK1xuICAgICAgICAgICAgYHZlcnNpb25zIG9mIHRoZSBzYW1lIG9iamVjdCR7dHlwZSA9PT0gYE1hcGAgPyBgIGFzIGtleXNgIDogYGB9LCBgICtcbiAgICAgICAgICAgIGB3aGljaCBjYW4gbGVhZCB0byBpbmNvbnNpc3RlbmNpZXMuIGAgK1xuICAgICAgICAgICAgYEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIGAgK1xuICAgICAgICAgICAgYG9mIGFuIG9iamVjdCBhbmQgb25seSB1c2UgdGhlIHJlYWN0aXZlIHZlcnNpb24gaWYgcG9zc2libGUuYCk7XG4gICAgfVxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBzaGFsbG93UmVhY3RpdmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVhZG9ubHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xuICAgIHN3aXRjaCAocmF3VHlwZSkge1xuICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBUYXJnZXRUeXBlLkNPTU1PTiAqLztcbiAgICAgICAgY2FzZSAnTWFwJzpcbiAgICAgICAgY2FzZSAnU2V0JzpcbiAgICAgICAgY2FzZSAnV2Vha01hcCc6XG4gICAgICAgIGNhc2UgJ1dlYWtTZXQnOlxuICAgICAgICAgICAgcmV0dXJuIDIgLyogVGFyZ2V0VHlwZS5DT0xMRUNUSU9OICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDAgLyogVGFyZ2V0VHlwZS5JTlZBTElEICovO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVbXCJfX3Zfc2tpcFwiIC8qIFJlYWN0aXZlRmxhZ3MuU0tJUCAqL10gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpXG4gICAgICAgID8gMCAvKiBUYXJnZXRUeXBlLklOVkFMSUQgKi9cbiAgICAgICAgOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XG4gICAgLy8gaWYgdHJ5aW5nIHRvIG9ic2VydmUgYSByZWFkb25seSBwcm94eSwgcmV0dXJuIHRoZSByZWFkb25seSB2ZXJzaW9uLlxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgZmFsc2UsIG11dGFibGVIYW5kbGVycywgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycywgcmVhY3RpdmVNYXApO1xufVxuLyoqXG4gKiBSZXR1cm4gYSBzaGFsbG93bHktcmVhY3RpdmUgY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290XG4gKiBsZXZlbCBwcm9wZXJ0aWVzIGFyZSByZWFjdGl2ZS4gSXQgYWxzbyBkb2VzIG5vdCBhdXRvLXVud3JhcCByZWZzIChldmVuIGF0IHRoZVxuICogcm9vdCBsZXZlbCkuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgc2hhbGxvd1JlYWN0aXZlSGFuZGxlcnMsIHNoYWxsb3dDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFjdGl2ZU1hcCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSByZWFkb25seSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QuIE5vdGUgdGhlIHJldHVybmVkIGNvcHkgaXMgbm90XG4gKiBtYWRlIHJlYWN0aXZlLCBidXQgYHJlYWRvbmx5YCBjYW4gYmUgY2FsbGVkIG9uIGFuIGFscmVhZHkgcmVhY3RpdmUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCB0cnVlLCByZWFkb25seUhhbmRsZXJzLCByZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgcmVhZG9ubHlNYXApO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcmVhY3RpdmUtY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290IGxldmVsXG4gKiBwcm9wZXJ0aWVzIGFyZSByZWFkb25seSwgYW5kIGRvZXMgTk9UIHVud3JhcCByZWZzIG5vciByZWN1cnNpdmVseSBjb252ZXJ0XG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxuICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGluZyB0aGUgcHJvcHMgcHJveHkgb2JqZWN0IGZvciBzdGF0ZWZ1bCBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgc2hhbGxvd1JlYWRvbmx5SGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seUNvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWRvbmx5TWFwKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seSwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgLy8gdGFyZ2V0IGlzIGFscmVhZHkgYSBQcm94eSwgcmV0dXJuIGl0LlxuICAgIC8vIGV4Y2VwdGlvbjogY2FsbGluZyByZWFkb25seSgpIG9uIGEgcmVhY3RpdmUgb2JqZWN0XG4gICAgaWYgKHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL10gJiZcbiAgICAgICAgIShpc1JlYWRvbmx5ICYmIHRhcmdldFtcIl9fdl9pc1JlYWN0aXZlXCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFDVElWRSAqL10pKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIHRhcmdldCBhbHJlYWR5IGhhcyBjb3JyZXNwb25kaW5nIFByb3h5XG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHByb3h5TWFwLmdldCh0YXJnZXQpO1xuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICAgIH1cbiAgICAvLyBvbmx5IHNwZWNpZmljIHZhbHVlIHR5cGVzIGNhbiBiZSBvYnNlcnZlZC5cbiAgICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRUeXBlID09PSAwIC8qIFRhcmdldFR5cGUuSU5WQUxJRCAqLykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHRhcmdldFR5cGUgPT09IDIgLyogVGFyZ2V0VHlwZS5DT0xMRUNUSU9OICovID8gY29sbGVjdGlvbkhhbmRsZXJzIDogYmFzZUhhbmRsZXJzKTtcbiAgICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL10pO1xuICAgIH1cbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBQ1RJVkUgKi9dKTtcbn1cbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi9dKTtcbn1cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZVtcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi9dKTtcbn1cbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xuICAgIGNvbnN0IHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcbiAgICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xufVxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiIC8qIFJlYWN0aXZlRmxhZ3MuU0tJUCAqLywgdHJ1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgdG9SZWFjdGl2ZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUodmFsdWUpIDogdmFsdWU7XG5jb25zdCB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcblxuZnVuY3Rpb24gdHJhY2tSZWZWYWx1ZShyZWYpIHtcbiAgICBpZiAoc2hvdWxkVHJhY2sgJiYgYWN0aXZlRWZmZWN0KSB7XG4gICAgICAgIHJlZiA9IHRvUmF3KHJlZik7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIHRyYWNrRWZmZWN0cyhyZWYuZGVwIHx8IChyZWYuZGVwID0gY3JlYXRlRGVwKCkpLCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFja0VmZmVjdHMocmVmLmRlcCB8fCAocmVmLmRlcCA9IGNyZWF0ZURlcCgpKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmVmFsdWUocmVmLCBuZXdWYWwpIHtcbiAgICByZWYgPSB0b1JhdyhyZWYpO1xuICAgIGNvbnN0IGRlcCA9IHJlZi5kZXA7XG4gICAgaWYgKGRlcCkge1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXAsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiIC8qIFRyaWdnZXJPcFR5cGVzLlNFVCAqLyxcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZScsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNSZWYocikge1xuICAgIHJldHVybiAhIShyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcbn1cbmZ1bmN0aW9uIHJlZih2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICAgIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZkltcGwocmF3VmFsdWUsIHNoYWxsb3cpO1xufVxuY2xhc3MgUmVmSW1wbCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIF9fdl9pc1NoYWxsb3cpIHtcbiAgICAgICAgdGhpcy5fX3ZfaXNTaGFsbG93ID0gX192X2lzU2hhbGxvdztcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBfX3ZfaXNTaGFsbG93ID8gdmFsdWUgOiB0b1Jhdyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX192X2lzU2hhbGxvdyA/IHZhbHVlIDogdG9SZWFjdGl2ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgdHJhY2tSZWZWYWx1ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICAgIGNvbnN0IHVzZURpcmVjdFZhbHVlID0gdGhpcy5fX3ZfaXNTaGFsbG93IHx8IGlzU2hhbGxvdyhuZXdWYWwpIHx8IGlzUmVhZG9ubHkobmV3VmFsKTtcbiAgICAgICAgbmV3VmFsID0gdXNlRGlyZWN0VmFsdWUgPyBuZXdWYWwgOiB0b1JhdyhuZXdWYWwpO1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZChuZXdWYWwsIHRoaXMuX3Jhd1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBuZXdWYWw7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHVzZURpcmVjdFZhbHVlID8gbmV3VmFsIDogdG9SZWFjdGl2ZShuZXdWYWwpO1xuICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMsIG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyUmVmKHJlZikge1xuICAgIHRyaWdnZXJSZWZWYWx1ZShyZWYsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHJlZi52YWx1ZSA6IHZvaWQgMCk7XG59XG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcbiAgICByZXR1cm4gaXNSZWYocmVmKSA/IHJlZi52YWx1ZSA6IHJlZjtcbn1cbmNvbnN0IHNoYWxsb3dVbndyYXBIYW5kbGVycyA9IHtcbiAgICBnZXQ6ICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHVucmVmKFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikpLFxuICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gcHJveHlSZWZzKG9iamVjdFdpdGhSZWZzKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpXG4gICAgICAgID8gb2JqZWN0V2l0aFJlZnNcbiAgICAgICAgOiBuZXcgUHJveHkob2JqZWN0V2l0aFJlZnMsIHNoYWxsb3dVbndyYXBIYW5kbGVycyk7XG59XG5jbGFzcyBDdXN0b21SZWZJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoKCkgPT4gdHJhY2tSZWZWYWx1ZSh0aGlzKSwgKCkgPT4gdHJpZ2dlclJlZlZhbHVlKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICAgICAgICB0aGlzLl9zZXQgPSBzZXQ7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldCgpO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICAgIHRoaXMuX3NldChuZXdWYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21SZWZJbXBsKGZhY3RvcnkpO1xufVxuZnVuY3Rpb24gdG9SZWZzKG9iamVjdCkge1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzUHJveHkob2JqZWN0KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5jbGFzcyBPYmplY3RSZWZJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5LCBfZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29iamVjdCA9IF9vYmplY3Q7XG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IF9kZWZhdWx0VmFsdWU7XG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gdW5kZWZpbmVkID8gdGhpcy5fZGVmYXVsdFZhbHVlIDogdmFsO1xuICAgIH1cbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICAgIHRoaXMuX29iamVjdFt0aGlzLl9rZXldID0gbmV3VmFsO1xuICAgIH1cbiAgICBnZXQgZGVwKCkge1xuICAgICAgICByZXR1cm4gZ2V0RGVwRnJvbVJlYWN0aXZlKHRvUmF3KHRoaXMuX29iamVjdCksIHRoaXMuX2tleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9SZWYob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xuICAgIHJldHVybiBpc1JlZih2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogbmV3IE9iamVjdFJlZkltcGwob2JqZWN0LCBrZXksIGRlZmF1bHRWYWx1ZSk7XG59XG5cbnZhciBfYSQxO1xuY2xhc3MgQ29tcHV0ZWRSZWZJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHksIGlzU1NSKSB7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IF9zZXR0ZXI7XG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XG4gICAgICAgIHRoaXNbX2EkMV0gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmVmZmVjdCA9IG5ldyBSZWFjdGl2ZUVmZmVjdChnZXR0ZXIsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZmZlY3QuY29tcHV0ZWQgPSB0aGlzO1xuICAgICAgICB0aGlzLmVmZmVjdC5hY3RpdmUgPSB0aGlzLl9jYWNoZWFibGUgPSAhaXNTU1I7XG4gICAgICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi9dID0gaXNSZWFkb25seTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAvLyB0aGUgY29tcHV0ZWQgcmVmIG1heSBnZXQgd3JhcHBlZCBieSBvdGhlciBwcm94aWVzIGUuZy4gcmVhZG9ubHkoKSAjMzM3NlxuICAgICAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XG4gICAgICAgIHRyYWNrUmVmVmFsdWUoc2VsZik7XG4gICAgICAgIGlmIChzZWxmLl9kaXJ0eSB8fCAhc2VsZi5fY2FjaGVhYmxlKSB7XG4gICAgICAgICAgICBzZWxmLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5fdmFsdWUgPSBzZWxmLmVmZmVjdC5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZShuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xuICAgIH1cbn1cbl9hJDEgPSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqLztcbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgc2V0dGVyO1xuICAgIGNvbnN0IG9ubHlHZXR0ZXIgPSBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucyk7XG4gICAgaWYgKG9ubHlHZXR0ZXIpIHtcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xuICAgICAgICBzZXR0ZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICAgICAgICAgID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogTk9PUDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucy5nZXQ7XG4gICAgICAgIHNldHRlciA9IGdldHRlck9yT3B0aW9ucy5zZXQ7XG4gICAgfVxuICAgIGNvbnN0IGNSZWYgPSBuZXcgQ29tcHV0ZWRSZWZJbXBsKGdldHRlciwgc2V0dGVyLCBvbmx5R2V0dGVyIHx8ICFzZXR0ZXIsIGlzU1NSKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGRlYnVnT3B0aW9ucyAmJiAhaXNTU1IpIHtcbiAgICAgICAgY1JlZi5lZmZlY3Qub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xuICAgICAgICBjUmVmLmVmZmVjdC5vblRyaWdnZXIgPSBkZWJ1Z09wdGlvbnMub25UcmlnZ2VyO1xuICAgIH1cbiAgICByZXR1cm4gY1JlZjtcbn1cblxudmFyIF9hO1xuY29uc3QgdGljayA9IC8qI19fUFVSRV9fKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5jb25zdCBxdWV1ZSA9IFtdO1xubGV0IHF1ZXVlZCA9IGZhbHNlO1xuY29uc3Qgc2NoZWR1bGVyID0gKGZuKSA9PiB7XG4gICAgcXVldWUucHVzaChmbik7XG4gICAgaWYgKCFxdWV1ZWQpIHtcbiAgICAgICAgcXVldWVkID0gdHJ1ZTtcbiAgICAgICAgdGljay50aGVuKGZsdXNoKTtcbiAgICB9XG59O1xuY29uc3QgZmx1c2ggPSAoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIHF1ZXVlZCA9IGZhbHNlO1xufTtcbmNsYXNzIERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5kZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xuICAgICAgICB0aGlzW19hXSA9IHRydWU7XG4gICAgICAgIGxldCBjb21wYXJlVGFyZ2V0O1xuICAgICAgICBsZXQgaGFzQ29tcGFyZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgKGNvbXB1dGVkVHJpZ2dlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVkVHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXJlVGFyZ2V0ID0gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbXBhcmVUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlVG9Db21wYXJlID0gaGFzQ29tcGFyZVRhcmdldCA/IGNvbXBhcmVUYXJnZXQgOiB0aGlzLl92YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29tcGFyZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZWZmZWN0LmFjdGl2ZSAmJiB0aGlzLl9nZXQoKSAhPT0gdmFsdWVUb0NvbXBhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoYWluZWQgdXBzdHJlYW0gY29tcHV0ZWRzIGFyZSBub3RpZmllZCBzeW5jaHJvbm91c2x5IHRvIGVuc3VyZVxuICAgICAgICAgICAgICAgIC8vIHZhbHVlIGludmFsaWRhdGlvbiBpbiBjYXNlIG9mIHN5bmMgYWNjZXNzOyBub3JtYWwgZWZmZWN0cyBhcmVcbiAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZCB0byBiZSB0cmlnZ2VyZWQgaW4gc2NoZWR1bGVyLlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLmRlcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jb21wdXRlZCBpbnN0YW5jZW9mIERlZmVycmVkQ29tcHV0ZWRSZWZJbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnNjaGVkdWxlcih0cnVlIC8qIGNvbXB1dGVkVHJpZ2dlciAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVmZmVjdC5jb21wdXRlZCA9IHRoaXM7XG4gICAgfVxuICAgIF9nZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fdmFsdWUgPSB0aGlzLmVmZmVjdC5ydW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHRyYWNrUmVmVmFsdWUodGhpcyk7XG4gICAgICAgIC8vIHRoZSBjb21wdXRlZCByZWYgbWF5IGdldCB3cmFwcGVkIGJ5IG90aGVyIHByb3hpZXMgZS5nLiByZWFkb25seSgpICMzMzc2XG4gICAgICAgIHJldHVybiB0b1Jhdyh0aGlzKS5fZ2V0KCk7XG4gICAgfVxufVxuX2EgPSBcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqLztcbmZ1bmN0aW9uIGRlZmVycmVkQ29tcHV0ZWQoZ2V0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZlcnJlZENvbXB1dGVkUmVmSW1wbChnZXR0ZXIpO1xufVxuXG5leHBvcnQgeyBFZmZlY3RTY29wZSwgSVRFUkFURV9LRVksIFJlYWN0aXZlRWZmZWN0LCBjb21wdXRlZCwgY3VzdG9tUmVmLCBkZWZlcnJlZENvbXB1dGVkLCBlZmZlY3QsIGVmZmVjdFNjb3BlLCBlbmFibGVUcmFja2luZywgZ2V0Q3VycmVudFNjb3BlLCBpc1Byb3h5LCBpc1JlYWN0aXZlLCBpc1JlYWRvbmx5LCBpc1JlZiwgaXNTaGFsbG93LCBtYXJrUmF3LCBvblNjb3BlRGlzcG9zZSwgcGF1c2VUcmFja2luZywgcHJveHlSZWZzLCByZWFjdGl2ZSwgcmVhZG9ubHksIHJlZiwgcmVzZXRUcmFja2luZywgc2hhbGxvd1JlYWN0aXZlLCBzaGFsbG93UmVhZG9ubHksIHNoYWxsb3dSZWYsIHN0b3AsIHRvUmF3LCB0b1JlZiwgdG9SZWZzLCB0cmFjaywgdHJpZ2dlciwgdHJpZ2dlclJlZiwgdW5yZWYgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_ARR\": () => (/* binding */ EMPTY_ARR),\n/* harmony export */   \"EMPTY_OBJ\": () => (/* binding */ EMPTY_OBJ),\n/* harmony export */   \"NO\": () => (/* binding */ NO),\n/* harmony export */   \"NOOP\": () => (/* binding */ NOOP),\n/* harmony export */   \"PatchFlagNames\": () => (/* binding */ PatchFlagNames),\n/* harmony export */   \"camelize\": () => (/* binding */ camelize),\n/* harmony export */   \"capitalize\": () => (/* binding */ capitalize),\n/* harmony export */   \"def\": () => (/* binding */ def),\n/* harmony export */   \"escapeHtml\": () => (/* binding */ escapeHtml),\n/* harmony export */   \"escapeHtmlComment\": () => (/* binding */ escapeHtmlComment),\n/* harmony export */   \"extend\": () => (/* binding */ extend),\n/* harmony export */   \"genPropsAccessExp\": () => (/* binding */ genPropsAccessExp),\n/* harmony export */   \"generateCodeFrame\": () => (/* binding */ generateCodeFrame),\n/* harmony export */   \"getGlobalThis\": () => (/* binding */ getGlobalThis),\n/* harmony export */   \"hasChanged\": () => (/* binding */ hasChanged),\n/* harmony export */   \"hasOwn\": () => (/* binding */ hasOwn),\n/* harmony export */   \"hyphenate\": () => (/* binding */ hyphenate),\n/* harmony export */   \"includeBooleanAttr\": () => (/* binding */ includeBooleanAttr),\n/* harmony export */   \"invokeArrayFns\": () => (/* binding */ invokeArrayFns),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"isBooleanAttr\": () => (/* binding */ isBooleanAttr),\n/* harmony export */   \"isBuiltInDirective\": () => (/* binding */ isBuiltInDirective),\n/* harmony export */   \"isDate\": () => (/* binding */ isDate),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isGloballyWhitelisted\": () => (/* binding */ isGloballyWhitelisted),\n/* harmony export */   \"isHTMLTag\": () => (/* binding */ isHTMLTag),\n/* harmony export */   \"isIntegerKey\": () => (/* binding */ isIntegerKey),\n/* harmony export */   \"isKnownHtmlAttr\": () => (/* binding */ isKnownHtmlAttr),\n/* harmony export */   \"isKnownSvgAttr\": () => (/* binding */ isKnownSvgAttr),\n/* harmony export */   \"isMap\": () => (/* binding */ isMap),\n/* harmony export */   \"isModelListener\": () => (/* binding */ isModelListener),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isOn\": () => (/* binding */ isOn),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"isRegExp\": () => (/* binding */ isRegExp),\n/* harmony export */   \"isReservedProp\": () => (/* binding */ isReservedProp),\n/* harmony export */   \"isSSRSafeAttrName\": () => (/* binding */ isSSRSafeAttrName),\n/* harmony export */   \"isSVGTag\": () => (/* binding */ isSVGTag),\n/* harmony export */   \"isSet\": () => (/* binding */ isSet),\n/* harmony export */   \"isSpecialBooleanAttr\": () => (/* binding */ isSpecialBooleanAttr),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"isSymbol\": () => (/* binding */ isSymbol),\n/* harmony export */   \"isVoidTag\": () => (/* binding */ isVoidTag),\n/* harmony export */   \"looseEqual\": () => (/* binding */ looseEqual),\n/* harmony export */   \"looseIndexOf\": () => (/* binding */ looseIndexOf),\n/* harmony export */   \"looseToNumber\": () => (/* binding */ looseToNumber),\n/* harmony export */   \"makeMap\": () => (/* binding */ makeMap),\n/* harmony export */   \"normalizeClass\": () => (/* binding */ normalizeClass),\n/* harmony export */   \"normalizeProps\": () => (/* binding */ normalizeProps),\n/* harmony export */   \"normalizeStyle\": () => (/* binding */ normalizeStyle),\n/* harmony export */   \"objectToString\": () => (/* binding */ objectToString),\n/* harmony export */   \"parseStringStyle\": () => (/* binding */ parseStringStyle),\n/* harmony export */   \"propsToAttrMap\": () => (/* binding */ propsToAttrMap),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"slotFlagsText\": () => (/* binding */ slotFlagsText),\n/* harmony export */   \"stringifyStyle\": () => (/* binding */ stringifyStyle),\n/* harmony export */   \"toDisplayString\": () => (/* binding */ toDisplayString),\n/* harmony export */   \"toHandlerKey\": () => (/* binding */ toHandlerKey),\n/* harmony export */   \"toNumber\": () => (/* binding */ toNumber),\n/* harmony export */   \"toRawType\": () => (/* binding */ toRawType),\n/* harmony export */   \"toTypeString\": () => (/* binding */ toTypeString)\n/* harmony export */ });\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    // Split the content into individual lines but capture the newline sequence\n    // that separated each line. This is important because the actual sequence is\n    // needed to properly take into account the full line length for offset\n    // comparison\n    let lines = source.split(/(\\r?\\n)/);\n    // Separate the lines and newline sequences into separate arrays for easier referencing\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n    lines = lines.filter((_, idx) => idx % 2 === 0);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count +=\n            lines[i].length +\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - (lineLength + newLineSeqLength));\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + newLineSeqLength;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\nfunction normalizeStyle(value) {\n    if (isArray(value)) {\n        const res = {};\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            const normalized = isString(item)\n                ? parseStringStyle(item)\n                : normalizeStyle(item);\n            if (normalized) {\n                for (const key in normalized) {\n                    res[key] = normalized[key];\n                }\n            }\n        }\n        return res;\n    }\n    else if (isString(value)) {\n        return value;\n    }\n    else if (isObject(value)) {\n        return value;\n    }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n    const ret = {};\n    cssText\n        .replace(styleCommentRE, '')\n        .split(listDelimiterRE)\n        .forEach(item => {\n        if (item) {\n            const tmp = item.split(propertyDelimiterRE);\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return ret;\n}\nfunction stringifyStyle(styles) {\n    let ret = '';\n    if (!styles || isString(styles)) {\n        return ret;\n    }\n    for (const key in styles) {\n        const value = styles[key];\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n        if (isString(value) || typeof value === 'number') {\n            // only render valid values\n            ret += `${normalizedKey}:${value};`;\n        }\n    }\n    return ret;\n}\nfunction normalizeClass(value) {\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value)) {\n        for (const name in value) {\n            if (value[name]) {\n                res += name + ' ';\n            }\n        }\n    }\n    return res.trim();\n}\nfunction normalizeProps(props) {\n    if (!props)\n        return null;\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n        props.class = normalizeClass(klass);\n    }\n    if (style) {\n        props.style = normalizeStyle(style);\n    }\n    return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n    'option,output,progress,select,textarea,details,dialog,menu,' +\n    'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n    'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n    return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n        return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n        console.error(`unsafe attribute name: ${name}`);\n    }\n    return (attrValidationCache[name] = !isUnsafe);\n}\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`);\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n    const str = '' + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n        return str;\n    }\n    let html = '';\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34: // \"\n                escaped = '&quot;';\n                break;\n            case 38: // &\n                escaped = '&amp;';\n                break;\n            case 39: // '\n                escaped = '&#39;';\n                break;\n            case 60: // <\n                escaped = '&lt;';\n                break;\n            case 62: // >\n                escaped = '&gt;';\n                break;\n            default:\n                continue;\n        }\n        if (lastIndex !== index) {\n            html += str.slice(lastIndex, index);\n        }\n        lastIndex = index + 1;\n        html += escaped;\n    }\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n    return src.replace(commentStripRE, '');\n}\n\nfunction looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n        equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n}\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isSymbol(a);\n    bValidType = isSymbol(b);\n    if (aValidType || bValidType) {\n        return a === b;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n        /* istanbul ignore if: this if will probably never be called */\n        if (!aValidType || !bValidType) {\n            return false;\n        }\n        const aKeysCount = Object.keys(a).length;\n        const bKeysCount = Object.keys(b).length;\n        if (aKeysCount !== bKeysCount) {\n            return false;\n        }\n        for (const key in a) {\n            const aHasKey = a.hasOwnProperty(key);\n            const bHasKey = b.hasOwnProperty(key);\n            if ((aHasKey && !bHasKey) ||\n                (!aHasKey && bHasKey) ||\n                !looseEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n    }\n    return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n    return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = (val) => {\n    return isString(val)\n        ? val\n        : val == null\n            ? ''\n            : isArray(val) ||\n                (isObject(val) &&\n                    (val.toString === objectToString || !isFunction(val.toString)))\n                ? JSON.stringify(val, replacer, 2)\n                : String(val);\n};\nconst replacer = (_key, val) => {\n    // can't use isRef here since @vue/shared has no deps\n    if (val && val.__v_isRef) {\n        return replacer(_key, val.value);\n    }\n    else if (isMap(val)) {\n        return {\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                entries[`${key} =>`] = val;\n                return entries;\n            }, {})\n        };\n    }\n    else if (isSet(val)) {\n        return {\n            [`Set(${val.size})`]: [...val.values()]\n        };\n    }\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n        return String(val);\n    }\n    return val;\n};\n\nconst EMPTY_OBJ = ( true)\n    ? Object.freeze({})\n    : 0;\nconst EMPTY_ARR = ( true) ? Object.freeze([]) : 0;\nconst NOOP = () => { };\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === '[object Map]';\nconst isSet = (val) => toTypeString(val) === '[object Set]';\nconst isDate = (val) => toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\nconst isFunction = (val) => typeof val === 'function';\nconst isString = (val) => typeof val === 'string';\nconst isSymbol = (val) => typeof val === 'symbol';\nconst isObject = (val) => val !== null && typeof val === 'object';\nconst isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\nconst isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\nconst def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = (val) => {\n    const n = isString(val) ? Number(val) : NaN;\n    return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof __webpack_require__.g !== 'undefined'\n                            ? __webpack_require__.g\n                            : {}));\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n    return identRE.test(name)\n        ? `__props.${name}`\n        : `__props[${JSON.stringify(name)}]`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWNvcmUvbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssRUFBRSxpREFBaUQsS0FBSyxTQUFTO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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cUJBQXFCLHFCQUFxQjtBQUMxQzs7QUFFdXpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B2dWUvcnVudGltZS1jb3JlL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcz9lMTZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqIElNUE9SVEFOVDogYWxsIGNhbGxzIG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBwcmVmaXhlZCB3aXRoXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xuICogU28gdGhhdCByb2xsdXAgY2FuIHRyZWUtc2hha2UgdGhlbSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xufVxuXG4vKipcbiAqIGRldiBvbmx5IGZsYWcgLT4gbmFtZSBtYXBwaW5nXG4gKi9cbmNvbnN0IFBhdGNoRmxhZ05hbWVzID0ge1xuICAgIFsxIC8qIFBhdGNoRmxhZ3MuVEVYVCAqL106IGBURVhUYCxcbiAgICBbMiAvKiBQYXRjaEZsYWdzLkNMQVNTICovXTogYENMQVNTYCxcbiAgICBbNCAvKiBQYXRjaEZsYWdzLlNUWUxFICovXTogYFNUWUxFYCxcbiAgICBbOCAvKiBQYXRjaEZsYWdzLlBST1BTICovXTogYFBST1BTYCxcbiAgICBbMTYgLyogUGF0Y2hGbGFncy5GVUxMX1BST1BTICovXTogYEZVTExfUFJPUFNgLFxuICAgIFszMiAvKiBQYXRjaEZsYWdzLkhZRFJBVEVfRVZFTlRTICovXTogYEhZRFJBVEVfRVZFTlRTYCxcbiAgICBbNjQgLyogUGF0Y2hGbGFncy5TVEFCTEVfRlJBR01FTlQgKi9dOiBgU1RBQkxFX0ZSQUdNRU5UYCxcbiAgICBbMTI4IC8qIFBhdGNoRmxhZ3MuS0VZRURfRlJBR01FTlQgKi9dOiBgS0VZRURfRlJBR01FTlRgLFxuICAgIFsyNTYgLyogUGF0Y2hGbGFncy5VTktFWUVEX0ZSQUdNRU5UICovXTogYFVOS0VZRURfRlJBR01FTlRgLFxuICAgIFs1MTIgLyogUGF0Y2hGbGFncy5ORUVEX1BBVENIICovXTogYE5FRURfUEFUQ0hgLFxuICAgIFsxMDI0IC8qIFBhdGNoRmxhZ3MuRFlOQU1JQ19TTE9UUyAqL106IGBEWU5BTUlDX1NMT1RTYCxcbiAgICBbMjA0OCAvKiBQYXRjaEZsYWdzLkRFVl9ST09UX0ZSQUdNRU5UICovXTogYERFVl9ST09UX0ZSQUdNRU5UYCxcbiAgICBbLTEgLyogUGF0Y2hGbGFncy5IT0lTVEVEICovXTogYEhPSVNURURgLFxuICAgIFstMiAvKiBQYXRjaEZsYWdzLkJBSUwgKi9dOiBgQkFJTGBcbn07XG5cbi8qKlxuICogRGV2IG9ubHlcbiAqL1xuY29uc3Qgc2xvdEZsYWdzVGV4dCA9IHtcbiAgICBbMSAvKiBTbG90RmxhZ3MuU1RBQkxFICovXTogJ1NUQUJMRScsXG4gICAgWzIgLyogU2xvdEZsYWdzLkRZTkFNSUMgKi9dOiAnRFlOQU1JQycsXG4gICAgWzMgLyogU2xvdEZsYWdzLkZPUldBUkRFRCAqL106ICdGT1JXQVJERUQnXG59O1xuXG5jb25zdCBHTE9CQUxTX1dISVRFX0xJU1RFRCA9ICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLHBhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLCcgK1xuICAgICdkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCxNYXRoLE51bWJlcixEYXRlLEFycmF5LCcgK1xuICAgICdPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCc7XG5jb25zdCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoR0xPQkFMU19XSElURV9MSVNURUQpO1xuXG5jb25zdCByYW5nZSA9IDI7XG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZShzb3VyY2UsIHN0YXJ0ID0gMCwgZW5kID0gc291cmNlLmxlbmd0aCkge1xuICAgIC8vIFNwbGl0IHRoZSBjb250ZW50IGludG8gaW5kaXZpZHVhbCBsaW5lcyBidXQgY2FwdHVyZSB0aGUgbmV3bGluZSBzZXF1ZW5jZVxuICAgIC8vIHRoYXQgc2VwYXJhdGVkIGVhY2ggbGluZS4gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgYWN0dWFsIHNlcXVlbmNlIGlzXG4gICAgLy8gbmVlZGVkIHRvIHByb3Blcmx5IHRha2UgaW50byBhY2NvdW50IHRoZSBmdWxsIGxpbmUgbGVuZ3RoIGZvciBvZmZzZXRcbiAgICAvLyBjb21wYXJpc29uXG4gICAgbGV0IGxpbmVzID0gc291cmNlLnNwbGl0KC8oXFxyP1xcbikvKTtcbiAgICAvLyBTZXBhcmF0ZSB0aGUgbGluZXMgYW5kIG5ld2xpbmUgc2VxdWVuY2VzIGludG8gc2VwYXJhdGUgYXJyYXlzIGZvciBlYXNpZXIgcmVmZXJlbmNpbmdcbiAgICBjb25zdCBuZXdsaW5lU2VxdWVuY2VzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDEpO1xuICAgIGxpbmVzID0gbGluZXMuZmlsdGVyKChfLCBpZHgpID0+IGlkeCAlIDIgPT09IDApO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb3VudCArPVxuICAgICAgICAgICAgbGluZXNbaV0ubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAoKG5ld2xpbmVTZXF1ZW5jZXNbaV0gJiYgbmV3bGluZVNlcXVlbmNlc1tpXS5sZW5ndGgpIHx8IDApO1xuICAgICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBqICsgMTtcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtsaW5lfSR7JyAnLnJlcGVhdChNYXRoLm1heCgzIC0gU3RyaW5nKGxpbmUpLmxlbmd0aCwgMCkpfXwgICR7bGluZXNbal19YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lU2VxTGVuZ3RoID0gKG5ld2xpbmVTZXF1ZW5jZXNbal0gJiYgbmV3bGluZVNlcXVlbmNlc1tqXS5sZW5ndGgpIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSAobGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoMSwgZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICcgJy5yZXBlYXQocGFkKSArICdeJy5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZSh2YWx1ZSkge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGlzU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgICAgPyBwYXJzZVN0cmluZ1N0eWxlKGl0ZW0pXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5jb25zdCBsaXN0RGVsaW1pdGVyUkUgPSAvOyg/IVteKF0qXFwpKS9nO1xuY29uc3QgcHJvcGVydHlEZWxpbWl0ZXJSRSA9IC86KFteXSspLztcbmNvbnN0IHN0eWxlQ29tbWVudFJFID0gL1xcL1xcKi4qP1xcKlxcLy9ncztcbmZ1bmN0aW9uIHBhcnNlU3RyaW5nU3R5bGUoY3NzVGV4dCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGNzc1RleHRcbiAgICAgICAgLnJlcGxhY2Uoc3R5bGVDb21tZW50UkUsICcnKVxuICAgICAgICAuc3BsaXQobGlzdERlbGltaXRlclJFKVxuICAgICAgICAuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXJSRSk7XG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmV0W3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3R5bGUoc3R5bGVzKSB7XG4gICAgbGV0IHJldCA9ICcnO1xuICAgIGlmICghc3R5bGVzIHx8IGlzU3RyaW5nKHN0eWxlcykpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBrZXkuc3RhcnRzV2l0aChgLS1gKSA/IGtleSA6IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVuZGVyIHZhbGlkIHZhbHVlc1xuICAgICAgICAgICAgcmV0ICs9IGAke25vcm1hbGl6ZWRLZXl9OiR7dmFsdWV9O2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzKHZhbHVlKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmVzID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBub3JtYWxpemVkICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlcyArPSBuYW1lICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMudHJpbSgpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcbiAgICBpZiAoa2xhc3MgJiYgIWlzU3RyaW5nKGtsYXNzKSkge1xuICAgICAgICBwcm9wcy5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKGtsYXNzKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIHByb3BzLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cbi8vIFRoZXNlIHRhZyBjb25maWdzIGFyZSBzaGFyZWQgYmV0d2VlbiBjb21waWxlci1kb20gYW5kIHJ1bnRpbWUtZG9tLCBzbyB0aGV5XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcbmNvbnN0IEhUTUxfVEFHUyA9ICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLCcgK1xuICAgICdoZWFkZXIsaGdyb3VwLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xuICAgICdmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCxhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSwnICtcbiAgICAnZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsJyArXG4gICAgJ3RpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsJyArXG4gICAgJ2NhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCwnICtcbiAgICAndGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLCcgK1xuICAgICdvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LCcgK1xuICAgICdzdW1tYXJ5LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290Jztcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50XG5jb25zdCBTVkdfVEFHUyA9ICdzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsJyArXG4gICAgJ2RlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsJyArXG4gICAgJ2ZlQ29tcG9zaXRlLGZlQ29udm9sdmVNYXRyaXgsZmVEaWZmdXNlTGlnaHRpbmcsZmVEaXNwbGFjZW1lbnRNYXAsJyArXG4gICAgJ2ZlRGlzdGFudExpZ2h0LGZlRHJvcFNoYWRvdyxmZUZsb29kLGZlRnVuY0EsZmVGdW5jQixmZUZ1bmNHLGZlRnVuY1IsJyArXG4gICAgJ2ZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsJyArXG4gICAgJ2ZlUG9pbnRMaWdodCxmZVNwZWN1bGFyTGlnaHRpbmcsZmVTcG90TGlnaHQsZmVUaWxlLGZlVHVyYnVsZW5jZSxmaWx0ZXIsJyArXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxoYXRjaCxoYXRjaHBhdGgsaW1hZ2UsbGluZSxsaW5lYXJHcmFkaWVudCxtYXJrZXIsbWFzaywnICtcbiAgICAnbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLCcgK1xuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJhZGlhbEdyYWRpZW50LHJlY3Qsc2V0LHNvbGlkY29sb3Isc3RvcCxzd2l0Y2gsc3ltYm9sLCcgK1xuICAgICd0ZXh0LHRleHRQYXRoLHRpdGxlLHRzcGFuLHVua25vd24sdXNlLHZpZXcnO1xuY29uc3QgVk9JRF9UQUdTID0gJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJztcbi8qKlxuICogQ29tcGlsZXIgb25seS5cbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cbiAqL1xuY29uc3QgaXNIVE1MVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEhUTUxfVEFHUyk7XG4vKipcbiAqIENvbXBpbGVyIG9ubHkuXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXG4gKi9cbmNvbnN0IGlzU1ZHVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFNWR19UQUdTKTtcbi8qKlxuICogQ29tcGlsZXIgb25seS5cbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cbiAqL1xuY29uc3QgaXNWb2lkVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFZPSURfVEFHUyk7XG5cbi8qKlxuICogT24gdGhlIGNsaWVudCB3ZSBvbmx5IG5lZWQgdG8gb2ZmZXIgc3BlY2lhbCBjYXNlcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXRcbiAqIGhhdmUgZGlmZmVyZW50IG5hbWVzIGZyb20gdGhlaXIgY29ycmVzcG9uZGluZyBkb20gcHJvcGVydGllczpcbiAqIC0gaXRlbXNjb3BlIC0+IE4vQVxuICogLSBhbGxvd2Z1bGxzY3JlZW4gLT4gYWxsb3dGdWxsc2NyZWVuXG4gKiAtIGZvcm1ub3ZhbGlkYXRlIC0+IGZvcm1Ob1ZhbGlkYXRlXG4gKiAtIGlzbWFwIC0+IGlzTWFwXG4gKiAtIG5vbW9kdWxlIC0+IG5vTW9kdWxlXG4gKiAtIG5vdmFsaWRhdGUgLT4gbm9WYWxpZGF0ZVxuICogLSByZWFkb25seSAtPiByZWFkT25seVxuICovXG5jb25zdCBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcbi8qKlxuICogVGhlIGZ1bGwgbGlzdCBpcyBuZWVkZWQgZHVyaW5nIFNTUiB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGluaXRpYWwgbWFya3VwLlxuICovXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMgK1xuICAgIGAsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGAgK1xuICAgIGBsb29wLG9wZW4scmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLGAgK1xuICAgIGBjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XG4vKipcbiAqIEJvb2xlYW4gYXR0cmlidXRlcyBzaG91bGQgYmUgaW5jbHVkZWQgaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBvciAnJy5cbiAqIGUuZy4gYDxzZWxlY3QgbXVsdGlwbGU+YCBjb21waWxlcyB0byBgeyBtdWx0aXBsZTogJycgfWBcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgfHwgdmFsdWUgPT09ICcnO1xufVxuY29uc3QgdW5zYWZlQXR0ckNoYXJSRSA9IC9bPi89XCInXFx1MDAwOVxcdTAwMGFcXHUwMDBjXFx1MDAyMF0vO1xuY29uc3QgYXR0clZhbGlkYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNTU1JTYWZlQXR0ck5hbWUobmFtZSkge1xuICAgIGlmIChhdHRyVmFsaWRhdGlvbkNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdO1xuICAgIH1cbiAgICBjb25zdCBpc1Vuc2FmZSA9IHVuc2FmZUF0dHJDaGFyUkUudGVzdChuYW1lKTtcbiAgICBpZiAoaXNVbnNhZmUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lOiAke25hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiAoYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXSA9ICFpc1Vuc2FmZSk7XG59XG5jb25zdCBwcm9wc1RvQXR0ck1hcCA9IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xufTtcbi8qKlxuICogS25vd24gYXR0cmlidXRlcywgdGhpcyBpcyB1c2VkIGZvciBzdHJpbmdpZmljYXRpb24gb2YgcnVudGltZSBzdGF0aWMgbm9kZXNcbiAqIHNvIHRoYXQgd2UgZG9uJ3Qgc3RyaW5naWZ5IGJpbmRpbmdzIHRoYXQgY2Fubm90IGJlIHNldCBmcm9tIEhUTUwuXG4gKiBEb24ndCBhbHNvIGZvcmdldCB0byBhbGxvdyBgZGF0YS0qYCBhbmQgYGFyaWEtKmAhXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0F0dHJpYnV0ZXNcbiAqL1xuY29uc3QgaXNLbm93bkh0bWxBdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYCArXG4gICAgYGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSxhdXRvZm9jdXMsYXV0b3BsYXksYmFja2dyb3VuZCxiZ2NvbG9yLGAgK1xuICAgIGBib3JkZXIsYnVmZmVyZWQsY2FwdHVyZSxjaGFsbGVuZ2UsY2hhcnNldCxjaGVja2VkLGNpdGUsY2xhc3MsY29kZSxgICtcbiAgICBgY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGAgK1xuICAgIGBjb29yZHMsY3Jvc3NvcmlnaW4sY3NwLGRhdGEsZGF0ZXRpbWUsZGVjb2RpbmcsZGVmYXVsdCxkZWZlcixkaXIsZGlybmFtZSxgICtcbiAgICBgZGlzYWJsZWQsZG93bmxvYWQsZHJhZ2dhYmxlLGRyb3B6b25lLGVuY3R5cGUsZW50ZXJrZXloaW50LGZvcixmb3JtLGAgK1xuICAgIGBmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGAgK1xuICAgIGBoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LGljb24saWQsaW1wb3J0YW5jZSxpbnRlZ3JpdHksYCArXG4gICAgYGlzbWFwLGl0ZW1wcm9wLGtleXR5cGUsa2luZCxsYWJlbCxsYW5nLGxhbmd1YWdlLGxvYWRpbmcsbGlzdCxsb29wLGxvdyxgICtcbiAgICBgbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxgICtcbiAgICBgb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIscHJlbG9hZCxyYWRpb2dyb3VwLHJlYWRvbmx5LGAgK1xuICAgIGByZWZlcnJlcnBvbGljeSxyZWwscmVxdWlyZWQscmV2ZXJzZWQscm93cyxyb3dzcGFuLHNhbmRib3gsc2NvcGUsc2NvcGVkLGAgK1xuICAgIGBzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsYCArXG4gICAgYHN0YXJ0LHN0ZXAsc3R5bGUsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLGAgK1xuICAgIGB2YWx1ZSx3aWR0aCx3cmFwYCk7XG4vKipcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGVcbiAqL1xuY29uc3QgaXNLbm93blN2Z0F0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYHhtbG5zLGFjY2VudC1oZWlnaHQsYWNjdW11bGF0ZSxhZGRpdGl2ZSxhbGlnbm1lbnQtYmFzZWxpbmUsYWxwaGFiZXRpYyxhbXBsaXR1ZGUsYCArXG4gICAgYGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGAgK1xuICAgIGBiYXNlbGluZS1zaGlmdCxiYXNlUHJvZmlsZSxiYm94LGJlZ2luLGJpYXMsYnksY2FsY01vZGUsY2FwLWhlaWdodCxjbGFzcyxgICtcbiAgICBgY2xpcCxjbGlwUGF0aFVuaXRzLGNsaXAtcGF0aCxjbGlwLXJ1bGUsY29sb3IsY29sb3ItaW50ZXJwb2xhdGlvbixgICtcbiAgICBgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGAgK1xuICAgIGBjb250ZW50U2NyaXB0VHlwZSxjb250ZW50U3R5bGVUeXBlLGNyb3Nzb3JpZ2luLGN1cnNvcixjeCxjeSxkLGRlY2VsZXJhdGUsYCArXG4gICAgYGRlc2NlbnQsZGlmZnVzZUNvbnN0YW50LGRpcmVjdGlvbixkaXNwbGF5LGRpdmlzb3IsZG9taW5hbnQtYmFzZWxpbmUsZHVyLGR4LGAgK1xuICAgIGBkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGAgK1xuICAgIGBmaWxsLXJ1bGUsZmlsdGVyLGZpbHRlclJlcyxmaWx0ZXJVbml0cyxmbG9vZC1jb2xvcixmbG9vZC1vcGFjaXR5LGAgK1xuICAgIGBmb250LWZhbWlseSxmb250LXNpemUsZm9udC1zaXplLWFkanVzdCxmb250LXN0cmV0Y2gsZm9udC1zdHlsZSxgICtcbiAgICBgZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsYCArXG4gICAgYGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwsZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwsZ2x5cGhSZWYsYCArXG4gICAgYGdyYWRpZW50VHJhbnNmb3JtLGdyYWRpZW50VW5pdHMsaGFuZ2luZyxoZWlnaHQsaHJlZixocmVmbGFuZyxob3Jpei1hZHYteCxgICtcbiAgICBgaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxgICtcbiAgICBgazQsa2VybmVsTWF0cml4LGtlcm5lbFVuaXRMZW5ndGgsa2VybmluZyxrZXlQb2ludHMsa2V5U3BsaW5lcyxrZXlUaW1lcyxgICtcbiAgICBgbGFuZyxsZW5ndGhBZGp1c3QsbGV0dGVyLXNwYWNpbmcsbGlnaHRpbmctY29sb3IsbGltaXRpbmdDb25lQW5nbGUsbG9jYWwsYCArXG4gICAgYG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLGAgK1xuICAgIGBtYXNrLG1hc2tDb250ZW50VW5pdHMsbWFza1VuaXRzLG1hdGhlbWF0aWNhbCxtYXgsbWVkaWEsbWV0aG9kLG1pbixtb2RlLGAgK1xuICAgIGBuYW1lLG51bU9jdGF2ZXMsb2Zmc2V0LG9wYWNpdHksb3BlcmF0b3Isb3JkZXIsb3JpZW50LG9yaWVudGF0aW9uLG9yaWdpbixgICtcbiAgICBgb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgsYCArXG4gICAgYHBhdGhMZW5ndGgscGF0dGVybkNvbnRlbnRVbml0cyxwYXR0ZXJuVHJhbnNmb3JtLHBhdHRlcm5Vbml0cyxwaW5nLGAgK1xuICAgIGBwb2ludGVyLWV2ZW50cyxwb2ludHMscG9pbnRzQXRYLHBvaW50c0F0WSxwb2ludHNBdFoscHJlc2VydmVBbHBoYSxgICtcbiAgICBgcHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLGAgK1xuICAgIGByZW5kZXJpbmctaW50ZW50LHJlcGVhdENvdW50LHJlcGVhdER1cixyZXF1aXJlZEV4dGVuc2lvbnMscmVxdWlyZWRGZWF0dXJlcyxgICtcbiAgICBgcmVzdGFydCxyZXN1bHQscm90YXRlLHJ4LHJ5LHNjYWxlLHNlZWQsc2hhcGUtcmVuZGVyaW5nLHNsb3BlLHNwYWNpbmcsYCArXG4gICAgYHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsYCArXG4gICAgYHN0ZERldmlhdGlvbixzdGVtaCxzdGVtdixzdGl0Y2hUaWxlcyxzdG9wLWNvbG9yLHN0b3Atb3BhY2l0eSxgICtcbiAgICBgc3RyaWtldGhyb3VnaC1wb3NpdGlvbixzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyxzdHJpbmcsc3Ryb2tlLGAgK1xuICAgIGBzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixgICtcbiAgICBgc3Ryb2tlLW1pdGVybGltaXQsc3Ryb2tlLW9wYWNpdHksc3Ryb2tlLXdpZHRoLHN0eWxlLHN1cmZhY2VTY2FsZSxgICtcbiAgICBgc3lzdGVtTGFuZ3VhZ2UsdGFiaW5kZXgsdGFibGVWYWx1ZXMsdGFyZ2V0LHRhcmdldFgsdGFyZ2V0WSx0ZXh0LWFuY2hvcixgICtcbiAgICBgdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sYCArXG4gICAgYHR5cGUsdTEsdTIsdW5kZXJsaW5lLXBvc2l0aW9uLHVuZGVybGluZS10aGlja25lc3MsdW5pY29kZSx1bmljb2RlLWJpZGksYCArXG4gICAgYHVuaWNvZGUtcmFuZ2UsdW5pdHMtcGVyLWVtLHYtYWxwaGFiZXRpYyx2LWhhbmdpbmcsdi1pZGVvZ3JhcGhpYyxgICtcbiAgICBgdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsYCArXG4gICAgYHZlcnQtb3JpZ2luLXksdmlld0JveCx2aWV3VGFyZ2V0LHZpc2liaWxpdHksd2lkdGgsd2lkdGhzLHdvcmQtc3BhY2luZyxgICtcbiAgICBgd3JpdGluZy1tb2RlLHgseC1oZWlnaHQseDEseDIseENoYW5uZWxTZWxlY3Rvcix4bGluazphY3R1YXRlLHhsaW5rOmFyY3JvbGUsYCArXG4gICAgYHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sOmJhc2UseG1sOmxhbmcsYCArXG4gICAgYHhtbDpzcGFjZSx5LHkxLHkyLHlDaGFubmVsU2VsZWN0b3Iseix6b29tQW5kUGFuYCk7XG5cbmNvbnN0IGVzY2FwZVJFID0gL1tcIicmPD5dLztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyaW5nKSB7XG4gICAgY29uc3Qgc3RyID0gJycgKyBzdHJpbmc7XG4gICAgY29uc3QgbWF0Y2ggPSBlc2NhcGVSRS5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGxldCBlc2NhcGVkO1xuICAgIGxldCBpbmRleDtcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgICAgICAgY2FzZSAzNDogLy8gXCJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZxdW90Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OiAvLyAmXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmYW1wOyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OiAvLyAnXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmIzM5Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYwOiAvLyA8XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmbHQ7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjI6IC8vID5cbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZndDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgaHRtbCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBodG1sICs9IGVzY2FwZWQ7XG4gICAgfVxuICAgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUyL3N5bnRheC5odG1sI2NvbW1lbnRzXG5jb25zdCBjb21tZW50U3RyaXBSRSA9IC9eLT8+fDwhLS18LS0+fC0tIT58PCEtJC9nO1xuZnVuY3Rpb24gZXNjYXBlSHRtbENvbW1lbnQoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5yZXBsYWNlKGNvbW1lbnRTdHJpcFJFLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVxdWFsID0gbG9vc2VFcXVhbChhW2ldLCBiW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xufVxuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBhVmFsaWRUeXBlID0gaXNEYXRlKGEpO1xuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNTeW1ib2woYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzU3ltYm9sKGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc0FycmF5KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNPYmplY3QoYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB0aGlzIGlmIHdpbGwgcHJvYmFibHkgbmV2ZXIgYmUgY2FsbGVkICovXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhiKS5sZW5ndGg7XG4gICAgICAgIGlmIChhS2V5c0NvdW50ICE9PSBiS2V5c0NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGJIYXNLZXkgPSBiLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgICAgICBpZiAoKGFIYXNLZXkgJiYgIWJIYXNLZXkpIHx8XG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZihhcnIsIHZhbCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGl0ZW0gPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcbn1cblxuLyoqXG4gKiBGb3IgY29udmVydGluZyB7eyBpbnRlcnBvbGF0aW9uIH19IHZhbHVlcyB0byBkaXNwbGF5ZWQgc3RyaW5ncy5cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRvRGlzcGxheVN0cmluZyA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHZhbCA9PSBudWxsXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IGlzQXJyYXkodmFsKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwpICYmXG4gICAgICAgICAgICAgICAgICAgICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpKVxuICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCByZXBsYWNlciwgMilcbiAgICAgICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xufTtcbmNvbnN0IHJlcGxhY2VyID0gKF9rZXksIHZhbCkgPT4ge1xuICAgIC8vIGNhbid0IHVzZSBpc1JlZiBoZXJlIHNpbmNlIEB2dWUvc2hhcmVkIGhhcyBubyBkZXBzXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlcihfa2V5LCB2YWwudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc01hcCh2YWwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbYE1hcCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC5lbnRyaWVzKCldLnJlZHVjZSgoZW50cmllcywgW2tleSwgdmFsXSkgPT4ge1xuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyaWVzO1xuICAgICAgICAgICAgfSwge30pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtgU2V0KCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLnZhbHVlcygpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpICYmICFpc0FycmF5KHZhbCkgJiYgIWlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuXG5jb25zdCBFTVBUWV9PQkogPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXG4gICAgOiB7fTtcbmNvbnN0IEVNUFRZX0FSUiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG5jb25zdCBOTyA9ICgpID0+IGZhbHNlO1xuY29uc3Qgb25SRSA9IC9eb25bXmEtel0vO1xuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xuY29uc3QgaXNNb2RlbExpc3RlbmVyID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoJ29uVXBkYXRlOicpO1xuY29uc3QgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbjtcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XG4gICAgY29uc3QgaSA9IGFyci5pbmRleE9mKGVsKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgfVxufTtcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE1hcF0nO1xuY29uc3QgaXNTZXQgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgU2V0XSc7XG5jb25zdCBpc0RhdGUgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuY29uc3QgaXNSZWdFeHAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG5jb25zdCBpc1N5bWJvbCA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzeW1ib2wnO1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwudGhlbikgJiYgaXNGdW5jdGlvbih2YWwuY2F0Y2gpO1xufTtcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5jb25zdCB0b1Jhd1R5cGUgPSAodmFsdWUpID0+IHtcbiAgICAvLyBleHRyYWN0IFwiUmF3VHlwZVwiIGZyb20gc3RyaW5ncyBsaWtlIFwiW29iamVjdCBSYXdUeXBlXVwiXG4gICAgcmV0dXJuIHRvVHlwZVN0cmluZyh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufTtcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5jb25zdCBpc0ludGVnZXJLZXkgPSAoa2V5KSA9PiBpc1N0cmluZyhrZXkpICYmXG4gICAga2V5ICE9PSAnTmFOJyAmJlxuICAgIGtleVswXSAhPT0gJy0nICYmXG4gICAgJycgKyBwYXJzZUludChrZXksIDEwKSA9PT0ga2V5O1xuY29uc3QgaXNSZXNlcnZlZFByb3AgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoXG4vLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4nLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LCcgK1xuICAgICdvblZub2RlQmVmb3JlTW91bnQsb25Wbm9kZU1vdW50ZWQsJyArXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXG4gICAgJ29uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWQnKTtcbmNvbnN0IGlzQnVpbHRJbkRpcmVjdGl2ZSA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtbycpO1xuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gKChzdHIpID0+IHtcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICAgIH0pO1xufTtcbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhbWVsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XG59KTtcbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCk7XG4vLyBjb21wYXJlIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZCwgYWNjb3VudGluZyBmb3IgTmFOLlxuY29uc3QgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+ICFPYmplY3QuaXModmFsdWUsIG9sZFZhbHVlKTtcbmNvbnN0IGludm9rZUFycmF5Rm5zID0gKGZucywgYXJnKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldKGFyZyk7XG4gICAgfVxufTtcbmNvbnN0IGRlZiA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICB9KTtcbn07XG4vKipcbiAqIFwiMTIzLWZvb1wiIHdpbGwgYmUgcGFyc2VkIHRvIDEyM1xuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgLm51bWJlciBtb2RpZmllciBpbiB2LW1vZGVsXG4gKi9cbmNvbnN0IGxvb3NlVG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbi8qKlxuICogT25seSBjb25lcmNlcyBudW1iZXItbGlrZSBzdHJpbmdzXG4gKiBcIjEyMy1mb29cIiB3aWxsIGJlIHJldHVybmVkIGFzLWlzXG4gKi9cbmNvbnN0IHRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG4gPSBpc1N0cmluZyh2YWwpID8gTnVtYmVyKHZhbCkgOiBOYU47XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG5sZXQgX2dsb2JhbFRoaXM7XG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xuICAgIHJldHVybiAoX2dsb2JhbFRoaXMgfHxcbiAgICAgICAgKF9nbG9iYWxUaGlzID1cbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICAgICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xufTtcbmNvbnN0IGlkZW50UkUgPSAvXltfJGEtekEtWlxceEEwLVxcdUZGRkZdW18kYS16QS1aMC05XFx4QTAtXFx1RkZGRl0qJC87XG5mdW5jdGlvbiBnZW5Qcm9wc0FjY2Vzc0V4cChuYW1lKSB7XG4gICAgcmV0dXJuIGlkZW50UkUudGVzdChuYW1lKVxuICAgICAgICA/IGBfX3Byb3BzLiR7bmFtZX1gXG4gICAgICAgIDogYF9fcHJvcHNbJHtKU09OLnN0cmluZ2lmeShuYW1lKX1dYDtcbn1cblxuZXhwb3J0IHsgRU1QVFlfQVJSLCBFTVBUWV9PQkosIE5PLCBOT09QLCBQYXRjaEZsYWdOYW1lcywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGRlZiwgZXNjYXBlSHRtbCwgZXNjYXBlSHRtbENvbW1lbnQsIGV4dGVuZCwgZ2VuUHJvcHNBY2Nlc3NFeHAsIGdlbmVyYXRlQ29kZUZyYW1lLCBnZXRHbG9iYWxUaGlzLCBoYXNDaGFuZ2VkLCBoYXNPd24sIGh5cGhlbmF0ZSwgaW5jbHVkZUJvb2xlYW5BdHRyLCBpbnZva2VBcnJheUZucywgaXNBcnJheSwgaXNCb29sZWFuQXR0ciwgaXNCdWlsdEluRGlyZWN0aXZlLCBpc0RhdGUsIGlzRnVuY3Rpb24sIGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCwgaXNIVE1MVGFnLCBpc0ludGVnZXJLZXksIGlzS25vd25IdG1sQXR0ciwgaXNLbm93blN2Z0F0dHIsIGlzTWFwLCBpc01vZGVsTGlzdGVuZXIsIGlzT2JqZWN0LCBpc09uLCBpc1BsYWluT2JqZWN0LCBpc1Byb21pc2UsIGlzUmVnRXhwLCBpc1Jlc2VydmVkUHJvcCwgaXNTU1JTYWZlQXR0ck5hbWUsIGlzU1ZHVGFnLCBpc1NldCwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGlzU3RyaW5nLCBpc1N5bWJvbCwgaXNWb2lkVGFnLCBsb29zZUVxdWFsLCBsb29zZUluZGV4T2YsIGxvb3NlVG9OdW1iZXIsIG1ha2VNYXAsIG5vcm1hbGl6ZUNsYXNzLCBub3JtYWxpemVQcm9wcywgbm9ybWFsaXplU3R5bGUsIG9iamVjdFRvU3RyaW5nLCBwYXJzZVN0cmluZ1N0eWxlLCBwcm9wc1RvQXR0ck1hcCwgcmVtb3ZlLCBzbG90RmxhZ3NUZXh0LCBzdHJpbmdpZnlTdHlsZSwgdG9EaXNwbGF5U3RyaW5nLCB0b0hhbmRsZXJLZXksIHRvTnVtYmVyLCB0b1Jhd1R5cGUsIHRvVHlwZVN0cmluZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTransition\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),\n/* harmony export */   \"Comment\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Comment),\n/* harmony export */   \"EffectScope\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EffectScope),\n/* harmony export */   \"Fragment\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   \"KeepAlive\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),\n/* harmony export */   \"ReactiveEffect\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),\n/* harmony export */   \"Static\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static),\n/* harmony export */   \"Suspense\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Suspense),\n/* harmony export */   \"Teleport\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Teleport),\n/* harmony export */   \"Text\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Text),\n/* harmony export */   \"Transition\": () => (/* binding */ Transition),\n/* harmony export */   \"TransitionGroup\": () => (/* binding */ TransitionGroup),\n/* harmony export */   \"VueElement\": () => (/* binding */ VueElement),\n/* harmony export */   \"assertNumber\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber),\n/* harmony export */   \"callWithAsyncErrorHandling\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),\n/* harmony export */   \"callWithErrorHandling\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),\n/* harmony export */   \"camelize\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.camelize),\n/* harmony export */   \"capitalize\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.capitalize),\n/* harmony export */   \"cloneVNode\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),\n/* harmony export */   \"compatUtils\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.compatUtils),\n/* harmony export */   \"computed\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.computed),\n/* harmony export */   \"createApp\": () => (/* binding */ createApp),\n/* harmony export */   \"createBlock\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createBlock),\n/* harmony export */   \"createCommentVNode\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),\n/* harmony export */   \"createElementBlock\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),\n/* harmony export */   \"createElementVNode\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),\n/* harmony export */   \"createHydrationRenderer\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),\n/* harmony export */   \"createPropsRestProxy\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),\n/* harmony export */   \"createRenderer\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer),\n/* harmony export */   \"createSSRApp\": () => (/* binding */ createSSRApp),\n/* harmony export */   \"createSlots\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createSlots),\n/* harmony export */   \"createStaticVNode\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),\n/* harmony export */   \"createTextVNode\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),\n/* harmony export */   \"createVNode\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode),\n/* harmony export */   \"customRef\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.customRef),\n/* harmony export */   \"defineAsyncComponent\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),\n/* harmony export */   \"defineComponent\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent),\n/* harmony export */   \"defineCustomElement\": () => (/* binding */ defineCustomElement),\n/* harmony export */   \"defineEmits\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineEmits),\n/* harmony export */   \"defineExpose\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineExpose),\n/* harmony export */   \"defineProps\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineProps),\n/* harmony export */   \"defineSSRCustomElement\": () => (/* binding */ defineSSRCustomElement),\n/* harmony export */   \"devtools\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.devtools),\n/* harmony export */   \"effect\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effect),\n/* harmony export */   \"effectScope\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.effectScope),\n/* harmony export */   \"getCurrentInstance\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),\n/* harmony export */   \"getCurrentScope\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),\n/* harmony export */   \"getTransitionRawChildren\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),\n/* harmony export */   \"guardReactiveProps\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),\n/* harmony export */   \"h\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   \"handleError\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.handleError),\n/* harmony export */   \"hydrate\": () => (/* binding */ hydrate),\n/* harmony export */   \"initCustomFormatter\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),\n/* harmony export */   \"initDirectivesForSSR\": () => (/* binding */ initDirectivesForSSR),\n/* harmony export */   \"inject\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.inject),\n/* harmony export */   \"isMemoSame\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),\n/* harmony export */   \"isProxy\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isProxy),\n/* harmony export */   \"isReactive\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReactive),\n/* harmony export */   \"isReadonly\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isReadonly),\n/* harmony export */   \"isRef\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRef),\n/* harmony export */   \"isRuntimeOnly\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),\n/* harmony export */   \"isShallow\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isShallow),\n/* harmony export */   \"isVNode\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isVNode),\n/* harmony export */   \"markRaw\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.markRaw),\n/* harmony export */   \"mergeDefaults\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),\n/* harmony export */   \"mergeProps\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mergeProps),\n/* harmony export */   \"nextTick\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick),\n/* harmony export */   \"normalizeClass\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),\n/* harmony export */   \"normalizeProps\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),\n/* harmony export */   \"normalizeStyle\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),\n/* harmony export */   \"onActivated\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onActivated),\n/* harmony export */   \"onBeforeMount\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),\n/* harmony export */   \"onBeforeUnmount\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),\n/* harmony export */   \"onBeforeUpdate\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),\n/* harmony export */   \"onDeactivated\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),\n/* harmony export */   \"onErrorCaptured\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),\n/* harmony export */   \"onMounted\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted),\n/* harmony export */   \"onRenderTracked\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),\n/* harmony export */   \"onRenderTriggered\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),\n/* harmony export */   \"onScopeDispose\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),\n/* harmony export */   \"onServerPrefetch\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),\n/* harmony export */   \"onUnmounted\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),\n/* harmony export */   \"onUpdated\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated),\n/* harmony export */   \"openBlock\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.openBlock),\n/* harmony export */   \"popScopeId\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.popScopeId),\n/* harmony export */   \"provide\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.provide),\n/* harmony export */   \"proxyRefs\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),\n/* harmony export */   \"pushScopeId\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),\n/* harmony export */   \"queuePostFlushCb\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),\n/* harmony export */   \"reactive\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.reactive),\n/* harmony export */   \"readonly\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.readonly),\n/* harmony export */   \"ref\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ref),\n/* harmony export */   \"registerRuntimeCompiler\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"renderList\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderList),\n/* harmony export */   \"renderSlot\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.renderSlot),\n/* harmony export */   \"resolveComponent\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),\n/* harmony export */   \"resolveDirective\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),\n/* harmony export */   \"resolveDynamicComponent\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),\n/* harmony export */   \"resolveFilter\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),\n/* harmony export */   \"resolveTransitionHooks\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),\n/* harmony export */   \"setBlockTracking\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),\n/* harmony export */   \"setDevtoolsHook\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),\n/* harmony export */   \"setTransitionHooks\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),\n/* harmony export */   \"shallowReactive\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),\n/* harmony export */   \"shallowReadonly\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),\n/* harmony export */   \"shallowRef\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.shallowRef),\n/* harmony export */   \"ssrContextKey\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),\n/* harmony export */   \"ssrUtils\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),\n/* harmony export */   \"stop\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.stop),\n/* harmony export */   \"toDisplayString\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),\n/* harmony export */   \"toHandlerKey\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),\n/* harmony export */   \"toHandlers\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toHandlers),\n/* harmony export */   \"toRaw\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRaw),\n/* harmony export */   \"toRef\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRef),\n/* harmony export */   \"toRefs\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.toRefs),\n/* harmony export */   \"transformVNodeArgs\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),\n/* harmony export */   \"triggerRef\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.triggerRef),\n/* harmony export */   \"unref\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.unref),\n/* harmony export */   \"useAttrs\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useAttrs),\n/* harmony export */   \"useCssModule\": () => (/* binding */ useCssModule),\n/* harmony export */   \"useCssVars\": () => (/* binding */ useCssVars),\n/* harmony export */   \"useSSRContext\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),\n/* harmony export */   \"useSlots\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useSlots),\n/* harmony export */   \"useTransitionState\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),\n/* harmony export */   \"vModelCheckbox\": () => (/* binding */ vModelCheckbox),\n/* harmony export */   \"vModelDynamic\": () => (/* binding */ vModelDynamic),\n/* harmony export */   \"vModelRadio\": () => (/* binding */ vModelRadio),\n/* harmony export */   \"vModelSelect\": () => (/* binding */ vModelSelect),\n/* harmony export */   \"vModelText\": () => (/* binding */ vModelText),\n/* harmony export */   \"vShow\": () => (/* binding */ vShow),\n/* harmony export */   \"version\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.version),\n/* harmony export */   \"warn\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn),\n/* harmony export */   \"watch\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watch),\n/* harmony export */   \"watchEffect\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchEffect),\n/* harmony export */   \"watchPostEffect\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),\n/* harmony export */   \"watchSyncEffect\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),\n/* harmony export */   \"withAsyncContext\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),\n/* harmony export */   \"withCtx\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withCtx),\n/* harmony export */   \"withDefaults\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDefaults),\n/* harmony export */   \"withDirectives\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withDirectives),\n/* harmony export */   \"withKeys\": () => (/* binding */ withKeys),\n/* harmony export */   \"withMemo\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withMemo),\n/* harmony export */   \"withModifiers\": () => (/* binding */ withModifiers),\n/* harmony export */   \"withScopeId\": () => (/* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.withScopeId)\n/* harmony export */ });\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\");\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/@vue/runtime-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\n\n\nconst svgNS = 'http://www.w3.org/2000/svg';\nconst doc = (typeof document !== 'undefined' ? document : null);\nconst templateContainer = doc && /*#__PURE__*/ doc.createElement('template');\nconst nodeOps = {\n    insert: (child, parent, anchor) => {\n        parent.insertBefore(child, anchor || null);\n    },\n    remove: child => {\n        const parent = child.parentNode;\n        if (parent) {\n            parent.removeChild(child);\n        }\n    },\n    createElement: (tag, isSVG, is, props) => {\n        const el = isSVG\n            ? doc.createElementNS(svgNS, tag)\n            : doc.createElement(tag, is ? { is } : undefined);\n        if (tag === 'select' && props && props.multiple != null) {\n            el.setAttribute('multiple', props.multiple);\n        }\n        return el;\n    },\n    createText: text => doc.createTextNode(text),\n    createComment: text => doc.createComment(text),\n    setText: (node, text) => {\n        node.nodeValue = text;\n    },\n    setElementText: (el, text) => {\n        el.textContent = text;\n    },\n    parentNode: node => node.parentNode,\n    nextSibling: node => node.nextSibling,\n    querySelector: selector => doc.querySelector(selector),\n    setScopeId(el, id) {\n        el.setAttribute(id, '');\n    },\n    // __UNSAFE__\n    // Reason: innerHTML.\n    // Static content here can only come from compiled templates.\n    // As long as the user only uses trusted templates, this is safe.\n    insertStaticContent(content, parent, anchor, isSVG, start, end) {\n        // <parent> before | first ... last | anchor </parent>\n        const before = anchor ? anchor.previousSibling : parent.lastChild;\n        // #5308 can only take cached path if:\n        // - has a single root node\n        // - nextSibling info is still available\n        if (start && (start === end || start.nextSibling)) {\n            // cached\n            while (true) {\n                parent.insertBefore(start.cloneNode(true), anchor);\n                if (start === end || !(start = start.nextSibling))\n                    break;\n            }\n        }\n        else {\n            // fresh insert\n            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\n            const template = templateContainer.content;\n            if (isSVG) {\n                // remove outer svg wrapper\n                const wrapper = template.firstChild;\n                while (wrapper.firstChild) {\n                    template.appendChild(wrapper.firstChild);\n                }\n                template.removeChild(wrapper);\n            }\n            parent.insertBefore(template, anchor);\n        }\n        return [\n            // first\n            before ? before.nextSibling : parent.firstChild,\n            // last\n            anchor ? anchor.previousSibling : parent.lastChild\n        ];\n    }\n};\n\n// compiler should normalize class + :class bindings on the same element\n// into a single binding ['staticClass', dynamic]\nfunction patchClass(el, value, isSVG) {\n    // directly setting className should be faster than setAttribute in theory\n    // if this is an element during a transition, take the temporary transition\n    // classes into account.\n    const transitionClasses = el._vtc;\n    if (transitionClasses) {\n        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');\n    }\n    if (value == null) {\n        el.removeAttribute('class');\n    }\n    else if (isSVG) {\n        el.setAttribute('class', value);\n    }\n    else {\n        el.className = value;\n    }\n}\n\nfunction patchStyle(el, prev, next) {\n    const style = el.style;\n    const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(next);\n    if (next && !isCssString) {\n        if (prev && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(prev)) {\n            for (const key in prev) {\n                if (next[key] == null) {\n                    setStyle(style, key, '');\n                }\n            }\n        }\n        for (const key in next) {\n            setStyle(style, key, next[key]);\n        }\n    }\n    else {\n        const currentDisplay = style.display;\n        if (isCssString) {\n            if (prev !== next) {\n                style.cssText = next;\n            }\n        }\n        else if (prev) {\n            el.removeAttribute('style');\n        }\n        // indicates that the `display` of the element is controlled by `v-show`,\n        // so we always keep the current `display` value regardless of the `style`\n        // value, thus handing over control to `v-show`.\n        if ('_vod' in el) {\n            style.display = currentDisplay;\n        }\n    }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val)) {\n        val.forEach(v => setStyle(style, name, v));\n    }\n    else {\n        if (val == null)\n            val = '';\n        if ((true)) {\n            if (semicolonRE.test(val)) {\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);\n            }\n        }\n        if (name.startsWith('--')) {\n            // custom property definition\n            style.setProperty(name, val);\n        }\n        else {\n            const prefixed = autoPrefix(style, name);\n            if (importantRE.test(val)) {\n                // !important\n                style.setProperty((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(prefixed), val.replace(importantRE, ''), 'important');\n            }\n            else {\n                style[prefixed] = val;\n            }\n        }\n    }\n}\nconst prefixes = ['Webkit', 'Moz', 'ms'];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n    const cached = prefixCache[rawName];\n    if (cached) {\n        return cached;\n    }\n    let name = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__.camelize)(rawName);\n    if (name !== 'filter' && name in style) {\n        return (prefixCache[rawName] = name);\n    }\n    name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.capitalize)(name);\n    for (let i = 0; i < prefixes.length; i++) {\n        const prefixed = prefixes[i] + name;\n        if (prefixed in style) {\n            return (prefixCache[rawName] = prefixed);\n        }\n    }\n    return rawName;\n}\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nfunction patchAttr(el, key, value, isSVG, instance) {\n    if (isSVG && key.startsWith('xlink:')) {\n        if (value == null) {\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n        }\n        else {\n            el.setAttributeNS(xlinkNS, key, value);\n        }\n    }\n    else {\n        // note we are only checking boolean attributes that don't have a\n        // corresponding dom prop of the same name here.\n        const isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSpecialBooleanAttr)(key);\n        if (value == null || (isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value))) {\n            el.removeAttribute(key);\n        }\n        else {\n            el.setAttribute(key, isBoolean ? '' : value);\n        }\n    }\n}\n\n// __UNSAFE__\n// functions. The user is responsible for using them with only trusted content.\nfunction patchDOMProp(el, key, value, \n// the following args are passed only due to potential innerHTML/textContent\n// overriding existing VNodes, in which case the old tree must be properly\n// unmounted.\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\n    if (key === 'innerHTML' || key === 'textContent') {\n        if (prevChildren) {\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\n        }\n        el[key] = value == null ? '' : value;\n        return;\n    }\n    if (key === 'value' &&\n        el.tagName !== 'PROGRESS' &&\n        // custom elements may use _value internally\n        !el.tagName.includes('-')) {\n        // store value as _value as well since\n        // non-string values will be stringified.\n        el._value = value;\n        const newValue = value == null ? '' : value;\n        if (el.value !== newValue ||\n            // #4956: always set for OPTION elements because its value falls back to\n            // textContent if no value attribute is present. And setting .value for\n            // OPTION has no side effect\n            el.tagName === 'OPTION') {\n            el.value = newValue;\n        }\n        if (value == null) {\n            el.removeAttribute(key);\n        }\n        return;\n    }\n    let needRemove = false;\n    if (value === '' || value == null) {\n        const type = typeof el[key];\n        if (type === 'boolean') {\n            // e.g. <select multiple> compiles to { multiple: '' }\n            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.includeBooleanAttr)(value);\n        }\n        else if (value == null && type === 'string') {\n            // e.g. <div :id=\"null\">\n            value = '';\n            needRemove = true;\n        }\n        else if (type === 'number') {\n            // e.g. <img :width=\"null\">\n            value = 0;\n            needRemove = true;\n        }\n    }\n    // some properties perform value validation and throw,\n    // some properties has getter, no setter, will error in 'use strict'\n    // eg. <select :type=\"null\"></select> <select :willValidate=\"null\"></select>\n    try {\n        el[key] = value;\n    }\n    catch (e) {\n        // do not warn if value is auto-coerced from nullish values\n        if (( true) && !needRemove) {\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` +\n                `value ${value} is invalid.`, e);\n        }\n    }\n    needRemove && el.removeAttribute(key);\n}\n\nfunction addEventListener(el, event, handler, options) {\n    el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n    el.removeEventListener(event, handler, options);\n}\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n    // vei = vue event invokers\n    const invokers = el._vei || (el._vei = {});\n    const existingInvoker = invokers[rawName];\n    if (nextValue && existingInvoker) {\n        // patch\n        existingInvoker.value = nextValue;\n    }\n    else {\n        const [name, options] = parseName(rawName);\n        if (nextValue) {\n            // add\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\n            addEventListener(el, name, invoker, options);\n        }\n        else if (existingInvoker) {\n            // remove\n            removeEventListener(el, name, existingInvoker, options);\n            invokers[rawName] = undefined;\n        }\n    }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n    let options;\n    if (optionsModifierRE.test(name)) {\n        options = {};\n        let m;\n        while ((m = name.match(optionsModifierRE))) {\n            name = name.slice(0, name.length - m[0].length);\n            options[m[0].toLowerCase()] = true;\n        }\n    }\n    const event = name[2] === ':' ? name.slice(3) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(name.slice(2));\n    return [event, options];\n}\n// To avoid the overhead of repeatedly calling Date.now(), we cache\n// and use the same timestamp for all event listeners attached in the same tick.\nlet cachedNow = 0;\nconst p = /*#__PURE__*/ Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => (cachedNow = 0)), (cachedNow = Date.now()));\nfunction createInvoker(initialValue, instance) {\n    const invoker = (e) => {\n        // async edge case vuejs/vue#6566\n        // inner click event triggers patch, event handler\n        // attached to outer element during patch, and triggered again. This\n        // happens because browsers fire microtask ticks between event propagation.\n        // this no longer happens for templates in Vue 3, but could still be\n        // theoretically possible for hand-written render functions.\n        // the solution: we save the timestamp when a handler is attached,\n        // and also attach the timestamp to any event that was handled by vue\n        // for the first time (to avoid inconsistent event timestamp implementations\n        // or events fired from iframes, e.g. #2513)\n        // The handler would only fire if the event passed to it was fired\n        // AFTER it was attached.\n        if (!e._vts) {\n            e._vts = Date.now();\n        }\n        else if (e._vts <= invoker.attached) {\n            return;\n        }\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling)(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* ErrorCodes.NATIVE_EVENT_HANDLER */, [e]);\n    };\n    invoker.value = initialValue;\n    invoker.attached = getNow();\n    return invoker;\n}\nfunction patchStopImmediatePropagation(e, value) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n        const originalStop = e.stopImmediatePropagation;\n        e.stopImmediatePropagation = () => {\n            originalStop.call(e);\n            e._stopped = true;\n        };\n        return value.map(fn => (e) => !e._stopped && fn && fn(e));\n    }\n    else {\n        return value;\n    }\n}\n\nconst nativeOnRE = /^on[a-z]/;\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\n    if (key === 'class') {\n        patchClass(el, nextValue, isSVG);\n    }\n    else if (key === 'style') {\n        patchStyle(el, prevValue, nextValue);\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isOn)(key)) {\n        // ignore v-model listeners\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isModelListener)(key)) {\n            patchEvent(el, key, prevValue, nextValue, parentComponent);\n        }\n    }\n    else if (key[0] === '.'\n        ? ((key = key.slice(1)), true)\n        : key[0] === '^'\n            ? ((key = key.slice(1)), false)\n            : shouldSetAsProp(el, key, nextValue, isSVG)) {\n        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\n    }\n    else {\n        // special case for <input v-model type=\"checkbox\"> with\n        // :true-value & :false-value\n        // store value as dom properties since non-string values will be\n        // stringified.\n        if (key === 'true-value') {\n            el._trueValue = nextValue;\n        }\n        else if (key === 'false-value') {\n            el._falseValue = nextValue;\n        }\n        patchAttr(el, key, nextValue, isSVG);\n    }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n    if (isSVG) {\n        // most keys must be set as attribute on svg elements to work\n        // ...except innerHTML & textContent\n        if (key === 'innerHTML' || key === 'textContent') {\n            return true;\n        }\n        // or native onclick with function values\n        if (key in el && nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value)) {\n            return true;\n        }\n        return false;\n    }\n    // these are enumerated attrs, however their corresponding DOM properties\n    // are actually booleans - this leads to setting it with a string \"false\"\n    // value leading it to be coerced to `true`, so we need to always treat\n    // them as attributes.\n    // Note that `contentEditable` doesn't have this problem: its DOM\n    // property is also enumerated string values.\n    if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {\n        return false;\n    }\n    // #1787, #2840 form property on form elements is readonly and must be set as\n    // attribute.\n    if (key === 'form') {\n        return false;\n    }\n    // #1526 <input list> must be set as attribute\n    if (key === 'list' && el.tagName === 'INPUT') {\n        return false;\n    }\n    // #2766 <textarea type> must be set as attribute\n    if (key === 'type' && el.tagName === 'TEXTAREA') {\n        return false;\n    }\n    // native onclick with string value, must be set as attribute\n    if (nativeOnRE.test(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(value)) {\n        return false;\n    }\n    return key in el;\n}\n\nfunction defineCustomElement(options, hydrate) {\n    const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.defineComponent)(options);\n    class VueCustomElement extends VueElement {\n        constructor(initialProps) {\n            super(Comp, initialProps, hydrate);\n        }\n    }\n    VueCustomElement.def = Comp;\n    return VueCustomElement;\n}\nconst defineSSRCustomElement = ((options) => {\n    // @ts-ignore\n    return defineCustomElement(options, hydrate);\n});\nconst BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {\n});\nclass VueElement extends BaseClass {\n    constructor(_def, _props = {}, hydrate) {\n        super();\n        this._def = _def;\n        this._props = _props;\n        /**\n         * @internal\n         */\n        this._instance = null;\n        this._connected = false;\n        this._resolved = false;\n        this._numberProps = null;\n        if (this.shadowRoot && hydrate) {\n            hydrate(this._createVNode(), this.shadowRoot);\n        }\n        else {\n            if (( true) && this.shadowRoot) {\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Custom element has pre-rendered declarative shadow root but is not ` +\n                    `defined as hydratable. Use \\`defineSSRCustomElement\\`.`);\n            }\n            this.attachShadow({ mode: 'open' });\n            if (!this._def.__asyncLoader) {\n                // for sync component defs we can immediately resolve props\n                this._resolveProps(this._def);\n            }\n        }\n    }\n    connectedCallback() {\n        this._connected = true;\n        if (!this._instance) {\n            if (this._resolved) {\n                this._update();\n            }\n            else {\n                this._resolveDef();\n            }\n        }\n    }\n    disconnectedCallback() {\n        this._connected = false;\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n            if (!this._connected) {\n                render(null, this.shadowRoot);\n                this._instance = null;\n            }\n        });\n    }\n    /**\n     * resolve inner component definition (handle possible async component)\n     */\n    _resolveDef() {\n        this._resolved = true;\n        // set initial attrs\n        for (let i = 0; i < this.attributes.length; i++) {\n            this._setAttr(this.attributes[i].name);\n        }\n        // watch future attr changes\n        new MutationObserver(mutations => {\n            for (const m of mutations) {\n                this._setAttr(m.attributeName);\n            }\n        }).observe(this, { attributes: true });\n        const resolve = (def, isAsync = false) => {\n            const { props, styles } = def;\n            // cast Number-type props set before resolve\n            let numberProps;\n            if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props)) {\n                for (const key in props) {\n                    const opt = props[key];\n                    if (opt === Number || (opt && opt.type === Number)) {\n                        if (key in this._props) {\n                            this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(this._props[key]);\n                        }\n                        (numberProps || (numberProps = Object.create(null)))[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key)] = true;\n                    }\n                }\n            }\n            this._numberProps = numberProps;\n            if (isAsync) {\n                // defining getter/setters on prototype\n                // for sync defs, this already happened in the constructor\n                this._resolveProps(def);\n            }\n            // apply CSS\n            this._applyStyles(styles);\n            // initial render\n            this._update();\n        };\n        const asyncDef = this._def.__asyncLoader;\n        if (asyncDef) {\n            asyncDef().then(def => resolve(def, true));\n        }\n        else {\n            resolve(this._def);\n        }\n    }\n    _resolveProps(def) {\n        const { props } = def;\n        const declaredPropKeys = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(props) ? props : Object.keys(props || {});\n        // check if there are props set pre-upgrade or connect\n        for (const key of Object.keys(this)) {\n            if (key[0] !== '_' && declaredPropKeys.includes(key)) {\n                this._setProp(key, this[key], true, false);\n            }\n        }\n        // defining getter/setters on prototype\n        for (const key of declaredPropKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)) {\n            Object.defineProperty(this, key, {\n                get() {\n                    return this._getProp(key);\n                },\n                set(val) {\n                    this._setProp(key, val);\n                }\n            });\n        }\n    }\n    _setAttr(key) {\n        let value = this.getAttribute(key);\n        const camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.camelize)(key);\n        if (this._numberProps && this._numberProps[camelKey]) {\n            value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(value);\n        }\n        this._setProp(camelKey, value, false);\n    }\n    /**\n     * @internal\n     */\n    _getProp(key) {\n        return this._props[key];\n    }\n    /**\n     * @internal\n     */\n    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\n        if (val !== this._props[key]) {\n            this._props[key] = val;\n            if (shouldUpdate && this._instance) {\n                this._update();\n            }\n            // reflect\n            if (shouldReflect) {\n                if (val === true) {\n                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), '');\n                }\n                else if (typeof val === 'string' || typeof val === 'number') {\n                    this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key), val + '');\n                }\n                else if (!val) {\n                    this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(key));\n                }\n            }\n        }\n    }\n    _update() {\n        render(this._createVNode(), this.shadowRoot);\n    }\n    _createVNode() {\n        const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, this._props));\n        if (!this._instance) {\n            vnode.ce = instance => {\n                this._instance = instance;\n                instance.isCE = true;\n                // HMR\n                if ((true)) {\n                    instance.ceReload = newStyles => {\n                        // always reset styles\n                        if (this._styles) {\n                            this._styles.forEach(s => this.shadowRoot.removeChild(s));\n                            this._styles.length = 0;\n                        }\n                        this._applyStyles(newStyles);\n                        this._instance = null;\n                        this._update();\n                    };\n                }\n                const dispatch = (event, args) => {\n                    this.dispatchEvent(new CustomEvent(event, {\n                        detail: args\n                    }));\n                };\n                // intercept emit\n                instance.emit = (event, ...args) => {\n                    // dispatch both the raw and hyphenated versions of an event\n                    // to match Vue behavior\n                    dispatch(event, args);\n                    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event) !== event) {\n                        dispatch((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event), args);\n                    }\n                };\n                // locate nearest Vue custom element parent for provide/inject\n                let parent = this;\n                while ((parent =\n                    parent && (parent.parentNode || parent.host))) {\n                    if (parent instanceof VueElement) {\n                        instance.parent = parent._instance;\n                        instance.provides = parent._instance.provides;\n                        break;\n                    }\n                }\n            };\n        }\n        return vnode;\n    }\n    _applyStyles(styles) {\n        if (styles) {\n            styles.forEach(css => {\n                const s = document.createElement('style');\n                s.textContent = css;\n                this.shadowRoot.appendChild(s);\n                // record for HMR\n                if ((true)) {\n                    (this._styles || (this._styles = [])).push(s);\n                }\n            });\n        }\n    }\n}\n\nfunction useCssModule(name = '$style') {\n    /* istanbul ignore else */\n    {\n        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\n        if (!instance) {\n            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssModule must be called inside setup()`);\n            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n        }\n        const modules = instance.type.__cssModules;\n        if (!modules) {\n            ( true) && (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS modules injected.`);\n            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n        }\n        const mod = modules[name];\n        if (!mod) {\n            ( true) &&\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Current instance does not have CSS module named \"${name}\".`);\n            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ;\n        }\n        return mod;\n    }\n}\n\n/**\n * Runtime helper for SFC's CSS variable injection feature.\n * @private\n */\nfunction useCssVars(getter) {\n    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\n    /* istanbul ignore next */\n    if (!instance) {\n        ( true) &&\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`useCssVars is called without current active component instance.`);\n        return;\n    }\n    const updateTeleports = (instance.ut = (vars = getter(instance.proxy)) => {\n        Array.from(document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)).forEach(node => setVarsOnNode(node, vars));\n    });\n    const setVars = () => {\n        const vars = getter(instance.proxy);\n        setVarsOnVNode(instance.subTree, vars);\n        updateTeleports(vars);\n    };\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect)(setVars);\n    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {\n        const ob = new MutationObserver(setVars);\n        ob.observe(instance.subTree.el.parentNode, { childList: true });\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => ob.disconnect());\n    });\n}\nfunction setVarsOnVNode(vnode, vars) {\n    if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n        const suspense = vnode.suspense;\n        vnode = suspense.activeBranch;\n        if (suspense.pendingBranch && !suspense.isHydrating) {\n            suspense.effects.push(() => {\n                setVarsOnVNode(suspense.activeBranch, vars);\n            });\n        }\n    }\n    // drill down HOCs until it's a non-component vnode\n    while (vnode.component) {\n        vnode = vnode.component.subTree;\n    }\n    if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && vnode.el) {\n        setVarsOnNode(vnode.el, vars);\n    }\n    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n        vnode.children.forEach(c => setVarsOnVNode(c, vars));\n    }\n    else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Static) {\n        let { el, anchor } = vnode;\n        while (el) {\n            setVarsOnNode(el, vars);\n            if (el === anchor)\n                break;\n            el = el.nextSibling;\n        }\n    }\n}\nfunction setVarsOnNode(el, vars) {\n    if (el.nodeType === 1) {\n        const style = el.style;\n        for (const key in vars) {\n            style.setProperty(`--${key}`, vars[key]);\n        }\n    }\n}\n\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n// DOM Transition is a higher-order-component based on the platform-agnostic\n// base Transition component, with DOM-specific logic.\nconst Transition = (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition, resolveTransitionProps(props), slots);\nTransition.displayName = 'Transition';\nconst DOMTransitionPropsValidators = {\n    name: String,\n    type: String,\n    css: {\n        type: Boolean,\n        default: true\n    },\n    duration: [String, Number, Object],\n    enterFromClass: String,\n    enterActiveClass: String,\n    enterToClass: String,\n    appearFromClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    leaveFromClass: String,\n    leaveActiveClass: String,\n    leaveToClass: String\n};\nconst TransitionPropsValidators = (Transition.props =\n    /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BaseTransition.props, DOMTransitionPropsValidators));\n/**\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\n * with custom HOCs.\n */\nconst callHook = (hook, args = []) => {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)) {\n        hook.forEach(h => h(...args));\n    }\n    else if (hook) {\n        hook(...args);\n    }\n};\n/**\n * Check if a hook expects a callback (2nd arg), which means the user\n * intends to explicitly control the end of the transition.\n */\nconst hasExplicitCallback = (hook) => {\n    return hook\n        ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(hook)\n            ? hook.some(h => h.length > 1)\n            : hook.length > 1\n        : false;\n};\nfunction resolveTransitionProps(rawProps) {\n    const baseProps = {};\n    for (const key in rawProps) {\n        if (!(key in DOMTransitionPropsValidators)) {\n            baseProps[key] = rawProps[key];\n        }\n    }\n    if (rawProps.css === false) {\n        return baseProps;\n    }\n    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\n    const durations = normalizeDuration(duration);\n    const enterDuration = durations && durations[0];\n    const leaveDuration = durations && durations[1];\n    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\n    const finishEnter = (el, isAppear, done) => {\n        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n        done && done();\n    };\n    const finishLeave = (el, done) => {\n        el._isLeaving = false;\n        removeTransitionClass(el, leaveFromClass);\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n        done && done();\n    };\n    const makeEnterHook = (isAppear) => {\n        return (el, done) => {\n            const hook = isAppear ? onAppear : onEnter;\n            const resolve = () => finishEnter(el, isAppear, done);\n            callHook(hook, [el, resolve]);\n            nextFrame(() => {\n                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n                addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n                if (!hasExplicitCallback(hook)) {\n                    whenTransitionEnds(el, type, enterDuration, resolve);\n                }\n            });\n        };\n    };\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)(baseProps, {\n        onBeforeEnter(el) {\n            callHook(onBeforeEnter, [el]);\n            addTransitionClass(el, enterFromClass);\n            addTransitionClass(el, enterActiveClass);\n        },\n        onBeforeAppear(el) {\n            callHook(onBeforeAppear, [el]);\n            addTransitionClass(el, appearFromClass);\n            addTransitionClass(el, appearActiveClass);\n        },\n        onEnter: makeEnterHook(false),\n        onAppear: makeEnterHook(true),\n        onLeave(el, done) {\n            el._isLeaving = true;\n            const resolve = () => finishLeave(el, done);\n            addTransitionClass(el, leaveFromClass);\n            // force reflow so *-leave-from classes immediately take effect (#2593)\n            forceReflow();\n            addTransitionClass(el, leaveActiveClass);\n            nextFrame(() => {\n                if (!el._isLeaving) {\n                    // cancelled\n                    return;\n                }\n                removeTransitionClass(el, leaveFromClass);\n                addTransitionClass(el, leaveToClass);\n                if (!hasExplicitCallback(onLeave)) {\n                    whenTransitionEnds(el, type, leaveDuration, resolve);\n                }\n            });\n            callHook(onLeave, [el, resolve]);\n        },\n        onEnterCancelled(el) {\n            finishEnter(el, false);\n            callHook(onEnterCancelled, [el]);\n        },\n        onAppearCancelled(el) {\n            finishEnter(el, true);\n            callHook(onAppearCancelled, [el]);\n        },\n        onLeaveCancelled(el) {\n            finishLeave(el);\n            callHook(onLeaveCancelled, [el]);\n        }\n    });\n}\nfunction normalizeDuration(duration) {\n    if (duration == null) {\n        return null;\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(duration)) {\n        return [NumberOf(duration.enter), NumberOf(duration.leave)];\n    }\n    else {\n        const n = NumberOf(duration);\n        return [n, n];\n    }\n}\nfunction NumberOf(val) {\n    const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.toNumber)(val);\n    if ((true)) {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.assertNumber)(res, '<transition> explicit duration');\n    }\n    return res;\n}\nfunction addTransitionClass(el, cls) {\n    cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\n    (el._vtc ||\n        (el._vtc = new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n    cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\n    const { _vtc } = el;\n    if (_vtc) {\n        _vtc.delete(cls);\n        if (!_vtc.size) {\n            el._vtc = undefined;\n        }\n    }\n}\nfunction nextFrame(cb) {\n    requestAnimationFrame(() => {\n        requestAnimationFrame(cb);\n    });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n    const id = (el._endId = ++endId);\n    const resolveIfNotStale = () => {\n        if (id === el._endId) {\n            resolve();\n        }\n    };\n    if (explicitTimeout) {\n        return setTimeout(resolveIfNotStale, explicitTimeout);\n    }\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\n    if (!type) {\n        return resolve();\n    }\n    const endEvent = type + 'end';\n    let ended = 0;\n    const end = () => {\n        el.removeEventListener(endEvent, onEnd);\n        resolveIfNotStale();\n    };\n    const onEnd = (e) => {\n        if (e.target === el && ++ended >= propCount) {\n            end();\n        }\n    };\n    setTimeout(() => {\n        if (ended < propCount) {\n            end();\n        }\n    }, timeout + 1);\n    el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n    const styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    const getStyleProperties = (key) => (styles[key] || '').split(', ');\n    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\n    let type = null;\n    let timeout = 0;\n    let propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n        if (transitionTimeout > 0) {\n            type = TRANSITION;\n            timeout = transitionTimeout;\n            propCount = transitionDurations.length;\n        }\n    }\n    else if (expectedType === ANIMATION) {\n        if (animationTimeout > 0) {\n            type = ANIMATION;\n            timeout = animationTimeout;\n            propCount = animationDurations.length;\n        }\n    }\n    else {\n        timeout = Math.max(transitionTimeout, animationTimeout);\n        type =\n            timeout > 0\n                ? transitionTimeout > animationTimeout\n                    ? TRANSITION\n                    : ANIMATION\n                : null;\n        propCount = type\n            ? type === TRANSITION\n                ? transitionDurations.length\n                : animationDurations.length\n            : 0;\n    }\n    const hasTransform = type === TRANSITION &&\n        /\\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());\n    return {\n        type,\n        timeout,\n        propCount,\n        hasTransform\n    };\n}\nfunction getTimeout(delays, durations) {\n    while (delays.length < durations.length) {\n        delays = delays.concat(delays);\n    }\n    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\n// numbers in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down\n// (i.e. acting as a floor function) causing unexpected behaviors\nfunction toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n// synchronously force layout to put elements into a certain state\nfunction forceReflow() {\n    return document.body.offsetHeight;\n}\n\nconst positionMap = new WeakMap();\nconst newPositionMap = new WeakMap();\nconst TransitionGroupImpl = {\n    name: 'TransitionGroup',\n    props: /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({}, TransitionPropsValidators, {\n        tag: String,\n        moveClass: String\n    }),\n    setup(props, { slots }) {\n        const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();\n        const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.useTransitionState)();\n        let prevChildren;\n        let children;\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.onUpdated)(() => {\n            // children is guaranteed to exist after initial render\n            if (!prevChildren.length) {\n                return;\n            }\n            const moveClass = props.moveClass || `${props.name || 'v'}-move`;\n            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\n                return;\n            }\n            // we divide the work into three loops to avoid mixing DOM reads and writes\n            // in each iteration - which helps prevent layout thrashing.\n            prevChildren.forEach(callPendingCbs);\n            prevChildren.forEach(recordPosition);\n            const movedChildren = prevChildren.filter(applyTranslation);\n            // force reflow to put everything in position\n            forceReflow();\n            movedChildren.forEach(c => {\n                const el = c.el;\n                const style = el.style;\n                addTransitionClass(el, moveClass);\n                style.transform = style.webkitTransform = style.transitionDuration = '';\n                const cb = (el._moveCb = (e) => {\n                    if (e && e.target !== el) {\n                        return;\n                    }\n                    if (!e || /transform$/.test(e.propertyName)) {\n                        el.removeEventListener('transitionend', cb);\n                        el._moveCb = null;\n                        removeTransitionClass(el, moveClass);\n                    }\n                });\n                el.addEventListener('transitionend', cb);\n            });\n        });\n        return () => {\n            const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__.toRaw)(props);\n            const cssTransitionProps = resolveTransitionProps(rawProps);\n            let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n            prevChildren = children;\n            children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren)(slots.default()) : [];\n            for (let i = 0; i < children.length; i++) {\n                const child = children[i];\n                if (child.key != null) {\n                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));\n                }\n                else if ((true)) {\n                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<TransitionGroup> children must be keyed.`);\n                }\n            }\n            if (prevChildren) {\n                for (let i = 0; i < prevChildren.length; i++) {\n                    const child = prevChildren[i];\n                    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks)(child, (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks)(child, cssTransitionProps, state, instance));\n                    positionMap.set(child, child.el.getBoundingClientRect());\n                }\n            }\n            return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createVNode)(tag, null, children);\n        };\n    }\n};\n/**\n * TransitionGroup does not support \"mode\" so we need to remove it from the\n * props declarations, but direct delete operation is considered a side effect\n * and will make the entire transition feature non-tree-shakeable, so we do it\n * in a function and mark the function's invocation as pure.\n */\nconst removeMode = (props) => delete props.mode;\n/*#__PURE__*/ removeMode(TransitionGroupImpl.props);\nconst TransitionGroup = TransitionGroupImpl;\nfunction callPendingCbs(c) {\n    const el = c.el;\n    if (el._moveCb) {\n        el._moveCb();\n    }\n    if (el._enterCb) {\n        el._enterCb();\n    }\n}\nfunction recordPosition(c) {\n    newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n    const oldPos = positionMap.get(c);\n    const newPos = newPositionMap.get(c);\n    const dx = oldPos.left - newPos.left;\n    const dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n        const s = c.el.style;\n        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n        s.transitionDuration = '0s';\n        return c;\n    }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n    // Detect whether an element with the move class applied has\n    // CSS transitions. Since the element may be inside an entering\n    // transition at this very moment, we make a clone of it and remove\n    // all other transition classes applied to ensure only the move class\n    // is applied.\n    const clone = el.cloneNode();\n    if (el._vtc) {\n        el._vtc.forEach(cls => {\n            cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\n        });\n    }\n    moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\n    clone.style.display = 'none';\n    const container = (root.nodeType === 1 ? root : root.parentNode);\n    container.appendChild(clone);\n    const { hasTransform } = getTransitionInfo(clone);\n    container.removeChild(clone);\n    return hasTransform;\n}\n\nconst getModelAssigner = (vnode) => {\n    const fn = vnode.props['onUpdate:modelValue'] ||\n        (false );\n    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fn) ? value => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.invokeArrayFns)(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n    e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n    const target = e.target;\n    if (target.composing) {\n        target.composing = false;\n        target.dispatchEvent(new Event('input'));\n    }\n}\n// We are exporting the v-model runtime directly as vnode hooks so that it can\n// be tree-shaken in case v-model is never used.\nconst vModelText = {\n    created(el, { modifiers: { lazy, trim, number } }, vnode) {\n        el._assign = getModelAssigner(vnode);\n        const castToNumber = number || (vnode.props && vnode.props.type === 'number');\n        addEventListener(el, lazy ? 'change' : 'input', e => {\n            if (e.target.composing)\n                return;\n            let domValue = el.value;\n            if (trim) {\n                domValue = domValue.trim();\n            }\n            if (castToNumber) {\n                domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(domValue);\n            }\n            el._assign(domValue);\n        });\n        if (trim) {\n            addEventListener(el, 'change', () => {\n                el.value = el.value.trim();\n            });\n        }\n        if (!lazy) {\n            addEventListener(el, 'compositionstart', onCompositionStart);\n            addEventListener(el, 'compositionend', onCompositionEnd);\n            // Safari < 10.2 & UIWebView doesn't fire compositionend when\n            // switching focus before confirming composition choice\n            // this also fixes the issue where some browsers e.g. iOS Chrome\n            // fires \"change\" instead of \"input\" on autocomplete.\n            addEventListener(el, 'change', onCompositionEnd);\n        }\n    },\n    // set value on mounted so it's after min/max for type=\"range\"\n    mounted(el, { value }) {\n        el.value = value == null ? '' : value;\n    },\n    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\n        el._assign = getModelAssigner(vnode);\n        // avoid clearing unresolved text. #2302\n        if (el.composing)\n            return;\n        if (document.activeElement === el && el.type !== 'range') {\n            if (lazy) {\n                return;\n            }\n            if (trim && el.value.trim() === value) {\n                return;\n            }\n            if ((number || el.type === 'number') &&\n                (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(el.value) === value) {\n                return;\n            }\n        }\n        const newValue = value == null ? '' : value;\n        if (el.value !== newValue) {\n            el.value = newValue;\n        }\n    }\n};\nconst vModelCheckbox = {\n    // #4096 array checkboxes need to be deep traversed\n    deep: true,\n    created(el, _, vnode) {\n        el._assign = getModelAssigner(vnode);\n        addEventListener(el, 'change', () => {\n            const modelValue = el._modelValue;\n            const elementValue = getValue(el);\n            const checked = el.checked;\n            const assign = el._assign;\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(modelValue)) {\n                const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(modelValue, elementValue);\n                const found = index !== -1;\n                if (checked && !found) {\n                    assign(modelValue.concat(elementValue));\n                }\n                else if (!checked && found) {\n                    const filtered = [...modelValue];\n                    filtered.splice(index, 1);\n                    assign(filtered);\n                }\n            }\n            else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(modelValue)) {\n                const cloned = new Set(modelValue);\n                if (checked) {\n                    cloned.add(elementValue);\n                }\n                else {\n                    cloned.delete(elementValue);\n                }\n                assign(cloned);\n            }\n            else {\n                assign(getCheckboxValue(el, checked));\n            }\n        });\n    },\n    // set initial checked on mount to wait for true-value/false-value\n    mounted: setChecked,\n    beforeUpdate(el, binding, vnode) {\n        el._assign = getModelAssigner(vnode);\n        setChecked(el, binding, vnode);\n    }\n};\nfunction setChecked(el, { value, oldValue }, vnode) {\n    el._modelValue = value;\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1;\n    }\n    else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\n        el.checked = value.has(vnode.props.value);\n    }\n    else if (value !== oldValue) {\n        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, getCheckboxValue(el, true));\n    }\n}\nconst vModelRadio = {\n    created(el, { value }, vnode) {\n        el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);\n        el._assign = getModelAssigner(vnode);\n        addEventListener(el, 'change', () => {\n            el._assign(getValue(el));\n        });\n    },\n    beforeUpdate(el, { value, oldValue }, vnode) {\n        el._assign = getModelAssigner(vnode);\n        if (value !== oldValue) {\n            el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(value, vnode.props.value);\n        }\n    }\n};\nconst vModelSelect = {\n    // <select multiple> value need to be deep traversed\n    deep: true,\n    created(el, { value, modifiers: { number } }, vnode) {\n        const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value);\n        addEventListener(el, 'change', () => {\n            const selectedVal = Array.prototype.filter\n                .call(el.options, (o) => o.selected)\n                .map((o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseToNumber)(getValue(o)) : getValue(o));\n            el._assign(el.multiple\n                ? isSetModel\n                    ? new Set(selectedVal)\n                    : selectedVal\n                : selectedVal[0]);\n        });\n        el._assign = getModelAssigner(vnode);\n    },\n    // set value in mounted & updated because <select> relies on its children\n    // <option>s.\n    mounted(el, { value }) {\n        setSelected(el, value);\n    },\n    beforeUpdate(el, _binding, vnode) {\n        el._assign = getModelAssigner(vnode);\n    },\n    updated(el, { value }) {\n        setSelected(el, value);\n    }\n};\nfunction setSelected(el, value) {\n    const isMultiple = el.multiple;\n    if (isMultiple && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\n        ( true) &&\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`<select multiple v-model> expects an Array or Set value for its binding, ` +\n                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);\n        return;\n    }\n    for (let i = 0, l = el.options.length; i < l; i++) {\n        const option = el.options[i];\n        const optionValue = getValue(option);\n        if (isMultiple) {\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n                option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, optionValue) > -1;\n            }\n            else {\n                option.selected = value.has(optionValue);\n            }\n        }\n        else {\n            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(getValue(option), value)) {\n                if (el.selectedIndex !== i)\n                    el.selectedIndex = i;\n                return;\n            }\n        }\n    }\n    if (!isMultiple && el.selectedIndex !== -1) {\n        el.selectedIndex = -1;\n    }\n}\n// retrieve raw value set via :value bindings\nfunction getValue(el) {\n    return '_value' in el ? el._value : el.value;\n}\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\nfunction getCheckboxValue(el, checked) {\n    const key = checked ? '_trueValue' : '_falseValue';\n    return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n    created(el, binding, vnode) {\n        callModelHook(el, binding, vnode, null, 'created');\n    },\n    mounted(el, binding, vnode) {\n        callModelHook(el, binding, vnode, null, 'mounted');\n    },\n    beforeUpdate(el, binding, vnode, prevVNode) {\n        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');\n    },\n    updated(el, binding, vnode, prevVNode) {\n        callModelHook(el, binding, vnode, prevVNode, 'updated');\n    }\n};\nfunction resolveDynamicModel(tagName, type) {\n    switch (tagName) {\n        case 'SELECT':\n            return vModelSelect;\n        case 'TEXTAREA':\n            return vModelText;\n        default:\n            switch (type) {\n                case 'checkbox':\n                    return vModelCheckbox;\n                case 'radio':\n                    return vModelRadio;\n                default:\n                    return vModelText;\n            }\n    }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);\n    const fn = modelToUse[hook];\n    fn && fn(el, binding, vnode, prevVNode);\n}\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nfunction initVModelForSSR() {\n    vModelText.getSSRProps = ({ value }) => ({ value });\n    vModelRadio.getSSRProps = ({ value }, vnode) => {\n        if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseEqual)(vnode.props.value, value)) {\n            return { checked: true };\n        }\n    };\n    vModelCheckbox.getSSRProps = ({ value }, vnode) => {\n        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(value)) {\n            if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.looseIndexOf)(value, vnode.props.value) > -1) {\n                return { checked: true };\n            }\n        }\n        else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSet)(value)) {\n            if (vnode.props && value.has(vnode.props.value)) {\n                return { checked: true };\n            }\n        }\n        else if (value) {\n            return { checked: true };\n        }\n    };\n    vModelDynamic.getSSRProps = (binding, vnode) => {\n        if (typeof vnode.type !== 'string') {\n            return;\n        }\n        const modelToUse = resolveDynamicModel(\n        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n        vnode.type.toUpperCase(), vnode.props && vnode.props.type);\n        if (modelToUse.getSSRProps) {\n            return modelToUse.getSSRProps(binding, vnode);\n        }\n    };\n}\n\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];\nconst modifierGuards = {\n    stop: e => e.stopPropagation(),\n    prevent: e => e.preventDefault(),\n    self: e => e.target !== e.currentTarget,\n    ctrl: e => !e.ctrlKey,\n    shift: e => !e.shiftKey,\n    alt: e => !e.altKey,\n    meta: e => !e.metaKey,\n    left: e => 'button' in e && e.button !== 0,\n    middle: e => 'button' in e && e.button !== 1,\n    right: e => 'button' in e && e.button !== 2,\n    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\n};\n/**\n * @private\n */\nconst withModifiers = (fn, modifiers) => {\n    return (event, ...args) => {\n        for (let i = 0; i < modifiers.length; i++) {\n            const guard = modifierGuards[modifiers[i]];\n            if (guard && guard(event, modifiers))\n                return;\n        }\n        return fn(event, ...args);\n    };\n};\n// Kept for 2.x compat.\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\nconst keyNames = {\n    esc: 'escape',\n    space: ' ',\n    up: 'arrow-up',\n    left: 'arrow-left',\n    right: 'arrow-right',\n    down: 'arrow-down',\n    delete: 'backspace'\n};\n/**\n * @private\n */\nconst withKeys = (fn, modifiers) => {\n    return (event) => {\n        if (!('key' in event)) {\n            return;\n        }\n        const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.hyphenate)(event.key);\n        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\n            return fn(event);\n        }\n    };\n};\n\nconst vShow = {\n    beforeMount(el, { value }, { transition }) {\n        el._vod = el.style.display === 'none' ? '' : el.style.display;\n        if (transition && value) {\n            transition.beforeEnter(el);\n        }\n        else {\n            setDisplay(el, value);\n        }\n    },\n    mounted(el, { value }, { transition }) {\n        if (transition && value) {\n            transition.enter(el);\n        }\n    },\n    updated(el, { value, oldValue }, { transition }) {\n        if (!value === !oldValue)\n            return;\n        if (transition) {\n            if (value) {\n                transition.beforeEnter(el);\n                setDisplay(el, true);\n                transition.enter(el);\n            }\n            else {\n                transition.leave(el, () => {\n                    setDisplay(el, false);\n                });\n            }\n        }\n        else {\n            setDisplay(el, value);\n        }\n    },\n    beforeUnmount(el, { value }) {\n        setDisplay(el, value);\n    }\n};\nfunction setDisplay(el, value) {\n    el.style.display = value ? el._vod : 'none';\n}\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nfunction initVShowForSSR() {\n    vShow.getSSRProps = ({ value }) => {\n        if (!value) {\n            return { style: { display: 'none' } };\n        }\n    };\n}\n\nconst rendererOptions = /*#__PURE__*/ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.extend)({ patchProp }, nodeOps);\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from Vue.\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n    return (renderer ||\n        (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createRenderer)(rendererOptions)));\n}\nfunction ensureHydrationRenderer() {\n    renderer = enabledHydration\n        ? renderer\n        : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer)(rendererOptions);\n    enabledHydration = true;\n    return renderer;\n}\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\nconst render = ((...args) => {\n    ensureRenderer().render(...args);\n});\nconst hydrate = ((...args) => {\n    ensureHydrationRenderer().hydrate(...args);\n});\nconst createApp = ((...args) => {\n    const app = ensureRenderer().createApp(...args);\n    if ((true)) {\n        injectNativeTagCheck(app);\n        injectCompilerOptionsCheck(app);\n    }\n    const { mount } = app;\n    app.mount = (containerOrSelector) => {\n        const container = normalizeContainer(containerOrSelector);\n        if (!container)\n            return;\n        const component = app._component;\n        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(component) && !component.render && !component.template) {\n            // __UNSAFE__\n            // Reason: potential execution of JS expressions in in-DOM template.\n            // The user must make sure the in-DOM template is trusted. If it's\n            // rendered by the server, the template should not contain any user data.\n            component.template = container.innerHTML;\n        }\n        // clear content before mounting\n        container.innerHTML = '';\n        const proxy = mount(container, false, container instanceof SVGElement);\n        if (container instanceof Element) {\n            container.removeAttribute('v-cloak');\n            container.setAttribute('data-v-app', '');\n        }\n        return proxy;\n    };\n    return app;\n});\nconst createSSRApp = ((...args) => {\n    const app = ensureHydrationRenderer().createApp(...args);\n    if ((true)) {\n        injectNativeTagCheck(app);\n        injectCompilerOptionsCheck(app);\n    }\n    const { mount } = app;\n    app.mount = (containerOrSelector) => {\n        const container = normalizeContainer(containerOrSelector);\n        if (container) {\n            return mount(container, true, container instanceof SVGElement);\n        }\n    };\n    return app;\n});\nfunction injectNativeTagCheck(app) {\n    // Inject `isNativeTag`\n    // this is used for component name validation (dev only)\n    Object.defineProperty(app.config, 'isNativeTag', {\n        value: (tag) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isHTMLTag)(tag) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isSVGTag)(tag),\n        writable: false\n    });\n}\n// dev only\nfunction injectCompilerOptionsCheck(app) {\n    if ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly)()) {\n        const isCustomElement = app.config.isCustomElement;\n        Object.defineProperty(app.config, 'isCustomElement', {\n            get() {\n                return isCustomElement;\n            },\n            set() {\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`The \\`isCustomElement\\` config option is deprecated. Use ` +\n                    `\\`compilerOptions.isCustomElement\\` instead.`);\n            }\n        });\n        const compilerOptions = app.config.compilerOptions;\n        const msg = `The \\`compilerOptions\\` config option is only respected when using ` +\n            `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` +\n            `Since you are using the runtime-only build, \\`compilerOptions\\` ` +\n            `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` +\n            `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` +\n            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` +\n            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;\n        Object.defineProperty(app.config, 'compilerOptions', {\n            get() {\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);\n                return compilerOptions;\n            },\n            set() {\n                (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(msg);\n            }\n        });\n    }\n}\nfunction normalizeContainer(container) {\n    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(container)) {\n        const res = document.querySelector(container);\n        if (( true) && !res) {\n            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`Failed to mount app: mount target selector \"${container}\" returned null.`);\n        }\n        return res;\n    }\n    if (( true) &&\n        window.ShadowRoot &&\n        container instanceof window.ShadowRoot &&\n        container.mode === 'closed') {\n        (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.warn)(`mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`);\n    }\n    return container;\n}\nlet ssrDirectiveInitialized = false;\n/**\n * @internal\n */\nconst initDirectivesForSSR = () => {\n        if (!ssrDirectiveInitialized) {\n            ssrDirectiveInitialized = true;\n            initVModelForSSR();\n            initVShowForSSR();\n        }\n    }\n    ;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9kaXN0L3J1bnRpbWUtZG9tLmVzbS1idW5kbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJZO0FBQ3pXO0FBQ3NROztBQUV4UztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixxREFBUTtBQUNoQztBQUNBLHFCQUFxQixxREFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVnUyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdnVlL3J1bnRpbWUtZG9tL2Rpc3QvcnVudGltZS1kb20uZXNtLWJ1bmRsZXIuanM/MjcyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3YXJuLCBjYW1lbGl6ZSwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGRlZmluZUNvbXBvbmVudCwgbmV4dFRpY2ssIGNyZWF0ZVZOb2RlLCBnZXRDdXJyZW50SW5zdGFuY2UsIHdhdGNoUG9zdEVmZmVjdCwgb25Nb3VudGVkLCBvblVubW91bnRlZCwgRnJhZ21lbnQsIFN0YXRpYywgaCwgQmFzZVRyYW5zaXRpb24sIGFzc2VydE51bWJlciwgdXNlVHJhbnNpdGlvblN0YXRlLCBvblVwZGF0ZWQsIHRvUmF3LCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIHNldFRyYW5zaXRpb25Ib29rcywgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcywgaXNSdW50aW1lT25seSwgY3JlYXRlUmVuZGVyZXIsIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHZ1ZS9ydW50aW1lLWNvcmUnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzQXJyYXksIGh5cGhlbmF0ZSwgY2FwaXRhbGl6ZSwgaXNTcGVjaWFsQm9vbGVhbkF0dHIsIGluY2x1ZGVCb29sZWFuQXR0ciwgaXNPbiwgaXNNb2RlbExpc3RlbmVyLCBpc0Z1bmN0aW9uLCBjYW1lbGl6ZSBhcyBjYW1lbGl6ZSQxLCB0b051bWJlciwgZXh0ZW5kLCBFTVBUWV9PQkosIGlzT2JqZWN0LCBsb29zZVRvTnVtYmVyLCBsb29zZUluZGV4T2YsIGlzU2V0LCBsb29zZUVxdWFsLCBpbnZva2VBcnJheUZucywgaXNIVE1MVGFnLCBpc1NWR1RhZyB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuY29uc3Qgc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuY29uc3QgZG9jID0gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGwpO1xuY29uc3QgdGVtcGxhdGVDb250YWluZXIgPSBkb2MgJiYgLyojX19QVVJFX18qLyBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbmNvbnN0IG5vZGVPcHMgPSB7XG4gICAgaW5zZXJ0OiAoY2hpbGQsIHBhcmVudCwgYW5jaG9yKSA9PiB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcbiAgICB9LFxuICAgIHJlbW92ZTogY2hpbGQgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50OiAodGFnLCBpc1NWRywgaXMsIHByb3BzKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gaXNTVkdcbiAgICAgICAgICAgID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdGFnKVxuICAgICAgICAgICAgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWcsIGlzID8geyBpcyB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsIHByb3BzLm11bHRpcGxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcbiAgICBjcmVhdGVUZXh0OiB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSxcbiAgICBjcmVhdGVDb21tZW50OiB0ZXh0ID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxuICAgIHNldFRleHQ6IChub2RlLCB0ZXh0KSA9PiB7XG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgICB9LFxuICAgIHNldEVsZW1lbnRUZXh0OiAoZWwsIHRleHQpID0+IHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH0sXG4gICAgcGFyZW50Tm9kZTogbm9kZSA9PiBub2RlLnBhcmVudE5vZGUsXG4gICAgbmV4dFNpYmxpbmc6IG5vZGUgPT4gbm9kZS5uZXh0U2libGluZyxcbiAgICBxdWVyeVNlbGVjdG9yOiBzZWxlY3RvciA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXG4gICAgc2V0U2NvcGVJZChlbCwgaWQpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGlkLCAnJyk7XG4gICAgfSxcbiAgICAvLyBfX1VOU0FGRV9fXG4gICAgLy8gUmVhc29uOiBpbm5lckhUTUwuXG4gICAgLy8gU3RhdGljIGNvbnRlbnQgaGVyZSBjYW4gb25seSBjb21lIGZyb20gY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgIC8vIEFzIGxvbmcgYXMgdGhlIHVzZXIgb25seSB1c2VzIHRydXN0ZWQgdGVtcGxhdGVzLCB0aGlzIGlzIHNhZmUuXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgaXNTVkcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgLy8gPHBhcmVudD4gYmVmb3JlIHwgZmlyc3QgLi4uIGxhc3QgfCBhbmNob3IgPC9wYXJlbnQ+XG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgICAgICAvLyAjNTMwOCBjYW4gb25seSB0YWtlIGNhY2hlZCBwYXRoIGlmOlxuICAgICAgICAvLyAtIGhhcyBhIHNpbmdsZSByb290IG5vZGVcbiAgICAgICAgLy8gLSBuZXh0U2libGluZyBpbmZvIGlzIHN0aWxsIGF2YWlsYWJsZVxuICAgICAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAvLyBjYWNoZWRcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgfHwgIShzdGFydCA9IHN0YXJ0Lm5leHRTaWJsaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBmcmVzaCBpbnNlcnRcbiAgICAgICAgICAgIHRlbXBsYXRlQ29udGFpbmVyLmlubmVySFRNTCA9IGlzU1ZHID8gYDxzdmc+JHtjb250ZW50fTwvc3ZnPmAgOiBjb250ZW50O1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNvbnRhaW5lci5jb250ZW50O1xuICAgICAgICAgICAgaWYgKGlzU1ZHKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG91dGVyIHN2ZyB3cmFwcGVyXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IHRlbXBsYXRlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIGZpcnN0XG4gICAgICAgICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgIC8vIGxhc3RcbiAgICAgICAgICAgIGFuY2hvciA/IGFuY2hvci5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkXG4gICAgICAgIF07XG4gICAgfVxufTtcblxuLy8gY29tcGlsZXIgc2hvdWxkIG5vcm1hbGl6ZSBjbGFzcyArIDpjbGFzcyBiaW5kaW5ncyBvbiB0aGUgc2FtZSBlbGVtZW50XG4vLyBpbnRvIGEgc2luZ2xlIGJpbmRpbmcgWydzdGF0aWNDbGFzcycsIGR5bmFtaWNdXG5mdW5jdGlvbiBwYXRjaENsYXNzKGVsLCB2YWx1ZSwgaXNTVkcpIHtcbiAgICAvLyBkaXJlY3RseSBzZXR0aW5nIGNsYXNzTmFtZSBzaG91bGQgYmUgZmFzdGVyIHRoYW4gc2V0QXR0cmlidXRlIGluIHRoZW9yeVxuICAgIC8vIGlmIHRoaXMgaXMgYW4gZWxlbWVudCBkdXJpbmcgYSB0cmFuc2l0aW9uLCB0YWtlIHRoZSB0ZW1wb3JhcnkgdHJhbnNpdGlvblxuICAgIC8vIGNsYXNzZXMgaW50byBhY2NvdW50LlxuICAgIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3Z0YztcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPyBbdmFsdWUsIC4uLnRyYW5zaXRpb25DbGFzc2VzXSA6IFsuLi50cmFuc2l0aW9uQ2xhc3Nlc10pLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NWRykge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdmFsdWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICBjb25zdCBpc0Nzc1N0cmluZyA9IGlzU3RyaW5nKG5leHQpO1xuICAgIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xuICAgICAgICBpZiAocHJldiAmJiAhaXNTdHJpbmcocHJldikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICAgICAgICBzZXRTdHlsZShzdHlsZSwga2V5LCBuZXh0W2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjdXJyZW50RGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmIChpc0Nzc1N0cmluZykge1xuICAgICAgICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5jc3NUZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5kaWNhdGVzIHRoYXQgdGhlIGBkaXNwbGF5YCBvZiB0aGUgZWxlbWVudCBpcyBjb250cm9sbGVkIGJ5IGB2LXNob3dgLFxuICAgICAgICAvLyBzbyB3ZSBhbHdheXMga2VlcCB0aGUgY3VycmVudCBgZGlzcGxheWAgdmFsdWUgcmVnYXJkbGVzcyBvZiB0aGUgYHN0eWxlYFxuICAgICAgICAvLyB2YWx1ZSwgdGh1cyBoYW5kaW5nIG92ZXIgY29udHJvbCB0byBgdi1zaG93YC5cbiAgICAgICAgaWYgKCdfdm9kJyBpbiBlbCkge1xuICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IGN1cnJlbnREaXNwbGF5O1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3Qgc2VtaWNvbG9uUkUgPSAvW15cXFxcXTtcXHMqJC87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xuICAgIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsLmZvckVhY2godiA9PiBzZXRTdHlsZShzdHlsZSwgbmFtZSwgdikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgdmFsID0gJyc7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgIGlmIChzZW1pY29sb25SRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBVbmV4cGVjdGVkIHNlbWljb2xvbiBhdCB0aGUgZW5kIG9mICcke25hbWV9JyBzdHlsZSB2YWx1ZTogJyR7dmFsfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCctLScpKSB7XG4gICAgICAgICAgICAvLyBjdXN0b20gcHJvcGVydHkgZGVmaW5pdGlvblxuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkID0gYXV0b1ByZWZpeChzdHlsZSwgbmFtZSk7XG4gICAgICAgICAgICBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gIWltcG9ydGFudFxuICAgICAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShwcmVmaXhlZCksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlW3ByZWZpeGVkXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5jb25zdCBwcmVmaXhDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYXV0b1ByZWZpeChzdHlsZSwgcmF3TmFtZSkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG5hbWUgPSBjYW1lbGl6ZShyYXdOYW1lKTtcbiAgICBpZiAobmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZSk7XG4gICAgfVxuICAgIG5hbWUgPSBjYXBpdGFsaXplKG5hbWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIG5hbWU7XG4gICAgICAgIGlmIChwcmVmaXhlZCBpbiBzdHlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmF3TmFtZTtcbn1cblxuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbmZ1bmN0aW9uIHBhdGNoQXR0cihlbCwga2V5LCB2YWx1ZSwgaXNTVkcsIGluc3RhbmNlKSB7XG4gICAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywga2V5LnNsaWNlKDYsIGtleS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBub3RlIHdlIGFyZSBvbmx5IGNoZWNraW5nIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0IGRvbid0IGhhdmUgYVxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGRvbSBwcm9wIG9mIHRoZSBzYW1lIG5hbWUgaGVyZS5cbiAgICAgICAgY29uc3QgaXNCb29sZWFuID0gaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGlzQm9vbGVhbiAmJiAhaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNCb29sZWFuID8gJycgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIF9fVU5TQUZFX19cbi8vIGZ1bmN0aW9ucy4gVGhlIHVzZXIgaXMgcmVzcG9uc2libGUgZm9yIHVzaW5nIHRoZW0gd2l0aCBvbmx5IHRydXN0ZWQgY29udGVudC5cbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXG4vLyB0aGUgZm9sbG93aW5nIGFyZ3MgYXJlIHBhc3NlZCBvbmx5IGR1ZSB0byBwb3RlbnRpYWwgaW5uZXJIVE1ML3RleHRDb250ZW50XG4vLyBvdmVycmlkaW5nIGV4aXN0aW5nIFZOb2RlcywgaW4gd2hpY2ggY2FzZSB0aGUgb2xkIHRyZWUgbXVzdCBiZSBwcm9wZXJseVxuLy8gdW5tb3VudGVkLlxucHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pIHtcbiAgICBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyB8fCBrZXkgPT09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgZWwudGFnTmFtZSAhPT0gJ1BST0dSRVNTJyAmJlxuICAgICAgICAvLyBjdXN0b20gZWxlbWVudHMgbWF5IHVzZSBfdmFsdWUgaW50ZXJuYWxseVxuICAgICAgICAhZWwudGFnTmFtZS5pbmNsdWRlcygnLScpKSB7XG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQuXG4gICAgICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICBpZiAoZWwudmFsdWUgIT09IG5ld1ZhbHVlIHx8XG4gICAgICAgICAgICAvLyAjNDk1NjogYWx3YXlzIHNldCBmb3IgT1BUSU9OIGVsZW1lbnRzIGJlY2F1c2UgaXRzIHZhbHVlIGZhbGxzIGJhY2sgdG9cbiAgICAgICAgICAgIC8vIHRleHRDb250ZW50IGlmIG5vIHZhbHVlIGF0dHJpYnV0ZSBpcyBwcmVzZW50LiBBbmQgc2V0dGluZyAudmFsdWUgZm9yXG4gICAgICAgICAgICAvLyBPUFRJT04gaGFzIG5vIHNpZGUgZWZmZWN0XG4gICAgICAgICAgICBlbC50YWdOYW1lID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgZWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbmVlZFJlbW92ZSA9IGZhbHNlO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGVsW2tleV07XG4gICAgICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIC8vIGUuZy4gPHNlbGVjdCBtdWx0aXBsZT4gY29tcGlsZXMgdG8geyBtdWx0aXBsZTogJycgfVxuICAgICAgICAgICAgdmFsdWUgPSBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGUuZy4gPGRpdiA6aWQ9XCJudWxsXCI+XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGUuZy4gPGltZyA6d2lkdGg9XCJudWxsXCI+XG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzb21lIHByb3BlcnRpZXMgcGVyZm9ybSB2YWx1ZSB2YWxpZGF0aW9uIGFuZCB0aHJvdyxcbiAgICAvLyBzb21lIHByb3BlcnRpZXMgaGFzIGdldHRlciwgbm8gc2V0dGVyLCB3aWxsIGVycm9yIGluICd1c2Ugc3RyaWN0J1xuICAgIC8vIGVnLiA8c2VsZWN0IDp0eXBlPVwibnVsbFwiPjwvc2VsZWN0PiA8c2VsZWN0IDp3aWxsVmFsaWRhdGU9XCJudWxsXCI+PC9zZWxlY3Q+XG4gICAgdHJ5IHtcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3Qgd2FybiBpZiB2YWx1ZSBpcyBhdXRvLWNvZXJjZWQgZnJvbSBudWxsaXNoIHZhbHVlc1xuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFuZWVkUmVtb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKGBGYWlsZWQgc2V0dGluZyBwcm9wIFwiJHtrZXl9XCIgb24gPCR7ZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xuICAgICAgICAgICAgICAgIGB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcGF0Y2hFdmVudChlbCwgcmF3TmFtZSwgcHJldlZhbHVlLCBuZXh0VmFsdWUsIGluc3RhbmNlID0gbnVsbCkge1xuICAgIC8vIHZlaSA9IHZ1ZSBldmVudCBpbnZva2Vyc1xuICAgIGNvbnN0IGludm9rZXJzID0gZWwuX3ZlaSB8fCAoZWwuX3ZlaSA9IHt9KTtcbiAgICBjb25zdCBleGlzdGluZ0ludm9rZXIgPSBpbnZva2Vyc1tyYXdOYW1lXTtcbiAgICBpZiAobmV4dFZhbHVlICYmIGV4aXN0aW5nSW52b2tlcikge1xuICAgICAgICAvLyBwYXRjaFxuICAgICAgICBleGlzdGluZ0ludm9rZXIudmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBbbmFtZSwgb3B0aW9uc10gPSBwYXJzZU5hbWUocmF3TmFtZSk7XG4gICAgICAgIGlmIChuZXh0VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGFkZFxuICAgICAgICAgICAgY29uc3QgaW52b2tlciA9IChpbnZva2Vyc1tyYXdOYW1lXSA9IGNyZWF0ZUludm9rZXIobmV4dFZhbHVlLCBpbnN0YW5jZSkpO1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaW52b2tlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmdJbnZva2VyKSB7XG4gICAgICAgICAgICAvLyByZW1vdmVcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpbnZva2Vyc1tyYXdOYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IG9wdGlvbnNNb2RpZmllclJFID0gLyg/Ok9uY2V8UGFzc2l2ZXxDYXB0dXJlKSQvO1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAob3B0aW9uc01vZGlmaWVyUkUudGVzdChuYW1lKSkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIGxldCBtO1xuICAgICAgICB3aGlsZSAoKG0gPSBuYW1lLm1hdGNoKG9wdGlvbnNNb2RpZmllclJFKSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgb3B0aW9uc1ttWzBdLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBldmVudCA9IG5hbWVbMl0gPT09ICc6JyA/IG5hbWUuc2xpY2UoMykgOiBoeXBoZW5hdGUobmFtZS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIFtldmVudCwgb3B0aW9uc107XG59XG4vLyBUbyBhdm9pZCB0aGUgb3ZlcmhlYWQgb2YgcmVwZWF0ZWRseSBjYWxsaW5nIERhdGUubm93KCksIHdlIGNhY2hlXG4vLyBhbmQgdXNlIHRoZSBzYW1lIHRpbWVzdGFtcCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCBpbiB0aGUgc2FtZSB0aWNrLlxubGV0IGNhY2hlZE5vdyA9IDA7XG5jb25zdCBwID0gLyojX19QVVJFX18qLyBQcm9taXNlLnJlc29sdmUoKTtcbmNvbnN0IGdldE5vdyA9ICgpID0+IGNhY2hlZE5vdyB8fCAocC50aGVuKCgpID0+IChjYWNoZWROb3cgPSAwKSksIChjYWNoZWROb3cgPSBEYXRlLm5vdygpKSk7XG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcbiAgICBjb25zdCBpbnZva2VyID0gKGUpID0+IHtcbiAgICAgICAgLy8gYXN5bmMgZWRnZSBjYXNlIHZ1ZWpzL3Z1ZSM2NTY2XG4gICAgICAgIC8vIGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgICAgICAvLyB0aGlzIG5vIGxvbmdlciBoYXBwZW5zIGZvciB0ZW1wbGF0ZXMgaW4gVnVlIDMsIGJ1dCBjb3VsZCBzdGlsbCBiZVxuICAgICAgICAvLyB0aGVvcmV0aWNhbGx5IHBvc3NpYmxlIGZvciBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgICAgICAgLy8gdGhlIHNvbHV0aW9uOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gICAgICAgIC8vIGFuZCBhbHNvIGF0dGFjaCB0aGUgdGltZXN0YW1wIHRvIGFueSBldmVudCB0aGF0IHdhcyBoYW5kbGVkIGJ5IHZ1ZVxuICAgICAgICAvLyBmb3IgdGhlIGZpcnN0IHRpbWUgKHRvIGF2b2lkIGluY29uc2lzdGVudCBldmVudCB0aW1lc3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIC8vIG9yIGV2ZW50cyBmaXJlZCBmcm9tIGlmcmFtZXMsIGUuZy4gIzI1MTMpXG4gICAgICAgIC8vIFRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAgICAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gICAgICAgIGlmICghZS5fdnRzKSB7XG4gICAgICAgICAgICBlLl92dHMgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUuX3Z0cyA8PSBpbnZva2VyLmF0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcocGF0Y2hTdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZSwgaW52b2tlci52YWx1ZSksIGluc3RhbmNlLCA1IC8qIEVycm9yQ29kZXMuTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi8sIFtlXSk7XG4gICAgfTtcbiAgICBpbnZva2VyLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIGludm9rZXIuYXR0YWNoZWQgPSBnZXROb3coKTtcbiAgICByZXR1cm4gaW52b2tlcjtcbn1cbmZ1bmN0aW9uIHBhdGNoU3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGUsIHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xuICAgICAgICAgICAgZS5fc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZm4gPT4gKGUpID0+ICFlLl9zdG9wcGVkICYmIGZuICYmIGZuKGUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbmNvbnN0IG5hdGl2ZU9uUkUgPSAvXm9uW2Etel0vO1xuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xuICAgIGlmIChrZXkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgcGF0Y2hDbGFzcyhlbCwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICBwYXRjaFN0eWxlKGVsLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT24oa2V5KSkge1xuICAgICAgICAvLyBpZ25vcmUgdi1tb2RlbCBsaXN0ZW5lcnNcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xuICAgICAgICAgICAgcGF0Y2hFdmVudChlbCwga2V5LCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgcGFyZW50Q29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChrZXlbMF0gPT09ICcuJ1xuICAgICAgICA/ICgoa2V5ID0ga2V5LnNsaWNlKDEpKSwgdHJ1ZSlcbiAgICAgICAgOiBrZXlbMF0gPT09ICdeJ1xuICAgICAgICAgICAgPyAoKGtleSA9IGtleS5zbGljZSgxKSksIGZhbHNlKVxuICAgICAgICAgICAgOiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRykpIHtcbiAgICAgICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8aW5wdXQgdi1tb2RlbCB0eXBlPVwiY2hlY2tib3hcIj4gd2l0aFxuICAgICAgICAvLyA6dHJ1ZS12YWx1ZSAmIDpmYWxzZS12YWx1ZVxuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBkb20gcHJvcGVydGllcyBzaW5jZSBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlXG4gICAgICAgIC8vIHN0cmluZ2lmaWVkLlxuICAgICAgICBpZiAoa2V5ID09PSAndHJ1ZS12YWx1ZScpIHtcbiAgICAgICAgICAgIGVsLl90cnVlVmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZmFsc2UtdmFsdWUnKSB7XG4gICAgICAgICAgICBlbC5fZmFsc2VWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHIoZWwsIGtleSwgbmV4dFZhbHVlLCBpc1NWRyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNob3VsZFNldEFzUHJvcChlbCwga2V5LCB2YWx1ZSwgaXNTVkcpIHtcbiAgICBpZiAoaXNTVkcpIHtcbiAgICAgICAgLy8gbW9zdCBrZXlzIG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZSBvbiBzdmcgZWxlbWVudHMgdG8gd29ya1xuICAgICAgICAvLyAuLi5leGNlcHQgaW5uZXJIVE1MICYgdGV4dENvbnRlbnRcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvciBuYXRpdmUgb25jbGljayB3aXRoIGZ1bmN0aW9uIHZhbHVlc1xuICAgICAgICBpZiAoa2V5IGluIGVsICYmIG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHRoZXNlIGFyZSBlbnVtZXJhdGVkIGF0dHJzLCBob3dldmVyIHRoZWlyIGNvcnJlc3BvbmRpbmcgRE9NIHByb3BlcnRpZXNcbiAgICAvLyBhcmUgYWN0dWFsbHkgYm9vbGVhbnMgLSB0aGlzIGxlYWRzIHRvIHNldHRpbmcgaXQgd2l0aCBhIHN0cmluZyBcImZhbHNlXCJcbiAgICAvLyB2YWx1ZSBsZWFkaW5nIGl0IHRvIGJlIGNvZXJjZWQgdG8gYHRydWVgLCBzbyB3ZSBuZWVkIHRvIGFsd2F5cyB0cmVhdFxuICAgIC8vIHRoZW0gYXMgYXR0cmlidXRlcy5cbiAgICAvLyBOb3RlIHRoYXQgYGNvbnRlbnRFZGl0YWJsZWAgZG9lc24ndCBoYXZlIHRoaXMgcHJvYmxlbTogaXRzIERPTVxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gZW51bWVyYXRlZCBzdHJpbmcgdmFsdWVzLlxuICAgIGlmIChrZXkgPT09ICdzcGVsbGNoZWNrJyB8fCBrZXkgPT09ICdkcmFnZ2FibGUnIHx8IGtleSA9PT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyAjMTc4NywgIzI4NDAgZm9ybSBwcm9wZXJ0eSBvbiBmb3JtIGVsZW1lbnRzIGlzIHJlYWRvbmx5IGFuZCBtdXN0IGJlIHNldCBhc1xuICAgIC8vIGF0dHJpYnV0ZS5cbiAgICBpZiAoa2V5ID09PSAnZm9ybScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyAjMTUyNiA8aW5wdXQgbGlzdD4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXG4gICAgaWYgKGtleSA9PT0gJ2xpc3QnICYmIGVsLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyAjMjc2NiA8dGV4dGFyZWEgdHlwZT4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXG4gICAgaWYgKGtleSA9PT0gJ3R5cGUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBuYXRpdmUgb25jbGljayB3aXRoIHN0cmluZyB2YWx1ZSwgbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXG4gICAgaWYgKG5hdGl2ZU9uUkUudGVzdChrZXkpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBrZXkgaW4gZWw7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgaHlkcmF0ZSkge1xuICAgIGNvbnN0IENvbXAgPSBkZWZpbmVDb21wb25lbnQob3B0aW9ucyk7XG4gICAgY2xhc3MgVnVlQ3VzdG9tRWxlbWVudCBleHRlbmRzIFZ1ZUVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcbiAgICAgICAgICAgIHN1cGVyKENvbXAsIGluaXRpYWxQcm9wcywgaHlkcmF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVnVlQ3VzdG9tRWxlbWVudC5kZWYgPSBDb21wO1xuICAgIHJldHVybiBWdWVDdXN0b21FbGVtZW50O1xufVxuY29uc3QgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCA9ICgob3B0aW9ucykgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlKTtcbn0pO1xuY29uc3QgQmFzZUNsYXNzID0gKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBIVE1MRWxlbWVudCA6IGNsYXNzIHtcbn0pO1xuY2xhc3MgVnVlRWxlbWVudCBleHRlbmRzIEJhc2VDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoX2RlZiwgX3Byb3BzID0ge30sIGh5ZHJhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZGVmID0gX2RlZjtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBfcHJvcHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBoeWRyYXRlKSB7XG4gICAgICAgICAgICBoeWRyYXRlKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgIHdhcm4oYEN1c3RvbSBlbGVtZW50IGhhcyBwcmUtcmVuZGVyZWQgZGVjbGFyYXRpdmUgc2hhZG93IHJvb3QgYnV0IGlzIG5vdCBgICtcbiAgICAgICAgICAgICAgICAgICAgYGRlZmluZWQgYXMgaHlkcmF0YWJsZS4gVXNlIFxcYGRlZmluZVNTUkN1c3RvbUVsZW1lbnRcXGAuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3Igc3luYyBjb21wb25lbnQgZGVmcyB3ZSBjYW4gaW1tZWRpYXRlbHkgcmVzb2x2ZSBwcm9wc1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9wcyh0aGlzLl9kZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVEZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIHRoaXMuc2hhZG93Um9vdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcbiAgICAgKi9cbiAgICBfcmVzb2x2ZURlZigpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCBhdHRyc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2F0Y2ggZnV0dXJlIGF0dHIgY2hhbmdlc1xuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEF0dHIobS5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkub2JzZXJ2ZSh0aGlzLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSAoZGVmLCBpc0FzeW5jID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIHN0eWxlcyB9ID0gZGVmO1xuICAgICAgICAgICAgLy8gY2FzdCBOdW1iZXItdHlwZSBwcm9wcyBzZXQgYmVmb3JlIHJlc29sdmVcbiAgICAgICAgICAgIGxldCBudW1iZXJQcm9wcztcbiAgICAgICAgICAgIGlmIChwcm9wcyAmJiAhaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0ID09PSBOdW1iZXIgfHwgKG9wdCAmJiBvcHQudHlwZSA9PT0gTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9wcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB0b051bWJlcih0aGlzLl9wcm9wc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIChudW1iZXJQcm9wcyB8fCAobnVtYmVyUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlbY2FtZWxpemUkMShrZXkpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJQcm9wcyA9IG51bWJlclByb3BzO1xuICAgICAgICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmluZyBnZXR0ZXIvc2V0dGVycyBvbiBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAvLyBmb3Igc3luYyBkZWZzLCB0aGlzIGFscmVhZHkgaGFwcGVuZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVByb3BzKGRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBseSBDU1NcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKHN0eWxlcyk7XG4gICAgICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFzeW5jRGVmID0gdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXI7XG4gICAgICAgIGlmIChhc3luY0RlZikge1xuICAgICAgICAgICAgYXN5bmNEZWYoKS50aGVuKGRlZiA9PiByZXNvbHZlKGRlZiwgdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZXNvbHZlUHJvcHMoZGVmKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IGRlZjtcbiAgICAgICAgY29uc3QgZGVjbGFyZWRQcm9wS2V5cyA9IGlzQXJyYXkocHJvcHMpID8gcHJvcHMgOiBPYmplY3Qua2V5cyhwcm9wcyB8fCB7fSk7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBwcm9wcyBzZXQgcHJlLXVwZ3JhZGUgb3IgY29ubmVjdFxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzKSkge1xuICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gJ18nICYmIGRlY2xhcmVkUHJvcEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB0aGlzW2tleV0sIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmluZyBnZXR0ZXIvc2V0dGVycyBvbiBwcm90b3R5cGVcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZGVjbGFyZWRQcm9wS2V5cy5tYXAoY2FtZWxpemUkMSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKGtleSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3Aoa2V5LCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXRBdHRyKGtleSkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgICAgICBjb25zdCBjYW1lbEtleSA9IGNhbWVsaXplJDEoa2V5KTtcbiAgICAgICAgaWYgKHRoaXMuX251bWJlclByb3BzICYmIHRoaXMuX251bWJlclByb3BzW2NhbWVsS2V5XSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0UHJvcChjYW1lbEtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2dldFByb3Aoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wc1trZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0UHJvcChrZXksIHZhbCwgc2hvdWxkUmVmbGVjdCA9IHRydWUsIHNob3VsZFVwZGF0ZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUgJiYgdGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZmxlY3RcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSwgdmFsICsgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGh5cGhlbmF0ZShrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3VwZGF0ZSgpIHtcbiAgICAgICAgcmVuZGVyKHRoaXMuX2NyZWF0ZVZOb2RlKCksIHRoaXMuc2hhZG93Um9vdCk7XG4gICAgfVxuICAgIF9jcmVhdGVWTm9kZSgpIHtcbiAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZSh0aGlzLl9kZWYsIGV4dGVuZCh7fSwgdGhpcy5fcHJvcHMpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgdm5vZGUuY2UgPSBpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBITVJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkID0gbmV3U3R5bGVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsd2F5cyByZXNldCBzdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMuZm9yRWFjaChzID0+IHRoaXMuc2hhZG93Um9vdC5yZW1vdmVDaGlsZChzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3R5bGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhuZXdTdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbDogYXJnc1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBpbnRlcmNlcHQgZW1pdFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzcGF0Y2ggYm90aCB0aGUgcmF3IGFuZCBoeXBoZW5hdGVkIHZlcnNpb25zIG9mIGFuIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIG1hdGNoIFZ1ZSBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChldmVudCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUoZXZlbnQpICE9PSBldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goaHlwaGVuYXRlKGV2ZW50KSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIGxvY2F0ZSBuZWFyZXN0IFZ1ZSBjdXN0b20gZWxlbWVudCBwYXJlbnQgZm9yIHByb3ZpZGUvaW5qZWN0XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChwYXJlbnQgPVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgJiYgKHBhcmVudC5wYXJlbnROb2RlIHx8IHBhcmVudC5ob3N0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFZ1ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5wcm92aWRlcyA9IHBhcmVudC5faW5zdGFuY2UucHJvdmlkZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgIH1cbiAgICBfYXBwbHlTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKGNzcyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICAgICAgcy50ZXh0Q29udGVudCA9IGNzcztcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgICAgICAgLy8gcmVjb3JkIGZvciBITVJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcbiAgICAgICAgaWYgKCFtb2R1bGVzKSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xuICAgICAgICBpZiAoIW1vZCkge1xuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICAgICAgd2FybihgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGUgbmFtZWQgXCIke25hbWV9XCIuYCk7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxuICAgICAgICAgICAgd2FybihgdXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlVGVsZXBvcnRzID0gKGluc3RhbmNlLnV0ID0gKHZhcnMgPSBnZXR0ZXIoaW5zdGFuY2UucHJveHkpKSA9PiB7XG4gICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtdi1vd25lcj1cIiR7aW5zdGFuY2UudWlkfVwiXWApKS5mb3JFYWNoKG5vZGUgPT4gc2V0VmFyc09uTm9kZShub2RlLCB2YXJzKSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2V0VmFycyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdmFycyA9IGdldHRlcihpbnN0YW5jZS5wcm94eSk7XG4gICAgICAgIHNldFZhcnNPblZOb2RlKGluc3RhbmNlLnN1YlRyZWUsIHZhcnMpO1xuICAgICAgICB1cGRhdGVUZWxlcG9ydHModmFycyk7XG4gICAgfTtcbiAgICB3YXRjaFBvc3RFZmZlY3Qoc2V0VmFycyk7XG4gICAgb25Nb3VudGVkKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb2IgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihzZXRWYXJzKTtcbiAgICAgICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICBvblVubW91bnRlZCgoKSA9PiBvYi5kaXNjb25uZWN0KCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFyc09uVk5vZGUodm5vZGUsIHZhcnMpIHtcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNoYXBlRmxhZ3MuU1VTUEVOU0UgKi8pIHtcbiAgICAgICAgY29uc3Qgc3VzcGVuc2UgPSB2bm9kZS5zdXNwZW5zZTtcbiAgICAgICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XG4gICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmICFzdXNwZW5zZS5pc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgc3VzcGVuc2UuZWZmZWN0cy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZHJpbGwgZG93biBIT0NzIHVudGlsIGl0J3MgYSBub24tY29tcG9uZW50IHZub2RlXG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudCkge1xuICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xuICAgIH1cbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBTaGFwZUZsYWdzLkVMRU1FTlQgKi8gJiYgdm5vZGUuZWwpIHtcbiAgICAgICAgc2V0VmFyc09uTm9kZSh2bm9kZS5lbCwgdmFycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IEZyYWdtZW50KSB7XG4gICAgICAgIHZub2RlLmNoaWxkcmVuLmZvckVhY2goYyA9PiBzZXRWYXJzT25WTm9kZShjLCB2YXJzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZub2RlLnR5cGUgPT09IFN0YXRpYykge1xuICAgICAgICBsZXQgeyBlbCwgYW5jaG9yIH0gPSB2bm9kZTtcbiAgICAgICAgd2hpbGUgKGVsKSB7XG4gICAgICAgICAgICBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKTtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gYW5jaG9yKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZWwgPSBlbC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpIHtcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbmNvbnN0IEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuLy8gRE9NIFRyYW5zaXRpb24gaXMgYSBoaWdoZXItb3JkZXItY29tcG9uZW50IGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS1hZ25vc3RpY1xuLy8gYmFzZSBUcmFuc2l0aW9uIGNvbXBvbmVudCwgd2l0aCBET00tc3BlY2lmaWMgbG9naWMuXG5jb25zdCBUcmFuc2l0aW9uID0gKHByb3BzLCB7IHNsb3RzIH0pID0+IGgoQmFzZVRyYW5zaXRpb24sIHJlc29sdmVUcmFuc2l0aW9uUHJvcHMocHJvcHMpLCBzbG90cyk7XG5UcmFuc2l0aW9uLmRpc3BsYXlOYW1lID0gJ1RyYW5zaXRpb24nO1xuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGNzczoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBkdXJhdGlvbjogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxuICAgIGVudGVyRnJvbUNsYXNzOiBTdHJpbmcsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckZyb21DbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICAgIGxlYXZlRnJvbUNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nXG59O1xuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IChUcmFuc2l0aW9uLnByb3BzID1cbiAgICAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgQmFzZVRyYW5zaXRpb24ucHJvcHMsIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKTtcbi8qKlxuICogIzMyMjcgSW5jb21pbmcgaG9va3MgbWF5IGJlIG1lcmdlZCBpbnRvIGFycmF5cyB3aGVuIHdyYXBwaW5nIFRyYW5zaXRpb25cbiAqIHdpdGggY3VzdG9tIEhPQ3MuXG4gKi9cbmNvbnN0IGNhbGxIb29rID0gKGhvb2ssIGFyZ3MgPSBbXSkgPT4ge1xuICAgIGlmIChpc0FycmF5KGhvb2spKSB7XG4gICAgICAgIGhvb2suZm9yRWFjaChoID0+IGgoLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChob29rKSB7XG4gICAgICAgIGhvb2soLi4uYXJncyk7XG4gICAgfVxufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBob29rIGV4cGVjdHMgYSBjYWxsYmFjayAoMm5kIGFyZyksIHdoaWNoIG1lYW5zIHRoZSB1c2VyXG4gKiBpbnRlbmRzIHRvIGV4cGxpY2l0bHkgY29udHJvbCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uLlxuICovXG5jb25zdCBoYXNFeHBsaWNpdENhbGxiYWNrID0gKGhvb2spID0+IHtcbiAgICByZXR1cm4gaG9va1xuICAgICAgICA/IGlzQXJyYXkoaG9vaylcbiAgICAgICAgICAgID8gaG9vay5zb21lKGggPT4gaC5sZW5ndGggPiAxKVxuICAgICAgICAgICAgOiBob29rLmxlbmd0aCA+IDFcbiAgICAgICAgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKSB7XG4gICAgY29uc3QgYmFzZVByb3BzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIERPTVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnMpKSB7XG4gICAgICAgICAgICBiYXNlUHJvcHNba2V5XSA9IHJhd1Byb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VQcm9wcztcbiAgICB9XG4gICAgY29uc3QgeyBuYW1lID0gJ3YnLCB0eXBlLCBkdXJhdGlvbiwgZW50ZXJGcm9tQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1mcm9tYCwgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCwgYXBwZWFyRnJvbUNsYXNzID0gZW50ZXJGcm9tQ2xhc3MsIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcywgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcywgbGVhdmVGcm9tQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1mcm9tYCwgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYCB9ID0gcmF3UHJvcHM7XG4gICAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xuICAgIGNvbnN0IGVudGVyRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzBdO1xuICAgIGNvbnN0IGxlYXZlRHVyYXRpb24gPSBkdXJhdGlvbnMgJiYgZHVyYXRpb25zWzFdO1xuICAgIGNvbnN0IHsgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25MZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLCBvbkFwcGVhciA9IG9uRW50ZXIsIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZCB9ID0gYmFzZVByb3BzO1xuICAgIGNvbnN0IGZpbmlzaEVudGVyID0gKGVsLCBpc0FwcGVhciwgZG9uZSkgPT4ge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xuICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XG4gICAgICAgIGVsLl9pc0xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgfTtcbiAgICBjb25zdCBtYWtlRW50ZXJIb29rID0gKGlzQXBwZWFyKSA9PiB7XG4gICAgICAgIHJldHVybiAoZWwsIGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hFbnRlcihlbCwgaXNBcHBlYXIsIGRvbmUpO1xuICAgICAgICAgICAgY2FsbEhvb2soaG9vaywgW2VsLCByZXNvbHZlXSk7XG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJGcm9tQ2xhc3MgOiBlbnRlckZyb21DbGFzcyk7XG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzRXhwbGljaXRDYWxsYmFjayhob29rKSkge1xuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIGV4dGVuZChiYXNlUHJvcHMsIHtcbiAgICAgICAgb25CZWZvcmVFbnRlcihlbCkge1xuICAgICAgICAgICAgY2FsbEhvb2sob25CZWZvcmVFbnRlciwgW2VsXSk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyRnJvbUNsYXNzKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgZW50ZXJBY3RpdmVDbGFzcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyKGVsKSB7XG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUFwcGVhciwgW2VsXSk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlcjogbWFrZUVudGVySG9vayhmYWxzZSksXG4gICAgICAgIG9uQXBwZWFyOiBtYWtlRW50ZXJIb29rKHRydWUpLFxuICAgICAgICBvbkxlYXZlKGVsLCBkb25lKSB7XG4gICAgICAgICAgICBlbC5faXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlRnJvbUNsYXNzKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlZmxvdyBzbyAqLWxlYXZlLWZyb20gY2xhc3NlcyBpbW1lZGlhdGVseSB0YWtlIGVmZmVjdCAoIzI1OTMpXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5faXNMZWF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbGxlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBsZWF2ZUR1cmF0aW9uLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmUsIFtlbCwgcmVzb2x2ZV0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgZmFsc2UpO1xuICAgICAgICAgICAgY2FsbEhvb2sob25FbnRlckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XG4gICAgICAgICAgICBmaW5pc2hFbnRlcihlbCwgdHJ1ZSk7XG4gICAgICAgICAgICBjYWxsSG9vayhvbkFwcGVhckNhbmNlbGxlZCwgW2VsXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQoZWwpIHtcbiAgICAgICAgICAgIGZpbmlzaExlYXZlKGVsKTtcbiAgICAgICAgICAgIGNhbGxIb29rKG9uTGVhdmVDYW5jZWxsZWQsIFtlbF0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChkdXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIFtOdW1iZXJPZihkdXJhdGlvbi5lbnRlciksIE51bWJlck9mKGR1cmF0aW9uLmxlYXZlKV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuID0gTnVtYmVyT2YoZHVyYXRpb24pO1xuICAgICAgICByZXR1cm4gW24sIG5dO1xuICAgIH1cbn1cbmZ1bmN0aW9uIE51bWJlck9mKHZhbCkge1xuICAgIGNvbnN0IHJlcyA9IHRvTnVtYmVyKHZhbCk7XG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgICAgICBhc3NlcnROdW1iZXIocmVzLCAnPHRyYW5zaXRpb24+IGV4cGxpY2l0IGR1cmF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgIChlbC5fdnRjIHx8XG4gICAgICAgIChlbC5fdnRjID0gbmV3IFNldCgpKSkuYWRkKGNscyk7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIGNvbnN0IHsgX3Z0YyB9ID0gZWw7XG4gICAgaWYgKF92dGMpIHtcbiAgICAgICAgX3Z0Yy5kZWxldGUoY2xzKTtcbiAgICAgICAgaWYgKCFfdnRjLnNpemUpIHtcbiAgICAgICAgICAgIGVsLl92dGMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpO1xuICAgIH0pO1xufVxubGV0IGVuZElkID0gMDtcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcbiAgICBjb25zdCBpZCA9IChlbC5fZW5kSWQgPSArK2VuZElkKTtcbiAgICBjb25zdCByZXNvbHZlSWZOb3RTdGFsZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGV4cGxpY2l0VGltZW91dCkge1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlSWZOb3RTdGFsZSwgZXhwbGljaXRUaW1lb3V0KTtcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCB0aW1lb3V0LCBwcm9wQ291bnQgfSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBlbmRFdmVudCA9IHR5cGUgKyAnZW5kJztcbiAgICBsZXQgZW5kZWQgPSAwO1xuICAgIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xuICAgICAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xuICAgIH07XG4gICAgY29uc3Qgb25FbmQgPSAoZSkgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgICAgICBlbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgIH1cbiAgICB9LCB0aW1lb3V0ICsgMSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICAgY29uc3QgZ2V0U3R5bGVQcm9wZXJ0aWVzID0gKGtleSkgPT4gKHN0eWxlc1trZXldIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RGVsYXlgKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke1RSQU5TSVRJT059RHVyYXRpb25gKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKGAke0FOSU1BVElPTn1EZWxheWApO1xuICAgIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IGdldFN0eWxlUHJvcGVydGllcyhgJHtBTklNQVRJT059RHVyYXRpb25gKTtcbiAgICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCB0aW1lb3V0ID0gMDtcbiAgICBsZXQgcHJvcENvdW50ID0gMDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgICAgICB0eXBlID1cbiAgICAgICAgICAgIHRpbWVvdXQgPiAwXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgICAgICAgICAgICAgIDogQU5JTUFUSU9OXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICAgICAgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KGdldFN0eWxlUHJvcGVydGllcyhgJHtUUkFOU0lUSU9OfVByb3BlcnR5YCkudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgcHJvcENvdW50LFxuICAgICAgICBoYXNUcmFuc2Zvcm1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICAgIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCguLi5kdXJhdGlvbnMubWFwKChkLCBpKSA9PiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pKSk7XG59XG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlclxuLy8gbnVtYmVycyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duXG4vLyAoaS5lLiBhY3RpbmcgYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyhzKSB7XG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwO1xufVxuLy8gc3luY2hyb25vdXNseSBmb3JjZSBsYXlvdXQgdG8gcHV0IGVsZW1lbnRzIGludG8gYSBjZXJ0YWluIHN0YXRlXG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG59XG5cbmNvbnN0IHBvc2l0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IFRyYW5zaXRpb25Hcm91cEltcGwgPSB7XG4gICAgbmFtZTogJ1RyYW5zaXRpb25Hcm91cCcsXG4gICAgcHJvcHM6IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XG4gICAgICAgIHRhZzogU3RyaW5nLFxuICAgICAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICAgIH0pLFxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcbiAgICAgICAgbGV0IHByZXZDaGlsZHJlbjtcbiAgICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgICBvblVwZGF0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gY2hpbGRyZW4gaXMgZ3VhcmFudGVlZCB0byBleGlzdCBhZnRlciBpbml0aWFsIHJlbmRlclxuICAgICAgICAgICAgaWYgKCFwcmV2Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW92ZUNsYXNzID0gcHJvcHMubW92ZUNsYXNzIHx8IGAke3Byb3BzLm5hbWUgfHwgJ3YnfS1tb3ZlYDtcbiAgICAgICAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKHByZXZDaGlsZHJlblswXS5lbCwgaW5zdGFuY2Uudm5vZGUuZWwsIG1vdmVDbGFzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAgICAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgbW92ZWRDaGlsZHJlbiA9IHByZXZDaGlsZHJlbi5maWx0ZXIoYXBwbHlUcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XG4gICAgICAgICAgICBtb3ZlZENoaWxkcmVuLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBjLmVsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gKGVsLl9tb3ZlQ2IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBjc3NUcmFuc2l0aW9uUHJvcHMgPSByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKTtcbiAgICAgICAgICAgIGxldCB0YWcgPSByYXdQcm9wcy50YWcgfHwgRnJhZ21lbnQ7XG4gICAgICAgICAgICBwcmV2Q2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCA/IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCkpIDogW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBwcmV2Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyhjaGlsZCwgcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhjaGlsZCwgY3NzVHJhbnNpdGlvblByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGNoaWxkLCBjaGlsZC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIFRyYW5zaXRpb25Hcm91cCBkb2VzIG5vdCBzdXBwb3J0IFwibW9kZVwiIHNvIHdlIG5lZWQgdG8gcmVtb3ZlIGl0IGZyb20gdGhlXG4gKiBwcm9wcyBkZWNsYXJhdGlvbnMsIGJ1dCBkaXJlY3QgZGVsZXRlIG9wZXJhdGlvbiBpcyBjb25zaWRlcmVkIGEgc2lkZSBlZmZlY3RcbiAqIGFuZCB3aWxsIG1ha2UgdGhlIGVudGlyZSB0cmFuc2l0aW9uIGZlYXR1cmUgbm9uLXRyZWUtc2hha2VhYmxlLCBzbyB3ZSBkbyBpdFxuICogaW4gYSBmdW5jdGlvbiBhbmQgbWFyayB0aGUgZnVuY3Rpb24ncyBpbnZvY2F0aW9uIGFzIHB1cmUuXG4gKi9cbmNvbnN0IHJlbW92ZU1vZGUgPSAocHJvcHMpID0+IGRlbGV0ZSBwcm9wcy5tb2RlO1xuLyojX19QVVJFX18qLyByZW1vdmVNb2RlKFRyYW5zaXRpb25Hcm91cEltcGwucHJvcHMpO1xuY29uc3QgVHJhbnNpdGlvbkdyb3VwID0gVHJhbnNpdGlvbkdyb3VwSW1wbDtcbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzKGMpIHtcbiAgICBjb25zdCBlbCA9IGMuZWw7XG4gICAgaWYgKGVsLl9tb3ZlQ2IpIHtcbiAgICAgICAgZWwuX21vdmVDYigpO1xuICAgIH1cbiAgICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gICAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gICAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xuICAgIGNvbnN0IG5ld1BvcyA9IG5ld1Bvc2l0aW9uTWFwLmdldChjKTtcbiAgICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gICAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgY29uc3QgcyA9IGMuZWwuc3R5bGU7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhc0NTU1RyYW5zZm9ybShlbCwgcm9vdCwgbW92ZUNsYXNzKSB7XG4gICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICBpZiAoZWwuX3Z0Yykge1xuICAgICAgICBlbC5fdnRjLmZvckVhY2goY2xzID0+IHtcbiAgICAgICAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbW92ZUNsYXNzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgY2xvbmUuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBjb25zdCBjb250YWluZXIgPSAocm9vdC5ub2RlVHlwZSA9PT0gMSA/IHJvb3QgOiByb290LnBhcmVudE5vZGUpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgIHJldHVybiBoYXNUcmFuc2Zvcm07XG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcbiAgICBjb25zdCBmbiA9IHZub2RlLnByb3BzWydvblVwZGF0ZTptb2RlbFZhbHVlJ10gfHxcbiAgICAgICAgKGZhbHNlICk7XG4gICAgcmV0dXJuIGlzQXJyYXkoZm4pID8gdmFsdWUgPT4gaW52b2tlQXJyYXlGbnMoZm4sIHZhbHVlKSA6IGZuO1xufTtcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0O1xuICAgIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgIHRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcpKTtcbiAgICB9XG59XG4vLyBXZSBhcmUgZXhwb3J0aW5nIHRoZSB2LW1vZGVsIHJ1bnRpbWUgZGlyZWN0bHkgYXMgdm5vZGUgaG9va3Mgc28gdGhhdCBpdCBjYW5cbi8vIGJlIHRyZWUtc2hha2VuIGluIGNhc2Ugdi1tb2RlbCBpcyBuZXZlciB1c2VkLlxuY29uc3Qgdk1vZGVsVGV4dCA9IHtcbiAgICBjcmVhdGVkKGVsLCB7IG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgICAgIGNvbnN0IGNhc3RUb051bWJlciA9IG51bWJlciB8fCAodm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSA9PT0gJ251bWJlcicpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCBsYXp5ID8gJ2NoYW5nZScgOiAnaW5wdXQnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGRvbVZhbHVlID0gZWwudmFsdWU7XG4gICAgICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gZG9tVmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhc3RUb051bWJlcikge1xuICAgICAgICAgICAgICAgIGRvbVZhbHVlID0gbG9vc2VUb051bWJlcihkb21WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fYXNzaWduKGRvbVZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0cmltKSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBzZXQgdmFsdWUgb24gbW91bnRlZCBzbyBpdCdzIGFmdGVyIG1pbi9tYXggZm9yIHR5cGU9XCJyYW5nZVwiXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9KSB7XG4gICAgICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgfSxcbiAgICBiZWZvcmVVcGRhdGUoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBsYXp5LCB0cmltLCBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgICAgIC8vIGF2b2lkIGNsZWFyaW5nIHVucmVzb2x2ZWQgdGV4dC4gIzIzMDJcbiAgICAgICAgaWYgKGVsLmNvbXBvc2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsICYmIGVsLnR5cGUgIT09ICdyYW5nZScpIHtcbiAgICAgICAgICAgIGlmIChsYXp5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaW0gJiYgZWwudmFsdWUudHJpbSgpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobnVtYmVyIHx8IGVsLnR5cGUgPT09ICdudW1iZXInKSAmJlxuICAgICAgICAgICAgICAgIGxvb3NlVG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICBpZiAoZWwudmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHZNb2RlbENoZWNrYm94ID0ge1xuICAgIC8vICM0MDk2IGFycmF5IGNoZWNrYm94ZXMgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxuICAgIGRlZXA6IHRydWUsXG4gICAgY3JlYXRlZChlbCwgXywgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxWYWx1ZSA9IGVsLl9tb2RlbFZhbHVlO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFZhbHVlID0gZ2V0VmFsdWUoZWwpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XG4gICAgICAgICAgICBjb25zdCBhc3NpZ24gPSBlbC5fYXNzaWduO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkobW9kZWxWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gaW5kZXggIT09IC0xO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkICYmICFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjaGVja2VkICYmIGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ24oZmlsdGVyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU2V0KG1vZGVsVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWQuYWRkKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZWQuZGVsZXRlKGVsZW1lbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzc2lnbihjbG9uZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzaWduKGdldENoZWNrYm94VmFsdWUoZWwsIGNoZWNrZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBzZXQgaW5pdGlhbCBjaGVja2VkIG9uIG1vdW50IHRvIHdhaXQgZm9yIHRydWUtdmFsdWUvZmFsc2UtdmFsdWVcbiAgICBtb3VudGVkOiBzZXRDaGVja2VkLFxuICAgIGJlZm9yZVVwZGF0ZShlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgICAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgZWwuX21vZGVsVmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XG4gICAgfVxufVxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XG4gICAgY3JlYXRlZChlbCwgeyB2YWx1ZSB9LCB2bm9kZSkge1xuICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBlbC5fYXNzaWduKGdldFZhbHVlKGVsKSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xuICAgIC8vIDxzZWxlY3QgbXVsdGlwbGU+IHZhbHVlIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgICBkZWVwOiB0cnVlLFxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xuICAgICAgICBjb25zdCBpc1NldE1vZGVsID0gaXNTZXQodmFsdWUpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gICAgICAgICAgICAgICAgLmNhbGwoZWwub3B0aW9ucywgKG8pID0+IG8uc2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcCgobykgPT4gbnVtYmVyID8gbG9vc2VUb051bWJlcihnZXRWYWx1ZShvKSkgOiBnZXRWYWx1ZShvKSk7XG4gICAgICAgICAgICBlbC5fYXNzaWduKGVsLm11bHRpcGxlXG4gICAgICAgICAgICAgICAgPyBpc1NldE1vZGVsXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IFNldChzZWxlY3RlZFZhbClcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3RlZFZhbFxuICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxbMF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xuICAgIH0sXG4gICAgLy8gc2V0IHZhbHVlIGluIG1vdW50ZWQgJiB1cGRhdGVkIGJlY2F1c2UgPHNlbGVjdD4gcmVsaWVzIG9uIGl0cyBjaGlsZHJlblxuICAgIC8vIDxvcHRpb24+cy5cbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIHZhbHVlKTtcbiAgICB9LFxuICAgIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcbiAgICB9LFxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgdmFsdWUpIHtcbiAgICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgICAgICB3YXJuKGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYCArXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHtPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKX0uYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIG9wdGlvblZhbHVlKSA+IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKVxuICAgICAgICAgICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc011bHRpcGxlICYmIGVsLnNlbGVjdGVkSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB9XG59XG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgc2V0IHZpYSA6dmFsdWUgYmluZGluZ3NcbmZ1bmN0aW9uIGdldFZhbHVlKGVsKSB7XG4gICAgcmV0dXJuICdfdmFsdWUnIGluIGVsID8gZWwuX3ZhbHVlIDogZWwudmFsdWU7XG59XG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgZm9yIHRydWUtdmFsdWUgYW5kIGZhbHNlLXZhbHVlIHNldCB2aWEgOnRydWUtdmFsdWUgb3IgOmZhbHNlLXZhbHVlIGJpbmRpbmdzXG5mdW5jdGlvbiBnZXRDaGVja2JveFZhbHVlKGVsLCBjaGVja2VkKSB7XG4gICAgY29uc3Qga2V5ID0gY2hlY2tlZCA/ICdfdHJ1ZVZhbHVlJyA6ICdfZmFsc2VWYWx1ZSc7XG4gICAgcmV0dXJuIGtleSBpbiBlbCA/IGVsW2tleV0gOiBjaGVja2VkO1xufVxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcbiAgICBjcmVhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ2NyZWF0ZWQnKTtcbiAgICB9LFxuICAgIG1vdW50ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBudWxsLCAnbW91bnRlZCcpO1xuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlKSB7XG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9LFxuICAgIHVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNNb2RlbCh0YWdOYW1lLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgICAgIGNhc2UgJ1NFTEVDVCc6XG4gICAgICAgICAgICByZXR1cm4gdk1vZGVsU2VsZWN0O1xuICAgICAgICBjYXNlICdURVhUQVJFQSc6XG4gICAgICAgICAgICByZXR1cm4gdk1vZGVsVGV4dDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZNb2RlbENoZWNrYm94O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFJhZGlvO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xuICAgICAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsIGhvb2spIHtcbiAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChlbC50YWdOYW1lLCB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlKTtcbiAgICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XG4gICAgZm4gJiYgZm4oZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpO1xufVxuLy8gU1NSIHZub2RlIHRyYW5zZm9ybXMsIG9ubHkgdXNlZCB3aGVuIHVzZXIgaW5jbHVkZXMgY2xpZW50LW9yaWVudGVkIHJlbmRlclxuLy8gZnVuY3Rpb24gaW4gU1NSXG5mdW5jdGlvbiBpbml0Vk1vZGVsRm9yU1NSKCkge1xuICAgIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcbiAgICB2TW9kZWxSYWRpby5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0sIHZub2RlKSA9PiB7XG4gICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUVxdWFsKHZub2RlLnByb3BzLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdk1vZGVsQ2hlY2tib3guZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS5wcm9wcyAmJiBsb29zZUluZGV4T2YodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZub2RlLnByb3BzICYmIHZhbHVlLmhhcyh2bm9kZS5wcm9wcy52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGVja2VkOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdk1vZGVsRHluYW1pYy5nZXRTU1JQcm9wcyA9IChiaW5kaW5nLCB2bm9kZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZub2RlLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoXG4gICAgICAgIC8vIHJlc29sdmVEeW5hbWljTW9kZWwgZXhwZWN0cyBhbiB1cHBlcmNhc2UgdGFnIG5hbWUsIGJ1dCB2bm9kZS50eXBlIGlzIGxvd2VyY2FzZVxuICAgICAgICB2bm9kZS50eXBlLnRvVXBwZXJDYXNlKCksIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUpO1xuICAgICAgICBpZiAobW9kZWxUb1VzZS5nZXRTU1JQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsVG9Vc2UuZ2V0U1NSUHJvcHMoYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuY29uc3Qgc3lzdGVtTW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ107XG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcbiAgICBzdG9wOiBlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCksXG4gICAgcHJldmVudDogZSA9PiBlLnByZXZlbnREZWZhdWx0KCksXG4gICAgc2VsZjogZSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxuICAgIGN0cmw6IGUgPT4gIWUuY3RybEtleSxcbiAgICBzaGlmdDogZSA9PiAhZS5zaGlmdEtleSxcbiAgICBhbHQ6IGUgPT4gIWUuYWx0S2V5LFxuICAgIG1ldGE6IGUgPT4gIWUubWV0YUtleSxcbiAgICBsZWZ0OiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDAsXG4gICAgbWlkZGxlOiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDEsXG4gICAgcmlnaHQ6IGUgPT4gJ2J1dHRvbicgaW4gZSAmJiBlLmJ1dHRvbiAhPT0gMixcbiAgICBleGFjdDogKGUsIG1vZGlmaWVycykgPT4gc3lzdGVtTW9kaWZpZXJzLnNvbWUobSA9PiBlW2Ake219S2V5YF0gJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhtKSlcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdpdGhNb2RpZmllcnMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGd1YXJkID0gbW9kaWZpZXJHdWFyZHNbbW9kaWZpZXJzW2ldXTtcbiAgICAgICAgICAgIGlmIChndWFyZCAmJiBndWFyZChldmVudCwgbW9kaWZpZXJzKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9O1xufTtcbi8vIEtlcHQgZm9yIDIueCBjb21wYXQuXG4vLyBOb3RlOiBJRTExIGNvbXBhdCBmb3IgYHNwYWNlYmFyYCBhbmQgYGRlbGAgaXMgcmVtb3ZlZCBmb3Igbm93LlxuY29uc3Qga2V5TmFtZXMgPSB7XG4gICAgZXNjOiAnZXNjYXBlJyxcbiAgICBzcGFjZTogJyAnLFxuICAgIHVwOiAnYXJyb3ctdXAnLFxuICAgIGxlZnQ6ICdhcnJvdy1sZWZ0JyxcbiAgICByaWdodDogJ2Fycm93LXJpZ2h0JyxcbiAgICBkb3duOiAnYXJyb3ctZG93bicsXG4gICAgZGVsZXRlOiAnYmFja3NwYWNlJ1xufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgd2l0aEtleXMgPSAoZm4sIG1vZGlmaWVycykgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCEoJ2tleScgaW4gZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRLZXkgPSBoeXBoZW5hdGUoZXZlbnQua2V5KTtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5zb21lKGsgPT4gayA9PT0gZXZlbnRLZXkgfHwga2V5TmFtZXNba10gPT09IGV2ZW50S2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5jb25zdCB2U2hvdyA9IHtcbiAgICBiZWZvcmVNb3VudChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgICAgICBlbC5fdm9kID0gZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSwgeyB0cmFuc2l0aW9uIH0pIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24gJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xuICAgICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcbiAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmVudGVyKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24ubGVhdmUoZWwsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVVbm1vdW50KGVsLCB7IHZhbHVlIH0pIHtcbiAgICAgICAgc2V0RGlzcGxheShlbCwgdmFsdWUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzZXREaXNwbGF5KGVsLCB2YWx1ZSkge1xuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl92b2QgOiAnbm9uZSc7XG59XG4vLyBTU1Igdm5vZGUgdHJhbnNmb3Jtcywgb25seSB1c2VkIHdoZW4gdXNlciBpbmNsdWRlcyBjbGllbnQtb3JpZW50ZWQgcmVuZGVyXG4vLyBmdW5jdGlvbiBpbiBTU1JcbmZ1bmN0aW9uIGluaXRWU2hvd0ZvclNTUigpIHtcbiAgICB2U2hvdy5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3R5bGU6IHsgZGlzcGxheTogJ25vbmUnIH0gfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHsgcGF0Y2hQcm9wIH0sIG5vZGVPcHMpO1xuLy8gbGF6eSBjcmVhdGUgdGhlIHJlbmRlcmVyIC0gdGhpcyBtYWtlcyBjb3JlIHJlbmRlcmVyIGxvZ2ljIHRyZWUtc2hha2FibGVcbi8vIGluIGNhc2UgdGhlIHVzZXIgb25seSBpbXBvcnRzIHJlYWN0aXZpdHkgdXRpbGl0aWVzIGZyb20gVnVlLlxubGV0IHJlbmRlcmVyO1xubGV0IGVuYWJsZWRIeWRyYXRpb24gPSBmYWxzZTtcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xuICAgIHJldHVybiAocmVuZGVyZXIgfHxcbiAgICAgICAgKHJlbmRlcmVyID0gY3JlYXRlUmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKSkpO1xufVxuZnVuY3Rpb24gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKSB7XG4gICAgcmVuZGVyZXIgPSBlbmFibGVkSHlkcmF0aW9uXG4gICAgICAgID8gcmVuZGVyZXJcbiAgICAgICAgOiBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuICAgIGVuYWJsZWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHJldHVybiByZW5kZXJlcjtcbn1cbi8vIHVzZSBleHBsaWNpdCB0eXBlIGNhc3RzIGhlcmUgdG8gYXZvaWQgaW1wb3J0KCkgY2FsbHMgaW4gcm9sbGVkLXVwIGQudHNcbmNvbnN0IHJlbmRlciA9ICgoLi4uYXJncykgPT4ge1xuICAgIGVuc3VyZVJlbmRlcmVyKCkucmVuZGVyKC4uLmFyZ3MpO1xufSk7XG5jb25zdCBoeWRyYXRlID0gKCguLi5hcmdzKSA9PiB7XG4gICAgZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5oeWRyYXRlKC4uLmFyZ3MpO1xufSk7XG5jb25zdCBjcmVhdGVBcHAgPSAoKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBhcHAgPSBlbnN1cmVSZW5kZXJlcigpLmNyZWF0ZUFwcCguLi5hcmdzKTtcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XG4gICAgICAgIGluamVjdENvbXBpbGVyT3B0aW9uc0NoZWNrKGFwcCk7XG4gICAgfVxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcbiAgICBhcHAubW91bnQgPSAoY29udGFpbmVyT3JTZWxlY3RvcikgPT4ge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XG4gICAgICAgIGlmICghY29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBhcHAuX2NvbXBvbmVudDtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gX19VTlNBRkVfX1xuICAgICAgICAgICAgLy8gUmVhc29uOiBwb3RlbnRpYWwgZXhlY3V0aW9uIG9mIEpTIGV4cHJlc3Npb25zIGluIGluLURPTSB0ZW1wbGF0ZS5cbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQnc1xuICAgICAgICAgICAgLy8gcmVuZGVyZWQgYnkgdGhlIHNlcnZlciwgdGhlIHRlbXBsYXRlIHNob3VsZCBub3QgY29udGFpbiBhbnkgdXNlciBkYXRhLlxuICAgICAgICAgICAgY29tcG9uZW50LnRlbXBsYXRlID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhciBjb250ZW50IGJlZm9yZSBtb3VudGluZ1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XG4gICAgICAgIGlmIChjb250YWluZXIgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJyk7XG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLXYtYXBwJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9O1xuICAgIHJldHVybiBhcHA7XG59KTtcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICgoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGFwcCA9IGVuc3VyZUh5ZHJhdGlvblJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcbiAgICB9XG4gICAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXJPclNlbGVjdG9yKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIG1vdW50KGNvbnRhaW5lciwgdHJ1ZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhcHA7XG59KTtcbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xuICAgIC8vIEluamVjdCBgaXNOYXRpdmVUYWdgXG4gICAgLy8gdGhpcyBpcyB1c2VkIGZvciBjb21wb25lbnQgbmFtZSB2YWxpZGF0aW9uIChkZXYgb25seSlcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzTmF0aXZlVGFnJywge1xuICAgICAgICB2YWx1ZTogKHRhZykgPT4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkdUYWcodGFnKSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG59XG4vLyBkZXYgb25seVxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XG4gICAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xuICAgICAgICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBhcHAuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc0N1c3RvbUVsZW1lbnQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQ3VzdG9tRWxlbWVudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgICAgICAgd2FybihgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBgICtcbiAgICAgICAgICAgICAgICAgICAgYFxcYGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnRcXGAgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IGFwcC5jb25maWcuY29tcGlsZXJPcHRpb25zO1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhlIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBjb25maWcgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgYCArXG4gICAgICAgICAgICBgYSBidWlsZCBvZiBWdWUuanMgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlciAoYWthIFwiZnVsbCBidWlsZFwiKS4gYCArXG4gICAgICAgICAgICBgU2luY2UgeW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkLCBcXGBjb21waWxlck9wdGlvbnNcXGAgYCArXG4gICAgICAgICAgICBgbXVzdCBiZSBwYXNzZWQgdG8gXFxgQHZ1ZS9jb21waWxlci1kb21cXGAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWQuXFxuYCArXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxcbmAgK1xuICAgICAgICAgICAgYC0gRm9yIHZ1ZS1jbGk6IHNlZSBodHRwczovL2NsaS52dWVqcy5vcmcvZ3VpZGUvd2VicGFjay5odG1sI21vZGlmeWluZy1vcHRpb25zLW9mLWEtbG9hZGVyXFxuYCArXG4gICAgICAgICAgICBgLSBGb3Igdml0ZTogcGFzcyBpdCB2aWEgQHZpdGVqcy9wbHVnaW4tdnVlIG9wdGlvbnMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLWRvbWA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnY29tcGlsZXJPcHRpb25zJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGlsZXJPcHRpb25zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICBpZiAoaXNTdHJpbmcoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIXJlcykge1xuICAgICAgICAgICAgd2FybihgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXG4gICAgICAgIHdpbmRvdy5TaGFkb3dSb290ICYmXG4gICAgICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmXG4gICAgICAgIGNvbnRhaW5lci5tb2RlID09PSAnY2xvc2VkJykge1xuICAgICAgICB3YXJuKGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYCk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG59XG5sZXQgc3NyRGlyZWN0aXZlSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGluaXREaXJlY3RpdmVzRm9yU1NSID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXNzckRpcmVjdGl2ZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICBpbml0Vk1vZGVsRm9yU1NSKCk7XG4gICAgICAgICAgICBpbml0VlNob3dGb3JTU1IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG5cbmV4cG9ydCB7IFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgVnVlRWxlbWVudCwgY3JlYXRlQXBwLCBjcmVhdGVTU1JBcHAsIGRlZmluZUN1c3RvbUVsZW1lbnQsIGRlZmluZVNTUkN1c3RvbUVsZW1lbnQsIGh5ZHJhdGUsIGluaXREaXJlY3RpdmVzRm9yU1NSLCByZW5kZXIsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB3aXRoS2V5cywgd2l0aE1vZGlmaWVycyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/@vue/runtime-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@vue/runtime-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_ARR\": () => (/* binding */ EMPTY_ARR),\n/* harmony export */   \"EMPTY_OBJ\": () => (/* binding */ EMPTY_OBJ),\n/* harmony export */   \"NO\": () => (/* binding */ NO),\n/* harmony export */   \"NOOP\": () => (/* binding */ NOOP),\n/* harmony export */   \"PatchFlagNames\": () => (/* binding */ PatchFlagNames),\n/* harmony export */   \"camelize\": () => (/* binding */ camelize),\n/* harmony export */   \"capitalize\": () => (/* binding */ capitalize),\n/* harmony export */   \"def\": () => (/* binding */ def),\n/* harmony export */   \"escapeHtml\": () => (/* binding */ escapeHtml),\n/* harmony export */   \"escapeHtmlComment\": () => (/* binding */ escapeHtmlComment),\n/* harmony export */   \"extend\": () => (/* binding */ extend),\n/* harmony export */   \"genPropsAccessExp\": () => (/* binding */ genPropsAccessExp),\n/* harmony export */   \"generateCodeFrame\": () => (/* binding */ generateCodeFrame),\n/* harmony export */   \"getGlobalThis\": () => (/* binding */ getGlobalThis),\n/* harmony export */   \"hasChanged\": () => (/* binding */ hasChanged),\n/* harmony export */   \"hasOwn\": () => (/* binding */ hasOwn),\n/* harmony export */   \"hyphenate\": () => (/* binding */ hyphenate),\n/* harmony export */   \"includeBooleanAttr\": () => (/* binding */ includeBooleanAttr),\n/* harmony export */   \"invokeArrayFns\": () => (/* binding */ invokeArrayFns),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"isBooleanAttr\": () => (/* binding */ isBooleanAttr),\n/* harmony export */   \"isBuiltInDirective\": () => (/* binding */ isBuiltInDirective),\n/* harmony export */   \"isDate\": () => (/* binding */ isDate),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isGloballyWhitelisted\": () => (/* binding */ isGloballyWhitelisted),\n/* harmony export */   \"isHTMLTag\": () => (/* binding */ isHTMLTag),\n/* harmony export */   \"isIntegerKey\": () => (/* binding */ isIntegerKey),\n/* harmony export */   \"isKnownHtmlAttr\": () => (/* binding */ isKnownHtmlAttr),\n/* harmony export */   \"isKnownSvgAttr\": () => (/* binding */ isKnownSvgAttr),\n/* harmony export */   \"isMap\": () => (/* binding */ isMap),\n/* harmony export */   \"isModelListener\": () => (/* binding */ isModelListener),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isOn\": () => (/* binding */ isOn),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"isRegExp\": () => (/* binding */ isRegExp),\n/* harmony export */   \"isReservedProp\": () => (/* binding */ isReservedProp),\n/* harmony export */   \"isSSRSafeAttrName\": () => (/* binding */ isSSRSafeAttrName),\n/* harmony export */   \"isSVGTag\": () => (/* binding */ isSVGTag),\n/* harmony export */   \"isSet\": () => (/* binding */ isSet),\n/* harmony export */   \"isSpecialBooleanAttr\": () => (/* binding */ isSpecialBooleanAttr),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"isSymbol\": () => (/* binding */ isSymbol),\n/* harmony export */   \"isVoidTag\": () => (/* binding */ isVoidTag),\n/* harmony export */   \"looseEqual\": () => (/* binding */ looseEqual),\n/* harmony export */   \"looseIndexOf\": () => (/* binding */ looseIndexOf),\n/* harmony export */   \"looseToNumber\": () => (/* binding */ looseToNumber),\n/* harmony export */   \"makeMap\": () => (/* binding */ makeMap),\n/* harmony export */   \"normalizeClass\": () => (/* binding */ normalizeClass),\n/* harmony export */   \"normalizeProps\": () => (/* binding */ normalizeProps),\n/* harmony export */   \"normalizeStyle\": () => (/* binding */ normalizeStyle),\n/* harmony export */   \"objectToString\": () => (/* binding */ objectToString),\n/* harmony export */   \"parseStringStyle\": () => (/* binding */ parseStringStyle),\n/* harmony export */   \"propsToAttrMap\": () => (/* binding */ propsToAttrMap),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"slotFlagsText\": () => (/* binding */ slotFlagsText),\n/* harmony export */   \"stringifyStyle\": () => (/* binding */ stringifyStyle),\n/* harmony export */   \"toDisplayString\": () => (/* binding */ toDisplayString),\n/* harmony export */   \"toHandlerKey\": () => (/* binding */ toHandlerKey),\n/* harmony export */   \"toNumber\": () => (/* binding */ toNumber),\n/* harmony export */   \"toRawType\": () => (/* binding */ toRawType),\n/* harmony export */   \"toTypeString\": () => (/* binding */ toTypeString)\n/* harmony export */ });\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    // Split the content into individual lines but capture the newline sequence\n    // that separated each line. This is important because the actual sequence is\n    // needed to properly take into account the full line length for offset\n    // comparison\n    let lines = source.split(/(\\r?\\n)/);\n    // Separate the lines and newline sequences into separate arrays for easier referencing\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n    lines = lines.filter((_, idx) => idx % 2 === 0);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count +=\n            lines[i].length +\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - (lineLength + newLineSeqLength));\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + newLineSeqLength;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\nfunction normalizeStyle(value) {\n    if (isArray(value)) {\n        const res = {};\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            const normalized = isString(item)\n                ? parseStringStyle(item)\n                : normalizeStyle(item);\n            if (normalized) {\n                for (const key in normalized) {\n                    res[key] = normalized[key];\n                }\n            }\n        }\n        return res;\n    }\n    else if (isString(value)) {\n        return value;\n    }\n    else if (isObject(value)) {\n        return value;\n    }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n    const ret = {};\n    cssText\n        .replace(styleCommentRE, '')\n        .split(listDelimiterRE)\n        .forEach(item => {\n        if (item) {\n            const tmp = item.split(propertyDelimiterRE);\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return ret;\n}\nfunction stringifyStyle(styles) {\n    let ret = '';\n    if (!styles || isString(styles)) {\n        return ret;\n    }\n    for (const key in styles) {\n        const value = styles[key];\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n        if (isString(value) || typeof value === 'number') {\n            // only render valid values\n            ret += `${normalizedKey}:${value};`;\n        }\n    }\n    return ret;\n}\nfunction normalizeClass(value) {\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value)) {\n        for (const name in value) {\n            if (value[name]) {\n                res += name + ' ';\n            }\n        }\n    }\n    return res.trim();\n}\nfunction normalizeProps(props) {\n    if (!props)\n        return null;\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n        props.class = normalizeClass(klass);\n    }\n    if (style) {\n        props.style = normalizeStyle(style);\n    }\n    return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n    'option,output,progress,select,textarea,details,dialog,menu,' +\n    'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n    'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n    return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n        return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n        console.error(`unsafe attribute name: ${name}`);\n    }\n    return (attrValidationCache[name] = !isUnsafe);\n}\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`);\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n    const str = '' + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n        return str;\n    }\n    let html = '';\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34: // \"\n                escaped = '&quot;';\n                break;\n            case 38: // &\n                escaped = '&amp;';\n                break;\n            case 39: // '\n                escaped = '&#39;';\n                break;\n            case 60: // <\n                escaped = '&lt;';\n                break;\n            case 62: // >\n                escaped = '&gt;';\n                break;\n            default:\n                continue;\n        }\n        if (lastIndex !== index) {\n            html += str.slice(lastIndex, index);\n        }\n        lastIndex = index + 1;\n        html += escaped;\n    }\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n    return src.replace(commentStripRE, '');\n}\n\nfunction looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n        equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n}\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isSymbol(a);\n    bValidType = isSymbol(b);\n    if (aValidType || bValidType) {\n        return a === b;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n        /* istanbul ignore if: this if will probably never be called */\n        if (!aValidType || !bValidType) {\n            return false;\n        }\n        const aKeysCount = Object.keys(a).length;\n        const bKeysCount = Object.keys(b).length;\n        if (aKeysCount !== bKeysCount) {\n            return false;\n        }\n        for (const key in a) {\n            const aHasKey = a.hasOwnProperty(key);\n            const bHasKey = b.hasOwnProperty(key);\n            if ((aHasKey && !bHasKey) ||\n                (!aHasKey && bHasKey) ||\n                !looseEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n    }\n    return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n    return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = (val) => {\n    return isString(val)\n        ? val\n        : val == null\n            ? ''\n            : isArray(val) ||\n                (isObject(val) &&\n                    (val.toString === objectToString || !isFunction(val.toString)))\n                ? JSON.stringify(val, replacer, 2)\n                : String(val);\n};\nconst replacer = (_key, val) => {\n    // can't use isRef here since @vue/shared has no deps\n    if (val && val.__v_isRef) {\n        return replacer(_key, val.value);\n    }\n    else if (isMap(val)) {\n        return {\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                entries[`${key} =>`] = val;\n                return entries;\n            }, {})\n        };\n    }\n    else if (isSet(val)) {\n        return {\n            [`Set(${val.size})`]: [...val.values()]\n        };\n    }\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n        return String(val);\n    }\n    return val;\n};\n\nconst EMPTY_OBJ = ( true)\n    ? Object.freeze({})\n    : 0;\nconst EMPTY_ARR = ( true) ? Object.freeze([]) : 0;\nconst NOOP = () => { };\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === '[object Map]';\nconst isSet = (val) => toTypeString(val) === '[object Set]';\nconst isDate = (val) => toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\nconst isFunction = (val) => typeof val === 'function';\nconst isString = (val) => typeof val === 'string';\nconst isSymbol = (val) => typeof val === 'symbol';\nconst isObject = (val) => val !== null && typeof val === 'object';\nconst isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\nconst isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\nconst def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = (val) => {\n    const n = isString(val) ? Number(val) : NaN;\n    return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof __webpack_require__.g !== 'undefined'\n                            ? __webpack_require__.g\n                            : {}));\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n    return identRE.test(name)\n        ? `__props.${name}`\n        : `__props[${JSON.stringify(name)}]`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtCQUErQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxFQUFFLGlEQUFpRCxLQUFLLFNBQVM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjLEdBQUcsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QkFBcUIscUJBQXFCO0FBQzFDOztBQUV1ekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9ydW50aW1lLWRvbS9ub2RlX21vZHVsZXMvQHZ1ZS9zaGFyZWQvZGlzdC9zaGFyZWQuZXNtLWJ1bmRsZXIuanM/YTRiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKiBJTVBPUlRBTlQ6IGFsbCBjYWxscyBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgcHJlZml4ZWQgd2l0aFxuICogXFwvXFwqI1xcX1xcX1BVUkVcXF9cXF9cXCpcXC9cbiAqIFNvIHRoYXQgcm9sbHVwIGNhbiB0cmVlLXNoYWtlIHRoZW0gaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBtYWtlTWFwKHN0ciwgZXhwZWN0c0xvd2VyQ2FzZSkge1xuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IHZhbCA9PiAhIW1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gISFtYXBbdmFsXTtcbn1cblxuLyoqXG4gKiBkZXYgb25seSBmbGFnIC0+IG5hbWUgbWFwcGluZ1xuICovXG5jb25zdCBQYXRjaEZsYWdOYW1lcyA9IHtcbiAgICBbMSAvKiBQYXRjaEZsYWdzLlRFWFQgKi9dOiBgVEVYVGAsXG4gICAgWzIgLyogUGF0Y2hGbGFncy5DTEFTUyAqL106IGBDTEFTU2AsXG4gICAgWzQgLyogUGF0Y2hGbGFncy5TVFlMRSAqL106IGBTVFlMRWAsXG4gICAgWzggLyogUGF0Y2hGbGFncy5QUk9QUyAqL106IGBQUk9QU2AsXG4gICAgWzE2IC8qIFBhdGNoRmxhZ3MuRlVMTF9QUk9QUyAqL106IGBGVUxMX1BST1BTYCxcbiAgICBbMzIgLyogUGF0Y2hGbGFncy5IWURSQVRFX0VWRU5UUyAqL106IGBIWURSQVRFX0VWRU5UU2AsXG4gICAgWzY0IC8qIFBhdGNoRmxhZ3MuU1RBQkxFX0ZSQUdNRU5UICovXTogYFNUQUJMRV9GUkFHTUVOVGAsXG4gICAgWzEyOCAvKiBQYXRjaEZsYWdzLktFWUVEX0ZSQUdNRU5UICovXTogYEtFWUVEX0ZSQUdNRU5UYCxcbiAgICBbMjU2IC8qIFBhdGNoRmxhZ3MuVU5LRVlFRF9GUkFHTUVOVCAqL106IGBVTktFWUVEX0ZSQUdNRU5UYCxcbiAgICBbNTEyIC8qIFBhdGNoRmxhZ3MuTkVFRF9QQVRDSCAqL106IGBORUVEX1BBVENIYCxcbiAgICBbMTAyNCAvKiBQYXRjaEZsYWdzLkRZTkFNSUNfU0xPVFMgKi9dOiBgRFlOQU1JQ19TTE9UU2AsXG4gICAgWzIwNDggLyogUGF0Y2hGbGFncy5ERVZfUk9PVF9GUkFHTUVOVCAqL106IGBERVZfUk9PVF9GUkFHTUVOVGAsXG4gICAgWy0xIC8qIFBhdGNoRmxhZ3MuSE9JU1RFRCAqL106IGBIT0lTVEVEYCxcbiAgICBbLTIgLyogUGF0Y2hGbGFncy5CQUlMICovXTogYEJBSUxgXG59O1xuXG4vKipcbiAqIERldiBvbmx5XG4gKi9cbmNvbnN0IHNsb3RGbGFnc1RleHQgPSB7XG4gICAgWzEgLyogU2xvdEZsYWdzLlNUQUJMRSAqL106ICdTVEFCTEUnLFxuICAgIFsyIC8qIFNsb3RGbGFncy5EWU5BTUlDICovXTogJ0RZTkFNSUMnLFxuICAgIFszIC8qIFNsb3RGbGFncy5GT1JXQVJERUQgKi9dOiAnRk9SV0FSREVEJ1xufTtcblxuY29uc3QgR0xPQkFMU19XSElURV9MSVNURUQgPSAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTixwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSwnICtcbiAgICAnZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSwnICtcbiAgICAnT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQnO1xuY29uc3QgaXNHbG9iYWxseVdoaXRlbGlzdGVkID0gLyojX19QVVJFX18qLyBtYWtlTWFwKEdMT0JBTFNfV0hJVEVfTElTVEVEKTtcblxuY29uc3QgcmFuZ2UgPSAyO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUoc291cmNlLCBzdGFydCA9IDAsIGVuZCA9IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAvLyBTcGxpdCB0aGUgY29udGVudCBpbnRvIGluZGl2aWR1YWwgbGluZXMgYnV0IGNhcHR1cmUgdGhlIG5ld2xpbmUgc2VxdWVuY2VcbiAgICAvLyB0aGF0IHNlcGFyYXRlZCBlYWNoIGxpbmUuIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIGFjdHVhbCBzZXF1ZW5jZSBpc1xuICAgIC8vIG5lZWRlZCB0byBwcm9wZXJseSB0YWtlIGludG8gYWNjb3VudCB0aGUgZnVsbCBsaW5lIGxlbmd0aCBmb3Igb2Zmc2V0XG4gICAgLy8gY29tcGFyaXNvblxuICAgIGxldCBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvKFxccj9cXG4pLyk7XG4gICAgLy8gU2VwYXJhdGUgdGhlIGxpbmVzIGFuZCBuZXdsaW5lIHNlcXVlbmNlcyBpbnRvIHNlcGFyYXRlIGFycmF5cyBmb3IgZWFzaWVyIHJlZmVyZW5jaW5nXG4gICAgY29uc3QgbmV3bGluZVNlcXVlbmNlcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAxKTtcbiAgICBsaW5lcyA9IGxpbmVzLmZpbHRlcigoXywgaWR4KSA9PiBpZHggJSAyID09PSAwKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnQgKz1cbiAgICAgICAgICAgIGxpbmVzW2ldLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgKChuZXdsaW5lU2VxdWVuY2VzW2ldICYmIG5ld2xpbmVTZXF1ZW5jZXNbaV0ubGVuZ3RoKSB8fCAwKTtcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gaiArIDE7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goYCR7bGluZX0keycgJy5yZXBlYXQoTWF0aC5tYXgoMyAtIFN0cmluZyhsaW5lKS5sZW5ndGgsIDApKX18ICAke2xpbmVzW2pdfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGluZVNlcUxlbmd0aCA9IChuZXdsaW5lU2VxdWVuY2VzW2pdICYmIG5ld2xpbmVTZXF1ZW5jZXNbal0ubGVuZ3RoKSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gKGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KDEsIGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnICcucmVwZWF0KHBhZCkgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArICdeJy5yZXBlYXQobGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIG5ld0xpbmVTZXFMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpc1N0cmluZyhpdGVtKVxuICAgICAgICAgICAgICAgID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKVxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplU3R5bGUoaXRlbSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBub3JtYWxpemVkW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuY29uc3QgbGlzdERlbGltaXRlclJFID0gLzsoPyFbXihdKlxcKSkvZztcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOihbXl0rKS87XG5jb25zdCBzdHlsZUNvbW1lbnRSRSA9IC9cXC9cXCouKj9cXCpcXC8vZ3M7XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBjc3NUZXh0XG4gICAgICAgIC5yZXBsYWNlKHN0eWxlQ29tbWVudFJFLCAnJylcbiAgICAgICAgLnNwbGl0KGxpc3REZWxpbWl0ZXJSRSlcbiAgICAgICAgLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyUkUpO1xuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlKHN0eWxlcykge1xuICAgIGxldCByZXQgPSAnJztcbiAgICBpZiAoIXN0eWxlcyB8fCBpc1N0cmluZyhzdHlsZXMpKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkS2V5ID0ga2V5LnN0YXJ0c1dpdGgoYC0tYCkgPyBrZXkgOiBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJlbmRlciB2YWxpZCB2YWx1ZXNcbiAgICAgICAgICAgIHJldCArPSBgJHtub3JtYWxpemVkS2V5fToke3ZhbHVlfTtgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJlcyA9IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQ2xhc3ModmFsdWVbaV0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gbmFtZSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzKHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgY2xhc3M6IGtsYXNzLCBzdHlsZSB9ID0gcHJvcHM7XG4gICAgaWYgKGtsYXNzICYmICFpc1N0cmluZyhrbGFzcykpIHtcbiAgICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XG4gICAgfVxuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG4vLyBUaGVzZSB0YWcgY29uZmlncyBhcmUgc2hhcmVkIGJldHdlZW4gY29tcGlsZXItZG9tIGFuZCBydW50aW1lLWRvbSwgc28gdGhleVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50XG5jb25zdCBIVE1MX1RBR1MgPSAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlciwnICtcbiAgICAnaGVhZGVyLGhncm91cCxoMSxoMixoMyxoNCxoNSxoNixuYXYsc2VjdGlvbixkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbiwnICtcbiAgICAnZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsJyArXG4gICAgJ2RhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLCcgK1xuICAgICd0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLCcgK1xuICAgICdjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsJyArXG4gICAgJ3RoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCwnICtcbiAgICAnb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSwnICtcbiAgICAnc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCc7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudFxuY29uc3QgU1ZHX1RBR1MgPSAnc3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLCcgK1xuICAgICdkZWZzLGRlc2MsZGlzY2FyZCxlbGxpcHNlLGZlQmxlbmQsZmVDb2xvck1hdHJpeCxmZUNvbXBvbmVudFRyYW5zZmVyLCcgK1xuICAgICdmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLCcgK1xuICAgICdmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLCcgK1xuICAgICdmZUdhdXNzaWFuQmx1cixmZUltYWdlLGZlTWVyZ2UsZmVNZXJnZU5vZGUsZmVNb3JwaG9sb2d5LGZlT2Zmc2V0LCcgK1xuICAgICdmZVBvaW50TGlnaHQsZmVTcGVjdWxhckxpZ2h0aW5nLGZlU3BvdExpZ2h0LGZlVGlsZSxmZVR1cmJ1bGVuY2UsZmlsdGVyLCcgK1xuICAgICdmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssJyArXG4gICAgJ21lc2gsbWVzaGdyYWRpZW50LG1lc2hwYXRjaCxtZXNocm93LG1ldGFkYXRhLG1wYXRoLHBhdGgscGF0dGVybiwnICtcbiAgICAncG9seWdvbixwb2x5bGluZSxyYWRpYWxHcmFkaWVudCxyZWN0LHNldCxzb2xpZGNvbG9yLHN0b3Asc3dpdGNoLHN5bWJvbCwnICtcbiAgICAndGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3JztcbmNvbnN0IFZPSURfVEFHUyA9ICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGhyLGltZyxpbnB1dCxsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicic7XG4vKipcbiAqIENvbXBpbGVyIG9ubHkuXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXG4gKi9cbmNvbnN0IGlzSFRNTFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xuLyoqXG4gKiBDb21waWxlciBvbmx5LlxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxuICovXG5jb25zdCBpc1NWR1RhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChTVkdfVEFHUyk7XG4vKipcbiAqIENvbXBpbGVyIG9ubHkuXG4gKiBEbyBOT1QgdXNlIGluIHJ1bnRpbWUgY29kZSBwYXRocyB1bmxlc3MgYmVoaW5kIGAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylgIGZsYWcuXG4gKi9cbmNvbnN0IGlzVm9pZFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChWT0lEX1RBR1MpO1xuXG4vKipcbiAqIE9uIHRoZSBjbGllbnQgd2Ugb25seSBuZWVkIHRvIG9mZmVyIHNwZWNpYWwgY2FzZXMgZm9yIGJvb2xlYW4gYXR0cmlidXRlcyB0aGF0XG4gKiBoYXZlIGRpZmZlcmVudCBuYW1lcyBmcm9tIHRoZWlyIGNvcnJlc3BvbmRpbmcgZG9tIHByb3BlcnRpZXM6XG4gKiAtIGl0ZW1zY29wZSAtPiBOL0FcbiAqIC0gYWxsb3dmdWxsc2NyZWVuIC0+IGFsbG93RnVsbHNjcmVlblxuICogLSBmb3Jtbm92YWxpZGF0ZSAtPiBmb3JtTm9WYWxpZGF0ZVxuICogLSBpc21hcCAtPiBpc01hcFxuICogLSBub21vZHVsZSAtPiBub01vZHVsZVxuICogLSBub3ZhbGlkYXRlIC0+IG5vVmFsaWRhdGVcbiAqIC0gcmVhZG9ubHkgLT4gcmVhZE9ubHlcbiAqL1xuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xuY29uc3QgaXNTcGVjaWFsQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyk7XG4vKipcbiAqIFRoZSBmdWxsIGxpc3QgaXMgbmVlZGVkIGR1cmluZyBTU1IgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBpbml0aWFsIG1hcmt1cC5cbiAqL1xuY29uc3QgaXNCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICtcbiAgICBgLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjb250cm9scyxkZWZhdWx0LGRlZmVyLGRpc2FibGVkLGhpZGRlbixgICtcbiAgICBgbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxgICtcbiAgICBgY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZGApO1xuLyoqXG4gKiBCb29sZWFuIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgb3IgJycuXG4gKiBlLmcuIGA8c2VsZWN0IG11bHRpcGxlPmAgY29tcGlsZXMgdG8gYHsgbXVsdGlwbGU6ICcnIH1gXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlIHx8IHZhbHVlID09PSAnJztcbn1cbmNvbnN0IHVuc2FmZUF0dHJDaGFyUkUgPSAvWz4vPVwiJ1xcdTAwMDlcXHUwMDBhXFx1MDAwY1xcdTAwMjBdLztcbmNvbnN0IGF0dHJWYWxpZGF0aW9uQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzU1NSU2FmZUF0dHJOYW1lKG5hbWUpIHtcbiAgICBpZiAoYXR0clZhbGlkYXRpb25DYWNoZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gYXR0clZhbGlkYXRpb25DYWNoZVtuYW1lXTtcbiAgICB9XG4gICAgY29uc3QgaXNVbnNhZmUgPSB1bnNhZmVBdHRyQ2hhclJFLnRlc3QobmFtZSk7XG4gICAgaWYgKGlzVW5zYWZlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHVuc2FmZSBhdHRyaWJ1dGUgbmFtZTogJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gKGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV0gPSAhaXNVbnNhZmUpO1xufVxuY29uc3QgcHJvcHNUb0F0dHJNYXAgPSB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbn07XG4vKipcbiAqIEtub3duIGF0dHJpYnV0ZXMsIHRoaXMgaXMgdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uIG9mIHJ1bnRpbWUgc3RhdGljIG5vZGVzXG4gKiBzbyB0aGF0IHdlIGRvbid0IHN0cmluZ2lmeSBiaW5kaW5ncyB0aGF0IGNhbm5vdCBiZSBzZXQgZnJvbSBIVE1MLlxuICogRG9uJ3QgYWxzbyBmb3JnZXQgdG8gYWxsb3cgYGRhdGEtKmAgYW5kIGBhcmlhLSpgIVxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9BdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IGlzS25vd25IdG1sQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgYWNjZXB0LGFjY2VwdC1jaGFyc2V0LGFjY2Vzc2tleSxhY3Rpb24sYWxpZ24sYWxsb3csYWx0LGFzeW5jLGAgK1xuICAgIGBhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsYXV0b2ZvY3VzLGF1dG9wbGF5LGJhY2tncm91bmQsYmdjb2xvcixgICtcbiAgICBgYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsYCArXG4gICAgYGNvZGViYXNlLGNvbG9yLGNvbHMsY29sc3Bhbixjb250ZW50LGNvbnRlbnRlZGl0YWJsZSxjb250ZXh0bWVudSxjb250cm9scyxgICtcbiAgICBgY29vcmRzLGNyb3Nzb3JpZ2luLGNzcCxkYXRhLGRhdGV0aW1lLGRlY29kaW5nLGRlZmF1bHQsZGVmZXIsZGlyLGRpcm5hbWUsYCArXG4gICAgYGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxgICtcbiAgICBgZm9ybWFjdGlvbixmb3JtZW5jdHlwZSxmb3JtbWV0aG9kLGZvcm1ub3ZhbGlkYXRlLGZvcm10YXJnZXQsaGVhZGVycyxgICtcbiAgICBgaGVpZ2h0LGhpZGRlbixoaWdoLGhyZWYsaHJlZmxhbmcsaHR0cC1lcXVpdixpY29uLGlkLGltcG9ydGFuY2UsaW50ZWdyaXR5LGAgK1xuICAgIGBpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csYCArXG4gICAgYG1hbmlmZXN0LG1heCxtYXhsZW5ndGgsbWlubGVuZ3RoLG1lZGlhLG1pbixtdWx0aXBsZSxtdXRlZCxuYW1lLG5vdmFsaWRhdGUsYCArXG4gICAgYG9wZW4sb3B0aW11bSxwYXR0ZXJuLHBpbmcscGxhY2Vob2xkZXIscG9zdGVyLHByZWxvYWQscmFkaW9ncm91cCxyZWFkb25seSxgICtcbiAgICBgcmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxgICtcbiAgICBgc2VsZWN0ZWQsc2hhcGUsc2l6ZSxzaXplcyxzbG90LHNwYW4sc3BlbGxjaGVjayxzcmMsc3JjZG9jLHNyY2xhbmcsc3Jjc2V0LGAgK1xuICAgIGBzdGFydCxzdGVwLHN0eWxlLHN1bW1hcnksdGFiaW5kZXgsdGFyZ2V0LHRpdGxlLHRyYW5zbGF0ZSx0eXBlLHVzZW1hcCxgICtcbiAgICBgdmFsdWUsd2lkdGgsd3JhcGApO1xuLyoqXG4gKiBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlXG4gKi9cbmNvbnN0IGlzS25vd25TdmdBdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGB4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGAgK1xuICAgIGBhcmFiaWMtZm9ybSxhc2NlbnQsYXR0cmlidXRlTmFtZSxhdHRyaWJ1dGVUeXBlLGF6aW11dGgsYmFzZUZyZXF1ZW5jeSxgICtcbiAgICBgYmFzZWxpbmUtc2hpZnQsYmFzZVByb2ZpbGUsYmJveCxiZWdpbixiaWFzLGJ5LGNhbGNNb2RlLGNhcC1oZWlnaHQsY2xhc3MsYCArXG4gICAgYGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sYCArXG4gICAgYGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyxjb2xvci1wcm9maWxlLGNvbG9yLXJlbmRlcmluZyxgICtcbiAgICBgY29udGVudFNjcmlwdFR5cGUsY29udGVudFN0eWxlVHlwZSxjcm9zc29yaWdpbixjdXJzb3IsY3gsY3ksZCxkZWNlbGVyYXRlLGAgK1xuICAgIGBkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxgICtcbiAgICBgZHksZWRnZU1vZGUsZWxldmF0aW9uLGVuYWJsZS1iYWNrZ3JvdW5kLGVuZCxleHBvbmVudCxmaWxsLGZpbGwtb3BhY2l0eSxgICtcbiAgICBgZmlsbC1ydWxlLGZpbHRlcixmaWx0ZXJSZXMsZmlsdGVyVW5pdHMsZmxvb2QtY29sb3IsZmxvb2Qtb3BhY2l0eSxgICtcbiAgICBgZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsYCArXG4gICAgYGZvbnQtdmFyaWFudCxmb250LXdlaWdodCxmb3JtYXQsZnJvbSxmcixmeCxmeSxnMSxnMixnbHlwaC1uYW1lLGAgK1xuICAgIGBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsLGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsLGdseXBoUmVmLGAgK1xuICAgIGBncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsYCArXG4gICAgYGhvcml6LW9yaWdpbi14LGlkLGlkZW9ncmFwaGljLGltYWdlLXJlbmRlcmluZyxpbixpbjIsaW50ZXJjZXB0LGssazEsazIsazMsYCArXG4gICAgYGs0LGtlcm5lbE1hdHJpeCxrZXJuZWxVbml0TGVuZ3RoLGtlcm5pbmcsa2V5UG9pbnRzLGtleVNwbGluZXMsa2V5VGltZXMsYCArXG4gICAgYGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLGAgK1xuICAgIGBtYXJrZXItZW5kLG1hcmtlci1taWQsbWFya2VyLXN0YXJ0LG1hcmtlckhlaWdodCxtYXJrZXJVbml0cyxtYXJrZXJXaWR0aCxgICtcbiAgICBgbWFzayxtYXNrQ29udGVudFVuaXRzLG1hc2tVbml0cyxtYXRoZW1hdGljYWwsbWF4LG1lZGlhLG1ldGhvZCxtaW4sbW9kZSxgICtcbiAgICBgbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sYCArXG4gICAgYG92ZXJmbG93LG92ZXJsaW5lLXBvc2l0aW9uLG92ZXJsaW5lLXRoaWNrbmVzcyxwYW5vc2UtMSxwYWludC1vcmRlcixwYXRoLGAgK1xuICAgIGBwYXRoTGVuZ3RoLHBhdHRlcm5Db250ZW50VW5pdHMscGF0dGVyblRyYW5zZm9ybSxwYXR0ZXJuVW5pdHMscGluZyxgICtcbiAgICBgcG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEsYCArXG4gICAgYHByZXNlcnZlQXNwZWN0UmF0aW8scHJpbWl0aXZlVW5pdHMscixyYWRpdXMscmVmZXJyZXJQb2xpY3kscmVmWCxyZWZZLHJlbCxgICtcbiAgICBgcmVuZGVyaW5nLWludGVudCxyZXBlYXRDb3VudCxyZXBlYXREdXIscmVxdWlyZWRFeHRlbnNpb25zLHJlcXVpcmVkRmVhdHVyZXMsYCArXG4gICAgYHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLGAgK1xuICAgIGBzcGVjdWxhckNvbnN0YW50LHNwZWN1bGFyRXhwb25lbnQsc3BlZWQsc3ByZWFkTWV0aG9kLHN0YXJ0T2Zmc2V0LGAgK1xuICAgIGBzdGREZXZpYXRpb24sc3RlbWgsc3RlbXYsc3RpdGNoVGlsZXMsc3RvcC1jb2xvcixzdG9wLW9wYWNpdHksYCArXG4gICAgYHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxgICtcbiAgICBgc3Ryb2tlLWRhc2hhcnJheSxzdHJva2UtZGFzaG9mZnNldCxzdHJva2UtbGluZWNhcCxzdHJva2UtbGluZWpvaW4sYCArXG4gICAgYHN0cm9rZS1taXRlcmxpbWl0LHN0cm9rZS1vcGFjaXR5LHN0cm9rZS13aWR0aCxzdHlsZSxzdXJmYWNlU2NhbGUsYCArXG4gICAgYHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsYCArXG4gICAgYHRleHQtZGVjb3JhdGlvbix0ZXh0LXJlbmRlcmluZyx0ZXh0TGVuZ3RoLHRvLHRyYW5zZm9ybSx0cmFuc2Zvcm0tb3JpZ2luLGAgK1xuICAgIGB0eXBlLHUxLHUyLHVuZGVybGluZS1wb3NpdGlvbix1bmRlcmxpbmUtdGhpY2tuZXNzLHVuaWNvZGUsdW5pY29kZS1iaWRpLGAgK1xuICAgIGB1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsYCArXG4gICAgYHYtbWF0aGVtYXRpY2FsLHZhbHVlcyx2ZWN0b3ItZWZmZWN0LHZlcnNpb24sdmVydC1hZHYteSx2ZXJ0LW9yaWdpbi14LGAgK1xuICAgIGB2ZXJ0LW9yaWdpbi15LHZpZXdCb3gsdmlld1RhcmdldCx2aXNpYmlsaXR5LHdpZHRoLHdpZHRocyx3b3JkLXNwYWNpbmcsYCArXG4gICAgYHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLGAgK1xuICAgIGB4bGluazpocmVmLHhsaW5rOnJvbGUseGxpbms6c2hvdyx4bGluazp0aXRsZSx4bGluazp0eXBlLHhtbDpiYXNlLHhtbDpsYW5nLGAgK1xuICAgIGB4bWw6c3BhY2UseSx5MSx5Mix5Q2hhbm5lbFNlbGVjdG9yLHosem9vbUFuZFBhbmApO1xuXG5jb25zdCBlc2NhcGVSRSA9IC9bXCInJjw+XS87XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICAgIGNvbnN0IHN0ciA9ICcnICsgc3RyaW5nO1xuICAgIGNvbnN0IG1hdGNoID0gZXNjYXBlUkUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBsZXQgZXNjYXBlZDtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgICAgICAgIGNhc2UgMzQ6IC8vIFwiXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmcXVvdDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODogLy8gJlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmFtcDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTogLy8gJ1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJiMzOTsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDogLy8gPFxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmx0Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDYyOiAvLyA+XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9ICcmZ3Q7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgaHRtbCArPSBlc2NhcGVkO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc2xpY2UobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1Mi9zeW50YXguaHRtbCNjb21tZW50c1xuY29uc3QgY29tbWVudFN0cmlwUkUgPSAvXi0/Pnw8IS0tfC0tPnwtLSE+fDwhLSQvZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWxDb21tZW50KHNyYykge1xuICAgIHJldHVybiBzcmMucmVwbGFjZShjb21tZW50U3RyaXBSRSwgJycpO1xufVxuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBlcXVhbCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlcXVhbCA9IGxvb3NlRXF1YWwoYVtpXSwgYltpXSk7XG4gICAgfVxuICAgIHJldHVybiBlcXVhbDtcbn1cbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcbiAgICBsZXQgYlZhbGlkVHlwZSA9IGlzRGF0ZShiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcbiAgICB9XG4gICAgYVZhbGlkVHlwZSA9IGlzU3ltYm9sKGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgIH1cbiAgICBhVmFsaWRUeXBlID0gaXNBcnJheShhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNBcnJheShiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikgOiBmYWxzZTtcbiAgICB9XG4gICAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xuICAgIGJWYWxpZFR5cGUgPSBpc09iamVjdChiKTtcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGhpcyBpZiB3aWxsIHByb2JhYmx5IG5ldmVyIGJlIGNhbGxlZCAqL1xuICAgICAgICBpZiAoIWFWYWxpZFR5cGUgfHwgIWJWYWxpZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBiS2V5c0NvdW50ID0gT2JqZWN0LmtleXMoYikubGVuZ3RoO1xuICAgICAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGFIYXNLZXkgPSBhLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgICAgICBjb25zdCBiSGFzS2V5ID0gYi5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICAgICAgaWYgKChhSGFzS2V5ICYmICFiSGFzS2V5KSB8fFxuICAgICAgICAgICAgICAgICghYUhhc0tleSAmJiBiSGFzS2V5KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChpdGVtID0+IGxvb3NlRXF1YWwoaXRlbSwgdmFsKSk7XG59XG5cbi8qKlxuICogRm9yIGNvbnZlcnRpbmcge3sgaW50ZXJwb2xhdGlvbiB9fSB2YWx1ZXMgdG8gZGlzcGxheWVkIHN0cmluZ3MuXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB2YWwgPT0gbnVsbFxuICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgOiBpc0FycmF5KHZhbCkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsKSAmJlxuICAgICAgICAgICAgICAgICAgICAodmFsLnRvU3RyaW5nID09PSBvYmplY3RUb1N0cmluZyB8fCAhaXNGdW5jdGlvbih2YWwudG9TdHJpbmcpKSlcbiAgICAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgcmVwbGFjZXIsIDIpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcbn07XG5jb25zdCByZXBsYWNlciA9IChfa2V5LCB2YWwpID0+IHtcbiAgICAvLyBjYW4ndCB1c2UgaXNSZWYgaGVyZSBzaW5jZSBAdnVlL3NoYXJlZCBoYXMgbm8gZGVwc1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdl9pc1JlZikge1xuICAgICAgICByZXR1cm4gcmVwbGFjZXIoX2tleSwgdmFsLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNNYXAodmFsKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICBlbnRyaWVzW2Ake2tleX0gPT5gXSA9IHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbYFNldCgke3ZhbC5zaXplfSlgXTogWy4uLnZhbC52YWx1ZXMoKV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSAmJiAhaXNBcnJheSh2YWwpICYmICFpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcblxuY29uc3QgRU1QVFlfT0JKID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXG4gICAgPyBPYmplY3QuZnJlZXplKHt9KVxuICAgIDoge307XG5jb25zdCBFTVBUWV9BUlIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xuY29uc3QgTk8gPSAoKSA9PiBmYWxzZTtcbmNvbnN0IG9uUkUgPSAvXm9uW15hLXpdLztcbmNvbnN0IGlzT24gPSAoa2V5KSA9PiBvblJFLnRlc3Qoa2V5KTtcbmNvbnN0IGlzTW9kZWxMaXN0ZW5lciA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKCdvblVwZGF0ZTonKTtcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XG5jb25zdCByZW1vdmUgPSAoYXJyLCBlbCkgPT4ge1xuICAgIGNvbnN0IGkgPSBhcnIuaW5kZXhPZihlbCk7XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgIH1cbn07XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5jb25zdCBoYXNPd24gPSAodmFsLCBrZXkpID0+IGhhc093blByb3BlcnR5LmNhbGwodmFsLCBrZXkpO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc01hcCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBNYXBdJztcbmNvbnN0IGlzU2V0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFNldF0nO1xuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbmNvbnN0IGlzUmVnRXhwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG5jb25zdCBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xuY29uc3QgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3ltYm9sJztcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xuY29uc3QgaXNQcm9taXNlID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnRoZW4pICYmIGlzRnVuY3Rpb24odmFsLmNhdGNoKTtcbn07XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB0b1R5cGVTdHJpbmcgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gICAgLy8gZXh0cmFjdCBcIlJhd1R5cGVcIiBmcm9tIHN0cmluZ3MgbGlrZSBcIltvYmplY3QgUmF3VHlwZV1cIlxuICAgIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn07XG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuY29uc3QgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJlxuICAgIGtleSAhPT0gJ05hTicgJiZcbiAgICBrZXlbMF0gIT09ICctJyAmJlxuICAgICcnICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxuLy8gdGhlIGxlYWRpbmcgY29tbWEgaXMgaW50ZW50aW9uYWwgc28gZW1wdHkgc3RyaW5nIFwiXCIgaXMgYWxzbyBpbmNsdWRlZFxuJyxrZXkscmVmLHJlZl9mb3IscmVmX2tleSwnICtcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xuICAgICdvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLCcgK1xuICAgICdvblZub2RlQmVmb3JlVW5tb3VudCxvblZub2RlVW5tb3VudGVkJyk7XG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW8nKTtcbmNvbnN0IGNhY2hlU3RyaW5nRnVuY3Rpb24gPSAoZm4pID0+IHtcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XG4gICAgICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKTtcbiAgICB9KTtcbn07XG5jb25zdCBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gKGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJykpO1xufSk7XG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApO1xuLy8gY29tcGFyZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQsIGFjY291bnRpbmcgZm9yIE5hTi5cbmNvbnN0IGhhc0NoYW5nZWQgPSAodmFsdWUsIG9sZFZhbHVlKSA9PiAhT2JqZWN0LmlzKHZhbHVlLCBvbGRWYWx1ZSk7XG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuc1tpXShhcmcpO1xuICAgIH1cbn07XG5jb25zdCBkZWYgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgfSk7XG59O1xuLyoqXG4gKiBcIjEyMy1mb29cIiB3aWxsIGJlIHBhcnNlZCB0byAxMjNcbiAqIFRoaXMgaXMgdXNlZCBmb3IgdGhlIC5udW1iZXIgbW9kaWZpZXIgaW4gdi1tb2RlbFxuICovXG5jb25zdCBsb29zZVRvTnVtYmVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcbn07XG4vKipcbiAqIE9ubHkgY29uZXJjZXMgbnVtYmVyLWxpa2Ugc3RyaW5nc1xuICogXCIxMjMtZm9vXCIgd2lsbCBiZSByZXR1cm5lZCBhcy1pc1xuICovXG5jb25zdCB0b051bWJlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBuID0gaXNTdHJpbmcodmFsKSA/IE51bWJlcih2YWwpIDogTmFOO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xubGV0IF9nbG9iYWxUaGlzO1xuY29uc3QgZ2V0R2xvYmFsVGhpcyA9ICgpID0+IHtcbiAgICByZXR1cm4gKF9nbG9iYWxUaGlzIHx8XG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICA/IHNlbGZcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcbn07XG5jb25zdCBpZGVudFJFID0gL15bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKiQvO1xuZnVuY3Rpb24gZ2VuUHJvcHNBY2Nlc3NFeHAobmFtZSkge1xuICAgIHJldHVybiBpZGVudFJFLnRlc3QobmFtZSlcbiAgICAgICAgPyBgX19wcm9wcy4ke25hbWV9YFxuICAgICAgICA6IGBfX3Byb3BzWyR7SlNPTi5zdHJpbmdpZnkobmFtZSl9XWA7XG59XG5cbmV4cG9ydCB7IEVNUFRZX0FSUiwgRU1QVFlfT0JKLCBOTywgTk9PUCwgUGF0Y2hGbGFnTmFtZXMsIGNhbWVsaXplLCBjYXBpdGFsaXplLCBkZWYsIGVzY2FwZUh0bWwsIGVzY2FwZUh0bWxDb21tZW50LCBleHRlbmQsIGdlblByb3BzQWNjZXNzRXhwLCBnZW5lcmF0ZUNvZGVGcmFtZSwgZ2V0R2xvYmFsVGhpcywgaGFzQ2hhbmdlZCwgaGFzT3duLCBoeXBoZW5hdGUsIGluY2x1ZGVCb29sZWFuQXR0ciwgaW52b2tlQXJyYXlGbnMsIGlzQXJyYXksIGlzQm9vbGVhbkF0dHIsIGlzQnVpbHRJbkRpcmVjdGl2ZSwgaXNEYXRlLCBpc0Z1bmN0aW9uLCBpc0dsb2JhbGx5V2hpdGVsaXN0ZWQsIGlzSFRNTFRhZywgaXNJbnRlZ2VyS2V5LCBpc0tub3duSHRtbEF0dHIsIGlzS25vd25TdmdBdHRyLCBpc01hcCwgaXNNb2RlbExpc3RlbmVyLCBpc09iamVjdCwgaXNPbiwgaXNQbGFpbk9iamVjdCwgaXNQcm9taXNlLCBpc1JlZ0V4cCwgaXNSZXNlcnZlZFByb3AsIGlzU1NSU2FmZUF0dHJOYW1lLCBpc1NWR1RhZywgaXNTZXQsIGlzU3BlY2lhbEJvb2xlYW5BdHRyLCBpc1N0cmluZywgaXNTeW1ib2wsIGlzVm9pZFRhZywgbG9vc2VFcXVhbCwgbG9vc2VJbmRleE9mLCBsb29zZVRvTnVtYmVyLCBtYWtlTWFwLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvYmplY3RUb1N0cmluZywgcGFyc2VTdHJpbmdTdHlsZSwgcHJvcHNUb0F0dHJNYXAsIHJlbW92ZSwgc2xvdEZsYWdzVGV4dCwgc3RyaW5naWZ5U3R5bGUsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b051bWJlciwgdG9SYXdUeXBlLCB0b1R5cGVTdHJpbmcgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vue/runtime-dom/node_modules/@vue/shared/dist/shared.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=script&lang=js":
/*!****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=script&lang=js ***!
  \****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconsole.log('HackerNews.vue loaded');\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'HackerNews',\n  props: ['keyword'],\n  data: function data() {\n    return {\n      news: [],\n      search: 'laravel',\n      loading: false,\n      article: {},\n      show: false\n    };\n  },\n  methods: {\n    fetchArticles: function fetchArticles(keyword) {\n      var _this = this;\n      this.loading = true;\n      fetch('https://api.todayintel.com/feed/reader', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          link: \"https://hnrss.org/newest?q=\" + keyword\n        })\n      }).then(function (response) {\n        return response.json();\n      }).then(function (response) {\n        console.log(response);\n        _this.loading = false;\n        _this.show = false;\n        _this.news = response.data.response.entries;\n      })[\"catch\"](function (error) {\n        alert(error);\n      });\n    },\n    extractArticle: function extractArticle(link) {\n      var _this2 = this;\n      this.loading = true;\n      fetch('https://api.todayintel.com/nlp/article', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n          'Access-Control-Allow-Origin': '*'\n        },\n        body: JSON.stringify({\n          link: link\n        })\n      }).then(function (response) {\n        return response.json();\n      }).then(function (response) {\n        console.log(response);\n        _this2.loading = false;\n        _this2.show = true;\n        _this2.article = response.data;\n      })[\"catch\"](function (error) {\n        alert(error);\n      });\n    },\n    saveArticle: function saveArticle() {\n      console.log(this.article);\n    },\n    searchNews: function searchNews() {\n      this.fetchArticles(this.search);\n    }\n  },\n  mounted: function mounted() {\n    this.fetchArticles(this.search);\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92dWUvSGFja2VyTmV3cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQWdIQUEsT0FBTyxDQUFDQyxHQUFHLENBQUMsdUJBQXVCLENBQUM7QUFDcEMsaUVBQWU7RUFDYkMsSUFBSSxFQUFFLFlBQVk7RUFDbEJDLEtBQUssRUFBRSxDQUFDLFNBQVMsQ0FBQztFQUNsQkMsSUFBSSxrQkFBRztJQUNMLE9BQU87TUFDTEMsSUFBSSxFQUFFLEVBQUU7TUFDUkMsTUFBTSxFQUFFLFNBQVM7TUFDakJDLE9BQU8sRUFBRSxLQUFLO01BQ2RDLE9BQU8sRUFBRSxDQUFDLENBQUM7TUFDWEMsSUFBSSxFQUFFO0lBQ1I7RUFDRixDQUFDO0VBQ0RDLE9BQU8sRUFBRTtJQUNQQyxhQUFhLHlCQUFDQyxPQUFPLEVBQUU7TUFBQTtNQUNsQixJQUFJLENBQUNMLE9BQU0sR0FBSSxJQUFJO01BQ2xCTSxLQUFLLENBQUMsd0NBQXdDLEVBQUU7UUFDOUNDLE1BQU0sRUFBRSxNQUFNO1FBQ2RDLE9BQU8sRUFBRTtVQUNQLGNBQWMsRUFBRSxrQkFBa0I7VUFDbEMsUUFBUSxFQUFFLGtCQUFrQjtVQUM1Qiw2QkFBNkIsRUFBRTtRQUNqQyxDQUFDO1FBQ0RDLElBQUksRUFBRUMsSUFBSSxDQUFDQyxTQUFTLENBQUM7VUFDbkJDLElBQUksRUFBRSw2QkFBNEIsR0FBSVA7UUFDeEMsQ0FBQztNQUNILENBQUMsRUFDQVEsSUFBSSxDQUFDLGtCQUFPLEVBQUs7UUFDaEIsT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEVBQUU7TUFDeEIsQ0FBQyxFQUNBRixJQUFJLENBQUMsa0JBQU8sRUFBSztRQUNoQnBCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDb0IsUUFBUSxDQUFDO1FBQ3JCLEtBQUksQ0FBQ2QsT0FBTSxHQUFJLEtBQUs7UUFDcEIsS0FBSSxDQUFDRSxJQUFHLEdBQUksS0FBSztRQUNqQixLQUFJLENBQUNKLElBQUcsR0FBSWdCLFFBQVEsQ0FBQ2pCLElBQUksQ0FBQ2lCLFFBQVEsQ0FBQ0UsT0FBTztNQUM1QyxDQUFDLFVBQ0ssQ0FBQyxlQUFJLEVBQUs7UUFDZEMsS0FBSyxDQUFDQyxLQUFLLENBQUM7TUFDZCxDQUFDLENBQUM7SUFDUixDQUFDO0lBQ0RDLGNBQWMsMEJBQUNQLElBQUksRUFBRTtNQUFBO01BQ25CLElBQUksQ0FBQ1osT0FBTSxHQUFJLElBQUk7TUFFbkJNLEtBQUssQ0FBQyx3Q0FBd0MsRUFBRTtRQUMxQ0MsTUFBTSxFQUFFLE1BQU07UUFDZEMsT0FBTyxFQUFFO1VBQ1AsY0FBYyxFQUFFLGtCQUFrQjtVQUNsQyxRQUFRLEVBQUUsa0JBQWtCO1VBQzVCLDZCQUE2QixFQUFFO1FBQ2pDLENBQUM7UUFDREMsSUFBSSxFQUFFQyxJQUFJLENBQUNDLFNBQVMsQ0FBQztVQUNuQkMsSUFBSSxFQUFFQTtRQUNSLENBQUM7TUFDSCxDQUFDLEVBQ0FDLElBQUksQ0FBQyxrQkFBTyxFQUFLO1FBQ2hCLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSSxFQUFFO01BQ3hCLENBQUMsRUFDQUYsSUFBSSxDQUFDLGtCQUFPLEVBQUs7UUFDaEJwQixPQUFPLENBQUNDLEdBQUcsQ0FBQ29CLFFBQVEsQ0FBQztRQUNyQixNQUFJLENBQUNkLE9BQU0sR0FBSSxLQUFLO1FBQ3BCLE1BQUksQ0FBQ0UsSUFBRyxHQUFJLElBQUk7UUFDaEIsTUFBSSxDQUFDRCxPQUFNLEdBQUlhLFFBQVEsQ0FBQ2pCLElBQUk7TUFDOUIsQ0FBQyxVQUNLLENBQUMsZUFBSSxFQUFLO1FBQ2RvQixLQUFLLENBQUNDLEtBQUssQ0FBQztNQUNkLENBQUMsQ0FBQztJQUNSLENBQUM7SUFDREUsV0FBVyx5QkFBRTtNQUNYM0IsT0FBTyxDQUFDQyxHQUFHLENBQUMsSUFBSSxDQUFDTyxPQUFPLENBQUM7SUFDM0IsQ0FBQztJQUNEb0IsVUFBVSx3QkFBRztNQUNYLElBQUksQ0FBQ2pCLGFBQWEsQ0FBQyxJQUFJLENBQUNMLE1BQU0sQ0FBQztJQUNqQztFQUNGLENBQUM7RUFDRHVCLE9BQU8scUJBQUc7SUFFUixJQUFJLENBQUNsQixhQUFhLENBQUMsSUFBSSxDQUFDTCxNQUFNLENBQUM7RUFFakM7QUFFRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92dWUvSGFja2VyTmV3cy52dWU/NzdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJjYXJkXCI+XG4gICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImJveFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgcm91bmRlZFwiPlxuICAgICAgICAgIDxpbnB1dCB2LW1vZGVsPVwic2VhcmNoXCIgIHR5cGU9XCJzZWFyY2hcIiBjbGFzcz1cImZvcm0tY29udHJvbCByb3VuZGVkXCIgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIiBhcmlhLWxhYmVsPVwiU2VhcmNoXCIgYXJpYS1kZXNjcmliZWRieT1cInNlYXJjaC1hZGRvblwiIC8+XG4gICAgICAgICAgPHNwYW4gQGNsaWNrPVwic2VhcmNoTmV3c1wiIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dCBib3JkZXItMFwiIGlkPVwic2VhcmNoLWFkZG9uXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cImZhcyBmYS1zZWFyY2hcIj48L2k+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwiY2FyZFwiIHYtaWY9XCJzaG93XCI+XG4gICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiPlxuICAgICAgPGZvcm0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG4gICAgICAgICAgPGxhYmVsIGZvcj1cInRpdGxlXCI+RW1haWwgYWRkcmVzczwvbGFiZWw+XG4gICAgICAgICAgPGlucHV0IHYtbW9kZWw9XCJhcnRpY2xlLnRpdGxlXCIgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGlkPVwidGl0bGVcIiBhcmlhLWRlc2NyaWJlZGJ5PVwiZW1haWxIZWxwXCI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxuICAgICAgICAgIDxsYWJlbCBmb3I9XCJleGFtcGxlSW5wdXRQYXNzd29yZDFcIj5UZXh0PC9sYWJlbD5cbiAgICAgICAgICA8di1tZC1lZGl0b3Igdi1tb2RlbD1cImFydGljbGUubWFya2Rvd25cIiBoZWlnaHQ9XCI0MDBweFwiPjwvdi1tZC1lZGl0b3I+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uIEBjbGljaz1cInNhdmVBcnRpY2xlXCIgdHlwZT1cInN1Ym1pdFwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCI+U3VibWl0PC9idXR0b24+XG4gICAgICA8L2Zvcm0+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxkaXYgIHYtaWY9XCIhc2hvd1wiIGNsYXNzPVwiY2FyZFwiPlxuICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIiB2LWlmPVwibG9hZGluZ1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLWxnLTEyXCI+XG4gICAgICAgICAgPGgyIGNsYXNzPVwidGV4dC1jZW50ZXJcIj5cbiAgICAgICAgICAgIDxzdmcgd2lkdGg9XCI1N1wiIGhlaWdodD1cIjU3XCIgdmlld0JveD1cIjAgMCA1NyA1N1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBzdHJva2U9XCIjZGRkXCI+XG4gICAgICAgICAgICAgIDxnIGZpbGw9XCIjZGRkXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxIDEpXCIgc3Ryb2tlLXdpZHRoPVwiMlwiPlxuICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjeD1cIjVcIiBjeT1cIjUwXCIgcj1cIjVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cImN5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW49XCIwc1wiIGR1cj1cIjIuMnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM9XCI1MDs1OzUwOzUwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY01vZGU9XCJsaW5lYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVwiY3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbj1cIjBzXCIgZHVyPVwiMi4yc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcz1cIjU7Mjc7NDk7NVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNNb2RlPVwibGluZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCIgLz5cbiAgICAgICAgICAgICAgICAgIDwvY2lyY2xlPlxuICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjeD1cIjI3XCIgY3k9XCI1XCIgcj1cIjVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cImN5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW49XCIwc1wiIGR1cj1cIjIuMnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tPVwiNVwiIHRvPVwiNVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcz1cIjU7NTA7NTA7NVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNNb2RlPVwibGluZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cImN4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW49XCIwc1wiIGR1cj1cIjIuMnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tPVwiMjdcIiB0bz1cIjI3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiMjc7NDk7NTsyN1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNNb2RlPVwibGluZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCIgLz5cbiAgICAgICAgICAgICAgICAgIDwvY2lyY2xlPlxuICAgICAgICAgICAgICAgICAgPGNpcmNsZSBjeD1cIjQ5XCIgY3k9XCI1MFwiIHI9XCI1XCI+XG4gICAgICAgICAgICAgICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XCJjeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luPVwiMHNcIiBkdXI9XCIyLjJzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiNTA7NTA7NTs1MFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNNb2RlPVwibGluZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cImN4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbT1cIjQ5XCIgdG89XCI0OVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luPVwiMHNcIiBkdXI9XCIyLjJzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiNDk7NTsyNzs0OVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNNb2RlPVwibGluZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9XCJpbmRlZmluaXRlXCIgLz5cbiAgICAgICAgICAgICAgICAgIDwvY2lyY2xlPlxuICAgICAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPC9oMj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC10YWJsZSB0YWJsZS1yZXNwb25zaXZlXCIgdi1lbHNlPlxuICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGVcIj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICA8dHI+XG4gICAgICAgICAgPHRoPlxuICAgICAgICAgICAgSURcbiAgICAgICAgICA8L3RoPlxuICAgICAgICAgIDx0aD5UaXRsZTwvdGg+XG4gICAgICAgICAgPHRoPlB1Ymxpc2hlZDwvdGg+XG4gICAgICAgICAgPHRoIGNsYXNzPVwidGV4dC1yaWdodFwiPkFjdGlvbnM8L3RoPlxuICAgICAgICA8L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgIDx0ciB2LWZvcj1cIihhcnRpY2xlLCBpbmRleCkgaW4gbmV3c1wiIDprZXk9XCJpbmRleFwiPlxuICAgICAgICAgIDx0ZD57eyBpbmRleCB9fTwvdGQ+XG4gICAgICAgICAgPHRkPnt7IGFydGljbGUudGl0bGUgfX08L3RkPlxuICAgICAgICAgIDx0ZD57eyBhcnRpY2xlLnB1Ymxpc2hlZCB9fTwvdGQ+XG4gICAgICAgICAgPHRkIGNsYXNzPVwidGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgPGEgQGNsaWNrPVwiZXh0cmFjdEFydGljbGUoYXJ0aWNsZS5saW5rKVwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCI+RXh0cmFjdDwvYT5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICA8L3RyPlxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICAgXG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5jb25zb2xlLmxvZygnSGFja2VyTmV3cy52dWUgbG9hZGVkJyk7XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdIYWNrZXJOZXdzJyxcbiAgcHJvcHM6IFsna2V5d29yZCddLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXdzOiBbXSxcbiAgICAgIHNlYXJjaDogJ2xhcmF2ZWwnLFxuICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICBhcnRpY2xlOiB7fSxcbiAgICAgIHNob3c6IGZhbHNlXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZmV0Y2hBcnRpY2xlcyhrZXl3b3JkKSB7XG4gICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIGZldGNoKCdodHRwczovL2FwaS50b2RheWludGVsLmNvbS9mZWVkL3JlYWRlcicsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBsaW5rOiBcImh0dHBzOi8vaG5yc3Mub3JnL25ld2VzdD9xPVwiICsga2V5d29yZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmV3cyA9IHJlc3BvbnNlLmRhdGEucmVzcG9uc2UuZW50cmllcztcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBhbGVydChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBleHRyYWN0QXJ0aWNsZShsaW5rKSB7XG4gICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICBmZXRjaCgnaHR0cHM6Ly9hcGkudG9kYXlpbnRlbC5jb20vbmxwL2FydGljbGUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6ICcqJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgbGluazogbGluayxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hcnRpY2xlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBhbGVydChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBzYXZlQXJ0aWNsZSgpe1xuICAgICAgY29uc29sZS5sb2codGhpcy5hcnRpY2xlKTtcbiAgICB9LFxuICAgIHNlYXJjaE5ld3MoKSB7XG4gICAgICB0aGlzLmZldGNoQXJ0aWNsZXModGhpcy5zZWFyY2gpO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcblxuICAgIHRoaXMuZmV0Y2hBcnRpY2xlcyh0aGlzLnNlYXJjaCk7XG5cbiAgfVxuXG59XG48L3NjcmlwdD5cbjxzdHlsZSBsYW5nPVwic2Nzc1wiPlxuJGNvbG9yXzE6ICMxNEIxQjI7XG4kYmFja2dyb3VuZC1jb2xvcl8xOiB3aGl0ZTtcblxuLnNlbGVjdHBpY2tlciB7XG4gIG9wdGlvbiB7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcbiAgICBjb2xvcjogJGNvbG9yXzE7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgZm9udC1zaXplOiAzMHB4O1xuICAgIHBhZGRpbmctbGVmdDogMDtcbiAgICBtYXJnaW46IC0yMHB4IDAgMDtcbiAgICBiYWNrZ3JvdW5kOiAkYmFja2dyb3VuZC1jb2xvcl8xIG5vbmU7XG4gIH1cbn1cbnNlbGVjdC5zZWxlY3RwaWNrZXIge1xuICBib3JkZXI6IG5vbmU7XG4gIG91dGxpbmU6IG5vbmU7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xuICBjb2xvcjogJGNvbG9yXzE7XG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xuICBmb250LXNpemU6IDMwcHg7XG4gIHBhZGRpbmctbGVmdDogMDtcbiAgbWFyZ2luOiAtMjBweCAwIDA7XG4gIGJhY2tncm91bmQ6ICRiYWNrZ3JvdW5kLWNvbG9yXzEgbm9uZTtcbn1cblxuPC9zdHlsZT5cblxuXG5cblxuIl0sIm5hbWVzIjpbImNvbnNvbGUiLCJsb2ciLCJuYW1lIiwicHJvcHMiLCJkYXRhIiwibmV3cyIsInNlYXJjaCIsImxvYWRpbmciLCJhcnRpY2xlIiwic2hvdyIsIm1ldGhvZHMiLCJmZXRjaEFydGljbGVzIiwia2V5d29yZCIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwibGluayIsInRoZW4iLCJyZXNwb25zZSIsImpzb24iLCJlbnRyaWVzIiwiYWxlcnQiLCJlcnJvciIsImV4dHJhY3RBcnRpY2xlIiwic2F2ZUFydGljbGUiLCJzZWFyY2hOZXdzIiwibW91bnRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=template&id=3595117c":
/*!********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=template&id=3595117c ***!
  \********************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\");\n\nvar _hoisted_1 = {\n  \"class\": \"card\"\n};\nvar _hoisted_2 = {\n  \"class\": \"card-body\"\n};\nvar _hoisted_3 = {\n  \"class\": \"box\"\n};\nvar _hoisted_4 = {\n  \"class\": \"input-group rounded\"\n};\nvar _hoisted_5 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"i\", {\n  \"class\": \"fas fa-search\"\n}, null, -1 /* HOISTED */);\nvar _hoisted_6 = [_hoisted_5];\nvar _hoisted_7 = {\n  key: 0,\n  \"class\": \"card\"\n};\nvar _hoisted_8 = {\n  \"class\": \"card-body\"\n};\nvar _hoisted_9 = {\n  \"class\": \"form-group\"\n};\nvar _hoisted_10 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"label\", {\n  \"for\": \"title\"\n}, \"Email address\", -1 /* HOISTED */);\nvar _hoisted_11 = {\n  \"class\": \"form-group\"\n};\nvar _hoisted_12 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"label\", {\n  \"for\": \"exampleInputPassword1\"\n}, \"Text\", -1 /* HOISTED */);\nvar _hoisted_13 = {\n  key: 1,\n  \"class\": \"card\"\n};\nvar _hoisted_14 = {\n  key: 0,\n  \"class\": \"card-body\"\n};\nvar _hoisted_15 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode)(\"<div class=\\\"row\\\"><div class=\\\"col-lg-12\\\"><h2 class=\\\"text-center\\\"><svg width=\\\"57\\\" height=\\\"57\\\" viewBox=\\\"0 0 57 57\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" stroke=\\\"#ddd\\\"><g fill=\\\"#ddd\\\" fill-rule=\\\"evenodd\\\"><g transform=\\\"translate(1 1)\\\" stroke-width=\\\"2\\\"><circle cx=\\\"5\\\" cy=\\\"50\\\" r=\\\"5\\\"><animate attributeName=\\\"cy\\\" begin=\\\"0s\\\" dur=\\\"2.2s\\\" values=\\\"50;5;50;50\\\" calcMode=\\\"linear\\\" repeatCount=\\\"indefinite\\\"></animate><animate attributeName=\\\"cx\\\" begin=\\\"0s\\\" dur=\\\"2.2s\\\" values=\\\"5;27;49;5\\\" calcMode=\\\"linear\\\" repeatCount=\\\"indefinite\\\"></animate></circle><circle cx=\\\"27\\\" cy=\\\"5\\\" r=\\\"5\\\"><animate attributeName=\\\"cy\\\" begin=\\\"0s\\\" dur=\\\"2.2s\\\" from=\\\"5\\\" to=\\\"5\\\" values=\\\"5;50;50;5\\\" calcMode=\\\"linear\\\" repeatCount=\\\"indefinite\\\"></animate><animate attributeName=\\\"cx\\\" begin=\\\"0s\\\" dur=\\\"2.2s\\\" from=\\\"27\\\" to=\\\"27\\\" values=\\\"27;49;5;27\\\" calcMode=\\\"linear\\\" repeatCount=\\\"indefinite\\\"></animate></circle><circle cx=\\\"49\\\" cy=\\\"50\\\" r=\\\"5\\\"><animate attributeName=\\\"cy\\\" begin=\\\"0s\\\" dur=\\\"2.2s\\\" values=\\\"50;50;5;50\\\" calcMode=\\\"linear\\\" repeatCount=\\\"indefinite\\\"></animate><animate attributeName=\\\"cx\\\" from=\\\"49\\\" to=\\\"49\\\" begin=\\\"0s\\\" dur=\\\"2.2s\\\" values=\\\"49;5;27;49\\\" calcMode=\\\"linear\\\" repeatCount=\\\"indefinite\\\"></animate></circle></g></g></svg></h2></div></div>\", 1);\nvar _hoisted_16 = [_hoisted_15];\nvar _hoisted_17 = {\n  key: 1,\n  \"class\": \"card-table table-responsive\"\n};\nvar _hoisted_18 = {\n  \"class\": \"table\"\n};\nvar _hoisted_19 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"thead\", null, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"tr\", null, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \" ID \"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"Title\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", null, \"Published\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"th\", {\n  \"class\": \"text-right\"\n}, \"Actions\")])], -1 /* HOISTED */);\nvar _hoisted_20 = {\n  \"class\": \"text-right\"\n};\nvar _hoisted_21 = [\"onClick\"];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_v_md_editor = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)(\"v-md-editor\");\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_2, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_3, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    \"onUpdate:modelValue\": _cache[0] || (_cache[0] = function ($event) {\n      return $data.search = $event;\n    }),\n    type: \"search\",\n    \"class\": \"form-control rounded\",\n    placeholder: \"Search\",\n    \"aria-label\": \"Search\",\n    \"aria-describedby\": \"search-addon\"\n  }, null, 512 /* NEED_PATCH */), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.search]]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"span\", {\n    onClick: _cache[1] || (_cache[1] = function () {\n      return $options.searchNews && $options.searchNews.apply($options, arguments);\n    }),\n    \"class\": \"input-group-text border-0\",\n    id: \"search-addon\"\n  }, _hoisted_6)])])])]), $data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_7, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_8, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"form\", null, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_9, [_hoisted_10, (0,vue__WEBPACK_IMPORTED_MODULE_0__.withDirectives)((0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"input\", {\n    \"onUpdate:modelValue\": _cache[2] || (_cache[2] = function ($event) {\n      return $data.article.title = $event;\n    }),\n    type: \"text\",\n    \"class\": \"form-control\",\n    id: \"title\",\n    \"aria-describedby\": \"emailHelp\"\n  }, null, 512 /* NEED_PATCH */), [[vue__WEBPACK_IMPORTED_MODULE_0__.vModelText, $data.article.title]])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"div\", _hoisted_11, [_hoisted_12, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_v_md_editor, {\n    modelValue: $data.article.markdown,\n    \"onUpdate:modelValue\": _cache[3] || (_cache[3] = function ($event) {\n      return $data.article.markdown = $event;\n    }),\n    height: \"400px\"\n  }, null, 8 /* PROPS */, [\"modelValue\"])]), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"button\", {\n    onClick: _cache[4] || (_cache[4] = function () {\n      return $options.saveArticle && $options.saveArticle.apply($options, arguments);\n    }),\n    type: \"submit\",\n    \"class\": \"btn btn-primary\"\n  }, \"Submit\")])])])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true), !$data.show ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_13, [$data.loading ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_14, _hoisted_16)) : ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"div\", _hoisted_17, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"table\", _hoisted_18, [_hoisted_19, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"tbody\", null, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)($data.news, function (article, index) {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)(\"tr\", {\n      key: index\n    }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"td\", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(index), 1 /* TEXT */), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"td\", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(article.title), 1 /* TEXT */), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"td\", null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(article.published), 1 /* TEXT */), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"td\", _hoisted_20, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)(\"a\", {\n      onClick: function onClick($event) {\n        return $options.extractArticle(article.link);\n      },\n      \"class\": \"btn btn-primary\"\n    }, \"Extract\", 8 /* PROPS */, _hoisted_21)])]);\n  }), 128 /* KEYED_FRAGMENT */))])])]))])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)(\"v-if\", true)], 64 /* STABLE_FRAGMENT */);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvdGVtcGxhdGVMb2FkZXIuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL3Jlc291cmNlcy9hc3NldHMvanMvdnVlL0hhY2tlck5ld3MudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM1OTUxMTdjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7RUFDTyxTQUFNO0FBQU07O0VBQ1YsU0FBTTtBQUFXOztFQUNmLFNBQU07QUFBSzs7RUFDVCxTQUFNO0FBQXFCOzhCQUc1QkEsdURBQUFBLENBQTZCO0VBQTFCLFNBQU07QUFBZTtrQkFBeEJDLFVBQTZCOzs7RUFPbEMsU0FBTTs7O0VBQ0osU0FBTTtBQUFXOztFQUViLFNBQU07QUFBWTsrQkFDckJELHVEQUFBQSxDQUF3QztFQUFqQyxPQUFJO0FBQU8sR0FBQyxlQUFhOztFQUc3QixTQUFNO0FBQVk7K0JBQ3JCQSx1REFBQUEsQ0FBK0M7RUFBeEMsT0FBSTtBQUF1QixHQUFDLE1BQUk7OztFQVE1QixTQUFNOzs7O0VBQ2xCLFNBQU07OzttQkFDVEUsV0FrRE07OztFQUVILFNBQU07OztFQUNGLFNBQU07QUFBTzsrQkFDbEJGLHVEQUFBQSxDQVNRLDZCQVJSQSx1REFBQUEsQ0FPSywwQkFOSEEsdURBQUFBLENBRUssWUFGRCxNQUVKLGdCQUNBQSx1REFBQUEsQ0FBYyxZQUFWLE9BQUssZ0JBQ1RBLHVEQUFBQSxDQUFrQixZQUFkLFdBQVMsZ0JBQ2JBLHVEQUFBQSxDQUFtQztFQUEvQixTQUFNO0FBQVksR0FBQyxTQUFPOztFQVExQixTQUFNO0FBQVk7Ozs7cUtBcEc5QkEsdURBQUFBLENBV00sT0FYTkcsVUFXTSxHQVZKSCx1REFBQUEsQ0FTTSxPQVROSSxVQVNNLEdBUkpKLHVEQUFBQSxDQU9NLE9BUE5LLFVBT00sR0FOSkwsdURBQUFBLENBS00sT0FMTk0sVUFLTSx1REFKSk4sdURBQUFBLENBQStJOzthQUEvSE8sWUFBTTtJQUFBO0lBQUdDLElBQUksRUFBQyxRQUFRO0lBQUMsU0FBTSxzQkFBc0I7SUFBQ0MsV0FBVyxFQUFDLFFBQVE7SUFBQyxZQUFVLEVBQUMsUUFBUTtJQUFDLGtCQUFnQixFQUFDO2lGQUE5R0YsWUFBTSxLQUN0QlAsdURBQUFBLENBRU87SUFGQVUsT0FBSztNQUFBLE9BQUVDLHFFQUFVO0lBQUE7SUFBRSxTQUFNLDJCQUEyQjtJQUFDQyxFQUFFLEVBQUM7MEJBUS9DTCxVQUFJLHNEQUE1Qk0sdURBQUFBLENBY00sT0FkTkMsVUFjTSxHQWJKZCx1REFBQUEsQ0FZTSxPQVpOZSxVQVlNLEdBWEpmLHVEQUFBQSxDQVVPLGVBVExBLHVEQUFBQSxDQUdNLE9BSE5nQixVQUdNLEdBRkpDLFdBQXdDLHNEQUN4Q2pCLHVEQUFBQSxDQUF3Rzs7YUFBeEZPLGFBQU8sQ0FBQ1csS0FBSztJQUFBO0lBQUVWLElBQUksRUFBQyxNQUFNO0lBQUMsU0FBTSxjQUFjO0lBQUNJLEVBQUUsRUFBQyxPQUFPO0lBQUMsa0JBQWdCLEVBQUM7aUZBQTVFTCxhQUFPLENBQUNXLEtBQUssT0FFL0JsQix1REFBQUEsQ0FHTSxPQUhObUIsV0FHTSxHQUZKQyxXQUErQyxFQUMvQ0MsZ0RBQUFBLENBQXFFQztnQkFBL0NmLGFBQU8sQ0FBQ2dCLFFBQVE7O2FBQWhCaEIsYUFBTyxDQUFDZ0IsUUFBUTtJQUFBO0lBQUVDLE1BQU0sRUFBQzs2Q0FFakR4Qix1REFBQUEsQ0FBa0Y7SUFBekVVLE9BQUs7TUFBQSxPQUFFQyx1RUFBVztJQUFBO0lBQUVILElBQUksRUFBQyxRQUFRO0lBQUMsU0FBTTtLQUFrQixRQUFNLG1GQUtsRUQsVUFBSSxzREFBakJNLHVEQUFBQSxDQStFTSxPQS9FTlksV0ErRU0sR0E5RXlCbEIsYUFBTyxzREFBcENNLHVEQUFBQSxDQW9ETSxPQXBETmEsV0FvRE0scUVBQ05iLHVEQUFBQSxDQXdCTSxPQXhCTmMsV0F3Qk0sR0F2QkozQix1REFBQUEsQ0FxQlEsU0FyQlI0QixXQXFCUSxHQXBCTkMsV0FTUSxFQUNSN0IsdURBQUFBLENBU1EsdUVBUlJhLHVEQUFBQSxDQU9LaUIseUNBQUFBLFFBQUFBLCtDQUFBQSxDQVAwQnZCLFVBQUksWUFBdkJ3QixPQUFPLEVBQUVDLEtBQUs7NkRBQTFCbkIsdURBQUFBLENBT0s7TUFQaUNvQixHQUFHLEVBQUVEO0lBQUssSUFDOUNoQyx1REFBQUEsQ0FBb0IsaUVBQWJnQyxLQUFLLGtCQUNaaEMsdURBQUFBLENBQTRCLGlFQUFyQitCLE9BQU8sQ0FBQ2IsS0FBSyxrQkFDcEJsQix1REFBQUEsQ0FBZ0MsaUVBQXpCK0IsT0FBTyxDQUFDRyxTQUFTLGtCQUN4QmxDLHVEQUFBQSxDQUVLLE1BRkxtQyxXQUVLLEdBREhuQyx1REFBQUEsQ0FBNEU7TUFBeEVVLE9BQUs7UUFBQSxPQUFFQyx1QkFBYyxDQUFDb0IsT0FBTyxDQUFDSyxJQUFJO01BQUE7TUFBRyxTQUFNO09BQWtCLFNBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3Z1ZS9IYWNrZXJOZXdzLnZ1ZT83N2IyIl0sInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYm94XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCByb3VuZGVkXCI+XG4gICAgICAgICAgPGlucHV0IHYtbW9kZWw9XCJzZWFyY2hcIiAgdHlwZT1cInNlYXJjaFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIHJvdW5kZWRcIiBwbGFjZWhvbGRlcj1cIlNlYXJjaFwiIGFyaWEtbGFiZWw9XCJTZWFyY2hcIiBhcmlhLWRlc2NyaWJlZGJ5PVwic2VhcmNoLWFkZG9uXCIgLz5cbiAgICAgICAgICA8c3BhbiBAY2xpY2s9XCJzZWFyY2hOZXdzXCIgY2xhc3M9XCJpbnB1dC1ncm91cC10ZXh0IGJvcmRlci0wXCIgaWQ9XCJzZWFyY2gtYWRkb25cIj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLXNlYXJjaFwiPjwvaT5cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJjYXJkXCIgdi1pZj1cInNob3dcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICA8Zm9ybT5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cbiAgICAgICAgICA8bGFiZWwgZm9yPVwidGl0bGVcIj5FbWFpbCBhZGRyZXNzPC9sYWJlbD5cbiAgICAgICAgICA8aW5wdXQgdi1tb2RlbD1cImFydGljbGUudGl0bGVcIiB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgaWQ9XCJ0aXRsZVwiIGFyaWEtZGVzY3JpYmVkYnk9XCJlbWFpbEhlbHBcIj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+XG4gICAgICAgICAgPGxhYmVsIGZvcj1cImV4YW1wbGVJbnB1dFBhc3N3b3JkMVwiPlRleHQ8L2xhYmVsPlxuICAgICAgICAgIDx2LW1kLWVkaXRvciB2LW1vZGVsPVwiYXJ0aWNsZS5tYXJrZG93blwiIGhlaWdodD1cIjQwMHB4XCI+PC92LW1kLWVkaXRvcj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b24gQGNsaWNrPVwic2F2ZUFydGljbGVcIiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIj5TdWJtaXQ8L2J1dHRvbj5cbiAgICAgIDwvZm9ybT5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPGRpdiAgdi1pZj1cIiFzaG93XCIgY2xhc3M9XCJjYXJkXCI+XG4gICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keVwiIHYtaWY9XCJsb2FkaW5nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbGctMTJcIj5cbiAgICAgICAgICA8aDIgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgPHN2ZyB3aWR0aD1cIjU3XCIgaGVpZ2h0PVwiNTdcIiB2aWV3Qm94PVwiMCAwIDU3IDU3XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHN0cm9rZT1cIiNkZGRcIj5cbiAgICAgICAgICAgICAgPGcgZmlsbD1cIiNkZGRcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEgMSlcIiBzdHJva2Utd2lkdGg9XCIyXCI+XG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlIGN4PVwiNVwiIGN5PVwiNTBcIiByPVwiNVwiPlxuICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVwiY3lcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbj1cIjBzXCIgZHVyPVwiMi4yc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcz1cIjUwOzU7NTA7NTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjTW9kZT1cImxpbmVhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdENvdW50PVwiaW5kZWZpbml0ZVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9XCJjeFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luPVwiMHNcIiBkdXI9XCIyLjJzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiNTsyNzs0OTs1XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY01vZGU9XCJsaW5lYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIiAvPlxuICAgICAgICAgICAgICAgICAgPC9jaXJjbGU+XG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlIGN4PVwiMjdcIiBjeT1cIjVcIiByPVwiNVwiPlxuICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVwiY3lcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbj1cIjBzXCIgZHVyPVwiMi4yc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb209XCI1XCIgdG89XCI1XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzPVwiNTs1MDs1MDs1XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY01vZGU9XCJsaW5lYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVwiY3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbj1cIjBzXCIgZHVyPVwiMi4yc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb209XCIyN1wiIHRvPVwiMjdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM9XCIyNzs0OTs1OzI3XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY01vZGU9XCJsaW5lYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIiAvPlxuICAgICAgICAgICAgICAgICAgPC9jaXJjbGU+XG4gICAgICAgICAgICAgICAgICA8Y2lyY2xlIGN4PVwiNDlcIiBjeT1cIjUwXCIgcj1cIjVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT1cImN5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW49XCIwc1wiIGR1cj1cIjIuMnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM9XCI1MDs1MDs1OzUwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY01vZGU9XCJsaW5lYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPVwiY3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tPVwiNDlcIiB0bz1cIjQ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW49XCIwc1wiIGR1cj1cIjIuMnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM9XCI0OTs1OzI3OzQ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY01vZGU9XCJsaW5lYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD1cImluZGVmaW5pdGVcIiAvPlxuICAgICAgICAgICAgICAgICAgPC9jaXJjbGU+XG4gICAgICAgICAgICAgICAgPC9nPlxuICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8L2gyPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjYXJkLXRhYmxlIHRhYmxlLXJlc3BvbnNpdmVcIiB2LWVsc2U+XG4gICAgICA8dGFibGUgY2xhc3M9XCJ0YWJsZVwiPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgIDx0cj5cbiAgICAgICAgICA8dGg+XG4gICAgICAgICAgICBJRFxuICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgPHRoPlRpdGxlPC90aD5cbiAgICAgICAgICA8dGg+UHVibGlzaGVkPC90aD5cbiAgICAgICAgICA8dGggY2xhc3M9XCJ0ZXh0LXJpZ2h0XCI+QWN0aW9uczwvdGg+XG4gICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgPHRyIHYtZm9yPVwiKGFydGljbGUsIGluZGV4KSBpbiBuZXdzXCIgOmtleT1cImluZGV4XCI+XG4gICAgICAgICAgPHRkPnt7IGluZGV4IH19PC90ZD5cbiAgICAgICAgICA8dGQ+e3sgYXJ0aWNsZS50aXRsZSB9fTwvdGQ+XG4gICAgICAgICAgPHRkPnt7IGFydGljbGUucHVibGlzaGVkIH19PC90ZD5cbiAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZXh0LXJpZ2h0XCI+XG4gICAgICAgICAgICA8YSBAY2xpY2s9XCJleHRyYWN0QXJ0aWNsZShhcnRpY2xlLmxpbmspXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIj5FeHRyYWN0PC9hPlxuICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgICBcbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmNvbnNvbGUubG9nKCdIYWNrZXJOZXdzLnZ1ZSBsb2FkZWQnKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ0hhY2tlck5ld3MnLFxuICBwcm9wczogWydrZXl3b3JkJ10sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5ld3M6IFtdLFxuICAgICAgc2VhcmNoOiAnbGFyYXZlbCcsXG4gICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgIGFydGljbGU6IHt9LFxuICAgICAgc2hvdzogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBmZXRjaEFydGljbGVzKGtleXdvcmQpIHtcbiAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vYXBpLnRvZGF5aW50ZWwuY29tL2ZlZWQvcmVhZGVyJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nOiAnKidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIGxpbms6IFwiaHR0cHM6Ly9obnJzcy5vcmcvbmV3ZXN0P3E9XCIgKyBrZXl3b3JkLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5uZXdzID0gcmVzcG9uc2UuZGF0YS5yZXNwb25zZS5lbnRyaWVzO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGFsZXJ0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGV4dHJhY3RBcnRpY2xlKGxpbmspIHtcbiAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgIGZldGNoKCdodHRwczovL2FwaS50b2RheWludGVsLmNvbS9ubHAvYXJ0aWNsZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBsaW5rOiBsaW5rLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFydGljbGUgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGFsZXJ0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIHNhdmVBcnRpY2xlKCl7XG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmFydGljbGUpO1xuICAgIH0sXG4gICAgc2VhcmNoTmV3cygpIHtcbiAgICAgIHRoaXMuZmV0Y2hBcnRpY2xlcyh0aGlzLnNlYXJjaCk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuXG4gICAgdGhpcy5mZXRjaEFydGljbGVzKHRoaXMuc2VhcmNoKTtcblxuICB9XG5cbn1cbjwvc2NyaXB0PlxuPHN0eWxlIGxhbmc9XCJzY3NzXCI+XG4kY29sb3JfMTogIzE0QjFCMjtcbiRiYWNrZ3JvdW5kLWNvbG9yXzE6IHdoaXRlO1xuXG4uc2VsZWN0cGlja2VyIHtcbiAgb3B0aW9uIHtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xuICAgIGNvbG9yOiAkY29sb3JfMTtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBmb250LXNpemU6IDMwcHg7XG4gICAgcGFkZGluZy1sZWZ0OiAwO1xuICAgIG1hcmdpbjogLTIwcHggMCAwO1xuICAgIGJhY2tncm91bmQ6ICRiYWNrZ3JvdW5kLWNvbG9yXzEgbm9uZTtcbiAgfVxufVxuc2VsZWN0LnNlbGVjdHBpY2tlciB7XG4gIGJvcmRlcjogbm9uZTtcbiAgb3V0bGluZTogbm9uZTtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XG4gIGNvbG9yOiAkY29sb3JfMTtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gIGZvbnQtc2l6ZTogMzBweDtcbiAgcGFkZGluZy1sZWZ0OiAwO1xuICBtYXJnaW46IC0yMHB4IDAgMDtcbiAgYmFja2dyb3VuZDogJGJhY2tncm91bmQtY29sb3JfMSBub25lO1xufVxuXG48L3N0eWxlPlxuXG5cblxuXG4iXSwibmFtZXMiOlsiX2NyZWF0ZUVsZW1lbnRWTm9kZSIsIl9ob2lzdGVkXzUiLCJfaG9pc3RlZF8xNSIsIl9ob2lzdGVkXzEiLCJfaG9pc3RlZF8yIiwiX2hvaXN0ZWRfMyIsIl9ob2lzdGVkXzQiLCIkZGF0YSIsInR5cGUiLCJwbGFjZWhvbGRlciIsIm9uQ2xpY2siLCIkb3B0aW9ucyIsImlkIiwiX2NyZWF0ZUVsZW1lbnRCbG9jayIsIl9ob2lzdGVkXzciLCJfaG9pc3RlZF84IiwiX2hvaXN0ZWRfOSIsIl9ob2lzdGVkXzEwIiwidGl0bGUiLCJfaG9pc3RlZF8xMSIsIl9ob2lzdGVkXzEyIiwiX2NyZWF0ZVZOb2RlIiwiX2NvbXBvbmVudF92X21kX2VkaXRvciIsIm1hcmtkb3duIiwiaGVpZ2h0IiwiX2hvaXN0ZWRfMTMiLCJfaG9pc3RlZF8xNCIsIl9ob2lzdGVkXzE3IiwiX2hvaXN0ZWRfMTgiLCJfaG9pc3RlZF8xOSIsIl9GcmFnbWVudCIsImFydGljbGUiLCJpbmRleCIsImtleSIsInB1Ymxpc2hlZCIsIl9ob2lzdGVkXzIwIiwibGluayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=template&id=3595117c\n");

/***/ }),

/***/ "./resources/assets/js/hacker-news.js":
/*!********************************************!*\
  !*** ./resources/assets/js/hacker-news.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\");\n/* harmony import */ var _vue_HackerNews_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vue/HackerNews.vue */ \"./resources/assets/js/vue/HackerNews.vue\");\n/* harmony import */ var _kangc_v_md_editor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @kangc/v-md-editor */ \"./node_modules/@kangc/v-md-editor/lib/base-editor.js\");\n/* harmony import */ var _kangc_v_md_editor__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_kangc_v_md_editor__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _kangc_v_md_editor_lib_style_base_editor_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @kangc/v-md-editor/lib/style/base-editor.css */ \"./node_modules/@kangc/v-md-editor/lib/style/base-editor.css\");\n/* harmony import */ var _kangc_v_md_editor_lib_theme_vuepress_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @kangc/v-md-editor/lib/theme/vuepress.js */ \"./node_modules/@kangc/v-md-editor/lib/theme/vuepress.js\");\n/* harmony import */ var _kangc_v_md_editor_lib_theme_vuepress_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_kangc_v_md_editor_lib_theme_vuepress_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _kangc_v_md_editor_lib_theme_style_vuepress_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @kangc/v-md-editor/lib/theme/style/vuepress.css */ \"./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css\");\n\n\n\n\n\n\n_kangc_v_md_editor__WEBPACK_IMPORTED_MODULE_2___default().use((_kangc_v_md_editor_lib_theme_vuepress_js__WEBPACK_IMPORTED_MODULE_4___default()));\nvar app = (0,vue__WEBPACK_IMPORTED_MODULE_0__.createApp)(_vue_HackerNews_vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]).use((_kangc_v_md_editor__WEBPACK_IMPORTED_MODULE_2___default()));\napp.mount('#hacker-news');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2hhY2tlci1uZXdzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUM4QjtBQUVnQjtBQUVLO0FBQ0c7QUFDZTtBQUNaO0FBR3pERSw2REFBcUIsQ0FBQ0MsaUZBQWEsQ0FBQztBQUdwQyxJQUFNRSxHQUFHLEdBQUdMLDhDQUFTLENBQUNDLDJEQUFVLENBQUMsQ0FBQ0csR0FBRyxDQUFDRiwyREFBaUIsQ0FBQztBQUV4REcsR0FBRyxDQUFDQyxLQUFLLENBQUMsY0FBYyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9oYWNrZXItbmV3cy5qcz83MWFiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHtjcmVhdGVBcHB9IGZyb20gJ3Z1ZSc7XG5cbmltcG9ydCBIYWNrZXJOZXdzIGZyb20gJy4vdnVlL0hhY2tlck5ld3MudnVlJztcblxuaW1wb3J0IFZ1ZU1hcmtkb3duRWRpdG9yIGZyb20gJ0BrYW5nYy92LW1kLWVkaXRvcic7XG5pbXBvcnQgJ0BrYW5nYy92LW1kLWVkaXRvci9saWIvc3R5bGUvYmFzZS1lZGl0b3IuY3NzJztcbmltcG9ydCB2dWVwcmVzc1RoZW1lIGZyb20gJ0BrYW5nYy92LW1kLWVkaXRvci9saWIvdGhlbWUvdnVlcHJlc3MuanMnO1xuaW1wb3J0ICdAa2FuZ2Mvdi1tZC1lZGl0b3IvbGliL3RoZW1lL3N0eWxlL3Z1ZXByZXNzLmNzcyc7XG5cblxuVnVlTWFya2Rvd25FZGl0b3IudXNlKHZ1ZXByZXNzVGhlbWUpO1xuXG5cbmNvbnN0IGFwcCA9IGNyZWF0ZUFwcChIYWNrZXJOZXdzKS51c2UoVnVlTWFya2Rvd25FZGl0b3IpO1xuXG5hcHAubW91bnQoJyNoYWNrZXItbmV3cycpO1xuIl0sIm5hbWVzIjpbImNyZWF0ZUFwcCIsIkhhY2tlck5ld3MiLCJWdWVNYXJrZG93bkVkaXRvciIsInZ1ZXByZXNzVGhlbWUiLCJ1c2UiLCJhcHAiLCJtb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/assets/js/hacker-news.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".selectpicker option {\\n  border: none;\\n  outline: none;\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n  color: #14B1B2;\\n  font-weight: bold;\\n  font-size: 30px;\\n  padding-left: 0;\\n  margin: -20px 0 0;\\n  background: white none;\\n}\\nselect.selectpicker {\\n  border: none;\\n  outline: none;\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n  color: #14B1B2;\\n  font-weight: bold;\\n  font-size: 30px;\\n  padding-left: 0;\\n  margin: -20px 0 0;\\n  background: white none;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./resources/assets/js/vue/HackerNews.vue\"],\"names\":[],\"mappings\":\"AAKE;EACE,YAAA;EACA,aAAA;EACA,wBAAA;EACA,qBAAA;EACA,cATM;EAUN,iBAAA;EACA,eAAA;EACA,eAAA;EACA,iBAAA;EACA,sBAAA;AAJJ;AAOA;EACE,YAAA;EACA,aAAA;EACA,wBAAA;EACA,qBAAA;EACA,cAtBQ;EAuBR,iBAAA;EACA,eAAA;EACA,eAAA;EACA,iBAAA;EACA,sBAAA;AAJF\",\"sourcesContent\":[\"\\n$color_1: #14B1B2;\\n$background-color_1: white;\\n\\n.selectpicker {\\n  option {\\n    border: none;\\n    outline: none;\\n    -webkit-appearance: none;\\n    -moz-appearance: none;\\n    color: $color_1;\\n    font-weight: bold;\\n    font-size: 30px;\\n    padding-left: 0;\\n    margin: -20px 0 0;\\n    background: $background-color_1 none;\\n  }\\n}\\nselect.selectpicker {\\n  border: none;\\n  outline: none;\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n  color: $color_1;\\n  font-weight: bold;\\n  font-size: 30px;\\n  padding-left: 0;\\n  margin: -20px 0 0;\\n  background: $background-color_1 none;\\n}\\n\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xMi51c2VbMV0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xMi51c2VbMl0hLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzNdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3Z1ZS9IYWNrZXJOZXdzLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTM1OTUxMTdjJmxhbmc9c2Nzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQytIO0FBQzdCO0FBQ2xHLDhCQUE4QixtRkFBMkIsQ0FBQyx3R0FBcUM7QUFDL0Y7QUFDQSxnRUFBZ0UsaUJBQWlCLGtCQUFrQiw2QkFBNkIsMEJBQTBCLG1CQUFtQixzQkFBc0Isb0JBQW9CLG9CQUFvQixzQkFBc0IsMkJBQTJCLEdBQUcsdUJBQXVCLGlCQUFpQixrQkFBa0IsNkJBQTZCLDBCQUEwQixtQkFBbUIsc0JBQXNCLG9CQUFvQixvQkFBb0Isc0JBQXNCLDJCQUEyQixHQUFHLE9BQU8seUdBQXlHLFVBQVUsVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxZQUFZLFVBQVUsVUFBVSxXQUFXLFdBQVcsNkNBQTZDLDZCQUE2QixtQkFBbUIsWUFBWSxtQkFBbUIsb0JBQW9CLCtCQUErQiw0QkFBNEIsc0JBQXNCLHdCQUF3QixzQkFBc0Isc0JBQXNCLHdCQUF3QiwyQ0FBMkMsS0FBSyxHQUFHLHVCQUF1QixpQkFBaUIsa0JBQWtCLDZCQUE2QiwwQkFBMEIsb0JBQW9CLHNCQUFzQixvQkFBb0Isb0JBQW9CLHNCQUFzQix5Q0FBeUMsR0FBRyx1QkFBdUI7QUFDLytDO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3Z1ZS9IYWNrZXJOZXdzLnZ1ZT84OTU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLnNlbGVjdHBpY2tlciBvcHRpb24ge1xcbiAgYm9yZGVyOiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gIGNvbG9yOiAjMTRCMUIyO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXNpemU6IDMwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxuICBtYXJnaW46IC0yMHB4IDAgMDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlIG5vbmU7XFxufVxcbnNlbGVjdC5zZWxlY3RwaWNrZXIge1xcbiAgYm9yZGVyOiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gIGNvbG9yOiAjMTRCMUIyO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXNpemU6IDMwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxuICBtYXJnaW46IC0yMHB4IDAgMDtcXG4gIGJhY2tncm91bmQ6IHdoaXRlIG5vbmU7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3Jlc291cmNlcy9hc3NldHMvanMvdnVlL0hhY2tlck5ld3MudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUtFO0VBQ0UsWUFBQTtFQUNBLGFBQUE7RUFDQSx3QkFBQTtFQUNBLHFCQUFBO0VBQ0EsY0FUTTtFQVVOLGlCQUFBO0VBQ0EsZUFBQTtFQUNBLGVBQUE7RUFDQSxpQkFBQTtFQUNBLHNCQUFBO0FBSko7QUFPQTtFQUNFLFlBQUE7RUFDQSxhQUFBO0VBQ0Esd0JBQUE7RUFDQSxxQkFBQTtFQUNBLGNBdEJRO0VBdUJSLGlCQUFBO0VBQ0EsZUFBQTtFQUNBLGVBQUE7RUFDQSxpQkFBQTtFQUNBLHNCQUFBO0FBSkZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiXFxuJGNvbG9yXzE6ICMxNEIxQjI7XFxuJGJhY2tncm91bmQtY29sb3JfMTogd2hpdGU7XFxuXFxuLnNlbGVjdHBpY2tlciB7XFxuICBvcHRpb24ge1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgICBjb2xvcjogJGNvbG9yXzE7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmb250LXNpemU6IDMwcHg7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgbWFyZ2luOiAtMjBweCAwIDA7XFxuICAgIGJhY2tncm91bmQ6ICRiYWNrZ3JvdW5kLWNvbG9yXzEgbm9uZTtcXG4gIH1cXG59XFxuc2VsZWN0LnNlbGVjdHBpY2tlciB7XFxuICBib3JkZXI6IG5vbmU7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgY29sb3I6ICRjb2xvcl8xO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXNpemU6IDMwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDA7XFxuICBtYXJnaW46IC0yMHB4IDAgMDtcXG4gIGJhY2tncm91bmQ6ICRiYWNrZ3JvdW5kLWNvbG9yXzEgbm9uZTtcXG59XFxuXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/@kangc/v-md-editor/lib/style/base-editor.css":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/@kangc/v-md-editor/lib/style/base-editor.css ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".v-md-textarea-editor{position:relative}.v-md-textarea-editor pre{margin:0;white-space:pre-wrap;visibility:hidden}.v-md-textarea-editor pre,.v-md-textarea-editor textarea{box-sizing:border-box;padding:20px 20px 30px;overflow:hidden;color:#2c3e50;font-size:14px;font-family:menlo,Ubuntu Mono,consolas,Courier New,Microsoft Yahei,Hiragino Sans GB,WenQuanYi Micro Hei,sans-serif;line-height:1.5;word-break:break-all}.v-md-textarea-editor textarea{position:absolute;top:0;left:0;width:100%;height:100%;border:none;outline:none;resize:none}.v-md-textarea-editor textarea::-webkit-input-placeholder{color:#c0c4cc}.v-md-textarea-editor textarea::placeholder{color:#c0c4cc}.v-md-zoom-in-top-enter-active,.v-md-zoom-in-top-leave-active{-webkit-transform:scaleY(1);transform:scaleY(1);opacity:1;-webkit-transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1)}.v-md-zoom-in-top-enter-from,.v-md-zoom-in-top-leave-active{-webkit-transform:scaleY(0);transform:scaleY(0);opacity:0}.v-md-fade-in-enter-active,.v-md-fade-in-leave-active{-webkit-transition:opacity .3s cubic-bezier(.55,0,.1,1);transition:opacity .3s cubic-bezier(.55,0,.1,1)}.v-md-fade-in-enter-from,.v-md-fade-in-leave-active{opacity:0}@font-face{font-family:v-md-iconfont;src:url(data:application/vnd.ms-fontobject;base64,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AT4BLwE3NicBBjIEBAa0BAYBFQEJBTGXBgYwBQX2BgaXMQUJARUBBgS0BgQEMpcFBQETAQkFMZcGBjAFBZcyBAQGtAQGAf3iBgaXMQUJARUBBgS0BgQEMpcFBQK2MQUJARUBBgS0BgQEMpcFBTAGBjwFBZcyBAQGtAQGARUBCQUxlwYG/p8GBAQylwUFMAYGlzEFCQEVAQYEAR8FBZcyBAQGtAQGARUBCQUxlwYGAAAAAAASAN4AAQAAAAAAAAAVAAAAAQAAAAAAAQALABUAAQAAAAAAAgAHACAAAQAAAAAAAwALACcAAQAAAAAABAALADIAAQAAAAAABQALAD0AAQAAAAAABgALAEgAAQAAAAAACgArAFMAAQAAAAAACwATAH4AAwABBAkAAAAqAJEAAwABBAkAAQAWALsAAwABBAkAAgAOANEAAwABBAkAAwAWAN8AAwABBAkABAAWAPUAAwABBAkABQAWAQsAAwABBAkABgAWASEAAwABBAkACgBWATcAAwABBAkACwAmAY0KQ3JlYXRlZCBieSBpY29uZm9udAp2LW1kLWVkaXRvclJlZ3VsYXJ2LW1kLWVkaXRvcnYtbWQtZWRpdG9yVmVyc2lvbiAxLjB2LW1kLWVkaXRvckdlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAAoAQwByAGUAYQB0AGUAZAAgAGIAeQAgAGkAYwBvAG4AZgBvAG4AdAAKAHYALQBtAGQALQBlAGQAaQB0AG8AcgBSAGUAZwB1AGwAYQByAHYALQBtAGQALQBlAGQAaQB0AG8AcgB2AC0AbQBkAC0AZQBkAGkAdABvAHIAVgBlAHIAcwBpAG8AbgAgADEALgAwAHYALQBtAGQALQBlAGQAaQB0AG8AcgBHAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAHMAdgBnADIAdAB0AGYAIABmAHIAbwBtACAARgBvAG4AdABlAGwAbABvACAAcAByAG8AagBlAGMAdAAuAGgAdAB0AHAAOgAvAC8AZgBvAG4AdABlAGwAbABvAC4AYwBvAG0AAAAAAgAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfAAdwcmV2aWV3DXJlZnJlc2gtcmlnaHQMcmVmcmVzaC1sZWZ0B3pvb20taW4Iem9vbS1vdXQDdG9jBHN5bmMFZW1vamkIY2hlY2tib3gFY2xlYXIDdGlwBHNhdmUEbGluawNpbWcEY29kZQJ1bAJvbARyZWRvBHVuZG8FcXVvdGUEYm9sZA1zdHJpa2V0aHJvdWdoCmFycm93LWRvd24Lb3Blbi1pbi1uZXcKdW5kZXItbGluZQZpdGFsaWMKaG9yaXpvbnRhbAV0YWJsZQpmdWxsc2NyZWVuAAA=);src:url(data:application/vnd.ms-fontobject;base64,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AT4BLwE3NicBBjIEBAa0BAYBFQEJBTGXBgYwBQX2BgaXMQUJARUBBgS0BgQEMpcFBQETAQkFMZcGBjAFBZcyBAQGtAQGAf3iBgaXMQUJARUBBgS0BgQEMpcFBQK2MQUJARUBBgS0BgQEMpcFBTAGBjwFBZcyBAQGtAQGARUBCQUxlwYG/p8GBAQylwUFMAYGlzEFCQEVAQYEAR8FBZcyBAQGtAQGARUBCQUxlwYGAAAAAAASAN4AAQAAAAAAAAAVAAAAAQAAAAAAAQALABUAAQAAAAAAAgAHACAAAQAAAAAAAwALACcAAQAAAAAABAALADIAAQAAAAAABQALAD0AAQAAAAAABgALAEgAAQAAAAAACgArAFMAAQAAAAAACwATAH4AAwABBAkAAAAqAJEAAwABBAkAAQAWALsAAwABBAkAAgAOANEAAwABBAkAAwAWAN8AAwABBAkABAAWAPUAAwABBAkABQAWAQsAAwABBAkABgAWASEAAwABBAkACgBWATcAAwABBAkACwAmAY0KQ3JlYXRlZCBieSBpY29uZm9udAp2LW1kLWVkaXRvclJlZ3VsYXJ2LW1kLWVkaXRvcnYtbWQtZWRpdG9yVmVyc2lvbiAxLjB2LW1kLWVkaXRvckdlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAAoAQwByAGUAYQB0AGUAZAAgAGIAeQAgAGkAYwBvAG4AZgBvAG4AdAAKAHYALQBtAGQALQBlAGQAaQB0AG8AcgBSAGUAZwB1AGwAYQByAHYALQBtAGQALQBlAGQAaQB0AG8AcgB2AC0AbQBkAC0AZQBkAGkAdABvAHIAVgBlAHIAcwBpAG8AbgAgADEALgAwAHYALQBtAGQALQBlAGQAaQB0AG8AcgBHAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAHMAdgBnADIAdAB0AGYAIABmAHIAbwBtACAARgBvAG4AdABlAGwAbABvACAAcAByAG8AagBlAGMAdAAuAGgAdAB0AHAAOgAvAC8AZgBvAG4AdABlAGwAbABvAC4AYwBvAG0AAAAAAgAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfAAdwcmV2aWV3DXJlZnJlc2gtcmlnaHQMcmVmcmVzaC1sZWZ0B3pvb20taW4Iem9vbS1vdXQDdG9jBHN5bmMFZW1vamkIY2hlY2tib3gFY2xlYXIDdGlwBHNhdmUEbGluawNpbWcEY29kZQJ1bAJvbARyZWRvBHVuZG8FcXVvdGUEYm9sZA1zdHJpa2V0aHJvdWdoCmFycm93LWRvd24Lb3Blbi1pbi1uZXcKdW5kZXItbGluZQZpdGFsaWMKaG9yaXpvbnRhbAV0YWJsZQpmdWxsc2NyZWVuAAA=#iefix) format(\\\"embedded-opentype\\\"),url(\\\"data:application/x-font-woff2;charset=utf-8;base64,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\\\") format(\\\"woff2\\\"),url(data:font/woff;base64,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) format(\\\"woff\\\"),url(data:font/ttf;base64,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) format(\\\"truetype\\\")}[class*=v-md-icon-]{font-size:16px;font-family:v-md-iconfont!important;font-style:normal!important;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.v-md-icon-preview:before{content:\\\"\\\\e618\\\"}.v-md-icon-refresh-right:before{content:\\\"\\\\e614\\\"}.v-md-icon-refresh-left:before{content:\\\"\\\\e615\\\"}.v-md-icon-zoom-in:before{content:\\\"\\\\e616\\\"}.v-md-icon-zoom-out:before{content:\\\"\\\\e617\\\"}.v-md-icon-toc:before{content:\\\"\\\\eb28\\\"}.v-md-icon-sync:before{content:\\\"\\\\e670\\\"}.v-md-icon-emoji:before{content:\\\"\\\\e67b\\\"}.v-md-icon-checkbox:before{content:\\\"\\\\e740\\\"}.v-md-icon-clear:before{content:\\\"\\\\e6ec\\\"}.v-md-icon-tip:before{content:\\\"\\\\e8f1\\\"}.v-md-icon-save:before{content:\\\"\\\\e624\\\"}.v-md-icon-link:before{content:\\\"\\\\e6fe\\\"}.v-md-icon-img:before{content:\\\"\\\\e702\\\"}.v-md-icon-code:before{content:\\\"\\\\e707\\\"}.v-md-icon-ul:before{content:\\\"\\\\e710\\\"}.v-md-icon-ol:before{content:\\\"\\\\e711\\\"}.v-md-icon-redo:before{content:\\\"\\\\e6f1\\\"}.v-md-icon-undo:before{content:\\\"\\\\e6f0\\\"}.v-md-icon-quote:before{content:\\\"\\\\e6b3\\\"}.v-md-icon-bold:before{content:\\\"\\\\e7c1\\\"}.v-md-icon-strikethrough:before{content:\\\"\\\\e70f\\\"}.v-md-icon-arrow-down:before{content:\\\"\\\\e623\\\"}.v-md-icon-open-in-new:before{content:\\\"\\\\e641\\\"}.v-md-icon-under-line:before{content:\\\"\\\\e611\\\"}.v-md-icon-italic:before{content:\\\"\\\\e610\\\"}.v-md-icon-horizontal:before{content:\\\"\\\\e60e\\\"}.v-md-icon-table:before{content:\\\"\\\\e60c\\\"}.v-md-icon-fullscreen:before{content:\\\"\\\\e606\\\"}.v-md-editor__tooltip{z-index:101;padding:4px 6px;color:#fff;font-size:12px;line-height:1;white-space:nowrap;background-color:#878787;border-radius:2px}.v-md-editor__menu,.v-md-editor__tooltip{position:absolute;box-shadow:0 2px 12px 0 rgba(0,0,0,.1)}.v-md-editor__menu{top:38px;z-index:99;list-style:none;background-color:#fff;border-radius:3px;-webkit-transform-origin:center top;transform-origin:center top}.v-md-editor__menu::-webkit-scrollbar{width:6px}.v-md-editor__menu::-webkit-scrollbar-thumb{background-color:rgba(144,147,153,.3);border-radius:4px}.v-md-editor__menu::-webkit-scrollbar-thumb:hover{background-color:rgba(144,147,153,.5)}.v-md-editor__menu-item{color:#595959;font-weight:400;font-size:14px;white-space:nowrap;list-style:none}.v-md-editor__menu-item:hover{background-color:#f5f5f5}.v-md-editor__menu--list{padding:5px 0}.v-md-editor__menu--list .v-md-editor__menu-item{padding:0 24px;line-height:34px;text-align:left}.v-md-editor__menu--panel{max-height:200px;padding:12px 10px;overflow-y:auto}.v-md-editor__menu--panel .v-md-editor__menu-row{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-wrap:nowrap;flex-wrap:nowrap}.v-md-editor__menu--panel .v-md-editor__menu-row:not(:last-child){margin-bottom:6px}.v-md-editor__menu--panel .v-md-editor__menu-item{display:inline-block;padding:8px 0;line-height:1;text-align:center;border-radius:2px}.v-md-editor__menu--panel .v-md-editor__menu-item:not(:last-child){margin-right:4px}.v-md-editor__menu-ctrl{position:absolute;top:0;right:0;display:none}.v-md-editor__toolbar-item{position:relative;height:28px;padding:0 6px;color:#595959;font-size:16px;line-height:28px;text-align:center;border-radius:4px;cursor:pointer;-webkit-transition:all .2s linear 0s;transition:all .2s linear 0s}.v-md-editor__toolbar-item:not(:first-child){margin-left:4px}.v-md-editor__toolbar-item:hover{background:#f5f5f5}.v-md-editor__toolbar-item--menu{padding-right:16px}.v-md-editor__toolbar-item--menu .v-md-editor__menu-ctrl{display:inline-block}.v-md-editor__toolbar-item--active,.v-md-editor__toolbar-item--active:hover{background:#e8e8e8}.v-md-editor__toolbar{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-box-align:center;-webkit-align-items:center;align-items:center;box-sizing:border-box;width:100%;padding:6px;border-bottom:1px solid #ddd}.v-md-editor__toolbar-left,.v-md-editor__toolbar-right{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-wrap:wrap;flex-wrap:wrap;margin:0;padding:0;list-style:none}.v-md-editor__toolbar-left+.v-md-editor__toolbar-right{margin-left:60px}.v-md-editor__toolbar-divider{position:relative;height:28px;margin:0 10px}.v-md-editor__toolbar-divider+li.v-md-editor__toolbar-item{margin-left:0}.v-md-editor__toolbar-divider:before{position:absolute;top:4px;bottom:4px;border-left:1px solid #ddd;content:\\\"\\\"}.v-md-editor{display:-webkit-box;display:-webkit-flex;display:flex;width:100%;background-color:#fff;border-radius:4px;box-shadow:0 2px 12px 0 rgba(0,0,0,.1)}.v-md-editor__left-area,.v-md-editor__right-area{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;flex-direction:column;width:200px}.v-md-editor__left-area{height:100%;overflow:hidden;border-right:1px solid #ddd;-webkit-transition:.3s;transition:.3s}.v-md-editor__left-area-title{position:relative;height:41px;padding:0 14px;color:#2c3e50;font-weight:600;font-size:16px;line-height:41px;white-space:nowrap}.v-md-editor__left-area-title:after{position:absolute;right:0;bottom:0;left:0;border-bottom:1px solid #ddd;content:\\\"\\\"}.v-md-editor__left-area-body{-webkit-box-flex:1;-webkit-flex:1;flex:1;padding:8px 14px;overflow:hidden}.v-md-editor--left-area-reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse}.v-md-editor--left-area-reverse .v-md-editor__left-area{border-right:none;border-left:1px solid #ddd}.v-md-editor__right-area{-webkit-box-flex:1;-webkit-flex:1;flex:1}.v-md-editor--preview{box-shadow:none}.v-md-editor--fullscreen{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1001}.v-md-editor__main{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-flex:1;-webkit-flex:1;flex:1;width:100%;overflow:hidden}.v-md-editor__editor-wrapper,.v-md-editor__preview-wrapper{position:relative;-webkit-box-flex:1;-webkit-flex:1;flex:1;height:100%;overflow:hidden}.v-md-editor__editor-wrapper{cursor:text;-webkit-user-select:none;user-select:none}.v-md-editor--editable .v-md-editor__editor-wrapper{border-right:1px solid #ddd}.scrollbar{height:100%;overflow:hidden}.scrollbar:active .scrollbar__bar,.scrollbar:focus .scrollbar__bar,.scrollbar:hover .scrollbar__bar{opacity:1}.scrollbar__wrap{height:100%;overflow-x:hidden}.scrollbar__wrap--hidden-default{scrollbar-width:none}.scrollbar__wrap--hidden-default::-webkit-scrollbar{width:0;height:0}.scrollbar__thumb{position:relative;display:block;width:0;height:0;background-color:rgba(144,147,153,.3);border-radius:inherit;cursor:pointer;-webkit-transition:background-color .3s;transition:background-color .3s}.scrollbar__thumb:hover{background-color:rgba(144,147,153,.5)}.scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px;cursor:pointer;opacity:0;-webkit-transition:opacity .34s ease-out;transition:opacity .34s ease-out}.scrollbar__bar.is-vertical{top:2px;width:6px}.scrollbar__bar.is-vertical>div{width:100%}.scrollbar__bar.is-horizontal{left:2px;height:6px}.scrollbar__bar.is-horizontal>div{height:100%}.v-md-editor__toc-nav{margin:0;padding:0;list-style:none}.v-md-editor__toc-nav-item{position:relative;height:38px;overflow:hidden;color:#2c3e50;line-height:38px;white-space:nowrap;text-overflow:ellipsis;cursor:pointer}.v-md-editor__toc-nav-item:hover .v-md-editor__toc-nav-title{font-size:17px;-webkit-transform-origin:center center;transform-origin:center center}.v-md-editor__toc-nav-title{position:relative;font-size:16px;-webkit-transition:.3s;transition:.3s}\", \"\",{\"version\":3,\"sources\":[\"webpack://./node_modules/@kangc/v-md-editor/lib/style/base-editor.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\".v-md-textarea-editor{position:relative}.v-md-textarea-editor pre{margin:0;white-space:pre-wrap;visibility:hidden}.v-md-textarea-editor pre,.v-md-textarea-editor textarea{box-sizing:border-box;padding:20px 20px 30px;overflow:hidden;color:#2c3e50;font-size:14px;font-family:menlo,Ubuntu Mono,consolas,Courier New,Microsoft Yahei,Hiragino Sans GB,WenQuanYi Micro Hei,sans-serif;line-height:1.5;word-break:break-all}.v-md-textarea-editor textarea{position:absolute;top:0;left:0;width:100%;height:100%;border:none;outline:none;resize:none}.v-md-textarea-editor textarea::-webkit-input-placeholder{color:#c0c4cc}.v-md-textarea-editor textarea::placeholder{color:#c0c4cc}.v-md-zoom-in-top-enter-active,.v-md-zoom-in-top-leave-active{-webkit-transform:scaleY(1);transform:scaleY(1);opacity:1;-webkit-transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1);transition:transform .3s cubic-bezier(.23,1,.32,1),opacity .3s cubic-bezier(.23,1,.32,1),-webkit-transform .3s cubic-bezier(.23,1,.32,1)}.v-md-zoom-in-top-enter-from,.v-md-zoom-in-top-leave-active{-webkit-transform:scaleY(0);transform:scaleY(0);opacity:0}.v-md-fade-in-enter-active,.v-md-fade-in-leave-active{-webkit-transition:opacity .3s cubic-bezier(.55,0,.1,1);transition:opacity .3s cubic-bezier(.55,0,.1,1)}.v-md-fade-in-enter-from,.v-md-fade-in-leave-active{opacity:0}@font-face{font-family:v-md-iconfont;src:url(data:application/vnd.ms-fontobject;base64,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AT4BLwE3NicBBjIEBAa0BAYBFQEJBTGXBgYwBQX2BgaXMQUJARUBBgS0BgQEMpcFBQETAQkFMZcGBjAFBZcyBAQGtAQGAf3iBgaXMQUJARUBBgS0BgQEMpcFBQK2MQUJARUBBgS0BgQEMpcFBTAGBjwFBZcyBAQGtAQGARUBCQUxlwYG/p8GBAQylwUFMAYGlzEFCQEVAQYEAR8FBZcyBAQGtAQGARUBCQUxlwYGAAAAAAASAN4AAQAAAAAAAAAVAAAAAQAAAAAAAQALABUAAQAAAAAAAgAHACAAAQAAAAAAAwALACcAAQAAAAAABAALADIAAQAAAAAABQALAD0AAQAAAAAABgALAEgAAQAAAAAACgArAFMAAQAAAAAACwATAH4AAwABBAkAAAAqAJEAAwABBAkAAQAWALsAAwABBAkAAgAOANEAAwABBAkAAwAWAN8AAwABBAkABAAWAPUAAwABBAkABQAWAQsAAwABBAkABgAWASEAAwABBAkACgBWATcAAwABBAkACwAmAY0KQ3JlYXRlZCBieSBpY29uZm9udAp2LW1kLWVkaXRvclJlZ3VsYXJ2LW1kLWVkaXRvcnYtbWQtZWRpdG9yVmVyc2lvbiAxLjB2LW1kLWVkaXRvckdlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAAoAQwByAGUAYQB0AGUAZAAgAGIAeQAgAGkAYwBvAG4AZgBvAG4AdAAKAHYALQBtAGQALQBlAGQAaQB0AG8AcgBSAGUAZwB1AGwAYQByAHYALQBtAGQALQBlAGQAaQB0AG8AcgB2AC0AbQBkAC0AZQBkAGkAdABvAHIAVgBlAHIAcwBpAG8AbgAgADEALgAwAHYALQBtAGQALQBlAGQAaQB0AG8AcgBHAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAHMAdgBnADIAdAB0AGYAIABmAHIAbwBtACAARgBvAG4AdABlAGwAbABvACAAcAByAG8AagBlAGMAdAAuAGgAdAB0AHAAOgAvAC8AZgBvAG4AdABlAGwAbABvAC4AYwBvAG0AAAAAAgAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfAAdwcmV2aWV3DXJlZnJlc2gtcmlnaHQMcmVmcmVzaC1sZWZ0B3pvb20taW4Iem9vbS1vdXQDdG9jBHN5bmMFZW1vamkIY2hlY2tib3gFY2xlYXIDdGlwBHNhdmUEbGluawNpbWcEY29kZQJ1bAJvbARyZWRvBHVuZG8FcXVvdGUEYm9sZA1zdHJpa2V0aHJvdWdoCmFycm93LWRvd24Lb3Blbi1pbi1uZXcKdW5kZXItbGluZQZpdGFsaWMKaG9yaXpvbnRhbAV0YWJsZQpmdWxsc2NyZWVuAAA=);src:url(data:application/vnd.ms-fontobject;base64,lBkAAOAYAAABAAIAAAAAAAIABQMAAAAAAAABAJABAAAAAExQAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAaGPnLwAAAAAAAAAAAAAAAAAAAAAAABYAdgAtAG0AZAAtAGUAZABpAHQAbwByAAAADgBSAGUAZwB1AGwAYQByAAAAFgBWAGUAcgBzAGkAbwBuACAAMQAuADAAAAAWAHYALQBtAGQALQBlAGQAaQB0AG8AcgAAAAAAAAEAAAALAIAAAwAwR1NVQrD+s+0AAAE4AAAAQk9TLzI8fE0eAAABfAAAAFZjbWFwEzte5gAAAkwAAAOQZ2x5ZhKJB5wAAAYcAAAO+GhlYWQY8MqxAAAA4AAAADZoaGVhB94EEAAAALwAAAAkaG10eHhxAAAAAAHUAAAAeGxvY2E5dDYWAAAF3AAAAD5tYXhwATIAawAAARgAAAAgbmFtZYA2YG8AABUUAAACkXBvc3Sv0n/QAAAXqAAAATgAAQAAA4D/gABcBHEAAAAABAAAAQAAAAAAAAAAAAAAAAAAAB4AAQAAAAEAAC/nY2hfDzz1AAsEAAAAAADa6MNaAAAAANrow1oAAP+CBAADfgAAAAgAAgAAAAAAAAABAAAAHgBfAAoAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKAB4ALAABREZMVAAIAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAAAAQQEAZAABQAIAokCzAAAAI8CiQLMAAAB6wAyAQgAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABA5gbrKAOA/4AAXAOAAIAAAAABAAAAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABHEAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAABQAAAAMAAAAsAAAABAAAAiQAAQAAAAABHgADAAEAAAAsAAMACgAAAiQABADyAAAAKgAgAAQACuYG5gzmDuYR5hjmJOZB5nDme+az5uzm8eb+5wLnB+cR50Dnwejx6yj//wAA5gbmDOYO5hDmFOYj5kHmcOZ75rPm7Obw5v7nAucH5w/nQOfB6PHrKP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABACoAKgAqACoALAA0ADYANgA2ADYANgA2ADgAOAA4ADgAPAA8ADwAPAAAAB0AHAAbABoAGQACAAMABAAFAAEAFwAMABgABwAIABQACgATABIADQAOAA8AFgAQABEACQAVAAsABgAAAQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAABbAAAAAAAAAAdAADmBgAA5gYAAAAdAADmDAAA5gwAAAAcAADmDgAA5g4AAAAbAADmEAAA5hAAAAAaAADmEQAA5hEAAAAZAADmFAAA5hQAAAACAADmFQAA5hUAAAADAADmFgAA5hYAAAAEAADmFwAA5hcAAAAFAADmGAAA5hgAAAABAADmIwAA5iMAAAAXAADmJAAA5iQAAAAMAADmQQAA5kEAAAAYAADmcAAA5nAAAAAHAADmewAA5nsAAAAIAADmswAA5rMAAAAUAADm7AAA5uwAAAAKAADm8AAA5vAAAAATAADm8QAA5vEAAAASAADm/gAA5v4AAAANAADnAgAA5wIAAAAOAADnBwAA5wcAAAAPAADnDwAA5w8AAAAWAADnEAAA5xAAAAAQAADnEQAA5xEAAAARAADnQAAA50AAAAAJAADnwQAA58EAAAAVAADo8QAA6PEAAAALAADrKAAA6ygAAAAGAAAAAABYAJoA3AE4AYIBwAH4Ak4CfgLIAvIDXAOUA8QD6AQUBFIEeASeBMoFCgWSBaAF+AYyBngGkgb2B3wAAAAEAAAAAAQAAtYACwAXACMALwAAARYAFwYAByYAJzYAFw4BBx4BFz4BNy4BBx4BFw4BBy4BJz4BFw4BBx4BFz4BNy4BAgDyAQwCAv708vL+9AICAQzyquIpKeKqquIpKeKqX38CAn9fX38CAn9fRFoCAlpERFoCAloC1Rb+zBYW/swWFgE0FhYBNCoLz0ZGzwsLz0ZGzzUCf19ffwICf19ffz4CWkREWgICWkREWgAAAAEAAP++A8IDUgAoAAABNTQ2MhYXFQ4BByMuATQ2OwEuAQcOARceARc+ATczDgEHLgEnPgIEAzEVHxYBARYPrhEVFRFtXPd0c2UfIsaDn9MFSwX+v7/+BQGP+gEDAsw6ERUVEa4PFQICFR8VYCk8QOWBf5kDBNSfv/4FBf6/iNxtKwAAAAEAAP++A8MDUgApAAATMzIWFAYHIy4BPQE0NjIWHQE2JBceARcOAQcuASczHgEXPgE3LgEnJgbrbREVFRGuERUVIRVlAQN9fZABBf6/v/4FSwTUn5/TBQGBbW7eAn0VHxYBARYPrhEVFRE6Wis0OdyIv/4FBf6/n9QEBNSfdrssKTIAAAMAAP++A8IDRgASAB4AOgAAJRcWFAYiLwEGJCcmEjc2JBcWEgU+ATcuAScOAQceARM1NDYyFh0BMzIWFAYrARUUBiImPQEjIiY0NjMDN4IJFBoKgor+r3x2BnyBAVCGgBT+RpzOBATOnJzNBATNexMdE2MPExMPYxMdE2QOExMOeIIKGhQJgnEUgIYBUIF8BnZ8/q/eBM6cnM0EBM2cnM4Bi2QOExMOZBMdE2MPExMPYxMdEwAAAAADAAD/vgPCA0YAEgAeACoAACUXFhQGIi8BBiQnJhI3NiQXFhIFPgE3LgEnDgEHHgETITIWFAYjISImNDYDN4IJFBoKgor+r3x2BnyBAVCGgBT+RpzOBATOnJzNBATNFwEKDxMTD/72DhMTeIIKGhQJgnEUgIYBUIF8BnZ8/q/eBM6cnM0EBM2cnM4BixMdExMdEwAABAAA/9cDqQMpAAMABwAXACQAABMRIRElITUhJyEyFhURFAYjISImNRE0NhMyFhcRDgEiJicRPgG2ApT9bAKU/WwvAvIUGxsU/Q4UGxvQFBsBARsoGgEBGwIN/ikB119eXhsU/Q4UGxsUAvIUG/62GxT+5RQaGhQBGxQbAAIAAP+CA20DfgAPAB8AAAE1Bxc1HgEXFAcXPgE1LgEDLgEnNjcnDgEVHgEXFTcnAgC2tnSaAyBCHB0Ezpp0mgMBH0IcHQTOmra2AvOLurmLA512RjxDLGM2ndL9ewOddkY8QyplNp3SBIu6uQAAAAAFAAD/mgPmA2YACwAXACAAKQAwAAAFJgAnNgA3FgAXBgADDgEHHgEXPgE3LgETIiY0NjIWFAYhIiY0NjIWFAYHHgEXPgE3AgDO/u4FBQESzs4BEgUF/u7OpNwEBNykpNwEBNweFhoaLBoa/mYWGhosGhoWAm5SUm4CZQUBEs7OARIFBf7uzs7+7gNkBNykpNwEBNykpNz+sRosGhosGhosGhosGmJSbgICblIAAwAA/8sDtQM1AA8AEwAZAAATITIWFREUBiMhLgEnETQ2FxEhEQEnNxcBF3wDCBQdHRT8+BUbAR1EAqj+fM5EigESRQM1HRT8+BQdARsVAwgUHWH9WAKo/erORIkBE0UABQAA/74DwwNlAAAADAAeACIAJwAANzMhMh0BFCMhIj0BNDcXFjMhMjcBNiYnASYGBwEGFgkBAwEHAQchJ08JA1AJCfywCQ+TDhEBZxgPARETBxn+oxo9Ff54EwgB0QFU0P6rMgFVAv60hhAJPwkJPwnScwoTAV0aPRUBEBQIGf4LGj8CGP72/vUBCkD+9QFpAAAAAAIAAP+4A8gDSAASABkAABMhMhYVERQGKwEHJyMiJjURNDYXETMXNzMRlALYJjU1Jra2trYmNTUm3JCQ3ANHNSb93iY1trY1JgIiJjVb/d6QkAIiAAQAAP/cA6QDJAATADEANQBFAAAlDgEHIS4BJxE+ATchMhYfAR4BFQMRNCYvAS4BIxUOAQchLgEnNSMRMzU+ATchHgEXFSM1IRUBNCYrASIGHQEUFjsBMjY1A6QBHRf9IRYdAQEdFgH8FzIRmRAVRgsFmgcYCQEdF/7FFh0BRkYBHRYBxxcdAUb+XAEYCghpBwoKB2kIChEXHQEBHRcC3xYdARUQmREyF/4WAeoJGQaaBgrjFx0BAR0X4/1E5BYdAQEdFuTS0gKrBwoKB68ICgoIAAAAAwAA/8ADwANAAAsAFwAbAAABBxc3JzcXBycHFzcBFwcnNxc3JwcBNycjARcBAm31ZUQibsttIkRm9f4fIm7LbSJEZvUBU/VlzAEPRP7xA0D1ZkQibctuIkRl9f7qIm3LbiJEZfX+rfVmAQ9E/vEAAAUAAAAAA8ADAAADAAcADQAOABcAABMRIREDIQEXNScBIxEhBSMeATI2NCYiBkADgGD+CAEf2dn+WUACwP3gMAEbKBsbKBsDAP0AAwD9YAEg2YjZ/lgCQKAUGxsoGxsAAAMAAAAAA94CtAAFAAsADwAAEwMTMwMTISMTAzMTATMTI9SysnaysgHidrKyd7H9m2qkagKz/s3+zQEzATP+zf7NATP+zQJmAAYAAAAAA8AC4AADAAcACwAPABMAFwAAASEVIREhFSERIRUhAzMVIxUzFSMVMxUjAQACwP1AAsD9QALA/UDAYGBgYGBgAbBgAZBg/gBgAsBg0GDQYAAAAAAGAAAAAAPAAvAAAwAHAAsAEQAeACgAAAEhFSERIRUhESEVIQMzNSMVMwMVMxUjFTMVIxUzNSMTNSMVMwcVMzUjAQACwP1AAsD9QALA/UCQIEAgMEAoKEBgICBgMzNgQAGwYAGQYP4AYAJQgCD9wCAPIBEggAEQICAzLSAAAQAAAAADgwMkABQAAAEhNRcHNSEOAQceARczFSMuASc+AQGIASzOzv7UWXcCAndZeHh/qgMDqgKseKWleAJ3WVl3AloDqn9/qgAAAAEAAAAAA6QDJAAUAAABITUHFzUhHgEXDgEHIxUzPgE3LgECeP7Uzs4BLFl3AgJ3WXh4f6oDA6oCrHilpXgCd1lZdwJaA6p/f6oAAAACAAAAAANxAtUACwAXAAABPgE3JwYHBh0BIREhPgE3JwYHBh0BIREBHAVJTj6BPC0BEgEyBEpOPoE8LQERAVR7gSFjOnFVvuoBKHuBIWM6cVW+6gEoAAAAAwAAAAADigL1AAkAFAAnAAABMjc2NCcmKwEVEzI3NjU0JyYrAREDITIXFhUUBwYHFhcWFRQHBiMhAms/Ijc6IUCx1VsnGEclP8RgATmANiAnFSY4HDEsQpD+zAG6ERySGQ/n/qc2IjBSHRD++QKUTi49Ri4YExYcMFZIOlgAAAADAAD//gPCAwIADwAyAF4AAAEyFh0BFAYjISImPQE0NjM3JicmNTQ2MzIXFhcWFxYVFA8BLwEmJyYjIgYVFBYXFhcWFwczFhUUBwYHBgcGBwYjIi8BJicmPQE0JyY/ATU3HwEWFx4CMzI+ATU0JyYDsgcJCQf8nAcJCQfjDgwYhoMZOiI3BQYHAwYqBxkbLD05REJrIzQdE3fPAxQMGBMkKCUoPjkpRh0HBAEBAQEzDwwDAxEtPCUgTC8pEQGACQcgBwkJByAHCSASFjItW4AKBhITKD4eCQ4BAwFLHC06LCVDIAoXDgyAFBs3MxwYEhcYCQsMFAgGBAcHNhgPExMWASQcCgQcJRUaPSIqJQ4AAAEAAAAAAtcB0wACAAABIRcC1/5S1wHT0QAAAAACAAAAAANkAuQAFwA7AAABIy4BNDY7ATIWHQEUBiImJzUBBiImNDcFPgEyFh0BDgEHIS4BJxE+ATczMhYUBgcjIgYVERQWMyEyNjUC9nUNExMNww0TExsSAf7yChoTCQE8ARIbEwE3Kf36KTcBATcpww4SEg7DDhISDgIGDhICowESGxMTDcMNExMNdf7xCRMaClYOEhIOwik3AQE3KQIGKTcBExsSARIO/foOEhIOAAIAAP/0A3IDDAADACQAADchFSERIRUPAREUFjMyNjURLwE1MxUPAREUBiMiJicuATURLwGPAtv9JQE7RQ9UX1dPEUX4Qw+ImVB4IxoWD0UxPQMYMQQO/qljVFpmAUoRBTExBRH+rIl6KiYfT0oBUw4EAAAAAQAA/9oC2AMmACsAAAE2JicmNTQ/AR4BMzI2NxYVFAcOAQcDBhYXFhUUByYnJiMiBgcmNTQ3PgE3AggFGikTAgMlSyAbTCIDEikhBX4FHCsRAycnIyQbSyIEESgkBQLHGhgFBBEEBAsEBAQEDQYTAQQaGv1yGhcGBA8IDQQBAwQEDQgPAwYYGgAAAAABAAAAAAOMAcIADAAAARQGIyEiJjQ2MyEyFgOMGhP9QhMaGhMCvhMaAZUTGRknGRkAAAAACgAA/+wDwgMBABAAFAAYABwAIAApAC4ANwA7AD8AAAEhMhYVERQGJyEiJjURNDYzEyMVMwU1IxUlMzUjJRUzNQUWNzI2NTYnIwUzNSMVJzUjBhcUFjMWNzM1IwU1IxUCAgGEIRsbIPzwHhsbHuHg4AEX3gEW4OD90t8BT21pAwgBAeH+6eDgOOEBAgoEZ6Pf3wH33wMBHCD9ZSEdARsfAqIdG/2/mAGYmAGYy5aWmAEBBwRHRZWVlsqYRkIECwEDlZaWlgAAAAAEAAD/8wONAw0AEwAnADsATwAAATc2Ji8BJgYfAR4BPwEXFj8BNicXFj8BFxY2PwE2Jg8BDgEfAQcGFwEuAQ8BJyYPAQYfAQcGFh8BFjYnASYPAScmBg8BBhY/AT4BLwE3NicBBjIEBAa0BAYBFQEJBTGXBgYwBQX2BgaXMQUJARUBBgS0BgQEMpcFBQETAQkFMZcGBjAFBZcyBAQGtAQGAf3iBgaXMQUJARUBBgS0BgQEMpcFBQK2MQUJARUBBgS0BgQEMpcFBTAGBjwFBZcyBAQGtAQGARUBCQUxlwYG/p8GBAQylwUFMAYGlzEFCQEVAQYEAR8FBZcyBAQGtAQGARUBCQUxlwYGAAAAAAASAN4AAQAAAAAAAAAVAAAAAQAAAAAAAQALABUAAQAAAAAAAgAHACAAAQAAAAAAAwALACcAAQAAAAAABAALADIAAQAAAAAABQALAD0AAQAAAAAABgALAEgAAQAAAAAACgArAFMAAQAAAAAACwATAH4AAwABBAkAAAAqAJEAAwABBAkAAQAWALsAAwABBAkAAgAOANEAAwABBAkAAwAWAN8AAwABBAkABAAWAPUAAwABBAkABQAWAQsAAwABBAkABgAWASEAAwABBAkACgBWATcAAwABBAkACwAmAY0KQ3JlYXRlZCBieSBpY29uZm9udAp2LW1kLWVkaXRvclJlZ3VsYXJ2LW1kLWVkaXRvcnYtbWQtZWRpdG9yVmVyc2lvbiAxLjB2LW1kLWVkaXRvckdlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAAoAQwByAGUAYQB0AGUAZAAgAGIAeQAgAGkAYwBvAG4AZgBvAG4AdAAKAHYALQBtAGQALQBlAGQAaQB0AG8AcgBSAGUAZwB1AGwAYQByAHYALQBtAGQALQBlAGQAaQB0AG8AcgB2AC0AbQBkAC0AZQBkAGkAdABvAHIAVgBlAHIAcwBpAG8AbgAgADEALgAwAHYALQBtAGQALQBlAGQAaQB0AG8AcgBHAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAHMAdgBnADIAdAB0AGYAIABmAHIAbwBtACAARgBvAG4AdABlAGwAbABvACAAcAByAG8AagBlAGMAdAAuAGgAdAB0AHAAOgAvAC8AZgBvAG4AdABlAGwAbABvAC4AYwBvAG0AAAAAAgAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfAAdwcmV2aWV3DXJlZnJlc2gtcmlnaHQMcmVmcmVzaC1sZWZ0B3pvb20taW4Iem9vbS1vdXQDdG9jBHN5bmMFZW1vamkIY2hlY2tib3gFY2xlYXIDdGlwBHNhdmUEbGluawNpbWcEY29kZQJ1bAJvbARyZWRvBHVuZG8FcXVvdGUEYm9sZA1zdHJpa2V0aHJvdWdoCmFycm93LWRvd24Lb3Blbi1pbi1uZXcKdW5kZXItbGluZQZpdGFsaWMKaG9yaXpvbnRhbAV0YWJsZQpmdWxsc2NyZWVuAAA=#iefix) format(\\\"embedded-opentype\\\"),url(\\\"data:application/x-font-woff2;charset=utf-8;base64,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\\\") format(\\\"woff2\\\"),url(data:font/woff;base64,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) format(\\\"woff\\\"),url(data:font/ttf;base64,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) format(\\\"truetype\\\")}[class*=v-md-icon-]{font-size:16px;font-family:v-md-iconfont!important;font-style:normal!important;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.v-md-icon-preview:before{content:\\\"\\\\e618\\\"}.v-md-icon-refresh-right:before{content:\\\"\\\\e614\\\"}.v-md-icon-refresh-left:before{content:\\\"\\\\e615\\\"}.v-md-icon-zoom-in:before{content:\\\"\\\\e616\\\"}.v-md-icon-zoom-out:before{content:\\\"\\\\e617\\\"}.v-md-icon-toc:before{content:\\\"\\\\eb28\\\"}.v-md-icon-sync:before{content:\\\"\\\\e670\\\"}.v-md-icon-emoji:before{content:\\\"\\\\e67b\\\"}.v-md-icon-checkbox:before{content:\\\"\\\\e740\\\"}.v-md-icon-clear:before{content:\\\"\\\\e6ec\\\"}.v-md-icon-tip:before{content:\\\"\\\\e8f1\\\"}.v-md-icon-save:before{content:\\\"\\\\e624\\\"}.v-md-icon-link:before{content:\\\"\\\\e6fe\\\"}.v-md-icon-img:before{content:\\\"\\\\e702\\\"}.v-md-icon-code:before{content:\\\"\\\\e707\\\"}.v-md-icon-ul:before{content:\\\"\\\\e710\\\"}.v-md-icon-ol:before{content:\\\"\\\\e711\\\"}.v-md-icon-redo:before{content:\\\"\\\\e6f1\\\"}.v-md-icon-undo:before{content:\\\"\\\\e6f0\\\"}.v-md-icon-quote:before{content:\\\"\\\\e6b3\\\"}.v-md-icon-bold:before{content:\\\"\\\\e7c1\\\"}.v-md-icon-strikethrough:before{content:\\\"\\\\e70f\\\"}.v-md-icon-arrow-down:before{content:\\\"\\\\e623\\\"}.v-md-icon-open-in-new:before{content:\\\"\\\\e641\\\"}.v-md-icon-under-line:before{content:\\\"\\\\e611\\\"}.v-md-icon-italic:before{content:\\\"\\\\e610\\\"}.v-md-icon-horizontal:before{content:\\\"\\\\e60e\\\"}.v-md-icon-table:before{content:\\\"\\\\e60c\\\"}.v-md-icon-fullscreen:before{content:\\\"\\\\e606\\\"}.v-md-editor__tooltip{z-index:101;padding:4px 6px;color:#fff;font-size:12px;line-height:1;white-space:nowrap;background-color:#878787;border-radius:2px}.v-md-editor__menu,.v-md-editor__tooltip{position:absolute;box-shadow:0 2px 12px 0 rgba(0,0,0,.1)}.v-md-editor__menu{top:38px;z-index:99;list-style:none;background-color:#fff;border-radius:3px;-webkit-transform-origin:center top;transform-origin:center top}.v-md-editor__menu::-webkit-scrollbar{width:6px}.v-md-editor__menu::-webkit-scrollbar-thumb{background-color:rgba(144,147,153,.3);border-radius:4px}.v-md-editor__menu::-webkit-scrollbar-thumb:hover{background-color:rgba(144,147,153,.5)}.v-md-editor__menu-item{color:#595959;font-weight:400;font-size:14px;white-space:nowrap;list-style:none}.v-md-editor__menu-item:hover{background-color:#f5f5f5}.v-md-editor__menu--list{padding:5px 0}.v-md-editor__menu--list .v-md-editor__menu-item{padding:0 24px;line-height:34px;text-align:left}.v-md-editor__menu--panel{max-height:200px;padding:12px 10px;overflow-y:auto}.v-md-editor__menu--panel .v-md-editor__menu-row{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-wrap:nowrap;flex-wrap:nowrap}.v-md-editor__menu--panel .v-md-editor__menu-row:not(:last-child){margin-bottom:6px}.v-md-editor__menu--panel .v-md-editor__menu-item{display:inline-block;padding:8px 0;line-height:1;text-align:center;border-radius:2px}.v-md-editor__menu--panel .v-md-editor__menu-item:not(:last-child){margin-right:4px}.v-md-editor__menu-ctrl{position:absolute;top:0;right:0;display:none}.v-md-editor__toolbar-item{position:relative;height:28px;padding:0 6px;color:#595959;font-size:16px;line-height:28px;text-align:center;border-radius:4px;cursor:pointer;-webkit-transition:all .2s linear 0s;transition:all .2s linear 0s}.v-md-editor__toolbar-item:not(:first-child){margin-left:4px}.v-md-editor__toolbar-item:hover{background:#f5f5f5}.v-md-editor__toolbar-item--menu{padding-right:16px}.v-md-editor__toolbar-item--menu .v-md-editor__menu-ctrl{display:inline-block}.v-md-editor__toolbar-item--active,.v-md-editor__toolbar-item--active:hover{background:#e8e8e8}.v-md-editor__toolbar{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-box-align:center;-webkit-align-items:center;align-items:center;box-sizing:border-box;width:100%;padding:6px;border-bottom:1px solid #ddd}.v-md-editor__toolbar-left,.v-md-editor__toolbar-right{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-wrap:wrap;flex-wrap:wrap;margin:0;padding:0;list-style:none}.v-md-editor__toolbar-left+.v-md-editor__toolbar-right{margin-left:60px}.v-md-editor__toolbar-divider{position:relative;height:28px;margin:0 10px}.v-md-editor__toolbar-divider+li.v-md-editor__toolbar-item{margin-left:0}.v-md-editor__toolbar-divider:before{position:absolute;top:4px;bottom:4px;border-left:1px solid #ddd;content:\\\"\\\"}.v-md-editor{display:-webkit-box;display:-webkit-flex;display:flex;width:100%;background-color:#fff;border-radius:4px;box-shadow:0 2px 12px 0 rgba(0,0,0,.1)}.v-md-editor__left-area,.v-md-editor__right-area{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;flex-direction:column;width:200px}.v-md-editor__left-area{height:100%;overflow:hidden;border-right:1px solid #ddd;-webkit-transition:.3s;transition:.3s}.v-md-editor__left-area-title{position:relative;height:41px;padding:0 14px;color:#2c3e50;font-weight:600;font-size:16px;line-height:41px;white-space:nowrap}.v-md-editor__left-area-title:after{position:absolute;right:0;bottom:0;left:0;border-bottom:1px solid #ddd;content:\\\"\\\"}.v-md-editor__left-area-body{-webkit-box-flex:1;-webkit-flex:1;flex:1;padding:8px 14px;overflow:hidden}.v-md-editor--left-area-reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-webkit-flex-direction:row-reverse;flex-direction:row-reverse}.v-md-editor--left-area-reverse .v-md-editor__left-area{border-right:none;border-left:1px solid #ddd}.v-md-editor__right-area{-webkit-box-flex:1;-webkit-flex:1;flex:1}.v-md-editor--preview{box-shadow:none}.v-md-editor--fullscreen{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1001}.v-md-editor__main{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-flex:1;-webkit-flex:1;flex:1;width:100%;overflow:hidden}.v-md-editor__editor-wrapper,.v-md-editor__preview-wrapper{position:relative;-webkit-box-flex:1;-webkit-flex:1;flex:1;height:100%;overflow:hidden}.v-md-editor__editor-wrapper{cursor:text;-webkit-user-select:none;user-select:none}.v-md-editor--editable .v-md-editor__editor-wrapper{border-right:1px solid #ddd}.scrollbar{height:100%;overflow:hidden}.scrollbar:active .scrollbar__bar,.scrollbar:focus .scrollbar__bar,.scrollbar:hover .scrollbar__bar{opacity:1}.scrollbar__wrap{height:100%;overflow-x:hidden}.scrollbar__wrap--hidden-default{scrollbar-width:none}.scrollbar__wrap--hidden-default::-webkit-scrollbar{width:0;height:0}.scrollbar__thumb{position:relative;display:block;width:0;height:0;background-color:rgba(144,147,153,.3);border-radius:inherit;cursor:pointer;-webkit-transition:background-color .3s;transition:background-color .3s}.scrollbar__thumb:hover{background-color:rgba(144,147,153,.5)}.scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px;cursor:pointer;opacity:0;-webkit-transition:opacity .34s ease-out;transition:opacity .34s ease-out}.scrollbar__bar.is-vertical{top:2px;width:6px}.scrollbar__bar.is-vertical>div{width:100%}.scrollbar__bar.is-horizontal{left:2px;height:6px}.scrollbar__bar.is-horizontal>div{height:100%}.v-md-editor__toc-nav{margin:0;padding:0;list-style:none}.v-md-editor__toc-nav-item{position:relative;height:38px;overflow:hidden;color:#2c3e50;line-height:38px;white-space:nowrap;text-overflow:ellipsis;cursor:pointer}.v-md-editor__toc-nav-item:hover .v-md-editor__toc-nav-title{font-size:17px;-webkit-transform-origin:center center;transform-origin:center center}.v-md-editor__toc-nav-title{position:relative;font-size:16px;-webkit-transition:.3s;transition:.3s}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsyXSEuL25vZGVfbW9kdWxlcy9Aa2FuZ2Mvdi1tZC1lZGl0b3IvbGliL3N0eWxlL2Jhc2UtZWRpdG9yLmNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ2tIO0FBQzdCO0FBQ3JGLDhCQUE4QixzRUFBMkIsQ0FBQywyRkFBcUM7QUFDL0Y7QUFDQSxnRUFBZ0Usa0JBQWtCLDBCQUEwQixTQUFTLHFCQUFxQixrQkFBa0IseURBQXlELHNCQUFzQix1QkFBdUIsZ0JBQWdCLGNBQWMsZUFBZSxtSEFBbUgsZ0JBQWdCLHFCQUFxQiwrQkFBK0Isa0JBQWtCLE1BQU0sT0FBTyxXQUFXLFlBQVksWUFBWSxhQUFhLFlBQVksMERBQTBELGNBQWMsNENBQTRDLGNBQWMsOERBQThELDRCQUE0QixvQkFBb0IsVUFBVSx5R0FBeUcsaUdBQWlHLHlGQUF5Rix5SUFBeUksNERBQTRELDRCQUE0QixvQkFBb0IsVUFBVSxzREFBc0Qsd0RBQXdELGdEQUFnRCxvREFBb0QsVUFBVSxXQUFXLDBCQUEwQiwyQ0FBMkMscWlSQUFxaVIsMkNBQTJDLDZtUkFBNm1SLGNBQWMsdzNJQUF3M0ksbzJLQUFvMkssMDBRQUEwMFEsb0JBQW9CLGVBQWUsb0NBQW9DLDRCQUE0QixtQ0FBbUMsa0NBQWtDLDBCQUEwQixtQkFBbUIsZ0NBQWdDLG1CQUFtQiwrQkFBK0IsbUJBQW1CLDBCQUEwQixtQkFBbUIsMkJBQTJCLG1CQUFtQixzQkFBc0IsbUJBQW1CLHVCQUF1QixtQkFBbUIsd0JBQXdCLG1CQUFtQiwyQkFBMkIsbUJBQW1CLHdCQUF3QixtQkFBbUIsc0JBQXNCLG1CQUFtQix1QkFBdUIsbUJBQW1CLHVCQUF1QixtQkFBbUIsc0JBQXNCLG1CQUFtQix1QkFBdUIsbUJB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LHVDQUF1QywrQkFBK0IsNEJBQTRCLGtCQUFrQixlQUFlLHVCQUF1QixlQUFlLG1CQUFtQjtBQUM3KzRGO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGthbmdjL3YtbWQtZWRpdG9yL2xpYi9zdHlsZS9iYXNlLWVkaXRvci5jc3M/Njc5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIudi1tZC10ZXh0YXJlYS1lZGl0b3J7cG9zaXRpb246cmVsYXRpdmV9LnYtbWQtdGV4dGFyZWEtZWRpdG9yIHByZXttYXJnaW46MDt3aGl0ZS1zcGFjZTpwcmUtd3JhcDt2aXNpYmlsaXR5OmhpZGRlbn0udi1tZC10ZXh0YXJlYS1lZGl0b3IgcHJlLC52LW1kLXRleHRhcmVhLWVkaXRvciB0ZXh0YXJlYXtib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzoyMHB4IDIwcHggMzBweDtvdmVyZmxvdzpoaWRkZW47Y29sb3I6IzJjM2U1MDtmb250LXNpemU6MTRweDtmb250LWZhbWlseTptZW5sbyxVYnVudHUgTW9ubyxjb25zb2xhcyxDb3VyaWVyIE5ldyxNaWNyb3NvZnQgWWFoZWksSGlyYWdpbm8gU2FucyBHQixXZW5RdWFuWWkgTWljcm8gSGVpLHNhbnMtc2VyaWY7bGluZS1oZWlnaHQ6MS41O3dvcmQtYnJlYWs6YnJlYWstYWxsfS52LW1kLXRleHRhcmVhLWVkaXRvciB0ZXh0YXJlYXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6bm9uZTtvdXRsaW5lOm5vbmU7cmVzaXplOm5vbmV9LnYtbWQtdGV4dGFyZWEtZWRpdG9yIHRleHRhcmVhOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiNjMGM0Y2N9LnYtbWQtdGV4dGFyZWEtZWRpdG9yIHRleHRhcmVhOjpwbGFjZWhvbGRlcntjb2xvcjojYzBjNGNjfS52LW1kLXpvb20taW4tdG9wLWVudGVyLWFjdGl2ZSwudi1tZC16b29tLWluLXRvcC1sZWF2ZS1hY3RpdmV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVZKDEpO3RyYW5zZm9ybTpzY2FsZVkoMSk7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLC13ZWJraXQtdHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpO3RyYW5zaXRpb246b3BhY2l0eSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSwtd2Via2l0LXRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSxvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLG9wYWNpdHkgLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSksLXdlYmtpdC10cmFuc2Zvcm0gLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSl9LnYtbWQtem9vbS1pbi10b3AtZW50ZXItZnJvbSwudi1tZC16b29tLWluLXRvcC1sZWF2ZS1hY3RpdmV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVZKDApO3RyYW5zZm9ybTpzY2FsZVkoMCk7b3BhY2l0eTowfS52LW1kLWZhZGUtaW4tZW50ZXItYWN0aXZlLC52LW1kLWZhZGUtaW4tbGVhdmUtYWN0aXZley13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjU1LDAsLjEsMSk7dHJhbnNpdGlvbjpvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjU1LDAsLjEsMSl9LnYtbWQtZmFkZS1pbi1lbnRlci1mcm9tLC52LW1kLWZhZGUtaW4tbGVhdmUtYWN0aXZle29wYWNpdHk6MH1AZm9udC1mYWNle2ZvbnQtZmFtaWx5OnYtbWQtaWNvbmZvbnQ7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0O2Jhc2U2NCxsQmtBQU9BWUFBQUJBQUlBQUFBQUFBSUFCUU1BQUFBQUFBQUJBSkFCQUFBQUFFeFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQWFHUG5Md0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQllBZGdBdEFHMEFaQUF0QUdVQVpBQnBBSFFBYndCeUFBQUFEZ0JTQUdVQVp3QjFBR3dBWVFCeUFBQUFGZ0JXQUdVQWNnQnpBR2tBYndCdUFDQUFNUUF1QURBQUFBQVdBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dBQUFBQUFBQUVBQUFBTEFJQUFBd0F3UjFOVlFyRCtzKzBBQUFFNEFBQUFRazlUTHpJOGZFMGVBQUFCZkFBQUFGWmpiV0Z3RXp0ZTVnQUFBa3dBQUFPUVoyeDVaaEtKQjV3QUFBWWNBQUFPK0dobFlXUVk4TXF4QUFBQTRBQUFBRFpvYUdWaEI5NEVFQUFBQUx3QUFBQWthRzEwZUhoeEFBQUFBQUhVQUFBQWVHeHZZMkU1ZERZV0FBQUYzQUFBQUQ1dFlYaHdBVElBYXdBQUFSZ0FBQUFnYm1GdFpZQTJZRzhBQUJVVUFBQUNrWEJ2YzNTdjBuL1FBQUFYcUFBQUFUZ0FBUUFBQTREL2dBQmNCSEVBQUFBQUJBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFCNEFBUUFBQUFFQUFDL25ZMmhmRHp6MUFBc0VBQUFBQUFEYTZNTmFBQUFBQU5yb3cxb0FBUCtDQkFBRGZnQUFBQWdBQWdBQUFBQUFBQUFCQUFBQUhnQmZBQW9BQUFBQUFBSUFBQUFLQUFvQUFBRC9BQUFBQUFBQUFBRUFBQUFLQUI0QUxBQUJSRVpNVkFBSUFBUUFBQUFBQUFBQUFRQUFBQUZzYVdkaEFBZ0FBQUFCQUFBQUFRQUVBQVFBQUFBQkFBZ0FBUUFHQUFBQUFRQUFBQUFBQVFRRUFaQUFCUUFJQW9rQ3pBQUFBSThDaVFMTUFBQUI2d0F5QVFnQUFBSUFCUU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVHWkZaQUJBNWdicktBT0EvNEFBWEFPQUFJQUFBQUFCQUFBQUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkhFQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQUFBQUJRQUFBQU1BQUFBc0FBQUFCQUFBQWlRQUFRQUFBQUFCSGdBREFBRUFBQUFzQUFNQUNnQUFBaVFBQkFEeUFBQUFLZ0FnQUFRQUN1WUc1Z3ptRHVZUjVoam1KT1pCNW5EbWUrYXo1dXptOGViKzV3TG5CK2NSNTBEbndlang2eWovL3dBQTVnYm1ET1lPNWhEbUZPWWo1a0htY09aNzVyUG03T2J3NXY3bkF1Y0g1dy9uUU9mQjZQSHJLUC8vQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQ29BS2dBcUFDb0FMQUEwQURZQU5nQTJBRFlBTmdBMkFEZ0FPQUE0QURnQVBBQThBRHdBUEFBQUFCMEFIQUFiQUJvQUdRQUNBQU1BQkFBRkFBRUFGd0FNQUJnQUJ3QUlBQlFBQ2dBVEFCSUFEUUFPQUE4QUZnQVFBQkVBQ1FBVkFBc0FCZ0FBQVFZQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREFBQUFBQUJiQUFBQUFBQUFBQWRBQURtQmdBQTVnWUFBQUFkQUFEbURBQUE1Z3dBQUFBY0FBRG1EZ0FBNWc0QUFBQWJBQURtRUFBQTVoQUFBQUFhQUFEbUVRQUE1aEVBQUFBWkFBRG1GQUFBNWhRQUFBQUNBQURtRlFBQTVoVUFBQUFEQUFEbUZnQUE1aFlBQUFBRUFBRG1Gd0FBNWhjQUFBQUZBQURtR0FBQTVoZ0FBQUFCQUFEbUl3QUE1aU1BQUFBWEFBRG1KQUFBNWlRQUFBQU1BQURtUVFBQTVrRUFBQUFZQUFEbWNBQUE1bkFBQUFBSEFBRG1ld0FBNW5zQUFBQUlBQURtc3dBQTVyTUFBQUFVQUFEbTdBQUE1dXdBQUFBS0FBRG04QUFBNXZBQUFBQVRBQURtOFFBQTV2RUFBQUFTQUFEbS9nQUE1djRBQUFBTkFBRG5BZ0FBNXdJQUFBQU9BQURuQndBQTV3Y0FBQUFQQUFEbkR3QUE1dzhBQUFBV0FBRG5FQUFBNXhBQUFBQVFBQURuRVFBQTV4RUFBQUFSQUFEblFBQUE1MEFBQUFBSkFBRG53UUFBNThFQUFBQVZBQURvOFFBQTZQRUFBQUFMQUFEcktBQUE2eWdBQUFBR0FBQUFBQUJZQUpvQTNBRTRBWUlCd0FINEFrNENmZ0xJQXZJRFhBT1VBOFFENkFRVUJGSUVlQVNlQk1vRkNnV1NCYUFGK0FZeUJuZ0drZ2IyQjN3QUFBQUVBQUFBQUFRQUF0WUFDd0FYQUNNQUx3QUFBUllBRndZQUJ5WUFKellBRnc0QkJ4NEJGejRCTnk0QkJ4NEJGdzRCQnk0Qkp6NEJGdzRCQng0QkZ6NEJOeTRCQWdEeUFRd0NBdjcwOHZMKzlBSUNBUXp5cXVJcEtlS3FxdUlwS2VLcVgzOENBbjlmWDM4Q0FuOWZSRm9DQWxwRVJGb0NBbG9DMVJiK3pCWVcvc3dXRmdFMEZoWUJOQ29MejBaR3p3c0x6MFpHenpVQ2YxOWZmd0lDZjE5ZmZ6NENXa1JFV2dJQ1drUkVXZ0FBQUFFQUFQKytBOElEVWdBb0FBQUJOVFEyTWhZWEZRNEJCeU11QVRRMk93RXVBUWNPQVJjZUFSYytBVGN6RGdFSExnRW5QZ0lFQXpFVkh4WUJBUllQcmhFVkZSRnRYUGQwYzJVZklzYURuOU1GU3dYK3Y3LytCUUdQK2dFREFzdzZFUlVWRWE0UEZRSUNGUjhWWUNrOFFPV0JmNWtEQk5TZnYvNEZCZjYvaU54dEt3QUFBQUVBQVArK0E4TURVZ0FwQUFBVE16SVdGQVlISXk0QlBRRTBOaklXSFFFMkpCY2VBUmNPQVFjdUFTY3pIZ0VYUGdFM0xnRW5KZ2JyYlJFVkZSR3VFUlVWSVJWbEFRTjlmWkFCQmY2L3YvNEZTd1RVbjUvVEJRR0JiVzdlQW4wVkh4WUJBUllQcmhFVkZSRTZXaXMwT2R5SXYvNEZCZjYvbjlRRUJOU2ZkcnNzS1RJQUFBTUFBUCsrQThJRFJnQVNBQjRBT2dBQUpSY1dGQVlpTHdFR0pDY21FamMySkJjV0VnVStBVGN1QVNjT0FRY2VBUk0xTkRZeUZoMEJNeklXRkFZckFSVVVCaUltUFFFaklpWTBOak1ETjRJSkZCb0tnb3IrcjN4MkJueUJBVkNHZ0JUK1Jwek9CQVRPbkp6TkJBVE5leE1kRTJNUEV4TVBZeE1kRTJRT0V4TU9lSUlLR2hRSmduRVVnSVlCVUlGOEJuWjgvcS9lQk02Y25NMEVCTTJjbk00QmkyUU9FeE1PWkJNZEUyTVBFeE1QWXhNZEV3QUFBQUFEQUFEL3ZnUENBMFlBRWdBZUFDb0FBQ1VYRmhRR0lpOEJCaVFuSmhJM05pUVhGaElGUGdFM0xnRW5EZ0VISGdFVElUSVdGQVlqSVNJbU5EWURONElKRkJvS2dvcityM3gyQm55QkFWQ0dnQlQrUnB6T0JBVE9uSnpOQkFUTkZ3RUtEeE1URC83MkRoTVRlSUlLR2hRSmduRVVnSVlCVUlGOEJuWjgvcS9lQk02Y25NMEVCTTJjbk00Qml4TWRFeE1kRXdBQUJBQUEvOWNEcVFNcEFBTUFCd0FYQUNRQUFCTVJJUkVsSVRVaEp5RXlGaFVSRkFZaklTSW1OUkUwTmhNeUZoY1JEZ0VpSmljUlBnRzJBcFQ5YkFLVS9Xd3ZBdklVR3hzVS9RNFVHeHZRRkJzQkFSc29HZ0VCR3dJTi9pa0IxMTllWGhzVS9RNFVHeHNVQXZJVUcvNjJHeFQrNVJRYUdoUUJHeFFiQUFJQUFQK0NBMjBEZmdBUEFCOEFBQUUxQnhjMUhnRVhGQWNYUGdFMUxnRURMZ0VuTmpjbkRnRVZIZ0VYRlRjbkFnQzJ0blNhQXlCQ0hCMEV6cHAwbWdNQkgwSWNIUVRPbXJhMkF2T0x1cm1MQTUxMlJqeERMR00ybmRMOWV3T2Rka1k4UXlwbE5wM1NCSXU2dVFBQUFBQUZBQUQvbWdQbUEyWUFDd0FYQUNBQUtRQXdBQUFGSmdBbk5nQTNGZ0FYQmdBRERnRUhIZ0VYUGdFM0xnRVRJaVkwTmpJV0ZBWWhJaVkwTmpJV0ZBWUhIZ0VYUGdFM0FnRE8vdTRGQlFFU3pzNEJFZ1VGL3U3T3BOd0VCTnlrcE53RUJOd2VGaG9hTEJvYS9tWVdHaG9zR2hvV0FtNVNVbTRDWlFVQkVzN09BUklGQmY3dXpzNys3Z05rQk55a3BOd0VCTnlrcE56K3NSb3NHaG9zR2hvc0dob3NHbUpTYmdJQ2JsSUFBd0FBLzhzRHRRTTFBQThBRXdBWkFBQVRJVElXRlJFVUJpTWhMZ0VuRVRRMkZ4RWhFUUVuTnhjQkYzd0RDQlFkSFJUOCtCVWJBUjFFQXFqK2ZNNUVpZ0VTUlFNMUhSVDgrQlFkQVJzVkF3Z1VIV0g5V0FLby9lck9SSWtCRTBVQUJRQUEvNzREd3dObEFBQUFEQUFlQUNJQUp3QUFOek1oTWgwQkZDTWhJajBCTkRjWEZqTWhNamNCTmlZbkFTWUdCd0VHRmdrQkF3RUhBUWNoSjA4SkExQUpDZnl3Q1ErVERoRUJaeGdQQVJFVEJ4bitveG85RmY1NEV3Z0IwUUZVMFA2ck1nRlZBdjYwaGhBSlB3a0pQd25TY3dvVEFWMGFQUlVCRUJRSUdmNExHajhDR1A3Mi92VUJDa0QrOVFGcEFBQUFBQUlBQVArNEE4Z0RTQUFTQUJrQUFCTWhNaFlWRVJRR0t3RUhKeU1pSmpVUk5EWVhFVE1YTnpNUmxBTFlKalUxSnJhMnRyWW1OVFVtM0pDUTNBTkhOU2I5M2lZMXRyWTFKZ0lpSmpWYi9kNlFrQUlpQUFRQUFQL2NBNlFESkFBVEFERUFOUUJGQUFBbERnRUhJUzRCSnhFK0FUY2hNaFlmQVI0QkZRTVJOQ1l2QVM0Qkl4VU9BUWNoTGdFbk5TTVJNelUrQVRjaEhnRVhGU00xSVJVQk5DWXJBU0lHSFFFVUZqc0JNalkxQTZRQkhSZjlJUllkQVFFZEZnSDhGeklSbVJBVlJnc0ZtZ2NZQ1FFZEYvN0ZGaDBCUmtZQkhSWUJ4eGNkQVViK1hBRVlDZ2hwQndvS0Iya0lDaEVYSFFFQkhSY0MzeFlkQVJVUW1SRXlGLzRXQWVvSkdRYWFCZ3JqRngwQkFSMFg0LzFFNUJZZEFRRWRGdVRTMGdLckJ3b0tCNjhJQ2dvSUFBQUFBd0FBLzhBRHdBTkFBQXNBRndBYkFBQUJCeGMzSnpjWEJ5Y0hGemNCRndjbk54YzNKd2NCTnljakFSY0JBbTMxWlVRaWJzdHRJa1JtOWY0ZkltN0xiU0pFWnZVQlUvVmx6QUVQUlA3eEEwRDFaa1FpYmN0dUlrUmw5ZjdxSW0zTGJpSkVaZlgrcmZWbUFROUUvdkVBQUFVQUFBQUFBOEFEQUFBREFBY0FEUUFPQUJjQUFCTVJJUkVESVFFWE5TY0JJeEVoQlNNZUFUSTJOQ1lpQmtBRGdHRCtDQUVmMmRuK1dVQUN3UDNnTUFFYktCc2JLQnNEQVAwQUF3RDlZQUVnMllqWi9sZ0NRS0FVR3hzb0d4c0FBQU1BQUFBQUE5NEN0QUFGQUFzQUR3QUFFd01UTXdNVElTTVRBek1UQVRNVEk5U3lzbmF5c2dIaWRyS3lkN0g5bTJxa2FnS3ovczMrelFFekFUUCt6ZjdOQVRQK3pRSm1BQVlBQUFBQUE4QUM0QUFEQUFjQUN3QVBBQk1BRndBQUFTRVZJUkVoRlNFUklSVWhBek1WSXhVekZTTVZNeFVqQVFBQ3dQMUFBc0Q5UUFMQS9VREFZR0JnWUdCZ0FiQmdBWkJnL2dCZ0FzQmcwR0RRWUFBQUFBQUdBQUFBQUFQQUF2QUFBd0FIQUFzQUVRQWVBQ2dBQUFFaEZTRVJJUlVoRVNFVklRTXpOU01WTXdNVk14VWpGVE1WSXhVek5TTVROU01WTXdjVk16VWpBUUFDd1AxQUFzRDlRQUxBL1VDUUlFQWdNRUFvS0VCZ0lDQmdNek5nUUFHd1lBR1FZUDRBWUFKUWdDRDl3Q0FQSUJFZ2dBRVFJQ0F6TFNBQUFRQUFBQUFEZ3dNa0FCUUFBQUVoTlJjSE5TRU9BUWNlQVJjekZTTXVBU2MrQVFHSUFTek96djdVV1hjQ0FuZFplSGgvcWdNRHFnS3NlS1dsZUFKM1dWbDNBbG9EcW45L3FnQUFBQUVBQUFBQUE2UURKQUFVQUFBQklUVUhGelVoSGdFWERnRUhJeFV6UGdFM0xnRUNlUDdVenM0QkxGbDNBZ0ozV1hoNGY2b0RBNm9DckhpbHBYZ0NkMWxaZHdKYUE2cC9mNm9BQUFBQ0FBQUFBQU54QXRVQUN3QVhBQUFCUGdFM0p3WUhCaDBCSVJFaFBnRTNKd1lIQmgwQklSRUJIQVZKVGo2QlBDMEJFZ0V5QkVwT1BvRThMUUVSQVZSN2dTRmpPbkZWdnVvQktIdUJJV002Y1ZXKzZnRW9BQUFBQXdBQUFBQURpZ0wxQUFrQUZBQW5BQUFCTWpjMk5DY21Ld0VWRXpJM05qVTBKeVlyQVJFRElUSVhGaFVVQndZSEZoY1dGUlFIQmlNaEFtcy9JamM2SVVDeDFWc25HRWNsUDhSZ0FUbUFOaUFuRlNZNEhERXNRcEQrekFHNkVSeVNHUS9uL3FjMklqQlNIUkQrK1FLVVRpNDlSaTRZRXhZY01GWklPbGdBQUFBREFBRC8vZ1BDQXdJQUR3QXlBRjRBQUFFeUZoMEJGQVlqSVNJbVBRRTBOak0zSmljbU5UUTJNeklYRmhjV0Z4WVZGQThCTHdFbUp5WWpJZ1lWRkJZWEZoY1dGd2N6RmhVVUJ3WUhCZ2NHQndZaklpOEJKaWNtUFFFMEp5WS9BVFUzSHdFV0Z4NENNekkrQVRVMEp5WURzZ2NKQ1FmOG5BY0pDUWZqRGd3WWhvTVpPaUkzQlFZSEF3WXFCeGtiTEQwNVJFSnJJelFkRTNmUEF4UU1HQk1rS0NVb1Bqa3BSaDBIQkFFQkFRRXpEd3dEQXhFdFBDVWdUQzhwRVFHQUNRY2dCd2tKQnlBSENTQVNGakl0VzRBS0JoSVRLRDRlQ1E0QkF3RkxIQzA2TENWRElBb1hEZ3lBRkJzM014d1lFaGNZQ1FzTUZBZ0dCQWNITmhnUEV4TVdBU1FjQ2dRY0pSVWFQU0lxSlE0QUFBRUFBQUFBQXRjQjB3QUNBQUFCSVJjQzEvNVMxd0hUMFFBQUFBQUNBQUFBQUFOa0F1UUFGd0E3QUFBQkl5NEJORFk3QVRJV0hRRVVCaUltSnpVQkJpSW1ORGNGUGdFeUZoMEJEZ0VISVM0Qkp4RStBVGN6TWhZVUJnY2pJZ1lWRVJRV015RXlOalVDOW5VTkV4TU53dzBURXhzU0FmN3lDaG9UQ1FFOEFSSWJFd0UzS2YzNktUY0JBVGNwd3c0U0VnN0REaElTRGdJR0RoSUNvd0VTR3hNVERjTU5FeE1OZGY3eENSTWFDbFlPRWhJT3dpazNBUUUzS1FJR0tUY0JFeHNTQVJJTy9mb09FaElPQUFJQUFQLzBBM0lEREFBREFDUUFBRGNoRlNFUklSVVBBUkVVRmpNeU5qVVJMd0UxTXhVUEFSRVVCaU1pSmljdUFUVVJMd0dQQXR2OUpRRTdSUTlVWDFkUEVVWDRRdytJbVZCNEl4b1dEMFV4UFFNWU1RUU8vcWxqVkZwbUFVb1JCVEV4QlJIK3JJbDZLaVlmVDBvQlV3NEVBQUFBQVFBQS85b0MyQU1tQUNzQUFBRTJKaWNtTlRRL0FSNEJNekkyTnhZVkZBY09BUWNEQmhZWEZoVVVCeVluSmlNaUJnY21OVFEzUGdFM0FnZ0ZHaWtUQWdNbFN5QWJUQ0lERWlraEJYNEZIQ3NSQXljbkl5UWJTeUlFRVNna0JRTEhHaGdGQkJFRUJBc0VCQVFFRFFZVEFRUWFHdjF5R2hjR0JBOElEUVFCQXdRRURRZ1BBd1lZR2dBQUFBQUJBQUFBQUFPTUFjSUFEQUFBQVJRR0l5RWlKalEyTXlFeUZnT01HaFA5UWhNYUdoTUN2aE1hQVpVVEdSa25HUmtBQUFBQUNnQUEvK3dEd2dNQkFCQUFGQUFZQUJ3QUlBQXBBQzRBTndBN0FEOEFBQUVoTWhZVkVSUUdKeUVpSmpVUk5EWXpFeU1WTXdVMUl4VWxNelVqSlJVek5RVVdOekkyTlRZbkl3VXpOU01WSnpVakJoY1VGak1XTnpNMUl3VTFJeFVDQWdHRUlSc2JJUHp3SGhzYkh1SGc0QUVYM2dFVzRPRDkwdDhCVDIxcEF3Z0JBZUgrNmVEZ09PRUJBZ29FWjZQZjN3SDMzd01CSENEOVpTRWRBUnNmQXFJZEcvMi9tQUdZbUFHWXk1YVdtQUVCQndSSFJaV1Zsc3FZUmtJRUN3RURsWmFXbGdBQUFBQUVBQUQvOHdPTkF3MEFFd0FuQURzQVR3QUFBVGMySmk4QkpnWWZBUjRCUHdFWEZqOEJOaWNYRmo4QkZ4WTJQd0UySmc4QkRnRWZBUWNHRndFdUFROEJKeVlQQVFZZkFRY0dGaDhCRmpZbkFTWVBBU2NtQmc4QkJoWS9BVDRCTHdFM05pY0JCaklFQkFhMEJBWUJGUUVKQlRHWEJnWXdCUVgyQmdhWE1RVUpBUlVCQmdTMEJnUUVNcGNGQlFFVEFRa0ZNWmNHQmpBRkJaY3lCQVFHdEFRR0FmM2lCZ2FYTVFVSkFSVUJCZ1MwQmdRRU1wY0ZCUUsyTVFVSkFSVUJCZ1MwQmdRRU1wY0ZCVEFHQmp3RkJaY3lCQVFHdEFRR0FSVUJDUVV4bHdZRy9wOEdCQVF5bHdVRk1BWUdsekVGQ1FFVkFRWUVBUjhGQlpjeUJBUUd0QVFHQVJVQkNRVXhsd1lHQUFBQUFBQVNBTjRBQVFBQUFBQUFBQUFWQUFBQUFRQUFBQUFBQVFBTEFCVUFBUUFBQUFBQUFnQUhBQ0FBQVFBQUFBQUFBd0FMQUNjQUFRQUFBQUFBQkFBTEFESUFBUUFBQUFBQUJRQUxBRDBBQVFBQUFBQUFCZ0FMQUVnQUFRQUFBQUFBQ2dBckFGTUFBUUFBQUFBQUN3QVRBSDRBQXdBQkJBa0FBQUFxQUpFQUF3QUJCQWtBQVFBV0FMc0FBd0FCQkFrQUFnQU9BTkVBQXdBQkJBa0FBd0FXQU44QUF3QUJCQWtBQkFBV0FQVUFBd0FCQkFrQUJRQVdBUXNBQXdBQkJBa0FCZ0FXQVNFQUF3QUJCQWtBQ2dCV0FUY0FBd0FCQkFrQUN3QW1BWTBLUTNKbFlYUmxaQ0JpZVNCcFkyOXVabTl1ZEFwMkxXMWtMV1ZrYVhSdmNsSmxaM1ZzWVhKMkxXMWtMV1ZrYVhSdmNuWXRiV1F0WldScGRHOXlWbVZ5YzJsdmJpQXhMakIyTFcxa0xXVmthWFJ2Y2tkbGJtVnlZWFJsWkNCaWVTQnpkbWN5ZEhSbUlHWnliMjBnUm05dWRHVnNiRzhnY0hKdmFtVmpkQzVvZEhSd09pOHZabTl1ZEdWc2JHOHVZMjl0QUFvQVF3QnlBR1VBWVFCMEFHVUFaQUFnQUdJQWVRQWdBR2tBWXdCdkFHNEFaZ0J2QUc0QWRBQUtBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dCU0FHVUFad0IxQUd3QVlRQnlBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dCMkFDMEFiUUJrQUMwQVpRQmtBR2tBZEFCdkFISUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F3QUhZQUxRQnRBR1FBTFFCbEFHUUFhUUIwQUc4QWNnQkhBR1VBYmdCbEFISUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FITUFkZ0JuQURJQWRBQjBBR1lBSUFCbUFISUFid0J0QUNBQVJnQnZBRzRBZEFCbEFHd0FiQUJ2QUNBQWNBQnlBRzhBYWdCbEFHTUFkQUF1QUdnQWRBQjBBSEFBT2dBdkFDOEFaZ0J2QUc0QWRBQmxBR3dBYkFCdkFDNEFZd0J2QUcwQUFBQUFBZ0FBQUFBQUFBQUtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZUFRSUJBd0VFQVFVQkJnRUhBUWdCQ1FFS0FRc0JEQUVOQVE0QkR3RVFBUkVCRWdFVEFSUUJGUUVXQVJjQkdBRVpBUm9CR3dFY0FSMEJIZ0VmQUFkd2NtVjJhV1YzRFhKbFpuSmxjMmd0Y21sbmFIUU1jbVZtY21WemFDMXNaV1owQjNwdmIyMHRhVzRJZW05dmJTMXZkWFFEZEc5akJITjVibU1GWlcxdmFta0lZMmhsWTJ0aWIzZ0ZZMnhsWVhJRGRHbHdCSE5oZG1VRWJHbHVhd05wYldjRVkyOWtaUUoxYkFKdmJBUnlaV1J2QkhWdVpHOEZjWFZ2ZEdVRVltOXNaQTF6ZEhKcGEyVjBhSEp2ZFdkb0NtRnljbTkzTFdSdmQyNExiM0JsYmkxcGJpMXVaWGNLZFc1a1pYSXRiR2x1WlFacGRHRnNhV01LYUc5eWFYcHZiblJoYkFWMFlXSnNaUXBtZFd4c2MyTnlaV1Z1QUFBPSk7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0O2Jhc2U2NCxsQmtBQU9BWUFBQUJBQUlBQUFBQUFBSUFCUU1BQUFBQUFBQUJBSkFCQUFBQUFFeFFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQWFHUG5Md0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQllBZGdBdEFHMEFaQUF0QUdVQVpBQnBBSFFBYndCeUFBQUFEZ0JTQUdVQVp3QjFBR3dBWVFCeUFBQUFGZ0JXQUdVQWNnQnpBR2tBYndCdUFDQUFNUUF1QURBQUFBQVdBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dBQUFBQUFBQUVBQUFBTEFJQUFBd0F3UjFOVlFyRCtzKzBBQUFFNEFBQUFRazlUTHpJOGZFMGVBQUFCZkFBQUFGWmpiV0Z3RXp0ZTVnQUFBa3dBQUFPUVoyeDVaaEtKQjV3QUFBWWNBQUFPK0dobFlXUVk4TXF4QUFBQTRBQUFBRFpvYUdWaEI5NEVFQUFBQUx3QUFBQWthRzEwZUhoeEFBQUFBQUhVQUFBQWVHeHZZMkU1ZERZV0FBQUYzQUFBQUQ1dFlYaHdBVElBYXdBQUFSZ0FBQUFnYm1GdFpZQTJZRzhBQUJVVUFBQUNrWEJ2YzNTdjBuL1FBQUFYcUFBQUFUZ0FBUUFBQTREL2dBQmNCSEVBQUFBQUJBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFCNEFBUUFBQUFFQUFDL25ZMmhmRHp6MUFBc0VBQUFBQUFEYTZNTmFBQUFBQU5yb3cxb0FBUCtDQkFBRGZnQUFBQWdBQWdBQUFBQUFBQUFCQUFBQUhnQmZBQW9BQUFBQUFBSUFBQUFLQUFvQUFBRC9BQUFBQUFBQUFBRUFBQUFLQUI0QUxBQUJSRVpNVkFBSUFBUUFBQUFBQUFBQUFRQUFBQUZzYVdkaEFBZ0FBQUFCQUFBQUFRQUVBQVFBQUFBQkFBZ0FBUUFHQUFBQUFRQUFBQUFBQVFRRUFaQUFCUUFJQW9rQ3pBQUFBSThDaVFMTUFBQUI2d0F5QVFnQUFBSUFCUU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVVHWkZaQUJBNWdicktBT0EvNEFBWEFPQUFJQUFBQUFCQUFBQUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkhFQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQUFBQUJRQUFBQU1BQUFBc0FBQUFCQUFBQWlRQUFRQUFBQUFCSGdBREFBRUFBQUFzQUFNQUNnQUFBaVFBQkFEeUFBQUFLZ0FnQUFRQUN1WUc1Z3ptRHVZUjVoam1KT1pCNW5EbWUrYXo1dXptOGViKzV3TG5CK2NSNTBEbndlang2eWovL3dBQTVnYm1ET1lPNWhEbUZPWWo1a0htY09aNzVyUG03T2J3NXY3bkF1Y0g1dy9uUU9mQjZQSHJLUC8vQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQ29BS2dBcUFDb0FMQUEwQURZQU5nQTJBRFlBTmdBMkFEZ0FPQUE0QURnQVBBQThBRHdBUEFBQUFCMEFIQUFiQUJvQUdRQUNBQU1BQkFBRkFBRUFGd0FNQUJnQUJ3QUlBQlFBQ2dBVEFCSUFEUUFPQUE4QUZnQVFBQkVBQ1FBVkFBc0FCZ0FBQVFZQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBREFBQUFBQUJiQUFBQUFBQUFBQWRBQURtQmdBQTVnWUFBQUFkQUFEbURBQUE1Z3dBQUFBY0FBRG1EZ0FBNWc0QUFBQWJBQURtRUFBQTVoQUFBQUFhQUFEbUVRQUE1aEVBQUFBWkFBRG1GQUFBNWhRQUFBQUNBQURtRlFBQTVoVUFBQUFEQUFEbUZnQUE1aFlBQUFBRUFBRG1Gd0FBNWhjQUFBQUZBQURtR0FBQTVoZ0FBQUFCQUFEbUl3QUE1aU1BQUFBWEFBRG1KQUFBNWlRQUFBQU1BQURtUVFBQTVrRUFBQUFZQUFEbWNBQUE1bkFBQUFBSEFBRG1ld0FBNW5zQUFBQUlBQURtc3dBQTVyTUFBQUFVQUFEbTdBQUE1dXdBQUFBS0FBRG04QUFBNXZBQUFBQVRBQURtOFFBQTV2RUFBQUFTQUFEbS9nQUE1djRBQUFBTkFBRG5BZ0FBNXdJQUFBQU9BQURuQndBQTV3Y0FBQUFQQUFEbkR3QUE1dzhBQUFBV0FBRG5FQUFBNXhBQUFBQVFBQURuRVFBQTV4RUFBQUFSQUFEblFBQUE1MEFBQUFBSkFBRG53UUFBNThFQUFBQVZBQURvOFFBQTZQRUFBQUFMQUFEcktBQUE2eWdBQUFBR0FBQUFBQUJZQUpvQTNBRTRBWUlCd0FINEFrNENmZ0xJQXZJRFhBT1VBOFFENkFRVUJGSUVlQVNlQk1vRkNnV1NCYUFGK0FZeUJuZ0drZ2IyQjN3QUFBQUVBQUFBQUFRQUF0WUFDd0FYQUNNQUx3QUFBUllBRndZQUJ5WUFKellBRnc0QkJ4NEJGejRCTnk0QkJ4NEJGdzRCQnk0Qkp6NEJGdzRCQng0QkZ6NEJOeTRCQWdEeUFRd0NBdjcwOHZMKzlBSUNBUXp5cXVJcEtlS3FxdUlwS2VLcVgzOENBbjlmWDM4Q0FuOWZSRm9DQWxwRVJGb0NBbG9DMVJiK3pCWVcvc3dXRmdFMEZoWUJOQ29MejBaR3p3c0x6MFpHenpVQ2YxOWZmd0lDZjE5ZmZ6NENXa1JFV2dJQ1drUkVXZ0FBQUFFQUFQKytBOElEVWdBb0FBQUJOVFEyTWhZWEZRNEJCeU11QVRRMk93RXVBUWNPQVJjZUFSYytBVGN6RGdFSExnRW5QZ0lFQXpFVkh4WUJBUllQcmhFVkZSRnRYUGQwYzJVZklzYURuOU1GU3dYK3Y3LytCUUdQK2dFREFzdzZFUlVWRWE0UEZRSUNGUjhWWUNrOFFPV0JmNWtEQk5TZnYvNEZCZjYvaU54dEt3QUFBQUVBQVArK0E4TURVZ0FwQUFBVE16SVdGQVlISXk0QlBRRTBOaklXSFFFMkpCY2VBUmNPQVFjdUFTY3pIZ0VYUGdFM0xnRW5KZ2JyYlJFVkZSR3VFUlVWSVJWbEFRTjlmWkFCQmY2L3YvNEZTd1RVbjUvVEJRR0JiVzdlQW4wVkh4WUJBUllQcmhFVkZSRTZXaXMwT2R5SXYvNEZCZjYvbjlRRUJOU2ZkcnNzS1RJQUFBTUFBUCsrQThJRFJnQVNBQjRBT2dBQUpSY1dGQVlpTHdFR0pDY21FamMySkJjV0VnVStBVGN1QVNjT0FRY2VBUk0xTkRZeUZoMEJNeklXRkFZckFSVVVCaUltUFFFaklpWTBOak1ETjRJSkZCb0tnb3IrcjN4MkJueUJBVkNHZ0JUK1Jwek9CQVRPbkp6TkJBVE5leE1kRTJNUEV4TVBZeE1kRTJRT0V4TU9lSUlLR2hRSmduRVVnSVlCVUlGOEJuWjgvcS9lQk02Y25NMEVCTTJjbk00QmkyUU9FeE1PWkJNZEUyTVBFeE1QWXhNZEV3QUFBQUFEQUFEL3ZnUENBMFlBRWdBZUFDb0FBQ1VYRmhRR0lpOEJCaVFuSmhJM05pUVhGaElGUGdFM0xnRW5EZ0VISGdFVElUSVdGQVlqSVNJbU5EWURONElKRkJvS2dvcityM3gyQm55QkFWQ0dnQlQrUnB6T0JBVE9uSnpOQkFUTkZ3RUtEeE1URC83MkRoTVRlSUlLR2hRSmduRVVnSVlCVUlGOEJuWjgvcS9lQk02Y25NMEVCTTJjbk00Qml4TWRFeE1kRXdBQUJBQUEvOWNEcVFNcEFBTUFCd0FYQUNRQUFCTVJJUkVsSVRVaEp5RXlGaFVSRkFZaklTSW1OUkUwTmhNeUZoY1JEZ0VpSmljUlBnRzJBcFQ5YkFLVS9Xd3ZBdklVR3hzVS9RNFVHeHZRRkJzQkFSc29HZ0VCR3dJTi9pa0IxMTllWGhzVS9RNFVHeHNVQXZJVUcvNjJHeFQrNVJRYUdoUUJHeFFiQUFJQUFQK0NBMjBEZmdBUEFCOEFBQUUxQnhjMUhnRVhGQWNYUGdFMUxnRURMZ0VuTmpjbkRnRVZIZ0VYRlRjbkFnQzJ0blNhQXlCQ0hCMEV6cHAwbWdNQkgwSWNIUVRPbXJhMkF2T0x1cm1MQTUxMlJqeERMR00ybmRMOWV3T2Rka1k4UXlwbE5wM1NCSXU2dVFBQUFBQUZBQUQvbWdQbUEyWUFDd0FYQUNBQUtRQXdBQUFGSmdBbk5nQTNGZ0FYQmdBRERnRUhIZ0VYUGdFM0xnRVRJaVkwTmpJV0ZBWWhJaVkwTmpJV0ZBWUhIZ0VYUGdFM0FnRE8vdTRGQlFFU3pzNEJFZ1VGL3U3T3BOd0VCTnlrcE53RUJOd2VGaG9hTEJvYS9tWVdHaG9zR2hvV0FtNVNVbTRDWlFVQkVzN09BUklGQmY3dXpzNys3Z05rQk55a3BOd0VCTnlrcE56K3NSb3NHaG9zR2hvc0dob3NHbUpTYmdJQ2JsSUFBd0FBLzhzRHRRTTFBQThBRXdBWkFBQVRJVElXRlJFVUJpTWhMZ0VuRVRRMkZ4RWhFUUVuTnhjQkYzd0RDQlFkSFJUOCtCVWJBUjFFQXFqK2ZNNUVpZ0VTUlFNMUhSVDgrQlFkQVJzVkF3Z1VIV0g5V0FLby9lck9SSWtCRTBVQUJRQUEvNzREd3dObEFBQUFEQUFlQUNJQUp3QUFOek1oTWgwQkZDTWhJajBCTkRjWEZqTWhNamNCTmlZbkFTWUdCd0VHRmdrQkF3RUhBUWNoSjA4SkExQUpDZnl3Q1ErVERoRUJaeGdQQVJFVEJ4bitveG85RmY1NEV3Z0IwUUZVMFA2ck1nRlZBdjYwaGhBSlB3a0pQd25TY3dvVEFWMGFQUlVCRUJRSUdmNExHajhDR1A3Mi92VUJDa0QrOVFGcEFBQUFBQUlBQVArNEE4Z0RTQUFTQUJrQUFCTWhNaFlWRVJRR0t3RUhKeU1pSmpVUk5EWVhFVE1YTnpNUmxBTFlKalUxSnJhMnRyWW1OVFVtM0pDUTNBTkhOU2I5M2lZMXRyWTFKZ0lpSmpWYi9kNlFrQUlpQUFRQUFQL2NBNlFESkFBVEFERUFOUUJGQUFBbERnRUhJUzRCSnhFK0FUY2hNaFlmQVI0QkZRTVJOQ1l2QVM0Qkl4VU9BUWNoTGdFbk5TTVJNelUrQVRjaEhnRVhGU00xSVJVQk5DWXJBU0lHSFFFVUZqc0JNalkxQTZRQkhSZjlJUllkQVFFZEZnSDhGeklSbVJBVlJnc0ZtZ2NZQ1FFZEYvN0ZGaDBCUmtZQkhSWUJ4eGNkQVViK1hBRVlDZ2hwQndvS0Iya0lDaEVYSFFFQkhSY0MzeFlkQVJVUW1SRXlGLzRXQWVvSkdRYWFCZ3JqRngwQkFSMFg0LzFFNUJZZEFRRWRGdVRTMGdLckJ3b0tCNjhJQ2dvSUFBQUFBd0FBLzhBRHdBTkFBQXNBRndBYkFBQUJCeGMzSnpjWEJ5Y0hGemNCRndjbk54YzNKd2NCTnljakFSY0JBbTMxWlVRaWJzdHRJa1JtOWY0ZkltN0xiU0pFWnZVQlUvVmx6QUVQUlA3eEEwRDFaa1FpYmN0dUlrUmw5ZjdxSW0zTGJpSkVaZlgrcmZWbUFROUUvdkVBQUFVQUFBQUFBOEFEQUFBREFBY0FEUUFPQUJjQUFCTVJJUkVESVFFWE5TY0JJeEVoQlNNZUFUSTJOQ1lpQmtBRGdHRCtDQUVmMmRuK1dVQUN3UDNnTUFFYktCc2JLQnNEQVAwQUF3RDlZQUVnMllqWi9sZ0NRS0FVR3hzb0d4c0FBQU1BQUFBQUE5NEN0QUFGQUFzQUR3QUFFd01UTXdNVElTTVRBek1UQVRNVEk5U3lzbmF5c2dIaWRyS3lkN0g5bTJxa2FnS3ovczMrelFFekFUUCt6ZjdOQVRQK3pRSm1BQVlBQUFBQUE4QUM0QUFEQUFjQUN3QVBBQk1BRndBQUFTRVZJUkVoRlNFUklSVWhBek1WSXhVekZTTVZNeFVqQVFBQ3dQMUFBc0Q5UUFMQS9VREFZR0JnWUdCZ0FiQmdBWkJnL2dCZ0FzQmcwR0RRWUFBQUFBQUdBQUFBQUFQQUF2QUFBd0FIQUFzQUVRQWVBQ2dBQUFFaEZTRVJJUlVoRVNFVklRTXpOU01WTXdNVk14VWpGVE1WSXhVek5TTVROU01WTXdjVk16VWpBUUFDd1AxQUFzRDlRQUxBL1VDUUlFQWdNRUFvS0VCZ0lDQmdNek5nUUFHd1lBR1FZUDRBWUFKUWdDRDl3Q0FQSUJFZ2dBRVFJQ0F6TFNBQUFRQUFBQUFEZ3dNa0FCUUFBQUVoTlJjSE5TRU9BUWNlQVJjekZTTXVBU2MrQVFHSUFTek96djdVV1hjQ0FuZFplSGgvcWdNRHFnS3NlS1dsZUFKM1dWbDNBbG9EcW45L3FnQUFBQUVBQUFBQUE2UURKQUFVQUFBQklUVUhGelVoSGdFWERnRUhJeFV6UGdFM0xnRUNlUDdVenM0QkxGbDNBZ0ozV1hoNGY2b0RBNm9DckhpbHBYZ0NkMWxaZHdKYUE2cC9mNm9BQUFBQ0FBQUFBQU54QXRVQUN3QVhBQUFCUGdFM0p3WUhCaDBCSVJFaFBnRTNKd1lIQmgwQklSRUJIQVZKVGo2QlBDMEJFZ0V5QkVwT1BvRThMUUVSQVZSN2dTRmpPbkZWdnVvQktIdUJJV002Y1ZXKzZnRW9BQUFBQXdBQUFBQURpZ0wxQUFrQUZBQW5BQUFCTWpjMk5DY21Ld0VWRXpJM05qVTBKeVlyQVJFRElUSVhGaFVVQndZSEZoY1dGUlFIQmlNaEFtcy9JamM2SVVDeDFWc25HRWNsUDhSZ0FUbUFOaUFuRlNZNEhERXNRcEQrekFHNkVSeVNHUS9uL3FjMklqQlNIUkQrK1FLVVRpNDlSaTRZRXhZY01GWklPbGdBQUFBREFBRC8vZ1BDQXdJQUR3QXlBRjRBQUFFeUZoMEJGQVlqSVNJbVBRRTBOak0zSmljbU5UUTJNeklYRmhjV0Z4WVZGQThCTHdFbUp5WWpJZ1lWRkJZWEZoY1dGd2N6RmhVVUJ3WUhCZ2NHQndZaklpOEJKaWNtUFFFMEp5WS9BVFUzSHdFV0Z4NENNekkrQVRVMEp5WURzZ2NKQ1FmOG5BY0pDUWZqRGd3WWhvTVpPaUkzQlFZSEF3WXFCeGtiTEQwNVJFSnJJelFkRTNmUEF4UU1HQk1rS0NVb1Bqa3BSaDBIQkFFQkFRRXpEd3dEQXhFdFBDVWdUQzhwRVFHQUNRY2dCd2tKQnlBSENTQVNGakl0VzRBS0JoSVRLRDRlQ1E0QkF3RkxIQzA2TENWRElBb1hEZ3lBRkJzM014d1lFaGNZQ1FzTUZBZ0dCQWNITmhnUEV4TVdBU1FjQ2dRY0pSVWFQU0lxSlE0QUFBRUFBQUFBQXRjQjB3QUNBQUFCSVJjQzEvNVMxd0hUMFFBQUFBQUNBQUFBQUFOa0F1UUFGd0E3QUFBQkl5NEJORFk3QVRJV0hRRVVCaUltSnpVQkJpSW1ORGNGUGdFeUZoMEJEZ0VISVM0Qkp4RStBVGN6TWhZVUJnY2pJZ1lWRVJRV015RXlOalVDOW5VTkV4TU53dzBURXhzU0FmN3lDaG9UQ1FFOEFSSWJFd0UzS2YzNktUY0JBVGNwd3c0U0VnN0REaElTRGdJR0RoSUNvd0VTR3hNVERjTU5FeE1OZGY3eENSTWFDbFlPRWhJT3dpazNBUUUzS1FJR0tUY0JFeHNTQVJJTy9mb09FaElPQUFJQUFQLzBBM0lEREFBREFDUUFBRGNoRlNFUklSVVBBUkVVRmpNeU5qVVJMd0UxTXhVUEFSRVVCaU1pSmljdUFUVVJMd0dQQXR2OUpRRTdSUTlVWDFkUEVVWDRRdytJbVZCNEl4b1dEMFV4UFFNWU1RUU8vcWxqVkZwbUFVb1JCVEV4QlJIK3JJbDZLaVlmVDBvQlV3NEVBQUFBQVFBQS85b0MyQU1tQUNzQUFBRTJKaWNtTlRRL0FSNEJNekkyTnhZVkZBY09BUWNEQmhZWEZoVVVCeVluSmlNaUJnY21OVFEzUGdFM0FnZ0ZHaWtUQWdNbFN5QWJUQ0lERWlraEJYNEZIQ3NSQXljbkl5UWJTeUlFRVNna0JRTEhHaGdGQkJFRUJBc0VCQVFFRFFZVEFRUWFHdjF5R2hjR0JBOElEUVFCQXdRRURRZ1BBd1lZR2dBQUFBQUJBQUFBQUFPTUFjSUFEQUFBQVJRR0l5RWlKalEyTXlFeUZnT01HaFA5UWhNYUdoTUN2aE1hQVpVVEdSa25HUmtBQUFBQUNnQUEvK3dEd2dNQkFCQUFGQUFZQUJ3QUlBQXBBQzRBTndBN0FEOEFBQUVoTWhZVkVSUUdKeUVpSmpVUk5EWXpFeU1WTXdVMUl4VWxNelVqSlJVek5RVVdOekkyTlRZbkl3VXpOU01WSnpVakJoY1VGak1XTnpNMUl3VTFJeFVDQWdHRUlSc2JJUHp3SGhzYkh1SGc0QUVYM2dFVzRPRDkwdDhCVDIxcEF3Z0JBZUgrNmVEZ09PRUJBZ29FWjZQZjN3SDMzd01CSENEOVpTRWRBUnNmQXFJZEcvMi9tQUdZbUFHWXk1YVdtQUVCQndSSFJaV1Zsc3FZUmtJRUN3RURsWmFXbGdBQUFBQUVBQUQvOHdPTkF3MEFFd0FuQURzQVR3QUFBVGMySmk4QkpnWWZBUjRCUHdFWEZqOEJOaWNYRmo4QkZ4WTJQd0UySmc4QkRnRWZBUWNHRndFdUFROEJKeVlQQVFZZkFRY0dGaDhCRmpZbkFTWVBBU2NtQmc4QkJoWS9BVDRCTHdFM05pY0JCaklFQkFhMEJBWUJGUUVKQlRHWEJnWXdCUVgyQmdhWE1RVUpBUlVCQmdTMEJnUUVNcGNGQlFFVEFRa0ZNWmNHQmpBRkJaY3lCQVFHdEFRR0FmM2lCZ2FYTVFVSkFSVUJCZ1MwQmdRRU1wY0ZCUUsyTVFVSkFSVUJCZ1MwQmdRRU1wY0ZCVEFHQmp3RkJaY3lCQVFHdEFRR0FSVUJDUVV4bHdZRy9wOEdCQVF5bHdVRk1BWUdsekVGQ1FFVkFRWUVBUjhGQlpjeUJBUUd0QVFHQVJVQkNRVXhsd1lHQUFBQUFBQVNBTjRBQVFBQUFBQUFBQUFWQUFBQUFRQUFBQUFBQVFBTEFCVUFBUUFBQUFBQUFnQUhBQ0FBQVFBQUFBQUFBd0FMQUNjQUFRQUFBQUFBQkFBTEFESUFBUUFBQUFBQUJRQUxBRDBBQVFBQUFBQUFCZ0FMQUVnQUFRQUFBQUFBQ2dBckFGTUFBUUFBQUFBQUN3QVRBSDRBQXdBQkJBa0FBQUFxQUpFQUF3QUJCQWtBQVFBV0FMc0FBd0FCQkFrQUFnQU9BTkVBQXdBQkJBa0FBd0FXQU44QUF3QUJCQWtBQkFBV0FQVUFBd0FCQkFrQUJRQVdBUXNBQXdBQkJBa0FCZ0FXQVNFQUF3QUJCQWtBQ2dCV0FUY0FBd0FCQkFrQUN3QW1BWTBLUTNKbFlYUmxaQ0JpZVNCcFkyOXVabTl1ZEFwMkxXMWtMV1ZrYVhSdmNsSmxaM1ZzWVhKMkxXMWtMV1ZrYVhSdmNuWXRiV1F0WldScGRHOXlWbVZ5YzJsdmJpQXhMakIyTFcxa0xXVmthWFJ2Y2tkbGJtVnlZWFJsWkNCaWVTQnpkbWN5ZEhSbUlHWnliMjBnUm05dWRHVnNiRzhnY0hKdmFtVmpkQzVvZEhSd09pOHZabTl1ZEdWc2JHOHVZMjl0QUFvQVF3QnlBR1VBWVFCMEFHVUFaQUFnQUdJQWVRQWdBR2tBWXdCdkFHNEFaZ0J2QUc0QWRBQUtBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dCU0FHVUFad0IxQUd3QVlRQnlBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dCMkFDMEFiUUJrQUMwQVpRQmtBR2tBZEFCdkFISUFWZ0JsQUhJQWN3QnBBRzhBYmdBZ0FERUFMZ0F3QUhZQUxRQnRBR1FBTFFCbEFHUUFhUUIwQUc4QWNnQkhBR1VBYmdCbEFISUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FITUFkZ0JuQURJQWRBQjBBR1lBSUFCbUFISUFid0J0QUNBQVJnQnZBRzRBZEFCbEFHd0FiQUJ2QUNBQWNBQnlBRzhBYWdCbEFHTUFkQUF1QUdnQWRBQjBBSEFBT2dBdkFDOEFaZ0J2QUc0QWRBQmxBR3dBYkFCdkFDNEFZd0J2QUcwQUFBQUFBZ0FBQUFBQUFBQUtBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBZUFRSUJBd0VFQVFVQkJnRUhBUWdCQ1FFS0FRc0JEQUVOQVE0QkR3RVFBUkVCRWdFVEFSUUJGUUVXQVJjQkdBRVpBUm9CR3dFY0FSMEJIZ0VmQUFkd2NtVjJhV1YzRFhKbFpuSmxjMmd0Y21sbmFIUU1jbVZtY21WemFDMXNaV1owQjNwdmIyMHRhVzRJZW05dmJTMXZkWFFEZEc5akJITjVibU1GWlcxdmFta0lZMmhsWTJ0aWIzZ0ZZMnhsWVhJRGRHbHdCSE5oZG1VRWJHbHVhd05wYldjRVkyOWtaUUoxYkFKdmJBUnlaV1J2QkhWdVpHOEZjWFZ2ZEdVRVltOXNaQTF6ZEhKcGEyVjBhSEp2ZFdkb0NtRnljbTkzTFdSdmQyNExiM0JsYmkxcGJpMXVaWGNLZFc1a1pYSXRiR2x1WlFacGRHRnNhV01LYUc5eWFYcHZiblJoYkFWMFlXSnNaUXBtZFd4c2MyTnlaV1Z1QUFBPSNpZWZpeCkgZm9ybWF0KFxcXCJlbWJlZGRlZC1vcGVudHlwZVxcXCIpLHVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtd29mZjI7Y2hhcnNldD11dGYtODtiYXNlNjQsZDA5R01nQUJBQUFBQUF6MEFBc0FBQUFBR09BQUFBeW1BQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUhFSUdWZ0NIRUFxZGVKaFNBVFlDSkFONEN6NEFCQ0FGaFJFSGdqZ2JOQlV6bzdhU2t6Sks5bjg2Ymc2RkNXajFFOGtWVDNsQndRTW13YURLRTRGVlM0WnNIWWpJQVRVdnltb3lpOTJ0YXphcWVjWlJyY2pUTUgxbDQ1K3dLMzdhZ3lmYTcvZG5kdWRlZjZLU01JOUVpNXFhUlpLMFRFbUVBZzFQOHZQL3Y3enFWL085WDhHaUJ6eU5Ud3Z3cGxSbEJGU3V5WFcwY21NRnBKUEZhUjBBQk1ETnJra0JSM2tpZzhKQXhxL3BENEF2dk5ZUWJmUDRvK3BwRzdEUTJZRStHSW5adU1hTWpXV1RxMHhZWlpIbTUrdHQvbjgrTUFjV2dYMWZwNlhWWWZkNkJWTEd2RDNacisxZ2Y0UGpJazRXYVF5QWJXSlVqcmtzZ0lBLzF6N3RabTVTQUQ0b3NWQVZya0tla1VrK0pubTcwM2VjSXk0UitRb0pLQThRWlJFa29FUXBhcHd2UkF5bnZhYzZSU04xU29oTVJCcUdnRkRUbkZSTjIvRXByWVJ0TnN0NXo5OElwNG5od25mY1NJV3h5ajErZm5ocnpzQmQrZm5seVVKQUJzT0owQ1Vlek9xSnZRdng4YlQvaGRKZzRSN09BTk9Ld0lJNVVKZ2ltaVk1dHBielVvZXhKNmQrbUdwVDRjVVZTOG9RY1pPZ1NhOXQzbDcrL29ma2xibThJN2Yvc3NvTG5jYmpTbi9McEk2RlRoQlRFM3B1eVFwZG8xdi9uUWNOZFRWVkZZYWxIS0lrVnVieDVZVnlzaEtTVW9yU01nSUZFUmVTd3RZeFFEWnFUUU92Uk9kYUFSMmtEakJCYWdBYnBBcWdJQldBQjJJQVBvZ0ZCQ0FLQ0VFY1FBUWlnQ3VLRkxpQnhFQUNpanhvQXZHQVhoQWYyQWFTQjk2Q2hNQkhrQnp3Q1NRTC9HY2VFbmhENWlHSk45SjBVbmliaHlMZTJJb1NVQlNBSENRQWpqQVBCYngvbW9jSVh6TFg2endPbXFHQ0xYQUNQY0V0MGZaM3Via1N3ajZUcFpsSjYrSU1WY1p5RFJGdGtrSzAyVXdKYWFheko5TmM3R2piUUZkTko5anBtQjRFWGxxSkVtZVZrUE40VFdYdjUxdFpnZXVxcXB1YkNBdUZtQjVHdVhSdmJrVjlsY3dUcUd3VU9JR3FMRVBVdVNYK04yWDJqK2I4U3ozd245bTJGbzh6MTlVZHArTHJERC9ub0ZndFJvZ1JzeUlwTUJrTzRlbW9FYU0wTDk2MldjcWh6WGQyZjFaUUt5TENXUTAwWVQyQSs0VDE2TkNoeXVhT1BjS21STmhNNVBZdjd2elFNeUsrVmNaZGwybVh0SFVOWlJBaGo1K0hvWG5CUjlWT3kvbEt5c3Vsd3FONjIxV2ljTFVuNlp0TFpaN2lOMkpGdHdROXM4UHRuT285RUdzaEdpTm51NG9GN0lKTEhLZDB0bkl4UDJ2RG5oOEduVmM1LzdqN1g0Ly9aZmFmNFh0RUZRMHVMc2VSS3M5K0hKbDdTU1F3YmM3cGFHb3dSK1pUL1kxY1p3MU1wendJQUlGelRFSU1uVTFSMlVwcmlCMHZxSTgremFzTkgydXBLNnpmVlJlUytJaHFmUUlWSHhFMWp1Ym5xNXZ5aGZsbzI0MzhJN1BoTEtYUFd2b1B4SEpsNjFVMjIzY0pDcjNHL2tRK2ZScmhBSkZXRWZSUmNsQ2Vlc0JhaDBTQ0ZtTWEwWndFRUZPVVdqTmtSR1A2T3AxcDY4b2NhdGRxWEYrcmM2M081WUFOckxZaU1EZFlLbFc5UTNndCt0VlczQmV4WWtiVURGY1VGdEhpRWhtTENtbEpKNjNBRWhVVUw4UTN2WndDd2lGaWhFU1h3aUdMaUIyMXE5NnlSU1pNSTlLOXlST3U1MC9ZZ1BSSWdQeDg0Vm11ZTFrMmhQdHpXN01CMlN1dlN1K3hWcis1U2J1T0NFWFc1Z3ZFNE9QV2VNcGxpNTBEc1NhODR0WGtIZGNiYkpSR3JDa0FNWG1YeStsSnkyZW92ai8xTWpGY2FtMjl0bk5meGpFUW9kQ3lSR2Q2SDAwYnJ1TnNUOTFPWld0MEg0Z0ZzM25oRlRlWFhFVnpHVCtkMkswOXFkTnBhV1I3UnNwVVF1VGVLMnE1VDRpeDduU1B4QVp3K2pVUlowWGdlWnFTU0dvbkozRkpWVE5QNGZ3T2ZseWlYUCtjNlQveVpmbXp1ZlloTk1QZ0V4R3FXakdpcTZBRVpkQkNIaEh2cjgzRVc4QUpCUzNaSTJ3MG5YVlJoM2dUK2NDQjZMTFR4RWhLdXBhdXpmSXBFRmxYYnlhWHprYVduZ0lSdXI3cyt2WGVjOGswTVhKdjNFa2JlWkx6NjJLcEVTUHkwMzVRenB4YTBUSUVXa1VRYWlqQmRxQ2tLcTQvRzFKY2pwVmJHd0VuYUxObkNNYjFNOUVrcGNYQTg0eUdKOWFHT242QlhpL004eW5DZUtOZ2tseVVvemV5aU5IQXk5ZnArRGtiOHVzTkJwNnEwTW1ZTEtQUzZac2FvNkRsa01rMTZOSzg4VGlqVVpDN2s4Qm1mK0xUZ3ZtT2xiNTZ3N2MxMUVmblpVckR3b1ZycUtzTlF5cHhJMGJnS29VSjl3ZW9EV0l4WEVrSkRqK21PRDVWSWdqbVdLSlFoVXMrMk1qTWY3UVJWN2RjZ1dyS3FyN0xXcU5iNHRWUG5iV1NFU2RNbzVHRjhQSVYvTUowL01GLy93NktIejloNUFvbVRML3phemppRFY3M2FWcGJ5bG1Ca3JVUlZVZytMa3BkZ25qM0JmZEZ6TGdESnVSdm1RNFhYcm15RUE1VU85Q3UzVHQ4Z0VaMkx4QUVOM1dOR2pYSlB0amVWTFNvU2NYdEhkaytqcERkcTlYMlpoUEd0WS9zNWFyMjNKc0hyVmJvaDgreldtS2h4YkxLM1dMdG1heG1TcDJrVEhVZFN3YXo2dHg3anRlUWNZTEoxRUVVZGJ3ajJFRy9vYnN4cDFKbnJ1dFg4Wm0zbHVmNlhVamRDRHJBTlRKejZPQmFZUHZjdFQwN2RrOXBSY3p6a2Zha1B3bUoreHhydytCODZ5WHoyTjBZb0h3ekdiWEhVYTFoMHgyQVRXM0ZveWplKzYwVGptKzFBLzJKZWhtOGN3ZmlYNlk0UHJYYUtVdGc5akhPM0dvSGZnMHVSNlBKd2NFQzg3c0IwckZRTXMvQ2MwYStGbC9HWU5XcmRjUEc4SzFXREpzMEVlVW9GQ0NMUlZGUktQR1UwTnZNUzdOYmJxR0RSSS9aNVY3RHg1YXo1cHhLbWZEVmE4UkZZUjdsQWpXZjRwSlBaV2VNR3d3b1dQSk5ENFdIVk9IT0hRSTcxMWE2bDBydnpxQ1g3a3BCbEJ3bFdxb2ZxQ3pFQndTTDZxK1F4ektaUGlZSWxhOWVVMVlyemViNmJzcVRGSWxlK1NScGY5TFRkRW1ucWkyRXAwbVhsMThXcmlXWnlVUGNNTkltc2pXa3BtVGdjVVgrOWF1NkhzTlF6ZkN6WjRkclVBeXJWKzljNG1GaEdwYWJtNUZ0WVRJeFRKVUE0bTBnUU5XaW44NHVOMjlPdFBtdFhDV1hIM1paRkFEWHlzdzBjR1hybGlEVjRmWGpTYW1kbTRQVVFVT1gxUThGdGsxWEg1N3BDSWc1ZEtoYTJ4YzV4UDRTWjJTTHRYS3gyRDllTEdmSnhESjBsVjJ0RmJ1d1FySTRXT3JyZDVDRENldDh1cXpMelNKZFBzVzRqZzVjTVJNbWkzU1ZkbzFBMXF4Qi9DTzRXdENaL3VVT2VmaWVGRzJtT0xaV0d4bmQ1Sk4vOERWSEZnUjdVcmNmSENvRFEvZkVzNGZOTmpIbFcxNWNMUzZyYnc3SVRYTE1qajlPcXBvVHFRM04vQmVicEVuT2JkL0hLa3paazFBME13UkVTN1NraVNTeHM5VmxibzlkTHUxbzlpMGJOM0tNM1JQcFZVNHMwamhUZkZXenEwVnA2L2JIUm1LUlB1NEppVU5kdk1Lc0F6cEdYbkIxQ0EvYTF5a0o2MHpwaVl1Y291U2VxZzhta2NKSVRBUVJpSi9zODNLbEhkL3VMazYzZXl2MUhzc0ExeTl2dkg0UmZGdmFkMWppSUdVY1kwaHJIRGowZGdiVFpDKzFueFJkd0VBZEpNeWo1SUZhb25ZZ21TZ2JIR055SE5DTElRRmxFdVU5QXRNRDdzVGVFVVVIS3VDN29ycTh2S3FpckpLQmFVQ0JEL3g1U01RL3pKODBvZHVzNnZSeVg4alBTc3Q3cDRDQWRETFZPTllWeFhPOXNUUW9ka2lIWEI4aWx6MkdrdG8vTFhYbkNzZ2krOVJWUzkwYzBpQTNoc3hDMnNOVFFjUVJQZGZFUFRqU25yUWFpRjF4WXlYcnhQTWs2eit5bmRlNkxIVmE2L3hRL3REMFVBQk05MDE4VVBldTcxbkRBME9XY1RnWURHQUhIaVFCeFNPQjdxSCtvU0g4ak9rUlVPSVM4SFB4QThGUzVJSCt3WGQ5czVZQXdnNTJTSVJxR3krZ0FQSzJFY1pnT0lNaFA5K21WSDZMTG42MndZRER4aEI0MjJCQndEYWVLaUtFYlRBb2xaenFESWF2NDVVNE9UZGVBMGJhYkgrL1F1ZURYQWZBZHRCUm1GdlNZOHNmaFVtQk4rQWE2QlU0bWdhT0NKenJPUnk0OWh6Y0FVTzdrUHJBM1U3RGxNQzdjRGwwVzNFWW1wVnlBQUNRQUJCL0g5bStHWWs4Sk9DakdwUExvY3RITmlQWE5wNk1mTFA5dnc0S2tZbklEZHdWbzBhZUV2aFZDNlN2dm8zY2hCNE1uNG83U3Q1S0hHdS9tQVlaL3lZVUJGeGUwTmhWckpodkM5cWZEdGZjZm5tc3RFeTFqWTZNM2E0NGZKZVNqdUNmZ29pNCtWN3luWHAxUkRNKy9vZmNXUjdUcm1zUjNIUWhOQWExbUIzd3owRlMxdk4xdFF2WklzaG93ejJkYm5qYTA2M0lpQ2hkSUE3ZEppN2RueDZhT2E0OGtuUEpramdBcGg1RzAwWFI0M1FqNldtNlZmUkNsUDZ6bk1FQmpiaFVJcjQ0MmVIVU1MSlZqejlpakVwZ1ZQMVVUbE95OXFmSzZsWkVVOEE0SWY1QzA0ZUtkdzVjZnVnZk9EdEs2bER1SStzdVNPRGhTc20zNWloaWxXV0s2dHh6NHhBQ3FZN3BDaTFsSzlLZGRqc2JhMFdwS1E1V0FHTlVBcVBVejdDMDA1UnNicklDSFlWb1JpTG43K0tFK0F0Tkh5cE9IMEZFL21FNHo4VGd0MGM1S08zenlFV24zRU5lUjVsUFZ6WkhZb3hWVHJLc2pjcjVXaHNFSlVsMEYxOTVoVDZKSzdVZFZuWW5PM01xSzdxODlYWjhPZG1lcklmUnoxRStGSWtsVXBsY29WU3BOVnFkM21BMG1TMVdtOTNoZExrOVhsOHdiMkxjSE81YmhyWDc1clpnMTdTeTJjZy93TXI4UlJRTGx4YmxlMEc5aklYMEpEK1RuaUxTMVMxMEMrMXJla3gxUU1WamNkMGtWemRNZ2t0KzdHSXowV1F3NnNPSXdvUmhhTkluUTlQL25nU1Rtb0xaWm1IbklTMVQzN1NyaWtjeDk4SzRqZEthT3FSTFhWa2szRmN0RExnWXJsVE1uRlRCNlZWTDdGNlUxdnhUVjJZZHNMSjlDRmt6a0FZREFBPT1cXFwiKSBmb3JtYXQoXFxcIndvZmYyXFxcIiksdXJsKGRhdGE6Zm9udC93b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBQS9vQUFzQUFBQUFHT0FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkhVMVZDQUFBQkNBQUFBRE1BQUFCQ3NQNno3VTlUTHpJQUFBRThBQUFBUkFBQUFGWThmRTBlWTIxaGNBQUFBWUFBQUFFNEFBQURrQk03WHVabmJIbG1BQUFDdUFBQUNqQUFBQTc0RW9rSG5HaGxZV1FBQUF6b0FBQUFMd0FBQURZWThNcXhhR2hsWVFBQURSZ0FBQUFlQUFBQUpBZmVCQkJvYlhSNEFBQU5PQUFBQUJJQUFBQjRlSEVBQUd4dlkyRUFBQTFNQUFBQVBnQUFBRDQ1ZERZV2JXRjRjQUFBRFl3QUFBQWRBQUFBSUFFeUFHdHVZVzFsQUFBTnJBQUFBVmNBQUFLUmdEWmdiM0J2YzNRQUFBOEVBQUFBNUFBQUFUaXYwbi9RZUp4allHUmdZT0Jpa0dQUVlXQjBjZk1KWWVCZ1lHR0FBSkFNWTA1bWVpSlFETW9EeXJHQWFRNGdab09JQWdDS0l3TlBBSGljWTJCa1lXR2N3TURLd01IVXlYU0dnWUdoSDBJenZtWXdZdVJnWUdCaVlHVm13QW9DMGx4VEdCeWVzYjNXWUc3NDM4QVF3OXpBMEFBVVpnVEpBUURpU3d3YWVKemRra3RPQWtFUWhyOFpFQlJIbUZGZVBqQW1zQ0NHcFRFdVhNQjlYTERuV0p5QXkveE5BZ3Z3QUdBMU5RdVdyTzNLTi8yWVN2cFJIM0FGVkl5SlVZVjBSR0lqa2xkYlRVN3JGUnFuOVNxL05uL256VVlOMVpTcHFVSjlqVFRUWEFzdHRkVmVoNUNHZWlqQ05LelcrODM0ZUlReU4xZGJ3N1BjWFpuYk9zKzlzQ1YyRG84SkgzeWV4VmNaMzJYQWdCZWVlZUtSMU81U3RSc245TWpvVStlYXR0M3VnWHZ1YU5LaVMwN0JEUjF1cWRrMnRZdFA5SDliRmovSlR6a2J4SG82cDNIbTJCdWpwbU92alhMSDNoMFZqbFVBdFIyckJlbzQwVDkxbmVpZ2VrNTBVMzBudXFpaFEvdy9jdUxwTkhPSXVYUEhhb3NXamxVWkxSM2kvbHNuZXEyZFl3Nmd2V00yb0lOalhoQlN4d3doMUIxemhWQmkxaEJ5aDlnWERyR2ZPdVlVWWVXWVhhejNqbm5HWnV4USt3TXJ3SWNmZUp5RlZ3MXNITVVWbmplenQrczcyM2ZlMjl2ZDg1M1B2aC83MWs0Yy85eDViNGtUMjZkZ0cwb1FpVUtnRUNoeG05Z29VRWZpTDdGS3dFNm9vaENvc0ZyeTI2QlVKYWdRS0Q5cGFyVlVBZ3ZhVWpXSmdSQWEwbHFKQ2RDcWFZVWc0RUJSYnVtYjNiTXhDQ2w3dDI5bTNyeVo5OTJiOTk2OEl3TEJSeUQwYjZTVTZDUkZtZ2tCamVnaWtkTEV5QkhkRDFJMTZKMWdOVGtkSERhQjBRbHorWlNjaHpKSzdVL1BuN2MvcFJUS3poODgyOUJ3OXFCTFZ3OVRPcnphcGQycktGM1Y3VkQ2dG1ZZjFad1gydmc3ci9UMTN0N1hTeDFxenE1WVBkdzVzd0lwUWdWQ3ZueUp2Y0pXa0hvY21HMjVqS2FyQ0NiVkJHMjVSWUFvL2FDN3lMSkZzRlJncldxTkJxQUZucFZWVlI2OCtiTzc3K3F2U2Y3NWdmMXZlWlo2N0pkZnRqM3d5QmZBNk5GMlB2OXNRS1ZVclZIN0doYm5QOWc4dkljSkovYWpDQXB1bXh5Y1A0dmhWY1RRUUlpU3pXZ2hrZXZ2QUk0bUJybGFmZFpTMlJrakdXbnhQNFBPN2tnU2FqK3crKzRiQlZmNVVsU0FVR0R6NFByVDlMNjVVTnRYelc5Yk9Mbk4xYjcvaElDQ0cvN1EySkFoaEJYdDBFdUNwSnEwRTFLbkk0eGtNNGkxUmpwb0lRWXQ2SEUxTzBlbG1DNDRCKzE4VUZFMjNRR3BaTG90bDJYV0ZtOG80dHV5M1g1dTB3WngwMlpZdm5Va1pQZnVteENFaVgzN2pnbkNzWHVWbUxJbW9DaUJOZGhaNjFjVS85QVdYeVRrM1hKSGFHUXJMTis4U2R5d3lYN3U5SXo0dm4wVDhKQWp0bmJ1UXU1cVg4Yzk3OUs0RXh4d0tzR0JYaHFuRGo2dXpMNkF1aStORUNFNXFEQUd2anpKbm1JTmlFN0NLS2pGVTVVVGNsM0NUQmlvWHBWZEFLYmNsbFBRM1dRL0pOT0czQWxqOU5IQ0QvbmJUTStIb3RGUXdZLzBqVkFVSUZvZlFVTEw3UVk0dWZxV1c0cFRJUzVtajBWRDlnZWhTQ1FFMFZDVVVOUzloUTJ5KzBtQTFIQ1BsblFUZlNZa29kdVlUY0RRRGprTFRhRWlVN1VNU3NiRzd0N0w0a3VxWXNMRVh1eEJqZHNkRzZPZlBQVGk3eDlpajIzb1hYeDU0NXJjWThjTDk3cURlZjA0RUhDUzI5K0QrdmF5ZjdJQko5N2o2TUV0eUhSaTNYTGluczJKYklWYm5kcy9NZE1wVGxFeVlYL284VUJ3WWdLQzZKc2ZUaHlZRklUSkF3NnQxaUtSeGtqRUhuQmJqYTVmc1dJOTdaOHJqYXZaMmhsNXBQWUxYSExtK3dNVXgwV09yeHhodjJVbTJrWWhsWGdxczZlQlpzSFQwUEdVd0xCMDBEZXhrbEFzRnJyNHVScUZXRGQ5MHQ0MDBiMGRnajNNNU14UURLSXFsL2grNFFiNlpPSGNSUGVEb1BRNHR1QngzSTkyS1VOdlRCS0RFQ3VieU1RZ2hBZU84V3pwR2c0dHlLVU5TSXNTaUpvWEdFZ2dKWXhsWHJiYzY3MzR2RGZ3TTc4TXQ0WURJQ3RTcGYxNHBFTzFoNVFTZUJOV3ZtRS9uWUhycUgxNGE0VzN5NHZmNDNmNUZQZ2VTa0JGcUtUU0xvMTAwYkI5d1o0R1h4N0pPbjQrM0I5K3gvN0Nyc1Q0bVBPTDU0TmtwRndYMU9Xc2JtWGxSK2s3YWROTWorSEQyOG5SMFVsMmhaa3VuRTZiWTJObW1xTHdUWVhUbzZNMDZmajNKRHZBYXRHS3JjUWtQUmgxZU1xT0VmRXdVVVVOVklQSzVMWjBNMmJRbEZxY05GTnkxdVFDM1BkU1prS0Z0dlI4U0lwb0htMFJaSEltT3dBeHZaREF0QUl4RFM3cUdYbFBoZHBiNnRrcmhiMDRZLzhKWjNwNytkeHJPdmJzbXlIc0sxa24rWHpTdWhLZnJQTmxPajJEUW1yRkhqbWoyeHFjODFhS2UwWGZlKzdjZTRYdTk5M04zejkrbkQ3TkZ6NVg0dk9WRlBQSU9CdG5lY2VQb3hnNWttNmhLMGdHdG9DTmhVTUpMQ01GT3REQjZmN3U1UG9qZzhudWdXbTdacVlIMTA3M0g0VkF0LzB4eTA4UGRDY0hqNnhQZHZkUDIrZG1lNytlSG5EbW5iaEJwZU9NT0RtaW5QaFJxNU1sV0FKMDA0Q1VuUENrcXRFb2JlbWttR2NqZlhZSjFKdzZaZCtZcCtPRnFSYk1DRkg4TWxMQTlZVStpSi9hZHNxK2dlWi9FZUxzcVBON2tKeW1oMUZUS2ZvN1VaaVNaVW9pcGJDc0Fsa2xkZUxRb1EySERzRlpKQnRmS1B6OHRnTzMwZC9ZeCt4amtJV3MyOXJINkFBUlhaeDB5c0ZaNmtRT0lvV0VtcENMTDh1cUtiWDRBa0Y0K1psM3ZNOTU0UGsrR08yelNSOGQ3M3NEUDN6TG1YMC9LdTRyWTd6VWYzTmZFL2RrNnV6MlprcmhISW4zdnE1b05KNlB0K1RyNi9OOThYaGZOdHVYLzBybDhwRjRZVHdlaU12eEVhaUl4N01MNHZ5K1JkMFBvUCtHdUVaVGw4eUVtNlZRalZPT3dEWm94S1J5NHNhTmxHNjhjV2hvK0NCakIra3pRMDg4TVlSajVLNWlCNGVIRDdwM04rNTFZSFl2VExjSjk3WkdwRzQ1TTJTZndFVFZlT205cUxQWEhmUnR4d2NKNEhKRGxEQTgwQnh6K2xEbCtjNDFuWnNYTDRBZ1pJU3IzSzRNSysvZG5GalRmc2QxTDUyRCtqbGRNdU1MMitrMDhTSkt6RW1Rc1hKdEJzYWVxbURQZExyb2VCbGRVME9TS0dsdW0wclEyN3VTVm5zaS84TGJOeG5oSytxNi90Z0hDMGR5Y1VOTlgxYlYycmhrMUQ0S0w4cFZQNjBNL012K1ZTN1pzaUpXWWYrUFBucE5VMGR2VTFqUnFscXV2N0w5aG1KczJYaEhVL1NlRExtRjY4Y29kQzlCWHVSa3JiU1J4bm9paXdCMFIza0FtZ0Y1cWFTb2hoeVdMbVZkYk00bmxYU21jYTJSN2dMVHFnRk5yNmJaREY1eHlHR0hKSzlYdXJpUDAvZjhaZUd0RDFTMkp5MlBLREZ4bmxRWmJleFkyTDNrOWxSYlRObjRPZ3VWaFpYYStycjZ6b1VOdlRGSkFIeXlnVExHNUFXTDYrSlhOemZJTU9LVjRud25KUEdnbGxsdzA0aFBEQ3IxbmRWZVA2YnVwVlVMMmh2ckxvLzdkSC9aU0NocVphdkNRVDNzTFMwTGxZaUNKT1hDV0Q1b1VGdmxFNnJxMUVoSGNsNmR2K2d6OUNTOHhVOGNFam85YWEvQTBadGsxZ2ZXMHZmUkF4YmhiTEVPZFEyR1pZSUpTTnNzTEdrNGEwN1dMWmFOYURFNXhDK1puRWt2M0ZPdUtPV3ZJb2tHd1Q3dml5aGVXQXpCcUFKV1ErR0xCZ3V3ZmRVZkRQb2RRa1Yva0Q3T3A5MDE1ZmZZSDN1VmlPOTZQdm1LSzAxRmJQbHVRWC9oQzg1MzdwZFAyWjJzREU4WjZ4ekxqVjI4dkJBRVlwQ2J3Y3c2UXp5MHRORUVuUE1JL1VlaERoYjFCRmF1L3U0eXVlZnp5d1BiOWl3ZlNrVzBRRTlyQnd1M0NuNzdxVFVyVnczQVZiS250ZFVqMjg4OCtLTjU2WnBsVjhHMWZxRllMLytkdnNQU0JLdG5mcGVpODNUaGpZTUtMZTRsYUJVbXVrN3NPcEdFQWhZdk0wbzhrUWFGc3JxbDhlalZTUlpzU0hqdTkxVE5sNWxocEdxalM1T0NYRi9yb2E5RndoNUJGb1JTQVo5eVVRRWhFaW5jR2RGRklWQlNMZ0JEWmttQWllRUltWTMvaCtFVnZQRUp6RlNXYUgrTlBSeFJDa3VVU0VTaEx5a1IyS0ZVVmhxVmxWemNoL2ovaS9FQXBBTGpNVXlxbkxxcGlWaDQ0bDNjSTl3NzJpaldpSmlzMWF3SE0xOGQ1cjA2VEg0ZXpVTFQ1b3lVaDJkSXZGWkZIYTJ0V1RqaVl2aVg2Y2VKYURSKzhhUHFhTFQ2M2FrcDBFK0ROalZWT0g0R2xnMnVZeVVBNzlyL25wcTY3RjJnUHVIV3g4K2NnYy9PTUtpS0Yvb1RXTmpVMEYvR29vV1hkOE51L0I3WnVYTTNnQ1JjMGJOang4Ni83dTVkSXBRQzI3Rno1MDczYng3NThoUDJFMWFPZDRLQjJKY2hkaXVIZDM1YTVBVkFGK2hhRitRTVRuVXRoOTEwQUQyMkJpUlJ4N0lnZ1A5aEFpRHlJZFlMV2c0cklzNFNrWWNMT2pFRFdNZ1RNNElnSGhaRVVNSHJhZDBsaWkwZXp3VlIzTlhxOFNKTEZBNkxncERaaGFXajh0WDhycGsxaGJQZklrbkh2c2xwRWNYRmMxYk5hTEwzZnpVL3V3dlVmSXNrSWY4SE1yWTVDM2ljWTJCa1lHQUFZdjNuM0FMeC9EWmZHYmhaR0VEZzFvdkRVUWo2ZnhNTEEzTWRrTXZCd0FRU0JRQWxEUXF3QUhpY1kyQmtZR0J1K04vQUVNTlN5QUFFTEF3TWpBeW9RQTRBVWkwQytBQUFlSnhqWVdCZ1lLRTJMaVNzQmdBcyt3RHFBQUFBQUFBQUFGZ0FtZ0RjQVRnQmdnSEFBZmdDVGdKK0FzZ0M4Z05jQTVRRHhBUG9CQlFFVWdSNEJKNEV5Z1VLQlpJRm9BWDRCaklHZUFhU0J2WUhmQUFBZUp4allHUmdZSkJqaUdmZ1lnQUJKaURtQXJQL2cva01BQldoQVo0QUFBQjRuSFdSelVyRFFCU0ZUL3FqbUlBTHhhN0hqWUtTOUdjakZGd1ZXdGNWdW0rVFNacVNaTUprV3VqR04zRGg4L2dVdm9BK2hYdVA2UWlsMkF5NWZPZk1tWnZMQk1BRlB1Rmc5MXp4M2JFRGoyckhEWnhDV0c3U3Y3WGNJZzhzdDhtUGxrL0lUNVpkM09QWnNvZEx2TENEMHpxanVzT2JaUWNkdkZ0dTRCd2ZscHYwdnl5M3lOK1cyK2c0bnVVVDhyVmxGelBud2JLSEcrZlZIV2s1TnpJU2k2MUlRMVhFcWpEdXhzOGpYMGFwVVhvcWszVTIxM3ZPSHM2a3JsSlZpSDdRMjNNbnNwRDZyMmUxU1FiR3hDTFdLaGRqTnBkWnBrU3AxVXFHSmxnYVV3NjczZGo2UWFoeWpqaUNoc1FjaGpYaXRTNndaVTBSUXFGQVhGZkQzQVkrY2liOE9wZlNVenc1cFVxd1JzWU8ra2ptZjNkR3BWRlIvMzVCb0k4QXZTUFpDVlZSNXcvbnJIZ2k0VTgzWERGMXpJeGlCNEd4blZ4eXRvd3NVTlo3S3pvaC9RREwrbFNKSWJwYzhVRStxRzhnL3dFQkNuVTdBSGljYlkxSmRvTXdFRVFwRUlaZ2sza2U3Qk53S0JBTktBZzFhWVJKZlByd2twZGQvcWJlWDFSVkVBYS9aTUgvN0JFaWdrS01EUktrT0VPR0xYYkljWTRMWE9JSzE3akJMZTV3andjODRnblBlTUVyM3JESElVaEdvYU9oSlJkcWhLYXVFTk4yZnZkbmxocWZuSmlId3JqMEozbjJrV2V0cGkrbll4cjQzYVM2STkxWC9CbHJTNlZFM294cUtvK2tySEY5WklaV2FhNHBuRzNJVmduVnJHWlhjL3d4c3lkVnNhM3p5WXZweVhmQ2M5dGxwUWd2UmMyTDIvSklibjB1SEMzWldpSXAxazNhR0Y5YW83T094WnpZclJMN3NyS1VOYk8xa3hZaUZ3VGZGdXBQbUE9PSkgZm9ybWF0KFxcXCJ3b2ZmXFxcIiksdXJsKGRhdGE6Zm9udC90dGY7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdSMU5WUXJEK3MrMEFBQUU0QUFBQVFrOVRMekk4ZkUwZUFBQUJmQUFBQUZaamJXRndFenRlNWdBQUFrd0FBQU9RWjJ4NVpoS0pCNXdBQUFZY0FBQU8rR2hsWVdRWThNcXhBQUFBNEFBQUFEWm9hR1ZoQjk0RUVBQUFBTHdBQUFBa2FHMTBlSGh4QUFBQUFBSFVBQUFBZUd4dlkyRTVkRFlXQUFBRjNBQUFBRDV0WVhod0FUSUFhd0FBQVJnQUFBQWdibUZ0WllBMllHOEFBQlVVQUFBQ2tYQnZjM1N2MG4vUUFBQVhxQUFBQVRnQUFRQUFBNEQvZ0FCY0JIRUFBQUFBQkFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUI0QUFRQUFBQUVBQUMvbkN4QmZEenoxQUFzRUFBQUFBQURhNk1OYUFBQUFBTnJvdzFvQUFQK0NCQUFEZmdBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFBSGdCZkFBb0FBQUFBQUFJQUFBQUtBQW9BQUFEL0FBQUFBQUFBQUFFQUFBQUtBQjRBTEFBQlJFWk1WQUFJQUFRQUFBQUFBQUFBQVFBQUFBRnNhV2RoQUFnQUFBQUJBQUFBQVFBRUFBUUFBQUFCQUFnQUFRQUdBQUFBQVFBQUFBQUFBUVFFQVpBQUJRQUlBb2tDekFBQUFJOENpUUxNQUFBQjZ3QXlBUWdBQUFJQUJRTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUdaRlpBQkE1Z2JyS0FPQS80QUFYQU9BQUlBQUFBQUJBQUFBQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCSEVBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFBQUFBQlFBQUFBTUFBQUFzQUFBQUJBQUFBaVFBQVFBQUFBQUJIZ0FEQUFFQUFBQXNBQU1BQ2dBQUFpUUFCQUR5QUFBQUtnQWdBQVFBQ3VZRzVnem1EdVlSNWhqbUpPWkI1bkRtZSthejV1em04ZWIrNXdMbkIrY1I1MERud2VqeDZ5ai8vd0FBNWdibURPWU81aERtRk9ZajVrSG1jT1o3NXJQbTdPYnc1djduQXVjSDV3L25RT2ZCNlBIcktQLy9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFDb0FLZ0FxQUNvQUxBQTBBRFlBTmdBMkFEWUFOZ0EyQURnQU9BQTRBRGdBUEFBOEFEd0FQQUFBQUIwQUhBQWJBQm9BR1FBQ0FBTUFCQUFGQUFFQUZ3QU1BQmdBQndBSUFCUUFDZ0FUQUJJQURRQU9BQThBRmdBUUFCRUFDUUFWQUFzQUJnQUFBUVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUFBQUFBQmJBQUFBQUFBQUFBZEFBRG1CZ0FBNWdZQUFBQWRBQURtREFBQTVnd0FBQUFjQUFEbURnQUE1ZzRBQUFBYkFBRG1FQUFBNWhBQUFBQWFBQURtRVFBQTVoRUFBQUFaQUFEbUZBQUE1aFFBQUFBQ0FBRG1GUUFBNWhVQUFBQURBQURtRmdBQTVoWUFBQUFFQUFEbUZ3QUE1aGNBQUFBRkFBRG1HQUFBNWhnQUFBQUJBQURtSXdBQTVpTUFBQUFYQUFEbUpBQUE1aVFBQUFBTUFBRG1RUUFBNWtFQUFBQVlBQURtY0FBQTVuQUFBQUFIQUFEbWV3QUE1bnNBQUFBSUFBRG1zd0FBNXJNQUFBQVVBQURtN0FBQTV1d0FBQUFLQUFEbThBQUE1dkFBQUFBVEFBRG04UUFBNXZFQUFBQVNBQURtL2dBQTV2NEFBQUFOQUFEbkFnQUE1d0lBQUFBT0FBRG5Cd0FBNXdjQUFBQVBBQURuRHdBQTV3OEFBQUFXQUFEbkVBQUE1eEFBQUFBUUFBRG5FUUFBNXhFQUFBQVJBQURuUUFBQTUwQUFBQUFKQUFEbndRQUE1OEVBQUFBVkFBRG84UUFBNlBFQUFBQUxBQURyS0FBQTZ5Z0FBQUFHQUFBQUFBQllBSm9BM0FFNEFZSUJ3QUg0QWs0Q2ZnTElBdklEWEFPVUE4UUQ2QVFVQkZJRWVBU2VCTW9GQ2dXU0JhQUYrQVl5Qm5nR2tnYjJCM3dBQUFBRUFBQUFBQVFBQXRZQUN3QVhBQ01BTHdBQUFSWUFGd1lBQnlZQUp6WUFGdzRCQng0QkZ6NEJOeTRCQng0QkZ3NEJCeTRCSno0QkZ3NEJCeDRCRno0Qk55NEJBZ0R5QVF3Q0F2NzA4dkwrOUFJQ0FRenlxdUlwS2VLcXF1SXBLZUtxWDM4Q0FuOWZYMzhDQW45ZlJGb0NBbHBFUkZvQ0Fsb0MxUmIrekJZVy9zd1dGZ0UwRmhZQk5Db0x6MFpHendzTHowWkd6elVDZjE5ZmZ3SUNmMTlmZno0Q1drUkVXZ0lDV2tSRVdnQUFBQUVBQVArK0E4SURVZ0FvQUFBQk5UUTJNaFlYRlE0QkJ5TXVBVFEyT3dFdUFRY09BUmNlQVJjK0FUY3pEZ0VITGdFblBnSUVBekVWSHhZQkFSWVByaEVWRlJGdFhQZDBjMlVmSXNhRG45TUZTd1grdjcvK0JRR1ArZ0VEQXN3NkVSVVZFYTRQRlFJQ0ZSOFZZQ2s4UU9XQmY1a0RCTlNmdi80RkJmNi9pTnh0S3dBQUFBRUFBUCsrQThNRFVnQXBBQUFUTXpJV0ZBWUhJeTRCUFFFME5qSVdIUUUySkJjZUFSY09BUWN1QVNjekhnRVhQZ0UzTGdFbkpnYnJiUkVWRlJHdUVSVVZJUlZsQVFOOWZaQUJCZjYvdi80RlN3VFVuNS9UQlFHQmJXN2VBbjBWSHhZQkFSWVByaEVWRlJFNldpczBPZHlJdi80RkJmNi9uOVFFQk5TZmRyc3NLVElBQUFNQUFQKytBOElEUmdBU0FCNEFPZ0FBSlJjV0ZBWWlMd0VHSkNjbUVqYzJKQmNXRWdVK0FUY3VBU2NPQVFjZUFSTTFORFl5RmgwQk16SVdGQVlyQVJVVUJpSW1QUUVqSWlZME5qTURONElKRkJvS2dvcityM3gyQm55QkFWQ0dnQlQrUnB6T0JBVE9uSnpOQkFUTmV4TWRFMk1QRXhNUFl4TWRFMlFPRXhNT2VJSUtHaFFKZ25FVWdJWUJVSUY4Qm5aOC9xL2VCTTZjbk0wRUJNMmNuTTRCaTJRT0V4TU9aQk1kRTJNUEV4TVBZeE1kRXdBQUFBQURBQUQvdmdQQ0EwWUFFZ0FlQUNvQUFDVVhGaFFHSWk4QkJpUW5KaEkzTmlRWEZoSUZQZ0UzTGdFbkRnRUhIZ0VUSVRJV0ZBWWpJU0ltTkRZRE40SUpGQm9LZ29yK3IzeDJCbnlCQVZDR2dCVCtScHpPQkFUT25Kek5CQVRORndFS0R4TVRELzcyRGhNVGVJSUtHaFFKZ25FVWdJWUJVSUY4Qm5aOC9xL2VCTTZjbk0wRUJNMmNuTTRCaXhNZEV4TWRFd0FBQkFBQS85Y0RxUU1wQUFNQUJ3QVhBQ1FBQUJNUklSRWxJVFVoSnlFeUZoVVJGQVlqSVNJbU5SRTBOaE15RmhjUkRnRWlKaWNSUGdHMkFwVDliQUtVL1d3dkF2SVVHeHNVL1E0VUd4dlFGQnNCQVJzb0dnRUJHd0lOL2lrQjExOWVYaHNVL1E0VUd4c1VBdklVRy82Mkd4VCs1UlFhR2hRQkd4UWJBQUlBQVArQ0EyMERmZ0FQQUI4QUFBRTFCeGMxSGdFWEZBY1hQZ0UxTGdFRExnRW5OamNuRGdFVkhnRVhGVGNuQWdDMnRuU2FBeUJDSEIwRXpwcDBtZ01CSDBJY0hRVE9tcmEyQXZPTHVybUxBNTEyUmp4RExHTTJuZEw5ZXdPZGRrWThReXBsTnAzU0JJdTZ1UUFBQUFBRkFBRC9tZ1BtQTJZQUN3QVhBQ0FBS1FBd0FBQUZKZ0FuTmdBM0ZnQVhCZ0FERGdFSEhnRVhQZ0UzTGdFVElpWTBOaklXRkFZaElpWTBOaklXRkFZSEhnRVhQZ0UzQWdETy91NEZCUUVTenM0QkVnVUYvdTdPcE53RUJOeWtwTndFQk53ZUZob2FMQm9hL21ZV0dob3NHaG9XQW01U1VtNENaUVVCRXM3T0FSSUZCZjd1enM3KzdnTmtCTnlrcE53RUJOeWtwTnorc1Jvc0dob3NHaG9zR2hvc0dtSlNiZ0lDYmxJQUF3QUEvOHNEdFFNMUFBOEFFd0FaQUFBVElUSVdGUkVVQmlNaExnRW5FVFEyRnhFaEVRRW5OeGNCRjN3RENCUWRIUlQ4K0JVYkFSMUVBcWorZk01RWlnRVNSUU0xSFJUOCtCUWRBUnNWQXdnVUhXSDlXQUtvL2VyT1JJa0JFMFVBQlFBQS83NER3d05sQUFBQURBQWVBQ0lBSndBQU56TWhNaDBCRkNNaElqMEJORGNYRmpNaE1qY0JOaVluQVNZR0J3RUdGZ2tCQXdFSEFRY2hKMDhKQTFBSkNmeXdDUStURGhFQlp4Z1BBUkVUQnhuK294bzlGZjU0RXdnQjBRRlUwUDZyTWdGVkF2NjBoaEFKUHdrSlB3blNjd29UQVYwYVBSVUJFQlFJR2Y0TEdqOENHUDcyL3ZVQkNrRCs5UUZwQUFBQUFBSUFBUCs0QThnRFNBQVNBQmtBQUJNaE1oWVZFUlFHS3dFSEp5TWlKalVSTkRZWEVUTVhOek1SbEFMWUpqVTFKcmEydHJZbU5UVW0zSkNRM0FOSE5TYjkzaVkxdHJZMUpnSWlKalZiL2Q2UWtBSWlBQVFBQVAvY0E2UURKQUFUQURFQU5RQkZBQUFsRGdFSElTNEJKeEUrQVRjaE1oWWZBUjRCRlFNUk5DWXZBUzRCSXhVT0FRY2hMZ0VuTlNNUk16VStBVGNoSGdFWEZTTTFJUlVCTkNZckFTSUdIUUVVRmpzQk1qWTFBNlFCSFJmOUlSWWRBUUVkRmdIOEZ6SVJtUkFWUmdzRm1nY1lDUUVkRi83RkZoMEJSa1lCSFJZQnh4Y2RBVWIrWEFFWUNnaHBCd29LQjJrSUNoRVhIUUVCSFJjQzN4WWRBUlVRbVJFeUYvNFdBZW9KR1FhYUJncmpGeDBCQVIwWDQvMUU1QllkQVFFZEZ1VFMwZ0tyQndvS0I2OElDZ29JQUFBQUF3QUEvOEFEd0FOQUFBc0FGd0FiQUFBQkJ4YzNKemNYQnljSEZ6Y0JGd2NuTnhjM0p3Y0JOeWNqQVJjQkFtMzFaVVFpYnN0dElrUm05ZjRmSW03TGJTSkVadlVCVS9WbHpBRVBSUDd4QTBEMVprUWliY3R1SWtSbDlmN3FJbTNMYmlKRVpmWCtyZlZtQVE5RS92RUFBQVVBQUFBQUE4QURBQUFEQUFjQURRQU9BQmNBQUJNUklSRURJUUVYTlNjQkl4RWhCU01lQVRJMk5DWWlCa0FEZ0dEK0NBRWYyZG4rV1VBQ3dQM2dNQUViS0JzYktCc0RBUDBBQXdEOVlBRWcyWWpaL2xnQ1FLQVVHeHNvR3hzQUFBTUFBQUFBQTk0Q3RBQUZBQXNBRHdBQUV3TVRNd01USVNNVEF6TVRBVE1USTlTeXNuYXlzZ0hpZHJLeWQ3SDltMnFrYWdLei9zMyt6UUV6QVRQK3pmN05BVFArelFKbUFBWUFBQUFBQThBQzRBQURBQWNBQ3dBUEFCTUFGd0FBQVNFVklSRWhGU0VSSVJVaEF6TVZJeFV6RlNNVk14VWpBUUFDd1AxQUFzRDlRQUxBL1VEQVlHQmdZR0JnQWJCZ0FaQmcvZ0JnQXNCZzBHRFFZQUFBQUFBR0FBQUFBQVBBQXZBQUF3QUhBQXNBRVFBZUFDZ0FBQUVoRlNFUklSVWhFU0VWSVFNek5TTVZNd01WTXhVakZUTVZJeFV6TlNNVE5TTVZNd2NWTXpVakFRQUN3UDFBQXNEOVFBTEEvVUNRSUVBZ01FQW9LRUJnSUNCZ016TmdRQUd3WUFHUVlQNEFZQUpRZ0NEOXdDQVBJQkVnZ0FFUUlDQXpMU0FBQVFBQUFBQURnd01rQUJRQUFBRWhOUmNITlNFT0FRY2VBUmN6RlNNdUFTYytBUUdJQVN6T3p2N1VXWGNDQW5kWmVIaC9xZ01EcWdLc2VLV2xlQUozV1ZsM0Fsb0RxbjkvcWdBQUFBRUFBQUFBQTZRREpBQVVBQUFCSVRVSEZ6VWhIZ0VYRGdFSEl4VXpQZ0UzTGdFQ2VQN1V6czRCTEZsM0FnSjNXWGg0ZjZvREE2b0NySGlscFhnQ2QxbFpkd0phQTZwL2Y2b0FBQUFDQUFBQUFBTnhBdFVBQ3dBWEFBQUJQZ0UzSndZSEJoMEJJUkVoUGdFM0p3WUhCaDBCSVJFQkhBVkpUajZCUEMwQkVnRXlCRXBPUG9FOExRRVJBVlI3Z1NGak9uRlZ2dW9CS0h1QklXTTZjVlcrNmdFb0FBQUFBd0FBQUFBRGlnTDFBQWtBRkFBbkFBQUJNamMyTkNjbUt3RVZFekkzTmpVMEp5WXJBUkVESVRJWEZoVVVCd1lIRmhjV0ZSUUhCaU1oQW1zL0lqYzZJVUN4MVZzbkdFY2xQOFJnQVRtQU5pQW5GU1k0SERFc1FwRCt6QUc2RVJ5U0dRL24vcWMySWpCU0hSRCsrUUtVVGk0OVJpNFlFeFljTUZaSU9sZ0FBQUFEQUFELy9nUENBd0lBRHdBeUFGNEFBQUV5RmgwQkZBWWpJU0ltUFFFME5qTTNKaWNtTlRRMk16SVhGaGNXRnhZVkZBOEJMd0VtSnlZaklnWVZGQllYRmhjV0Z3Y3pGaFVVQndZSEJnY0dCd1lqSWk4QkppY21QUUUwSnlZL0FUVTNId0VXRng0Q016SStBVFUwSnlZRHNnY0pDUWY4bkFjSkNRZmpEZ3dZaG9NWk9pSTNCUVlIQXdZcUJ4a2JMRDA1UkVKckl6UWRFM2ZQQXhRTUdCTWtLQ1VvUGprcFJoMEhCQUVCQVFFekR3d0RBeEV0UENVZ1RDOHBFUUdBQ1FjZ0J3a0pCeUFIQ1NBU0ZqSXRXNEFLQmhJVEtENGVDUTRCQXdGTEhDMDZMQ1ZESUFvWERneUFGQnMzTXh3WUVoY1lDUXNNRkFnR0JBY0hOaGdQRXhNV0FTUWNDZ1FjSlJVYVBTSXFKUTRBQUFFQUFBQUFBdGNCMHdBQ0FBQUJJUmNDMS81UzF3SFQwUUFBQUFBQ0FBQUFBQU5rQXVRQUZ3QTdBQUFCSXk0Qk5EWTdBVElXSFFFVUJpSW1KelVCQmlJbU5EY0ZQZ0V5RmgwQkRnRUhJUzRCSnhFK0FUY3pNaFlVQmdjaklnWVZFUlFXTXlFeU5qVUM5blVORXhNTnd3MFRFeHNTQWY3eUNob1RDUUU4QVJJYkV3RTNLZjM2S1RjQkFUY3B3dzRTRWc3RERoSVNEZ0lHRGhJQ293RVNHeE1URGNNTkV4TU5kZjd4Q1JNYUNsWU9FaElPd2lrM0FRRTNLUUlHS1RjQkV4c1NBUklPL2ZvT0VoSU9BQUlBQVAvMEEzSUREQUFEQUNRQUFEY2hGU0VSSVJVUEFSRVVGak15TmpVUkx3RTFNeFVQQVJFVUJpTWlKaWN1QVRVUkx3R1BBdHY5SlFFN1JROVVYMWRQRVVYNFF3K0ltVkI0SXhvV0QwVXhQUU1ZTVFRTy9xbGpWRnBtQVVvUkJURXhCUkgrcklsNktpWWZUMG9CVXc0RUFBQUFBUUFBLzlvQzJBTW1BQ3NBQUFFMkppY21OVFEvQVI0Qk16STJOeFlWRkFjT0FRY0RCaFlYRmhVVUJ5WW5KaU1pQmdjbU5UUTNQZ0UzQWdnRkdpa1RBZ01sU3lBYlRDSURFaWtoQlg0RkhDc1JBeWNuSXlRYlN5SUVFU2drQlFMSEdoZ0ZCQkVFQkFzRUJBUUVEUVlUQVFRYUd2MXlHaGNHQkE4SURRUUJBd1FFRFFnUEF3WVlHZ0FBQUFBQkFBQUFBQU9NQWNJQURBQUFBUlFHSXlFaUpqUTJNeUV5RmdPTUdoUDlRaE1hR2hNQ3ZoTWFBWlVUR1JrbkdSa0FBQUFBQ2dBQS8rd0R3Z01CQUJBQUZBQVlBQndBSUFBcEFDNEFOd0E3QUQ4QUFBRWhNaFlWRVJRR0p5RWlKalVSTkRZekV5TVZNd1UxSXhVbE16VWpKUlV6TlFVV056STJOVFluSXdVek5TTVZKelVqQmhjVUZqTVdOek0xSXdVMUl4VUNBZ0dFSVJzYklQendIaHNiSHVIZzRBRVgzZ0VXNE9EOTB0OEJUMjFwQXdnQkFlSCs2ZURnT09FQkFnb0VaNlBmM3dIMzN3TUJIQ0Q5WlNFZEFSc2ZBcUlkRy8yL21BR1ltQUdZeTVhV21BRUJCd1JIUlpXVmxzcVlSa0lFQ3dFRGxaYVdsZ0FBQUFBRUFBRC84d09OQXcwQUV3QW5BRHNBVHdBQUFUYzJKaThCSmdZZkFSNEJQd0VYRmo4Qk5pY1hGajhCRnhZMlB3RTJKZzhCRGdFZkFRY0dGd0V1QVE4Qkp5WVBBUVlmQVFjR0ZoOEJGalluQVNZUEFTY21CZzhCQmhZL0FUNEJMd0UzTmljQkJqSUVCQWEwQkFZQkZRRUpCVEdYQmdZd0JRWDJCZ2FYTVFVSkFSVUJCZ1MwQmdRRU1wY0ZCUUVUQVFrRk1aY0dCakFGQlpjeUJBUUd0QVFHQWYzaUJnYVhNUVVKQVJVQkJnUzBCZ1FFTXBjRkJRSzJNUVVKQVJVQkJnUzBCZ1FFTXBjRkJUQUdCandGQlpjeUJBUUd0QVFHQVJVQkNRVXhsd1lHL3A4R0JBUXlsd1VGTUFZR2x6RUZDUUVWQVFZRUFSOEZCWmN5QkFRR3RBUUdBUlVCQ1FVeGx3WUdBQUFBQUFBU0FONEFBUUFBQUFBQUFBQVZBQUFBQVFBQUFBQUFBUUFMQUJVQUFRQUFBQUFBQWdBSEFDQUFBUUFBQUFBQUF3QUxBQ2NBQVFBQUFBQUFCQUFMQURJQUFRQUFBQUFBQlFBTEFEMEFBUUFBQUFBQUJnQUxBRWdBQVFBQUFBQUFDZ0FyQUZNQUFRQUFBQUFBQ3dBVEFINEFBd0FCQkFrQUFBQXFBSkVBQXdBQkJBa0FBUUFXQUxzQUF3QUJCQWtBQWdBT0FORUFBd0FCQkFrQUF3QVdBTjhBQXdBQkJBa0FCQUFXQVBVQUF3QUJCQWtBQlFBV0FRc0FBd0FCQkFrQUJnQVdBU0VBQXdBQkJBa0FDZ0JXQVRjQUF3QUJCQWtBQ3dBbUFZMEtRM0psWVhSbFpDQmllU0JwWTI5dVptOXVkQXAyTFcxa0xXVmthWFJ2Y2xKbFozVnNZWEoyTFcxa0xXVmthWFJ2Y25ZdGJXUXRaV1JwZEc5eVZtVnljMmx2YmlBeExqQjJMVzFrTFdWa2FYUnZja2RsYm1WeVlYUmxaQ0JpZVNCemRtY3lkSFJtSUdaeWIyMGdSbTl1ZEdWc2JHOGdjSEp2YW1WamRDNW9kSFJ3T2k4dlptOXVkR1ZzYkc4dVkyOXRBQW9BUXdCeUFHVUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FHa0FZd0J2QUc0QVpnQnZBRzRBZEFBS0FIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0JTQUdVQVp3QjFBR3dBWVFCeUFIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0IyQUMwQWJRQmtBQzBBWlFCa0FHa0FkQUJ2QUhJQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dCSEFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUhNQWRnQm5BRElBZEFCMEFHWUFJQUJtQUhJQWJ3QnRBQ0FBUmdCdkFHNEFkQUJsQUd3QWJBQnZBQ0FBY0FCeUFHOEFhZ0JsQUdNQWRBQXVBR2dBZEFCMEFIQUFPZ0F2QUM4QVpnQnZBRzRBZEFCbEFHd0FiQUJ2QUM0QVl3QnZBRzBBQUFBQUFnQUFBQUFBQUFBS0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFlQVFJQkF3RUVBUVVCQmdFSEFRZ0JDUUVLQVFzQkRBRU5BUTRCRHdFUUFSRUJFZ0VUQVJRQkZRRVdBUmNCR0FFWkFSb0JHd0VjQVIwQkhnRWZBQWR3Y21WMmFXVjNEWEpsWm5KbGMyZ3RjbWxuYUhRTWNtVm1jbVZ6YUMxc1pXWjBCM3B2YjIwdGFXNEllbTl2YlMxdmRYUURkRzlqQkhONWJtTUZaVzF2YW1rSVkyaGxZMnRpYjNnRlkyeGxZWElEZEdsd0JITmhkbVVFYkdsdWF3TnBiV2NFWTI5a1pRSjFiQUp2YkFSeVpXUnZCSFZ1Wkc4RmNYVnZkR1VFWW05c1pBMXpkSEpwYTJWMGFISnZkV2RvQ21GeWNtOTNMV1J2ZDI0TGIzQmxiaTFwYmkxdVpYY0tkVzVrWlhJdGJHbHVaUVpwZEdGc2FXTUthRzl5YVhwdmJuUmhiQVYwWVdKc1pRcG1kV3hzYzJOeVpXVnVBQUE9KSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIil9W2NsYXNzKj12LW1kLWljb24tXXtmb250LXNpemU6MTZweDtmb250LWZhbWlseTp2LW1kLWljb25mb250IWltcG9ydGFudDtmb250LXN0eWxlOm5vcm1hbCFpbXBvcnRhbnQ7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGV9LnYtbWQtaWNvbi1wcmV2aWV3OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYxOFxcXCJ9LnYtbWQtaWNvbi1yZWZyZXNoLXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYxNFxcXCJ9LnYtbWQtaWNvbi1yZWZyZXNoLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjE1XFxcIn0udi1tZC1pY29uLXpvb20taW46YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjE2XFxcIn0udi1tZC1pY29uLXpvb20tb3V0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYxN1xcXCJ9LnYtbWQtaWNvbi10b2M6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlYjI4XFxcIn0udi1tZC1pY29uLXN5bmM6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjcwXFxcIn0udi1tZC1pY29uLWVtb2ppOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTY3YlxcXCJ9LnYtbWQtaWNvbi1jaGVja2JveDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU3NDBcXFwifS52LW1kLWljb24tY2xlYXI6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNmVjXFxcIn0udi1tZC1pY29uLXRpcDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU4ZjFcXFwifS52LW1kLWljb24tc2F2ZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2MjRcXFwifS52LW1kLWljb24tbGluazpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2ZmVcXFwifS52LW1kLWljb24taW1nOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTcwMlxcXCJ9LnYtbWQtaWNvbi1jb2RlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTcwN1xcXCJ9LnYtbWQtaWNvbi11bDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU3MTBcXFwifS52LW1kLWljb24tb2w6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNzExXFxcIn0udi1tZC1pY29uLXJlZG86YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNmYxXFxcIn0udi1tZC1pY29uLXVuZG86YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNmYwXFxcIn0udi1tZC1pY29uLXF1b3RlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTZiM1xcXCJ9LnYtbWQtaWNvbi1ib2xkOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTdjMVxcXCJ9LnYtbWQtaWNvbi1zdHJpa2V0aHJvdWdoOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTcwZlxcXCJ9LnYtbWQtaWNvbi1hcnJvdy1kb3duOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYyM1xcXCJ9LnYtbWQtaWNvbi1vcGVuLWluLW5ldzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2NDFcXFwifS52LW1kLWljb24tdW5kZXItbGluZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2MTFcXFwifS52LW1kLWljb24taXRhbGljOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYxMFxcXCJ9LnYtbWQtaWNvbi1ob3Jpem9udGFsOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYwZVxcXCJ9LnYtbWQtaWNvbi10YWJsZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2MGNcXFwifS52LW1kLWljb24tZnVsbHNjcmVlbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2MDZcXFwifS52LW1kLWVkaXRvcl9fdG9vbHRpcHt6LWluZGV4OjEwMTtwYWRkaW5nOjRweCA2cHg7Y29sb3I6I2ZmZjtmb250LXNpemU6MTJweDtsaW5lLWhlaWdodDoxO3doaXRlLXNwYWNlOm5vd3JhcDtiYWNrZ3JvdW5kLWNvbG9yOiM4Nzg3ODc7Ym9yZGVyLXJhZGl1czoycHh9LnYtbWQtZWRpdG9yX19tZW51LC52LW1kLWVkaXRvcl9fdG9vbHRpcHtwb3NpdGlvbjphYnNvbHV0ZTtib3gtc2hhZG93OjAgMnB4IDEycHggMCByZ2JhKDAsMCwwLC4xKX0udi1tZC1lZGl0b3JfX21lbnV7dG9wOjM4cHg7ei1pbmRleDo5OTtsaXN0LXN0eWxlOm5vbmU7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlci1yYWRpdXM6M3B4Oy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgdG9wO3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyIHRvcH0udi1tZC1lZGl0b3JfX21lbnU6Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjZweH0udi1tZC1lZGl0b3JfX21lbnU6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1ie2JhY2tncm91bmQtY29sb3I6cmdiYSgxNDQsMTQ3LDE1MywuMyk7Ym9yZGVyLXJhZGl1czo0cHh9LnYtbWQtZWRpdG9yX19tZW51Ojotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMTQ0LDE0NywxNTMsLjUpfS52LW1kLWVkaXRvcl9fbWVudS1pdGVte2NvbG9yOiM1OTU5NTk7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZToxNHB4O3doaXRlLXNwYWNlOm5vd3JhcDtsaXN0LXN0eWxlOm5vbmV9LnYtbWQtZWRpdG9yX19tZW51LWl0ZW06aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZjVmNWY1fS52LW1kLWVkaXRvcl9fbWVudS0tbGlzdHtwYWRkaW5nOjVweCAwfS52LW1kLWVkaXRvcl9fbWVudS0tbGlzdCAudi1tZC1lZGl0b3JfX21lbnUtaXRlbXtwYWRkaW5nOjAgMjRweDtsaW5lLWhlaWdodDozNHB4O3RleHQtYWxpZ246bGVmdH0udi1tZC1lZGl0b3JfX21lbnUtLXBhbmVse21heC1oZWlnaHQ6MjAwcHg7cGFkZGluZzoxMnB4IDEwcHg7b3ZlcmZsb3cteTphdXRvfS52LW1kLWVkaXRvcl9fbWVudS0tcGFuZWwgLnYtbWQtZWRpdG9yX19tZW51LXJvd3tkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2Rpc3BsYXk6ZmxleDstd2Via2l0LWZsZXgtd3JhcDpub3dyYXA7ZmxleC13cmFwOm5vd3JhcH0udi1tZC1lZGl0b3JfX21lbnUtLXBhbmVsIC52LW1kLWVkaXRvcl9fbWVudS1yb3c6bm90KDpsYXN0LWNoaWxkKXttYXJnaW4tYm90dG9tOjZweH0udi1tZC1lZGl0b3JfX21lbnUtLXBhbmVsIC52LW1kLWVkaXRvcl9fbWVudS1pdGVte2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6OHB4IDA7bGluZS1oZWlnaHQ6MTt0ZXh0LWFsaWduOmNlbnRlcjtib3JkZXItcmFkaXVzOjJweH0udi1tZC1lZGl0b3JfX21lbnUtLXBhbmVsIC52LW1kLWVkaXRvcl9fbWVudS1pdGVtOm5vdCg6bGFzdC1jaGlsZCl7bWFyZ2luLXJpZ2h0OjRweH0udi1tZC1lZGl0b3JfX21lbnUtY3RybHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO2Rpc3BsYXk6bm9uZX0udi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbXtwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MjhweDtwYWRkaW5nOjAgNnB4O2NvbG9yOiM1OTU5NTk7Zm9udC1zaXplOjE2cHg7bGluZS1oZWlnaHQ6MjhweDt0ZXh0LWFsaWduOmNlbnRlcjtib3JkZXItcmFkaXVzOjRweDtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBsaW5lYXIgMHM7dHJhbnNpdGlvbjphbGwgLjJzIGxpbmVhciAwc30udi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbTpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tbGVmdDo0cHh9LnYtbWQtZWRpdG9yX190b29sYmFyLWl0ZW06aG92ZXJ7YmFja2dyb3VuZDojZjVmNWY1fS52LW1kLWVkaXRvcl9fdG9vbGJhci1pdGVtLS1tZW51e3BhZGRpbmctcmlnaHQ6MTZweH0udi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbS0tbWVudSAudi1tZC1lZGl0b3JfX21lbnUtY3RybHtkaXNwbGF5OmlubGluZS1ibG9ja30udi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbS0tYWN0aXZlLC52LW1kLWVkaXRvcl9fdG9vbGJhci1pdGVtLS1hY3RpdmU6aG92ZXJ7YmFja2dyb3VuZDojZThlOGU4fS52LW1kLWVkaXRvcl9fdG9vbGJhcntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1wYWNrOmp1c3RpZnk7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbjstd2Via2l0LWJveC1hbGlnbjpjZW50ZXI7LXdlYmtpdC1hbGlnbi1pdGVtczpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO2JveC1zaXppbmc6Ym9yZGVyLWJveDt3aWR0aDoxMDAlO3BhZGRpbmc6NnB4O2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNkZGR9LnYtbWQtZWRpdG9yX190b29sYmFyLWxlZnQsLnYtbWQtZWRpdG9yX190b29sYmFyLXJpZ2h0e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4Oy13ZWJraXQtZmxleC13cmFwOndyYXA7ZmxleC13cmFwOndyYXA7bWFyZ2luOjA7cGFkZGluZzowO2xpc3Qtc3R5bGU6bm9uZX0udi1tZC1lZGl0b3JfX3Rvb2xiYXItbGVmdCsudi1tZC1lZGl0b3JfX3Rvb2xiYXItcmlnaHR7bWFyZ2luLWxlZnQ6NjBweH0udi1tZC1lZGl0b3JfX3Rvb2xiYXItZGl2aWRlcntwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MjhweDttYXJnaW46MCAxMHB4fS52LW1kLWVkaXRvcl9fdG9vbGJhci1kaXZpZGVyK2xpLnYtbWQtZWRpdG9yX190b29sYmFyLWl0ZW17bWFyZ2luLWxlZnQ6MH0udi1tZC1lZGl0b3JfX3Rvb2xiYXItZGl2aWRlcjpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjRweDtib3R0b206NHB4O2JvcmRlci1sZWZ0OjFweCBzb2xpZCAjZGRkO2NvbnRlbnQ6XFxcIlxcXCJ9LnYtbWQtZWRpdG9ye2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4O3dpZHRoOjEwMCU7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlci1yYWRpdXM6NHB4O2JveC1zaGFkb3c6MCAycHggMTJweCAwIHJnYmEoMCwwLDAsLjEpfS52LW1kLWVkaXRvcl9fbGVmdC1hcmVhLC52LW1kLWVkaXRvcl9fcmlnaHQtYXJlYXtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWw7LXdlYmtpdC1ib3gtZGlyZWN0aW9uOm5vcm1hbDstd2Via2l0LWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47d2lkdGg6MjAwcHh9LnYtbWQtZWRpdG9yX19sZWZ0LWFyZWF7aGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlci1yaWdodDoxcHggc29saWQgI2RkZDstd2Via2l0LXRyYW5zaXRpb246LjNzO3RyYW5zaXRpb246LjNzfS52LW1kLWVkaXRvcl9fbGVmdC1hcmVhLXRpdGxle3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDo0MXB4O3BhZGRpbmc6MCAxNHB4O2NvbG9yOiMyYzNlNTA7Zm9udC13ZWlnaHQ6NjAwO2ZvbnQtc2l6ZToxNnB4O2xpbmUtaGVpZ2h0OjQxcHg7d2hpdGUtc3BhY2U6bm93cmFwfS52LW1kLWVkaXRvcl9fbGVmdC1hcmVhLXRpdGxlOmFmdGVye3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNkZGQ7Y29udGVudDpcXFwiXFxcIn0udi1tZC1lZGl0b3JfX2xlZnQtYXJlYS1ib2R5ey13ZWJraXQtYm94LWZsZXg6MTstd2Via2l0LWZsZXg6MTtmbGV4OjE7cGFkZGluZzo4cHggMTRweDtvdmVyZmxvdzpoaWRkZW59LnYtbWQtZWRpdG9yLS1sZWZ0LWFyZWEtcmV2ZXJzZXstd2Via2l0LWJveC1vcmllbnQ6aG9yaXpvbnRhbDstd2Via2l0LWJveC1kaXJlY3Rpb246cmV2ZXJzZTstd2Via2l0LWZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS52LW1kLWVkaXRvci0tbGVmdC1hcmVhLXJldmVyc2UgLnYtbWQtZWRpdG9yX19sZWZ0LWFyZWF7Ym9yZGVyLXJpZ2h0Om5vbmU7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNkZGR9LnYtbWQtZWRpdG9yX19yaWdodC1hcmVhey13ZWJraXQtYm94LWZsZXg6MTstd2Via2l0LWZsZXg6MTtmbGV4OjF9LnYtbWQtZWRpdG9yLS1wcmV2aWV3e2JveC1zaGFkb3c6bm9uZX0udi1tZC1lZGl0b3ItLWZ1bGxzY3JlZW57cG9zaXRpb246Zml4ZWQ7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7ei1pbmRleDoxMDAxfS52LW1kLWVkaXRvcl9fbWFpbntkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1mbGV4OjE7LXdlYmtpdC1mbGV4OjE7ZmxleDoxO3dpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVufS52LW1kLWVkaXRvcl9fZWRpdG9yLXdyYXBwZXIsLnYtbWQtZWRpdG9yX19wcmV2aWV3LXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmU7LXdlYmtpdC1ib3gtZmxleDoxOy13ZWJraXQtZmxleDoxO2ZsZXg6MTtoZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW59LnYtbWQtZWRpdG9yX19lZGl0b3Itd3JhcHBlcntjdXJzb3I6dGV4dDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0udi1tZC1lZGl0b3ItLWVkaXRhYmxlIC52LW1kLWVkaXRvcl9fZWRpdG9yLXdyYXBwZXJ7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCAjZGRkfS5zY3JvbGxiYXJ7aGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5zY3JvbGxiYXI6YWN0aXZlIC5zY3JvbGxiYXJfX2Jhciwuc2Nyb2xsYmFyOmZvY3VzIC5zY3JvbGxiYXJfX2Jhciwuc2Nyb2xsYmFyOmhvdmVyIC5zY3JvbGxiYXJfX2JhcntvcGFjaXR5OjF9LnNjcm9sbGJhcl9fd3JhcHtoZWlnaHQ6MTAwJTtvdmVyZmxvdy14OmhpZGRlbn0uc2Nyb2xsYmFyX193cmFwLS1oaWRkZW4tZGVmYXVsdHtzY3JvbGxiYXItd2lkdGg6bm9uZX0uc2Nyb2xsYmFyX193cmFwLS1oaWRkZW4tZGVmYXVsdDo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6MDtoZWlnaHQ6MH0uc2Nyb2xsYmFyX190aHVtYntwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDE0NCwxNDcsMTUzLC4zKTtib3JkZXItcmFkaXVzOmluaGVyaXQ7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjNzO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuM3N9LnNjcm9sbGJhcl9fdGh1bWI6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDE0NCwxNDcsMTUzLC41KX0uc2Nyb2xsYmFyX19iYXJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MnB4O2JvdHRvbToycHg7ei1pbmRleDoxO2JvcmRlci1yYWRpdXM6NHB4O2N1cnNvcjpwb2ludGVyO29wYWNpdHk6MDstd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuMzRzIGVhc2Utb3V0O3RyYW5zaXRpb246b3BhY2l0eSAuMzRzIGVhc2Utb3V0fS5zY3JvbGxiYXJfX2Jhci5pcy12ZXJ0aWNhbHt0b3A6MnB4O3dpZHRoOjZweH0uc2Nyb2xsYmFyX19iYXIuaXMtdmVydGljYWw+ZGl2e3dpZHRoOjEwMCV9LnNjcm9sbGJhcl9fYmFyLmlzLWhvcml6b250YWx7bGVmdDoycHg7aGVpZ2h0OjZweH0uc2Nyb2xsYmFyX19iYXIuaXMtaG9yaXpvbnRhbD5kaXZ7aGVpZ2h0OjEwMCV9LnYtbWQtZWRpdG9yX190b2MtbmF2e21hcmdpbjowO3BhZGRpbmc6MDtsaXN0LXN0eWxlOm5vbmV9LnYtbWQtZWRpdG9yX190b2MtbmF2LWl0ZW17cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjM4cHg7b3ZlcmZsb3c6aGlkZGVuO2NvbG9yOiMyYzNlNTA7bGluZS1oZWlnaHQ6MzhweDt3aGl0ZS1zcGFjZTpub3dyYXA7dGV4dC1vdmVyZmxvdzplbGxpcHNpcztjdXJzb3I6cG9pbnRlcn0udi1tZC1lZGl0b3JfX3RvYy1uYXYtaXRlbTpob3ZlciAudi1tZC1lZGl0b3JfX3RvYy1uYXYtdGl0bGV7Zm9udC1zaXplOjE3cHg7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBjZW50ZXI7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgY2VudGVyfS52LW1kLWVkaXRvcl9fdG9jLW5hdi10aXRsZXtwb3NpdGlvbjpyZWxhdGl2ZTtmb250LXNpemU6MTZweDstd2Via2l0LXRyYW5zaXRpb246LjNzO3RyYW5zaXRpb246LjNzfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9Aa2FuZ2Mvdi1tZC1lZGl0b3IvbGliL3N0eWxlL2Jhc2UtZWRpdG9yLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxzQkFBc0IsaUJBQWlCLENBQUMsMEJBQTBCLFFBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxpQkFBaUIsQ0FBQyx5REFBeUQscUJBQXFCLENBQUMsc0JBQXNCLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsa0hBQWtILENBQUMsZUFBZSxDQUFDLG9CQUFvQixDQUFDLCtCQUErQixpQkFBaUIsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsMERBQTBELGFBQWEsQ0FBQyw0Q0FBNEMsYUFBYSxDQUFDLDhEQUE4RCwyQkFBMkIsQ0FBQyxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsd0dBQXdHLENBQUMsZ0dBQWdHLENBQUMsd0ZBQXdGLENBQUMsd0lBQXdJLENBQUMsNERBQTRELDJCQUEyQixDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxzREFBc0QsdURBQXVELENBQUMsK0NBQStDLENBQUMsb0RBQW9ELFNBQVMsQ0FBQyxXQUFXLHlCQUF5QixDQUFDLCtrUkFBK2tSLENBQUMsaXMxQkFBaXMxQixDQUFDLG9CQUFvQixjQUFjLENBQUMsbUNBQW1DLENBQUMsMkJBQTJCLENBQUMsa0NBQWtDLENBQUMsaUNBQWlDLENBQUMsMEJBQTBCLGVBQWUsQ0FBQyxnQ0FB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QVcsQ0FBQyxpQkFBaUIsQ0FBQyxpQ0FBaUMsb0JBQW9CLENBQUMsb0RBQW9ELE9BQU8sQ0FBQyxRQUFRLENBQUMsa0JBQWtCLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLHFDQUFxQyxDQUFDLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyx1Q0FBdUMsQ0FBQywrQkFBK0IsQ0FBQyx3QkFBd0IscUNBQXFDLENBQUMsZ0JBQWdCLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsd0NBQXdDLENBQUMsZ0NBQWdDLENBQUMsNEJBQTRCLE9BQU8sQ0FBQyxTQUFTLENBQUMsZ0NBQWdDLFVBQVUsQ0FBQyw4QkFBOEIsUUFBUSxDQUFDLFVBQVUsQ0FBQyxrQ0FBa0MsV0FBVyxDQUFDLHNCQUFzQixRQUFRLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQywyQkFBMkIsaUJBQWlCLENBQUMsV0FBVyxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLENBQUMsc0JBQXNCLENBQUMsY0FBYyxDQUFDLDZEQUE2RCxjQUFjLENBQUMsc0NBQXNDLENBQUMsOEJBQThCLENBQUMsNEJBQTRCLGlCQUFpQixDQUFDLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQyxjQUFjXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi52LW1kLXRleHRhcmVhLWVkaXRvcntwb3NpdGlvbjpyZWxhdGl2ZX0udi1tZC10ZXh0YXJlYS1lZGl0b3IgcHJle21hcmdpbjowO3doaXRlLXNwYWNlOnByZS13cmFwO3Zpc2liaWxpdHk6aGlkZGVufS52LW1kLXRleHRhcmVhLWVkaXRvciBwcmUsLnYtbWQtdGV4dGFyZWEtZWRpdG9yIHRleHRhcmVhe2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjIwcHggMjBweCAzMHB4O292ZXJmbG93OmhpZGRlbjtjb2xvcjojMmMzZTUwO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5Om1lbmxvLFVidW50dSBNb25vLGNvbnNvbGFzLENvdXJpZXIgTmV3LE1pY3Jvc29mdCBZYWhlaSxIaXJhZ2lubyBTYW5zIEdCLFdlblF1YW5ZaSBNaWNybyBIZWksc2Fucy1zZXJpZjtsaW5lLWhlaWdodDoxLjU7d29yZC1icmVhazpicmVhay1hbGx9LnYtbWQtdGV4dGFyZWEtZWRpdG9yIHRleHRhcmVhe3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JvcmRlcjpub25lO291dGxpbmU6bm9uZTtyZXNpemU6bm9uZX0udi1tZC10ZXh0YXJlYS1lZGl0b3IgdGV4dGFyZWE6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6I2MwYzRjY30udi1tZC10ZXh0YXJlYS1lZGl0b3IgdGV4dGFyZWE6OnBsYWNlaG9sZGVye2NvbG9yOiNjMGM0Y2N9LnYtbWQtem9vbS1pbi10b3AtZW50ZXItYWN0aXZlLC52LW1kLXpvb20taW4tdG9wLWxlYXZlLWFjdGl2ZXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVkoMSk7dHJhbnNmb3JtOnNjYWxlWSgxKTtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSksLXdlYmtpdC10cmFuc2Zvcm0gLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSk7dHJhbnNpdGlvbjpvcGFjaXR5IC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLC13ZWJraXQtdHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpO3RyYW5zaXRpb246dHJhbnNmb3JtIC4zcyBjdWJpYy1iZXppZXIoLjIzLDEsLjMyLDEpLG9wYWNpdHkgLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjNzIGN1YmljLWJlemllciguMjMsMSwuMzIsMSksb3BhY2l0eSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKSwtd2Via2l0LXRyYW5zZm9ybSAuM3MgY3ViaWMtYmV6aWVyKC4yMywxLC4zMiwxKX0udi1tZC16b29tLWluLXRvcC1lbnRlci1mcm9tLC52LW1kLXpvb20taW4tdG9wLWxlYXZlLWFjdGl2ZXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVkoMCk7dHJhbnNmb3JtOnNjYWxlWSgwKTtvcGFjaXR5OjB9LnYtbWQtZmFkZS1pbi1lbnRlci1hY3RpdmUsLnYtbWQtZmFkZS1pbi1sZWF2ZS1hY3RpdmV7LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGN1YmljLWJlemllciguNTUsMCwuMSwxKTt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzIGN1YmljLWJlemllciguNTUsMCwuMSwxKX0udi1tZC1mYWRlLWluLWVudGVyLWZyb20sLnYtbWQtZmFkZS1pbi1sZWF2ZS1hY3RpdmV7b3BhY2l0eTowfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6di1tZC1pY29uZm9udDtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3Q7YmFzZTY0LGxCa0FBT0FZQUFBQkFBSUFBQUFBQUFJQUJRTUFBQUFBQUFBQkFKQUJBQUFBQUV4UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBYUdQbkx3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCWUFkZ0F0QUcwQVpBQXRBR1VBWkFCcEFIUUFid0J5QUFBQURnQlNBR1VBWndCMUFHd0FZUUJ5QUFBQUZnQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREFBQUFBV0FIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0FBQUFBQUFBRUFBQUFMQUlBQUF3QXdSMU5WUXJEK3MrMEFBQUU0QUFBQVFrOVRMekk4ZkUwZUFBQUJmQUFBQUZaamJXRndFenRlNWdBQUFrd0FBQU9RWjJ4NVpoS0pCNXdBQUFZY0FBQU8rR2hsWVdRWThNcXhBQUFBNEFBQUFEWm9hR1ZoQjk0RUVBQUFBTHdBQUFBa2FHMTBlSGh4QUFBQUFBSFVBQUFBZUd4dlkyRTVkRFlXQUFBRjNBQUFBRDV0WVhod0FUSUFhd0FBQVJnQUFBQWdibUZ0WllBMllHOEFBQlVVQUFBQ2tYQnZjM1N2MG4vUUFBQVhxQUFBQVRnQUFRQUFBNEQvZ0FCY0JIRUFBQUFBQkFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUI0QUFRQUFBQUVBQUMvblkyaGZEenoxQUFzRUFBQUFBQURhNk1OYUFBQUFBTnJvdzFvQUFQK0NCQUFEZmdBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFBSGdCZkFBb0FBQUFBQUFJQUFBQUtBQW9BQUFEL0FBQUFBQUFBQUFFQUFBQUtBQjRBTEFBQlJFWk1WQUFJQUFRQUFBQUFBQUFBQVFBQUFBRnNhV2RoQUFnQUFBQUJBQUFBQVFBRUFBUUFBQUFCQUFnQUFRQUdBQUFBQVFBQUFBQUFBUVFFQVpBQUJRQUlBb2tDekFBQUFJOENpUUxNQUFBQjZ3QXlBUWdBQUFJQUJRTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUdaRlpBQkE1Z2JyS0FPQS80QUFYQU9BQUlBQUFBQUJBQUFBQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCSEVBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFBQUFBQlFBQUFBTUFBQUFzQUFBQUJBQUFBaVFBQVFBQUFBQUJIZ0FEQUFFQUFBQXNBQU1BQ2dBQUFpUUFCQUR5QUFBQUtnQWdBQVFBQ3VZRzVnem1EdVlSNWhqbUpPWkI1bkRtZSthejV1em04ZWIrNXdMbkIrY1I1MERud2VqeDZ5ai8vd0FBNWdibURPWU81aERtRk9ZajVrSG1jT1o3NXJQbTdPYnc1djduQXVjSDV3L25RT2ZCNlBIcktQLy9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFDb0FLZ0FxQUNvQUxBQTBBRFlBTmdBMkFEWUFOZ0EyQURnQU9BQTRBRGdBUEFBOEFEd0FQQUFBQUIwQUhBQWJBQm9BR1FBQ0FBTUFCQUFGQUFFQUZ3QU1BQmdBQndBSUFCUUFDZ0FUQUJJQURRQU9BQThBRmdBUUFCRUFDUUFWQUFzQUJnQUFBUVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUFBQUFBQmJBQUFBQUFBQUFBZEFBRG1CZ0FBNWdZQUFBQWRBQURtREFBQTVnd0FBQUFjQUFEbURnQUE1ZzRBQUFBYkFBRG1FQUFBNWhBQUFBQWFBQURtRVFBQTVoRUFBQUFaQUFEbUZBQUE1aFFBQUFBQ0FBRG1GUUFBNWhVQUFBQURBQURtRmdBQTVoWUFBQUFFQUFEbUZ3QUE1aGNBQUFBRkFBRG1HQUFBNWhnQUFBQUJBQURtSXdBQTVpTUFBQUFYQUFEbUpBQUE1aVFBQUFBTUFBRG1RUUFBNWtFQUFBQVlBQURtY0FBQTVuQUFBQUFIQUFEbWV3QUE1bnNBQUFBSUFBRG1zd0FBNXJNQUFBQVVBQURtN0FBQTV1d0FBQUFLQUFEbThBQUE1dkFBQUFBVEFBRG04UUFBNXZFQUFBQVNBQURtL2dBQTV2NEFBQUFOQUFEbkFnQUE1d0lBQUFBT0FBRG5Cd0FBNXdjQUFBQVBBQURuRHdBQTV3OEFBQUFXQUFEbkVBQUE1eEFBQUFBUUFBRG5FUUFBNXhFQUFBQVJBQURuUUFBQTUwQUFBQUFKQUFEbndRQUE1OEVBQUFBVkFBRG84UUFBNlBFQUFBQUxBQURyS0FBQTZ5Z0FBQUFHQUFBQUFBQllBSm9BM0FFNEFZSUJ3QUg0QWs0Q2ZnTElBdklEWEFPVUE4UUQ2QVFVQkZJRWVBU2VCTW9GQ2dXU0JhQUYrQVl5Qm5nR2tnYjJCM3dBQUFBRUFBQUFBQVFBQXRZQUN3QVhBQ01BTHdBQUFSWUFGd1lBQnlZQUp6WUFGdzRCQng0QkZ6NEJOeTRCQng0QkZ3NEJCeTRCSno0QkZ3NEJCeDRCRno0Qk55NEJBZ0R5QVF3Q0F2NzA4dkwrOUFJQ0FRenlxdUlwS2VLcXF1SXBLZUtxWDM4Q0FuOWZYMzhDQW45ZlJGb0NBbHBFUkZvQ0Fsb0MxUmIrekJZVy9zd1dGZ0UwRmhZQk5Db0x6MFpHendzTHowWkd6elVDZjE5ZmZ3SUNmMTlmZno0Q1drUkVXZ0lDV2tSRVdnQUFBQUVBQVArK0E4SURVZ0FvQUFBQk5UUTJNaFlYRlE0QkJ5TXVBVFEyT3dFdUFRY09BUmNlQVJjK0FUY3pEZ0VITGdFblBnSUVBekVWSHhZQkFSWVByaEVWRlJGdFhQZDBjMlVmSXNhRG45TUZTd1grdjcvK0JRR1ArZ0VEQXN3NkVSVVZFYTRQRlFJQ0ZSOFZZQ2s4UU9XQmY1a0RCTlNmdi80RkJmNi9pTnh0S3dBQUFBRUFBUCsrQThNRFVnQXBBQUFUTXpJV0ZBWUhJeTRCUFFFME5qSVdIUUUySkJjZUFSY09BUWN1QVNjekhnRVhQZ0UzTGdFbkpnYnJiUkVWRlJHdUVSVVZJUlZsQVFOOWZaQUJCZjYvdi80RlN3VFVuNS9UQlFHQmJXN2VBbjBWSHhZQkFSWVByaEVWRlJFNldpczBPZHlJdi80RkJmNi9uOVFFQk5TZmRyc3NLVElBQUFNQUFQKytBOElEUmdBU0FCNEFPZ0FBSlJjV0ZBWWlMd0VHSkNjbUVqYzJKQmNXRWdVK0FUY3VBU2NPQVFjZUFSTTFORFl5RmgwQk16SVdGQVlyQVJVVUJpSW1QUUVqSWlZME5qTURONElKRkJvS2dvcityM3gyQm55QkFWQ0dnQlQrUnB6T0JBVE9uSnpOQkFUTmV4TWRFMk1QRXhNUFl4TWRFMlFPRXhNT2VJSUtHaFFKZ25FVWdJWUJVSUY4Qm5aOC9xL2VCTTZjbk0wRUJNMmNuTTRCaTJRT0V4TU9aQk1kRTJNUEV4TVBZeE1kRXdBQUFBQURBQUQvdmdQQ0EwWUFFZ0FlQUNvQUFDVVhGaFFHSWk4QkJpUW5KaEkzTmlRWEZoSUZQZ0UzTGdFbkRnRUhIZ0VUSVRJV0ZBWWpJU0ltTkRZRE40SUpGQm9LZ29yK3IzeDJCbnlCQVZDR2dCVCtScHpPQkFUT25Kek5CQVRORndFS0R4TVRELzcyRGhNVGVJSUtHaFFKZ25FVWdJWUJVSUY4Qm5aOC9xL2VCTTZjbk0wRUJNMmNuTTRCaXhNZEV4TWRFd0FBQkFBQS85Y0RxUU1wQUFNQUJ3QVhBQ1FBQUJNUklSRWxJVFVoSnlFeUZoVVJGQVlqSVNJbU5SRTBOaE15RmhjUkRnRWlKaWNSUGdHMkFwVDliQUtVL1d3dkF2SVVHeHNVL1E0VUd4dlFGQnNCQVJzb0dnRUJHd0lOL2lrQjExOWVYaHNVL1E0VUd4c1VBdklVRy82Mkd4VCs1UlFhR2hRQkd4UWJBQUlBQVArQ0EyMERmZ0FQQUI4QUFBRTFCeGMxSGdFWEZBY1hQZ0UxTGdFRExnRW5OamNuRGdFVkhnRVhGVGNuQWdDMnRuU2FBeUJDSEIwRXpwcDBtZ01CSDBJY0hRVE9tcmEyQXZPTHVybUxBNTEyUmp4RExHTTJuZEw5ZXdPZGRrWThReXBsTnAzU0JJdTZ1UUFBQUFBRkFBRC9tZ1BtQTJZQUN3QVhBQ0FBS1FBd0FBQUZKZ0FuTmdBM0ZnQVhCZ0FERGdFSEhnRVhQZ0UzTGdFVElpWTBOaklXRkFZaElpWTBOaklXRkFZSEhnRVhQZ0UzQWdETy91NEZCUUVTenM0QkVnVUYvdTdPcE53RUJOeWtwTndFQk53ZUZob2FMQm9hL21ZV0dob3NHaG9XQW01U1VtNENaUVVCRXM3T0FSSUZCZjd1enM3KzdnTmtCTnlrcE53RUJOeWtwTnorc1Jvc0dob3NHaG9zR2hvc0dtSlNiZ0lDYmxJQUF3QUEvOHNEdFFNMUFBOEFFd0FaQUFBVElUSVdGUkVVQmlNaExnRW5FVFEyRnhFaEVRRW5OeGNCRjN3RENCUWRIUlQ4K0JVYkFSMUVBcWorZk01RWlnRVNSUU0xSFJUOCtCUWRBUnNWQXdnVUhXSDlXQUtvL2VyT1JJa0JFMFVBQlFBQS83NER3d05sQUFBQURBQWVBQ0lBSndBQU56TWhNaDBCRkNNaElqMEJORGNYRmpNaE1qY0JOaVluQVNZR0J3RUdGZ2tCQXdFSEFRY2hKMDhKQTFBSkNmeXdDUStURGhFQlp4Z1BBUkVUQnhuK294bzlGZjU0RXdnQjBRRlUwUDZyTWdGVkF2NjBoaEFKUHdrSlB3blNjd29UQVYwYVBSVUJFQlFJR2Y0TEdqOENHUDcyL3ZVQkNrRCs5UUZwQUFBQUFBSUFBUCs0QThnRFNBQVNBQmtBQUJNaE1oWVZFUlFHS3dFSEp5TWlKalVSTkRZWEVUTVhOek1SbEFMWUpqVTFKcmEydHJZbU5UVW0zSkNRM0FOSE5TYjkzaVkxdHJZMUpnSWlKalZiL2Q2UWtBSWlBQVFBQVAvY0E2UURKQUFUQURFQU5RQkZBQUFsRGdFSElTNEJKeEUrQVRjaE1oWWZBUjRCRlFNUk5DWXZBUzRCSXhVT0FRY2hMZ0VuTlNNUk16VStBVGNoSGdFWEZTTTFJUlVCTkNZckFTSUdIUUVVRmpzQk1qWTFBNlFCSFJmOUlSWWRBUUVkRmdIOEZ6SVJtUkFWUmdzRm1nY1lDUUVkRi83RkZoMEJSa1lCSFJZQnh4Y2RBVWIrWEFFWUNnaHBCd29LQjJrSUNoRVhIUUVCSFJjQzN4WWRBUlVRbVJFeUYvNFdBZW9KR1FhYUJncmpGeDBCQVIwWDQvMUU1QllkQVFFZEZ1VFMwZ0tyQndvS0I2OElDZ29JQUFBQUF3QUEvOEFEd0FOQUFBc0FGd0FiQUFBQkJ4YzNKemNYQnljSEZ6Y0JGd2NuTnhjM0p3Y0JOeWNqQVJjQkFtMzFaVVFpYnN0dElrUm05ZjRmSW03TGJTSkVadlVCVS9WbHpBRVBSUDd4QTBEMVprUWliY3R1SWtSbDlmN3FJbTNMYmlKRVpmWCtyZlZtQVE5RS92RUFBQVVBQUFBQUE4QURBQUFEQUFjQURRQU9BQmNBQUJNUklSRURJUUVYTlNjQkl4RWhCU01lQVRJMk5DWWlCa0FEZ0dEK0NBRWYyZG4rV1VBQ3dQM2dNQUViS0JzYktCc0RBUDBBQXdEOVlBRWcyWWpaL2xnQ1FLQVVHeHNvR3hzQUFBTUFBQUFBQTk0Q3RBQUZBQXNBRHdBQUV3TVRNd01USVNNVEF6TVRBVE1USTlTeXNuYXlzZ0hpZHJLeWQ3SDltMnFrYWdLei9zMyt6UUV6QVRQK3pmN05BVFArelFKbUFBWUFBQUFBQThBQzRBQURBQWNBQ3dBUEFCTUFGd0FBQVNFVklSRWhGU0VSSVJVaEF6TVZJeFV6RlNNVk14VWpBUUFDd1AxQUFzRDlRQUxBL1VEQVlHQmdZR0JnQWJCZ0FaQmcvZ0JnQXNCZzBHRFFZQUFBQUFBR0FBQUFBQVBBQXZBQUF3QUhBQXNBRVFBZUFDZ0FBQUVoRlNFUklSVWhFU0VWSVFNek5TTVZNd01WTXhVakZUTVZJeFV6TlNNVE5TTVZNd2NWTXpVakFRQUN3UDFBQXNEOVFBTEEvVUNRSUVBZ01FQW9LRUJnSUNCZ016TmdRQUd3WUFHUVlQNEFZQUpRZ0NEOXdDQVBJQkVnZ0FFUUlDQXpMU0FBQVFBQUFBQURnd01rQUJRQUFBRWhOUmNITlNFT0FRY2VBUmN6RlNNdUFTYytBUUdJQVN6T3p2N1VXWGNDQW5kWmVIaC9xZ01EcWdLc2VLV2xlQUozV1ZsM0Fsb0RxbjkvcWdBQUFBRUFBQUFBQTZRREpBQVVBQUFCSVRVSEZ6VWhIZ0VYRGdFSEl4VXpQZ0UzTGdFQ2VQN1V6czRCTEZsM0FnSjNXWGg0ZjZvREE2b0NySGlscFhnQ2QxbFpkd0phQTZwL2Y2b0FBQUFDQUFBQUFBTnhBdFVBQ3dBWEFBQUJQZ0UzSndZSEJoMEJJUkVoUGdFM0p3WUhCaDBCSVJFQkhBVkpUajZCUEMwQkVnRXlCRXBPUG9FOExRRVJBVlI3Z1NGak9uRlZ2dW9CS0h1QklXTTZjVlcrNmdFb0FBQUFBd0FBQUFBRGlnTDFBQWtBRkFBbkFBQUJNamMyTkNjbUt3RVZFekkzTmpVMEp5WXJBUkVESVRJWEZoVVVCd1lIRmhjV0ZSUUhCaU1oQW1zL0lqYzZJVUN4MVZzbkdFY2xQOFJnQVRtQU5pQW5GU1k0SERFc1FwRCt6QUc2RVJ5U0dRL24vcWMySWpCU0hSRCsrUUtVVGk0OVJpNFlFeFljTUZaSU9sZ0FBQUFEQUFELy9nUENBd0lBRHdBeUFGNEFBQUV5RmgwQkZBWWpJU0ltUFFFME5qTTNKaWNtTlRRMk16SVhGaGNXRnhZVkZBOEJMd0VtSnlZaklnWVZGQllYRmhjV0Z3Y3pGaFVVQndZSEJnY0dCd1lqSWk4QkppY21QUUUwSnlZL0FUVTNId0VXRng0Q016SStBVFUwSnlZRHNnY0pDUWY4bkFjSkNRZmpEZ3dZaG9NWk9pSTNCUVlIQXdZcUJ4a2JMRDA1UkVKckl6UWRFM2ZQQXhRTUdCTWtLQ1VvUGprcFJoMEhCQUVCQVFFekR3d0RBeEV0UENVZ1RDOHBFUUdBQ1FjZ0J3a0pCeUFIQ1NBU0ZqSXRXNEFLQmhJVEtENGVDUTRCQXdGTEhDMDZMQ1ZESUFvWERneUFGQnMzTXh3WUVoY1lDUXNNRkFnR0JBY0hOaGdQRXhNV0FTUWNDZ1FjSlJVYVBTSXFKUTRBQUFFQUFBQUFBdGNCMHdBQ0FBQUJJUmNDMS81UzF3SFQwUUFBQUFBQ0FBQUFBQU5rQXVRQUZ3QTdBQUFCSXk0Qk5EWTdBVElXSFFFVUJpSW1KelVCQmlJbU5EY0ZQZ0V5RmgwQkRnRUhJUzRCSnhFK0FUY3pNaFlVQmdjaklnWVZFUlFXTXlFeU5qVUM5blVORXhNTnd3MFRFeHNTQWY3eUNob1RDUUU4QVJJYkV3RTNLZjM2S1RjQkFUY3B3dzRTRWc3RERoSVNEZ0lHRGhJQ293RVNHeE1URGNNTkV4TU5kZjd4Q1JNYUNsWU9FaElPd2lrM0FRRTNLUUlHS1RjQkV4c1NBUklPL2ZvT0VoSU9BQUlBQVAvMEEzSUREQUFEQUNRQUFEY2hGU0VSSVJVUEFSRVVGak15TmpVUkx3RTFNeFVQQVJFVUJpTWlKaWN1QVRVUkx3R1BBdHY5SlFFN1JROVVYMWRQRVVYNFF3K0ltVkI0SXhvV0QwVXhQUU1ZTVFRTy9xbGpWRnBtQVVvUkJURXhCUkgrcklsNktpWWZUMG9CVXc0RUFBQUFBUUFBLzlvQzJBTW1BQ3NBQUFFMkppY21OVFEvQVI0Qk16STJOeFlWRkFjT0FRY0RCaFlYRmhVVUJ5WW5KaU1pQmdjbU5UUTNQZ0UzQWdnRkdpa1RBZ01sU3lBYlRDSURFaWtoQlg0RkhDc1JBeWNuSXlRYlN5SUVFU2drQlFMSEdoZ0ZCQkVFQkFzRUJBUUVEUVlUQVFRYUd2MXlHaGNHQkE4SURRUUJBd1FFRFFnUEF3WVlHZ0FBQUFBQkFBQUFBQU9NQWNJQURBQUFBUlFHSXlFaUpqUTJNeUV5RmdPTUdoUDlRaE1hR2hNQ3ZoTWFBWlVUR1JrbkdSa0FBQUFBQ2dBQS8rd0R3Z01CQUJBQUZBQVlBQndBSUFBcEFDNEFOd0E3QUQ4QUFBRWhNaFlWRVJRR0p5RWlKalVSTkRZekV5TVZNd1UxSXhVbE16VWpKUlV6TlFVV056STJOVFluSXdVek5TTVZKelVqQmhjVUZqTVdOek0xSXdVMUl4VUNBZ0dFSVJzYklQendIaHNiSHVIZzRBRVgzZ0VXNE9EOTB0OEJUMjFwQXdnQkFlSCs2ZURnT09FQkFnb0VaNlBmM3dIMzN3TUJIQ0Q5WlNFZEFSc2ZBcUlkRy8yL21BR1ltQUdZeTVhV21BRUJCd1JIUlpXVmxzcVlSa0lFQ3dFRGxaYVdsZ0FBQUFBRUFBRC84d09OQXcwQUV3QW5BRHNBVHdBQUFUYzJKaThCSmdZZkFSNEJQd0VYRmo4Qk5pY1hGajhCRnhZMlB3RTJKZzhCRGdFZkFRY0dGd0V1QVE4Qkp5WVBBUVlmQVFjR0ZoOEJGalluQVNZUEFTY21CZzhCQmhZL0FUNEJMd0UzTmljQkJqSUVCQWEwQkFZQkZRRUpCVEdYQmdZd0JRWDJCZ2FYTVFVSkFSVUJCZ1MwQmdRRU1wY0ZCUUVUQVFrRk1aY0dCakFGQlpjeUJBUUd0QVFHQWYzaUJnYVhNUVVKQVJVQkJnUzBCZ1FFTXBjRkJRSzJNUVVKQVJVQkJnUzBCZ1FFTXBjRkJUQUdCandGQlpjeUJBUUd0QVFHQVJVQkNRVXhsd1lHL3A4R0JBUXlsd1VGTUFZR2x6RUZDUUVWQVFZRUFSOEZCWmN5QkFRR3RBUUdBUlVCQ1FVeGx3WUdBQUFBQUFBU0FONEFBUUFBQUFBQUFBQVZBQUFBQVFBQUFBQUFBUUFMQUJVQUFRQUFBQUFBQWdBSEFDQUFBUUFBQUFBQUF3QUxBQ2NBQVFBQUFBQUFCQUFMQURJQUFRQUFBQUFBQlFBTEFEMEFBUUFBQUFBQUJnQUxBRWdBQVFBQUFBQUFDZ0FyQUZNQUFRQUFBQUFBQ3dBVEFINEFBd0FCQkFrQUFBQXFBSkVBQXdBQkJBa0FBUUFXQUxzQUF3QUJCQWtBQWdBT0FORUFBd0FCQkFrQUF3QVdBTjhBQXdBQkJBa0FCQUFXQVBVQUF3QUJCQWtBQlFBV0FRc0FBd0FCQkFrQUJnQVdBU0VBQXdBQkJBa0FDZ0JXQVRjQUF3QUJCQWtBQ3dBbUFZMEtRM0psWVhSbFpDQmllU0JwWTI5dVptOXVkQXAyTFcxa0xXVmthWFJ2Y2xKbFozVnNZWEoyTFcxa0xXVmthWFJ2Y25ZdGJXUXRaV1JwZEc5eVZtVnljMmx2YmlBeExqQjJMVzFrTFdWa2FYUnZja2RsYm1WeVlYUmxaQ0JpZVNCemRtY3lkSFJtSUdaeWIyMGdSbTl1ZEdWc2JHOGdjSEp2YW1WamRDNW9kSFJ3T2k4dlptOXVkR1ZzYkc4dVkyOXRBQW9BUXdCeUFHVUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FHa0FZd0J2QUc0QVpnQnZBRzRBZEFBS0FIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0JTQUdVQVp3QjFBR3dBWVFCeUFIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0IyQUMwQWJRQmtBQzBBWlFCa0FHa0FkQUJ2QUhJQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dCSEFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUhNQWRnQm5BRElBZEFCMEFHWUFJQUJtQUhJQWJ3QnRBQ0FBUmdCdkFHNEFkQUJsQUd3QWJBQnZBQ0FBY0FCeUFHOEFhZ0JsQUdNQWRBQXVBR2dBZEFCMEFIQUFPZ0F2QUM4QVpnQnZBRzRBZEFCbEFHd0FiQUJ2QUM0QVl3QnZBRzBBQUFBQUFnQUFBQUFBQUFBS0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFlQVFJQkF3RUVBUVVCQmdFSEFRZ0JDUUVLQVFzQkRBRU5BUTRCRHdFUUFSRUJFZ0VUQVJRQkZRRVdBUmNCR0FFWkFSb0JHd0VjQVIwQkhnRWZBQWR3Y21WMmFXVjNEWEpsWm5KbGMyZ3RjbWxuYUhRTWNtVm1jbVZ6YUMxc1pXWjBCM3B2YjIwdGFXNEllbTl2YlMxdmRYUURkRzlqQkhONWJtTUZaVzF2YW1rSVkyaGxZMnRpYjNnRlkyeGxZWElEZEdsd0JITmhkbVVFYkdsdWF3TnBiV2NFWTI5a1pRSjFiQUp2YkFSeVpXUnZCSFZ1Wkc4RmNYVnZkR1VFWW05c1pBMXpkSEpwYTJWMGFISnZkV2RvQ21GeWNtOTNMV1J2ZDI0TGIzQmxiaTFwYmkxdVpYY0tkVzVrWlhJdGJHbHVaUVpwZEdGc2FXTUthRzl5YVhwdmJuUmhiQVYwWVdKc1pRcG1kV3hzYzJOeVpXVnVBQUE9KTtzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3Q7YmFzZTY0LGxCa0FBT0FZQUFBQkFBSUFBQUFBQUFJQUJRTUFBQUFBQUFBQkFKQUJBQUFBQUV4UUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBYUdQbkx3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCWUFkZ0F0QUcwQVpBQXRBR1VBWkFCcEFIUUFid0J5QUFBQURnQlNBR1VBWndCMUFHd0FZUUJ5QUFBQUZnQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREFBQUFBV0FIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0FBQUFBQUFBRUFBQUFMQUlBQUF3QXdSMU5WUXJEK3MrMEFBQUU0QUFBQVFrOVRMekk4ZkUwZUFBQUJmQUFBQUZaamJXRndFenRlNWdBQUFrd0FBQU9RWjJ4NVpoS0pCNXdBQUFZY0FBQU8rR2hsWVdRWThNcXhBQUFBNEFBQUFEWm9hR1ZoQjk0RUVBQUFBTHdBQUFBa2FHMTBlSGh4QUFBQUFBSFVBQUFBZUd4dlkyRTVkRFlXQUFBRjNBQUFBRDV0WVhod0FUSUFhd0FBQVJnQUFBQWdibUZ0WllBMllHOEFBQlVVQUFBQ2tYQnZjM1N2MG4vUUFBQVhxQUFBQVRnQUFRQUFBNEQvZ0FCY0JIRUFBQUFBQkFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUI0QUFRQUFBQUVBQUMvblkyaGZEenoxQUFzRUFBQUFBQURhNk1OYUFBQUFBTnJvdzFvQUFQK0NCQUFEZmdBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFBSGdCZkFBb0FBQUFBQUFJQUFBQUtBQW9BQUFEL0FBQUFBQUFBQUFFQUFBQUtBQjRBTEFBQlJFWk1WQUFJQUFRQUFBQUFBQUFBQVFBQUFBRnNhV2RoQUFnQUFBQUJBQUFBQVFBRUFBUUFBQUFCQUFnQUFRQUdBQUFBQVFBQUFBQUFBUVFFQVpBQUJRQUlBb2tDekFBQUFJOENpUUxNQUFBQjZ3QXlBUWdBQUFJQUJRTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBVUdaRlpBQkE1Z2JyS0FPQS80QUFYQU9BQUlBQUFBQUJBQUFBQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCSEVBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFBQUFBQlFBQUFBTUFBQUFzQUFBQUJBQUFBaVFBQVFBQUFBQUJIZ0FEQUFFQUFBQXNBQU1BQ2dBQUFpUUFCQUR5QUFBQUtnQWdBQVFBQ3VZRzVnem1EdVlSNWhqbUpPWkI1bkRtZSthejV1em04ZWIrNXdMbkIrY1I1MERud2VqeDZ5ai8vd0FBNWdibURPWU81aERtRk9ZajVrSG1jT1o3NXJQbTdPYnc1djduQXVjSDV3L25RT2ZCNlBIcktQLy9BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFDb0FLZ0FxQUNvQUxBQTBBRFlBTmdBMkFEWUFOZ0EyQURnQU9BQTRBRGdBUEFBOEFEd0FQQUFBQUIwQUhBQWJBQm9BR1FBQ0FBTUFCQUFGQUFFQUZ3QU1BQmdBQndBSUFCUUFDZ0FUQUJJQURRQU9BQThBRmdBUUFCRUFDUUFWQUFzQUJnQUFBUVlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUFBQUFBQmJBQUFBQUFBQUFBZEFBRG1CZ0FBNWdZQUFBQWRBQURtREFBQTVnd0FBQUFjQUFEbURnQUE1ZzRBQUFBYkFBRG1FQUFBNWhBQUFBQWFBQURtRVFBQTVoRUFBQUFaQUFEbUZBQUE1aFFBQUFBQ0FBRG1GUUFBNWhVQUFBQURBQURtRmdBQTVoWUFBQUFFQUFEbUZ3QUE1aGNBQUFBRkFBRG1HQUFBNWhnQUFBQUJBQURtSXdBQTVpTUFBQUFYQUFEbUpBQUE1aVFBQUFBTUFBRG1RUUFBNWtFQUFBQVlBQURtY0FBQTVuQUFBQUFIQUFEbWV3QUE1bnNBQUFBSUFBRG1zd0FBNXJNQUFBQVVBQURtN0FBQTV1d0FBQUFLQUFEbThBQUE1dkFBQUFBVEFBRG04UUFBNXZFQUFBQVNBQURtL2dBQTV2NEFBQUFOQUFEbkFnQUE1d0lBQUFBT0FBRG5Cd0FBNXdjQUFBQVBBQURuRHdBQTV3OEFBQUFXQUFEbkVBQUE1eEFBQUFBUUFBRG5FUUFBNXhFQUFBQVJBQURuUUFBQTUwQUFBQUFKQUFEbndRQUE1OEVBQUFBVkFBRG84UUFBNlBFQUFBQUxBQURyS0FBQTZ5Z0FBQUFHQUFBQUFBQllBSm9BM0FFNEFZSUJ3QUg0QWs0Q2ZnTElBdklEWEFPVUE4UUQ2QVFVQkZJRWVBU2VCTW9GQ2dXU0JhQUYrQVl5Qm5nR2tnYjJCM3dBQUFBRUFBQUFBQVFBQXRZQUN3QVhBQ01BTHdBQUFSWUFGd1lBQnlZQUp6WUFGdzRCQng0QkZ6NEJOeTRCQng0QkZ3NEJCeTRCSno0QkZ3NEJCeDRCRno0Qk55NEJBZ0R5QVF3Q0F2NzA4dkwrOUFJQ0FRenlxdUlwS2VLcXF1SXBLZUtxWDM4Q0FuOWZYMzhDQW45ZlJGb0NBbHBFUkZvQ0Fsb0MxUmIrekJZVy9zd1dGZ0UwRmhZQk5Db0x6MFpHendzTHowWkd6elVDZjE5ZmZ3SUNmMTlmZno0Q1drUkVXZ0lDV2tSRVdnQUFBQUVBQVArK0E4SURVZ0FvQUFBQk5UUTJNaFlYRlE0QkJ5TXVBVFEyT3dFdUFRY09BUmNlQVJjK0FUY3pEZ0VITGdFblBnSUVBekVWSHhZQkFSWVByaEVWRlJGdFhQZDBjMlVmSXNhRG45TUZTd1grdjcvK0JRR1ArZ0VEQXN3NkVSVVZFYTRQRlFJQ0ZSOFZZQ2s4UU9XQmY1a0RCTlNmdi80RkJmNi9pTnh0S3dBQUFBRUFBUCsrQThNRFVnQXBBQUFUTXpJV0ZBWUhJeTRCUFFFME5qSVdIUUUySkJjZUFSY09BUWN1QVNjekhnRVhQZ0UzTGdFbkpnYnJiUkVWRlJHdUVSVVZJUlZsQVFOOWZaQUJCZjYvdi80RlN3VFVuNS9UQlFHQmJXN2VBbjBWSHhZQkFSWVByaEVWRlJFNldpczBPZHlJdi80RkJmNi9uOVFFQk5TZmRyc3NLVElBQUFNQUFQKytBOElEUmdBU0FCNEFPZ0FBSlJjV0ZBWWlMd0VHSkNjbUVqYzJKQmNXRWdVK0FUY3VBU2NPQVFjZUFSTTFORFl5RmgwQk16SVdGQVlyQVJVVUJpSW1QUUVqSWlZME5qTURONElKRkJvS2dvcityM3gyQm55QkFWQ0dnQlQrUnB6T0JBVE9uSnpOQkFUTmV4TWRFMk1QRXhNUFl4TWRFMlFPRXhNT2VJSUtHaFFKZ25FVWdJWUJVSUY4Qm5aOC9xL2VCTTZjbk0wRUJNMmNuTTRCaTJRT0V4TU9aQk1kRTJNUEV4TVBZeE1kRXdBQUFBQURBQUQvdmdQQ0EwWUFFZ0FlQUNvQUFDVVhGaFFHSWk4QkJpUW5KaEkzTmlRWEZoSUZQZ0UzTGdFbkRnRUhIZ0VUSVRJV0ZBWWpJU0ltTkRZRE40SUpGQm9LZ29yK3IzeDJCbnlCQVZDR2dCVCtScHpPQkFUT25Kek5CQVRORndFS0R4TVRELzcyRGhNVGVJSUtHaFFKZ25FVWdJWUJVSUY4Qm5aOC9xL2VCTTZjbk0wRUJNMmNuTTRCaXhNZEV4TWRFd0FBQkFBQS85Y0RxUU1wQUFNQUJ3QVhBQ1FBQUJNUklSRWxJVFVoSnlFeUZoVVJGQVlqSVNJbU5SRTBOaE15RmhjUkRnRWlKaWNSUGdHMkFwVDliQUtVL1d3dkF2SVVHeHNVL1E0VUd4dlFGQnNCQVJzb0dnRUJHd0lOL2lrQjExOWVYaHNVL1E0VUd4c1VBdklVRy82Mkd4VCs1UlFhR2hRQkd4UWJBQUlBQVArQ0EyMERmZ0FQQUI4QUFBRTFCeGMxSGdFWEZBY1hQZ0UxTGdFRExnRW5OamNuRGdFVkhnRVhGVGNuQWdDMnRuU2FBeUJDSEIwRXpwcDBtZ01CSDBJY0hRVE9tcmEyQXZPTHVybUxBNTEyUmp4RExHTTJuZEw5ZXdPZGRrWThReXBsTnAzU0JJdTZ1UUFBQUFBRkFBRC9tZ1BtQTJZQUN3QVhBQ0FBS1FBd0FBQUZKZ0FuTmdBM0ZnQVhCZ0FERGdFSEhnRVhQZ0UzTGdFVElpWTBOaklXRkFZaElpWTBOaklXRkFZSEhnRVhQZ0UzQWdETy91NEZCUUVTenM0QkVnVUYvdTdPcE53RUJOeWtwTndFQk53ZUZob2FMQm9hL21ZV0dob3NHaG9XQW01U1VtNENaUVVCRXM3T0FSSUZCZjd1enM3KzdnTmtCTnlrcE53RUJOeWtwTnorc1Jvc0dob3NHaG9zR2hvc0dtSlNiZ0lDYmxJQUF3QUEvOHNEdFFNMUFBOEFFd0FaQUFBVElUSVdGUkVVQmlNaExnRW5FVFEyRnhFaEVRRW5OeGNCRjN3RENCUWRIUlQ4K0JVYkFSMUVBcWorZk01RWlnRVNSUU0xSFJUOCtCUWRBUnNWQXdnVUhXSDlXQUtvL2VyT1JJa0JFMFVBQlFBQS83NER3d05sQUFBQURBQWVBQ0lBSndBQU56TWhNaDBCRkNNaElqMEJORGNYRmpNaE1qY0JOaVluQVNZR0J3RUdGZ2tCQXdFSEFRY2hKMDhKQTFBSkNmeXdDUStURGhFQlp4Z1BBUkVUQnhuK294bzlGZjU0RXdnQjBRRlUwUDZyTWdGVkF2NjBoaEFKUHdrSlB3blNjd29UQVYwYVBSVUJFQlFJR2Y0TEdqOENHUDcyL3ZVQkNrRCs5UUZwQUFBQUFBSUFBUCs0QThnRFNBQVNBQmtBQUJNaE1oWVZFUlFHS3dFSEp5TWlKalVSTkRZWEVUTVhOek1SbEFMWUpqVTFKcmEydHJZbU5UVW0zSkNRM0FOSE5TYjkzaVkxdHJZMUpnSWlKalZiL2Q2UWtBSWlBQVFBQVAvY0E2UURKQUFUQURFQU5RQkZBQUFsRGdFSElTNEJKeEUrQVRjaE1oWWZBUjRCRlFNUk5DWXZBUzRCSXhVT0FRY2hMZ0VuTlNNUk16VStBVGNoSGdFWEZTTTFJUlVCTkNZckFTSUdIUUVVRmpzQk1qWTFBNlFCSFJmOUlSWWRBUUVkRmdIOEZ6SVJtUkFWUmdzRm1nY1lDUUVkRi83RkZoMEJSa1lCSFJZQnh4Y2RBVWIrWEFFWUNnaHBCd29LQjJrSUNoRVhIUUVCSFJjQzN4WWRBUlVRbVJFeUYvNFdBZW9KR1FhYUJncmpGeDBCQVIwWDQvMUU1QllkQVFFZEZ1VFMwZ0tyQndvS0I2OElDZ29JQUFBQUF3QUEvOEFEd0FOQUFBc0FGd0FiQUFBQkJ4YzNKemNYQnljSEZ6Y0JGd2NuTnhjM0p3Y0JOeWNqQVJjQkFtMzFaVVFpYnN0dElrUm05ZjRmSW03TGJTSkVadlVCVS9WbHpBRVBSUDd4QTBEMVprUWliY3R1SWtSbDlmN3FJbTNMYmlKRVpmWCtyZlZtQVE5RS92RUFBQVVBQUFBQUE4QURBQUFEQUFjQURRQU9BQmNBQUJNUklSRURJUUVYTlNjQkl4RWhCU01lQVRJMk5DWWlCa0FEZ0dEK0NBRWYyZG4rV1VBQ3dQM2dNQUViS0JzYktCc0RBUDBBQXdEOVlBRWcyWWpaL2xnQ1FLQVVHeHNvR3hzQUFBTUFBQUFBQTk0Q3RBQUZBQXNBRHdBQUV3TVRNd01USVNNVEF6TVRBVE1USTlTeXNuYXlzZ0hpZHJLeWQ3SDltMnFrYWdLei9zMyt6UUV6QVRQK3pmN05BVFArelFKbUFBWUFBQUFBQThBQzRBQURBQWNBQ3dBUEFCTUFGd0FBQVNFVklSRWhGU0VSSVJVaEF6TVZJeFV6RlNNVk14VWpBUUFDd1AxQUFzRDlRQUxBL1VEQVlHQmdZR0JnQWJCZ0FaQmcvZ0JnQXNCZzBHRFFZQUFBQUFBR0FBQUFBQVBBQXZBQUF3QUhBQXNBRVFBZUFDZ0FBQUVoRlNFUklSVWhFU0VWSVFNek5TTVZNd01WTXhVakZUTVZJeFV6TlNNVE5TTVZNd2NWTXpVakFRQUN3UDFBQXNEOVFBTEEvVUNRSUVBZ01FQW9LRUJnSUNCZ016TmdRQUd3WUFHUVlQNEFZQUpRZ0NEOXdDQVBJQkVnZ0FFUUlDQXpMU0FBQVFBQUFBQURnd01rQUJRQUFBRWhOUmNITlNFT0FRY2VBUmN6RlNNdUFTYytBUUdJQVN6T3p2N1VXWGNDQW5kWmVIaC9xZ01EcWdLc2VLV2xlQUozV1ZsM0Fsb0RxbjkvcWdBQUFBRUFBQUFBQTZRREpBQVVBQUFCSVRVSEZ6VWhIZ0VYRGdFSEl4VXpQZ0UzTGdFQ2VQN1V6czRCTEZsM0FnSjNXWGg0ZjZvREE2b0NySGlscFhnQ2QxbFpkd0phQTZwL2Y2b0FBQUFDQUFBQUFBTnhBdFVBQ3dBWEFBQUJQZ0UzSndZSEJoMEJJUkVoUGdFM0p3WUhCaDBCSVJFQkhBVkpUajZCUEMwQkVnRXlCRXBPUG9FOExRRVJBVlI3Z1NGak9uRlZ2dW9CS0h1QklXTTZjVlcrNmdFb0FBQUFBd0FBQUFBRGlnTDFBQWtBRkFBbkFBQUJNamMyTkNjbUt3RVZFekkzTmpVMEp5WXJBUkVESVRJWEZoVVVCd1lIRmhjV0ZSUUhCaU1oQW1zL0lqYzZJVUN4MVZzbkdFY2xQOFJnQVRtQU5pQW5GU1k0SERFc1FwRCt6QUc2RVJ5U0dRL24vcWMySWpCU0hSRCsrUUtVVGk0OVJpNFlFeFljTUZaSU9sZ0FBQUFEQUFELy9nUENBd0lBRHdBeUFGNEFBQUV5RmgwQkZBWWpJU0ltUFFFME5qTTNKaWNtTlRRMk16SVhGaGNXRnhZVkZBOEJMd0VtSnlZaklnWVZGQllYRmhjV0Z3Y3pGaFVVQndZSEJnY0dCd1lqSWk4QkppY21QUUUwSnlZL0FUVTNId0VXRng0Q016SStBVFUwSnlZRHNnY0pDUWY4bkFjSkNRZmpEZ3dZaG9NWk9pSTNCUVlIQXdZcUJ4a2JMRDA1UkVKckl6UWRFM2ZQQXhRTUdCTWtLQ1VvUGprcFJoMEhCQUVCQVFFekR3d0RBeEV0UENVZ1RDOHBFUUdBQ1FjZ0J3a0pCeUFIQ1NBU0ZqSXRXNEFLQmhJVEtENGVDUTRCQXdGTEhDMDZMQ1ZESUFvWERneUFGQnMzTXh3WUVoY1lDUXNNRkFnR0JBY0hOaGdQRXhNV0FTUWNDZ1FjSlJVYVBTSXFKUTRBQUFFQUFBQUFBdGNCMHdBQ0FBQUJJUmNDMS81UzF3SFQwUUFBQUFBQ0FBQUFBQU5rQXVRQUZ3QTdBQUFCSXk0Qk5EWTdBVElXSFFFVUJpSW1KelVCQmlJbU5EY0ZQZ0V5RmgwQkRnRUhJUzRCSnhFK0FUY3pNaFlVQmdjaklnWVZFUlFXTXlFeU5qVUM5blVORXhNTnd3MFRFeHNTQWY3eUNob1RDUUU4QVJJYkV3RTNLZjM2S1RjQkFUY3B3dzRTRWc3RERoSVNEZ0lHRGhJQ293RVNHeE1URGNNTkV4TU5kZjd4Q1JNYUNsWU9FaElPd2lrM0FRRTNLUUlHS1RjQkV4c1NBUklPL2ZvT0VoSU9BQUlBQVAvMEEzSUREQUFEQUNRQUFEY2hGU0VSSVJVUEFSRVVGak15TmpVUkx3RTFNeFVQQVJFVUJpTWlKaWN1QVRVUkx3R1BBdHY5SlFFN1JROVVYMWRQRVVYNFF3K0ltVkI0SXhvV0QwVXhQUU1ZTVFRTy9xbGpWRnBtQVVvUkJURXhCUkgrcklsNktpWWZUMG9CVXc0RUFBQUFBUUFBLzlvQzJBTW1BQ3NBQUFFMkppY21OVFEvQVI0Qk16STJOeFlWRkFjT0FRY0RCaFlYRmhVVUJ5WW5KaU1pQmdjbU5UUTNQZ0UzQWdnRkdpa1RBZ01sU3lBYlRDSURFaWtoQlg0RkhDc1JBeWNuSXlRYlN5SUVFU2drQlFMSEdoZ0ZCQkVFQkFzRUJBUUVEUVlUQVFRYUd2MXlHaGNHQkE4SURRUUJBd1FFRFFnUEF3WVlHZ0FBQUFBQkFBQUFBQU9NQWNJQURBQUFBUlFHSXlFaUpqUTJNeUV5RmdPTUdoUDlRaE1hR2hNQ3ZoTWFBWlVUR1JrbkdSa0FBQUFBQ2dBQS8rd0R3Z01CQUJBQUZBQVlBQndBSUFBcEFDNEFOd0E3QUQ4QUFBRWhNaFlWRVJRR0p5RWlKalVSTkRZekV5TVZNd1UxSXhVbE16VWpKUlV6TlFVV056STJOVFluSXdVek5TTVZKelVqQmhjVUZqTVdOek0xSXdVMUl4VUNBZ0dFSVJzYklQendIaHNiSHVIZzRBRVgzZ0VXNE9EOTB0OEJUMjFwQXdnQkFlSCs2ZURnT09FQkFnb0VaNlBmM3dIMzN3TUJIQ0Q5WlNFZEFSc2ZBcUlkRy8yL21BR1ltQUdZeTVhV21BRUJCd1JIUlpXVmxzcVlSa0lFQ3dFRGxaYVdsZ0FBQUFBRUFBRC84d09OQXcwQUV3QW5BRHNBVHdBQUFUYzJKaThCSmdZZkFSNEJQd0VYRmo4Qk5pY1hGajhCRnhZMlB3RTJKZzhCRGdFZkFRY0dGd0V1QVE4Qkp5WVBBUVlmQVFjR0ZoOEJGalluQVNZUEFTY21CZzhCQmhZL0FUNEJMd0UzTmljQkJqSUVCQWEwQkFZQkZRRUpCVEdYQmdZd0JRWDJCZ2FYTVFVSkFSVUJCZ1MwQmdRRU1wY0ZCUUVUQVFrRk1aY0dCakFGQlpjeUJBUUd0QVFHQWYzaUJnYVhNUVVKQVJVQkJnUzBCZ1FFTXBjRkJRSzJNUVVKQVJVQkJnUzBCZ1FFTXBjRkJUQUdCandGQlpjeUJBUUd0QVFHQVJVQkNRVXhsd1lHL3A4R0JBUXlsd1VGTUFZR2x6RUZDUUVWQVFZRUFSOEZCWmN5QkFRR3RBUUdBUlVCQ1FVeGx3WUdBQUFBQUFBU0FONEFBUUFBQUFBQUFBQVZBQUFBQVFBQUFBQUFBUUFMQUJVQUFRQUFBQUFBQWdBSEFDQUFBUUFBQUFBQUF3QUxBQ2NBQVFBQUFBQUFCQUFMQURJQUFRQUFBQUFBQlFBTEFEMEFBUUFBQUFBQUJnQUxBRWdBQVFBQUFBQUFDZ0FyQUZNQUFRQUFBQUFBQ3dBVEFINEFBd0FCQkFrQUFBQXFBSkVBQXdBQkJBa0FBUUFXQUxzQUF3QUJCQWtBQWdBT0FORUFBd0FCQkFrQUF3QVdBTjhBQXdBQkJBa0FCQUFXQVBVQUF3QUJCQWtBQlFBV0FRc0FBd0FCQkFrQUJnQVdBU0VBQXdBQkJBa0FDZ0JXQVRjQUF3QUJCQWtBQ3dBbUFZMEtRM0psWVhSbFpDQmllU0JwWTI5dVptOXVkQXAyTFcxa0xXVmthWFJ2Y2xKbFozVnNZWEoyTFcxa0xXVmthWFJ2Y25ZdGJXUXRaV1JwZEc5eVZtVnljMmx2YmlBeExqQjJMVzFrTFdWa2FYUnZja2RsYm1WeVlYUmxaQ0JpZVNCemRtY3lkSFJtSUdaeWIyMGdSbTl1ZEdWc2JHOGdjSEp2YW1WamRDNW9kSFJ3T2k4dlptOXVkR1ZzYkc4dVkyOXRBQW9BUXdCeUFHVUFZUUIwQUdVQVpBQWdBR0lBZVFBZ0FHa0FZd0J2QUc0QVpnQnZBRzRBZEFBS0FIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0JTQUdVQVp3QjFBR3dBWVFCeUFIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0IyQUMwQWJRQmtBQzBBWlFCa0FHa0FkQUJ2QUhJQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBSFlBTFFCdEFHUUFMUUJsQUdRQWFRQjBBRzhBY2dCSEFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUhNQWRnQm5BRElBZEFCMEFHWUFJQUJtQUhJQWJ3QnRBQ0FBUmdCdkFHNEFkQUJsQUd3QWJBQnZBQ0FBY0FCeUFHOEFhZ0JsQUdNQWRBQXVBR2dBZEFCMEFIQUFPZ0F2QUM4QVpnQnZBRzRBZEFCbEFHd0FiQUJ2QUM0QVl3QnZBRzBBQUFBQUFnQUFBQUFBQUFBS0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFlQVFJQkF3RUVBUVVCQmdFSEFRZ0JDUUVLQVFzQkRBRU5BUTRCRHdFUUFSRUJFZ0VUQVJRQkZRRVdBUmNCR0FFWkFSb0JHd0VjQVIwQkhnRWZBQWR3Y21WMmFXVjNEWEpsWm5KbGMyZ3RjbWxuYUhRTWNtVm1jbVZ6YUMxc1pXWjBCM3B2YjIwdGFXNEllbTl2YlMxdmRYUURkRzlqQkhONWJtTUZaVzF2YW1rSVkyaGxZMnRpYjNnRlkyeGxZWElEZEdsd0JITmhkbVVFYkdsdWF3TnBiV2NFWTI5a1pRSjFiQUp2YkFSeVpXUnZCSFZ1Wkc4RmNYVnZkR1VFWW05c1pBMXpkSEpwYTJWMGFISnZkV2RvQ21GeWNtOTNMV1J2ZDI0TGIzQmxiaTFwYmkxdVpYY0tkVzVrWlhJdGJHbHVaUVpwZEdGc2FXTUthRzl5YVhwdmJuUmhiQVYwWVdKc1pRcG1kV3hzYzJOeVpXVnVBQUE9I2llZml4KSBmb3JtYXQoXFxcImVtYmVkZGVkLW9wZW50eXBlXFxcIiksdXJsKFxcXCJkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC13b2ZmMjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxkMDlHTWdBQkFBQUFBQXowQUFzQUFBQUFHT0FBQUF5bUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSEVJR1ZnQ0hFQXFkZUpoU0FUWUNKQU40Q3o0QUJDQUZoUkVIZ2pnYk5CVXpvN2FTa3pKSzluODZiZzZGQ1dqMUU4a1ZUM2xCd1FNbXdhREtFNEZWUzRac0hZaklBVFV2eW1veWk5MnRhemFxZWNaUnJjalRNSDFsNDUrd0szN2FneWZhNy9kbmR1ZGVmNktTTUk5RWk1cWFSWkswVEVtRUFnMVA4dlAvdjd6cVYvTzlYOEdpQnp5TlR3dndwbFJsQkZTdXlYVzBjbU1GcEpQRmFSMEFCTUROcmtrQlIza2lnOEpBeHEvcEQ0QXZ2TllRYmZQNG8rcHBHN0RRMllFK0dJblp1TWFNaldXVHEweFlaWkhtNSt0dC9uOCtNQWNXZ1gxZnA2WFZZZmQ2QlZMR3ZEM1pyKzFnZjRQaklrNFdhUXlBYldKVWpya3NnSUEvMXo3dFptNVNBRDRvc1ZBVnJrS2VrVWsrSm5tNzAzZWNJeTRSK1FvSktBOFFaUkVrb0VRcGFwd3ZSQXludmFjNlJTTjFTb2hNUkJxR2dGRFRuRlJOMi9FcHJZUnROc3Q1ejk4SXA0bmh3bmZjU0lXeHlqMStmbmhyenNCZCtmbmx5VUpBQnNPSjBDVWV6T3FKdlF2eDhiVC9oZEpnNFI3T0FOT0t3SUk1VUpnaW1pWTV0cGJ6VW9leEo2ZCttR3BUNGNVVlM4b1FjWk9nU2E5dDNsNysvb2ZrbGJtOEk3Zi9zc29MbmNialNuL0xwSTZGVGhCVEUzcHV5UXBkbzF2L25RY05kVFZWRllhbEhLSWtWdWJ4NVlWeXNoS1NVb3JTTWdJRkVSZVN3dFl4UURacVRRT3ZST2RhQVIya0RqQkJhZ0FicEFxZ0lCV0FCMklBUG9nRkJDQUtDRUVjUUFRaWdDdUtGTGlCeEVBQ2lqeG9BdkdBWGhBZjJBYVNCOTZDaE1CSGtCendDU1FML0djZUVuaEQ1aUdKTjlKMFVuaWJoeUxlMklvU1VCU0FIQ1FBampBUEJieC9tb2NJWHpMWDZ6d09tcUdDTFhBQ1BjRXQwZlozdWJrU3dqNlRwWmxKNitJTVZjWnlEUkZ0a2tLMDJVd0phYWF6SjlOYzdHamJRRmROSjlqcG1CNEVYbHFKRW1lVmtQTjRUV1h2NTF0WmdldXFxcHViQ0F1Rm1CNUd1WFJ2YmtWOWxjd1RxR3dVT0lHcUxFUFV1U1grTjJYMmorYjhTejN3bjltMkZvOHoxOVVkcCtMckREL25vRmd0Um9nUnN5SXBNQmtPNGVtb0VhTTBMOTYyV2NxaHpYZDJmMVpRS3lMQ1dRMDBZVDJBKzRUMTZOQ2h5dWFPUGNLbVJOaE01UFl2N3Z6UU15SytWY1pkbDJtWHRIVU5aUkFoajUrSG9YbkJSOVZPeS9sS3lzdWx3cU42MjFXaWNMVW42WnRMWlo3aU4ySkZ0d1E5czhQdG5PbzlFR3NoR2lObnU0b0Y3SUpMSEtkMHRuSXhQMnZEbmg4R25WYzUvN2o3WDQvL1pmYWY0WHRFRlEwdUxzZVJLczkrSEpsN1NTUXdiYzdwYUdvd1IrWlQvWTFjWncxTXB6d0lBSUZ6VEVJTW5VMVIyVXByaUIwdnFJOCt6YXNOSDJ1cEs2emZWUmVTK0locWZRSVZIeEUxanVibnE1dnloZmxvMjQzOEk3UGhMS1hQV3ZvUHhISmw2MVUyMjNjSkNyM0cva1ErZlJyaEFKRldFZlJSY2xDZWVzQmFoMFNDRm1NYTBad0VFRk9VV2pOa1JHUDZPcDFwNjhvY2F0ZHFYRityYzYzTzVZQU5yTFlpTURkWUtsVzlRM2d0K3RWVzNCZXhZa2JVREZjVUZ0SGlFaG1MQ21sSko2M0FFaFVVTDhRM3Zad0N3aUZpaEVTWHdpR0xpQjIxcTk2eVJTWk1JOUs5eVJPdTUwL1lnUFJJZ1B4ODRWbXVlMWsyaFB0elc3TUIyU3V2U3UreFZyKzVTYnVPQ0VYVzVndkU0T1BXZU1wbGk1MERzU2E4NHRYa0hkY2JiSlJHckNrQU1YbVh5K2xKeTJlb3ZqLzFNakZjYW0yOXRuTmZ4akVRb2RDeVJHZDZIMDBicnVOc1Q5MU9aV3QwSDRnRnMzbmhGVGVYWEVWekdUK2QySzA5cWROcGFXUjdSc3BVUXVUZUsycTVUNGl4N25TUHhBWncralVSWjBYZ2VacVNTR29uSjNGSlZUTlA0ZndPZmx5aVhQK2M2VC95WmZtenVmWWhOTVBnRXhHcVdqR2lxNkFFWmRCQ0hoSHZyODNFVzhBSkJTM1pJMncwblhWUmgzZ1QrY0NCNkxMVHhFaEt1cGF1emZJcEVGbFhieWFYemthV25nSVJ1cjdzK3ZYZWM4azBNWEp2M0VrYmVaTHo2MktwRVNQeTAzNVF6cHhhMFRJRVdrVVFhaWpCZHFDa0txNC9HMUpjanBWYkd3RW5hTE5uQ01iMU05RWtwY1hBODR5R0o5YUdPbjZCWGkvTTh5bkNlS05na2x5VW96ZXlpTkhBeTlmcCtEa2I4dXNOQnA2cTBNbVlMS1BTNlpzYW82RGxrTWsxNk5LODhUaWpVWkM3azhCbWYrTFRndm1PbGI1Nnc3YzExRWZuWlVyRHdvVnJxS3NOUXlweEkwYmdLb1VKOXdlb0RXSXhYRWtKRGorbU9ENVZJZ2ptV0tKUWhVcysyTWpNZjdRUlY3ZGNnV3JLcXI3TFdxTmI0dFZQbmJXU0VTZE1vNUdGOFBJVi9NSjAvTUYvL3c2S0h6OWg1QW9tVEwvemF6amlEVjczYVZwYnlsbUJrclVSVlVnK0xrcGRnbmozQmZkRnpMZ0RKdVJ2bVE0WFhybXlFQTVVTzlDdTNUdDhnRVoyTHhBRU4zV05HalhKUHRqZVZMU29TY1h0SGRrK2pwRGRxOVgyWmhQR3RZL3M1YXIyM0pzSHJWYm9oOCt6V21LaHhiTEszV0x0bWF4bVNwMmtUSFVkU3dhejZ0eDdqdGVRY1lMSjFFRVVkYndqMkVHL29ic3hwMUpucnV0WDhabTNsdWY2WFVqZENEckFOVEp6Nk9CYVlQdmN0VDA3ZGs5cFJjenprZmFrUHdtSit4eHJ3K0I4NnlYejJOMFlvSHd6R2JYSFVhMWgweDJBVFczRm95amUrNjBUam0rMUEvMkplaG04Y3dmaVg2WTRQclhhS1V0ZzlqSE8zR29IZmcwdVI2UEp3Y0VDODdzQjByRlFNcy9DYzBhK0ZsL0dZTldyZGNQRzhLMVdESnMwRWVVb0ZDQ0xSVkZSS1BHVTBOdk1TN05iYnFHRFJJL1o1VjdEeDVhejVweEttZkRWYThSRllSN2xBaldmNHBKUFpXZU1Hd3dvV1BKTkQ0V0hWT0hPSFFJNzExYTZsMHJ2enFDWDdrcEJsQndsV3FvZnFDekVCd1NMNnErUXh6S1pQaVlJbGE5ZVUxWXJ6ZWI2YnNxVEZJbGUrU1JwZjlMVGRFbW5xaTJFcDBtWGwxOFdyaVdaeVVQY01OSW1zaldrcG1UZ2NVWCs5YXU2SHNOUXpmQ3paNGRyVUF5clYrOWM0bUZoR3BhYm01RnRZVEl4VEpVQTRtMGdRTldpbjg0dU4yOU90UG10WENXWEgzWlpGQURYeXN3MGNHWHJsaURWNGZYalNhbWRtNFBVUVVPWDFROEZ0azFYSDU3cENJZzVkS2hhMnhjNXhQNFNaMlNMdFhLeDJEOWVMR2ZKeERKMGxWMnRGYnV3UXJJNFdPcnJkNUNEQ2V0OHVxekx6U0pkUHNXNGpnNWNNUk1taTNTVmRvMUExcXhCL0NPNFd0Q1ovdVVPZWZpZUZHMm1PTFpXR3huZDVKTi84RFZIRmdSN1VyY2ZIQ29EUS9mRXM0Zk5OakhsVzE1Y0xTNnJidzdJVFhMTWpqOU9xcG9UcVEzTi9CZWJwRW5PYmQvSEtrelprMUEwTXdSRVM3U2tpU1N4czlWbGJvOWRMdTFvOWkwYk4zS00zUlBwVlU0czBqaFRmRld6cTBWcDYvYkhSbUtSUHU0SmlVTmR2TUtzQXpwR1huQjFDQS9hMXlrSjYwenBpWXVjb3VTZXFnOG1rY0pJVEFRUmlKL3M4M0tsSGQvdUxrNjNleXYxSHNzQTF5OXZ2SDRSZkZ2YWQxamlJR1VjWTBockhEajBkZ2JUWkMrMW54UmR3RUFkSk15ajVJRmFvbllnbVNnYkhHTnlITkNMSVFGbEV1VTlBdE1EN3NUZUVVVUhLdUM3b3JxOHZLcWlySktCYVVDQkQveDVTTVEveko4MG9kdXM2dlJ5WDhqUFNzdDdwNENBZERMVk9OWVZ4WE85c1RRb2RraUhYQjhpbHoyR2t0by9MWFhuQ3NnaSs5UlZTOTBjMGlBM2hzeEMyc05UUWNRUlBkZkVQVGpTbnJRYWlGMXhZeVhyeFBNazZ6K3luZGU2TEhWYTYveFEvdEQwVUFCTTkwMThVUGV1NzFuREEwT1djVGdZREdBSEhpUUJ4U09CN3FIK29TSDhqT2tSVU9JUzhIUHhBOEZTNUlIK3dYZDlzNVlBd2c1MlNJUnFHeStnQVBLMkVjWmdPSU1oUDkrbVZINkxMbjYyd1lERHhoQjQyMkJCd0RhZUtpS0ViVEFvbFp6cURJYXY0NVU0T1RkZUEwYmFiSCsvUXVlRFhBZkFkdEJSbUZ2U1k4c2ZoVW1CTitBYTZCVTRtZ2FPQ0p6ck9SeTQ5aHpjQVVPN2tQckEzVTdEbE1DN2NEbDBXM0VZbXBWeUFBQ1FBQkIvSDltK0dZazhKT0NqR3BQTG9jdEhOaVBYTnA2TWZMUDl2dzRLa1luSURkd1ZvMGFlRXZoVkM2U3Z2bzNjaEI0TW40bzdTdDVLSEd1L21BWVoveVlVQkZ4ZTBOaFZySmh2QzlxZkR0ZmNmbm1zdEV5MWpZNk0zYTQ0ZkplU2p1Q2Znb2k0K1Y3eW5YcDFSRE0rL29mY1dSN1RybXNSM0hRaE5BYTFtQjN3ejBGUzF2TjF0UXZaSXNob3d6MmRibmphMDYzSWlDaGRJQTdkSmk3ZG54NmFPYTQ4a25QSmtqZ0FwaDVHMDBYUjQzUWo2V202VmZSQ2xQNnpuTUVCamJoVUlyNDQyZUhVTUxKVmp6OWlqRXBnVlAxVVRsT3k5cWZLNmxaRVU4QTRJZjVDMDRlS2R3NWNmdWdmT0R0SzZsRHVJK3N1U09EaFNzbTM1aWhpbFdXSzZ0eHo0eEFDcVk3cENpMWxLOUtkZGpzYmEwV3BLUTVXQUdOVUFxUFV6N0MwMDVSc2JySUNIWVZvUmlMbjcrS0UrQXROSHlwT0gwRkUvbUU0ejhUZ3QwYzVLTzN6eUVXbjNFTmVSNWxQVnpaSFlveFZUcktzamNyNVdoc0VKVWwwRjE5NWhUNkpLN1VkVm5Zbk8zTXFLN3E4OVhaOE9kbWVySWZSejFFK0ZJa2xVcGxjb1ZTcE5WcWQzbUEwbVMxV205M2hkTGs5WGw4d2IyTGNITzViaHJYNzVyWmcxN1N5MmNnL3dNcjhSUlFMbHhibGUwRzlqSVgwSkQrVG5pTFMxUzEwQysxcmVreDFRTVZqY2Qwa1Z6ZE1na3QrN0dJejBXUXc2c09Jd29SaGFOSW5ROVAvbmdTVG1vTFpabUhuSVMxVDM3U3Jpa2N4OThLNGpkS2FPcVJMWFZrazNGY3RETGdZcmxUTW5GVEI2VlZMN0Y2VTF2eFRWMllkc0xKOUNGa3prQVlEQUE9PVxcXCIpIGZvcm1hdChcXFwid29mZjJcXFwiKSx1cmwoZGF0YTpmb250L3dvZmY7YmFzZTY0LGQwOUdSZ0FCQUFBQUFBL29BQXNBQUFBQUdPQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCSFUxVkNBQUFCQ0FBQUFETUFBQUJDc1A2ejdVOVRMeklBQUFFOEFBQUFSQUFBQUZZOGZFMGVZMjFoY0FBQUFZQUFBQUU0QUFBRGtCTTdYdVpuYkhsbUFBQUN1QUFBQ2pBQUFBNzRFb2tIbkdobFlXUUFBQXpvQUFBQUx3QUFBRFlZOE1xeGFHaGxZUUFBRFJnQUFBQWVBQUFBSkFmZUJCQm9iWFI0QUFBTk9BQUFBQklBQUFCNGVIRUFBR3h2WTJFQUFBMU1BQUFBUGdBQUFENDVkRFlXYldGNGNBQUFEWXdBQUFBZEFBQUFJQUV5QUd0dVlXMWxBQUFOckFBQUFWY0FBQUtSZ0RaZ2IzQnZjM1FBQUE4RUFBQUE1QUFBQVRpdjBuL1FlSnhqWUdSZ1lPQmlrR1BRWVdCMGNmTUpZZUJnWUdHQUFKQU1ZMDVtZWlKUURNb0R5ckdBYVE0Z1pvT0lBZ0NLSXdOUEFIaWNZMkJrWVdHY3dNREt3TUhVeVhTR2dZR2hIMEl6dm1Zd1l1UmdZR0JpWUdWbXdBb0MwbHhUR0J5ZXNiM1dZRzc0MzhBUXc5ekEwQUFVWmdUSkFRRGlTd3dhZUp6ZGtrdE9Ba0VRaHI4WkVCUkhtRkZlUGpBbXNDQ0dwVEV1WE1COVhMRG5XSnlBeS94TkFndndBR0ExTlF1V3JPM0tOLzJZU3ZwUkgzQUZWSXlKVVlWMFJHSWprbGRiVFU3ckZScW45U3EvTm4vbnpVWU4xWlNwcVVKOWpUVFRYQXN0dGRWZWg1Q0dlaWpDTkt6Vys4MzRlSVF5TjFkYnc3UGNYWm5iT3MrOXNDVjJEbzhKSDN5ZXhWY1ozMlhBZ0JlZWVlS1IxTzVTdFJzbjlNam9VK2VhdHQzdWdYdnVhTktpUzA3QkRSMXVxZGsydFl0UDlIOWJGai9KVHprYnhIbzZwM0htMkJ1anBtT3ZqWExIM2gwVmpsVUF0UjJyQmVvNDBUOTFuZWlnZWs1MFUzMG51cWloUS93L2N1THBOSE9JdVhQSGFvc1dqbFVaTFIzaS9sc25lcTJkWXc2Z3ZXTTJvSU5qWGhCU3h3d2gxQjF6aFZCaTFoQnloOWdYRHJHZk91WVVZZVdZWGF6M2pubkdadXhRK3dNcndJY2ZlSnlGVncxc0hNVVZuamV6dCtzNzIzZmUyOXZkODUzUHZoLzcxazRjLzl4NWI0a1QyNmRnRzBvUWlVS2dFQ2h4bTlnb1VFZmlMN0ZLd0U2b29oQ29zRnJ5MjZCVUphZ1FLRDlwYXJWVUFndmFValdKZ1JBYTBscUpDZENxYVlVZzRFQlJidW1iM2JNeENDbDd0MjltM3J5Wjk5MmI5OTY4SXdMQlJ5RDBiNlNVNkNSRm1na0JqZWdpa2RMRXlCSGREMUkxNkoxZ05Ua2RIRGFCMFFseitaU2NoekpLN1UvUG43Yy9wUlRLemg4ODI5Qnc5cUJMVnc5VE9yemFwZDJyS0YzVjdWRDZ0bVlmMVp3WDJ2ZzdyL1QxM3Q3WFN4MXF6cTVZUGR3NXN3SXBRZ1ZDdm55SnZjSldrSG9jbUcyNWpLYXJDQ2JWQkcyNVJZQW8vYUM3eUxKRnNGUmdyV3FOQnFBRm5wVlZWUjY4K2JPNzcrcXZTZjc1Z2YxdmVaWjY3SmRmdGozd3lCZkE2TkYyUHY5c1FLVlVyVkg3R2hiblA5Zzh2SWNKSi9hakNBcHVteHljUDR2aFZjVFFRSWlTeldnaGtldnZBSTRtQnJsYWZkWlMyUmtqR1dueFA0UE83a2dTYWordysrNGJCVmY1VWxTQVVHRHo0UHJUOUw2NVVOdFh6VzliT0xuTjFiNy9oSUNDRy83UTJKQWhoQlh0MEV1Q3BKcTBFMUtuSTR4a000aTFSanBvSVFZdDZIRTFPMGVsbUM0NEIrMThVRkUyM1FHcFpMb3RsMlhXRm04bzR0dXkzWDV1MHdaeDAyWll2blVrWlBmdW14Q0VpWDM3amduQ3NYdVZtTEltb0NpQk5kaFo2MWNVLzlBV1h5VGszWEpIYUdRckxOKzhTZHl3eVg3dTlJejR2bjBUOEpBanRuYnVRdTVxWDhjOTc5SzRFeHh3S3NHQlhocW5EajZ1ekw2QXVpK05FQ0U1cURBR3ZqekpubUlOaUU3Q0tLakZVNVVUY2wzQ1RCaW9YcFZkQUtiY2xsUFEzV1EvSk5PRzNBbGo5TkhDRC9uYlRNK0hvdEZRd1kvMGpWQVVJRm9mUVVMTDdRWTR1ZnFXVzRwVElTNW1qMFZEOWdlaFNDUUUwVkNVVU5TOWhRMnkrMG1BMUhDUGxuUVRmU1lrb2R1WVRjRFFEamtMVGFFaVU3VU1Tc2JHN3Q3TDRrdXFZc0xFWHV4Qmpkc2RHNk9mUFBUaTd4OWlqMjNvWFh4NTQ1cmNZOGNMOTdxRGVmMDRFSENTMjkrRCt2YXlmN0lCSjk3ajZNRXR5SFJpM1hMaW5zMkpiSVZibmRzL01kTXBUbEV5WVgvbzhVQndZZ0tDNkpzZlRoeVlGSVRKQXc2dDFpS1J4a2pFSG5CYmphNWZzV0k5N1o4cmphdloyaGw1cFBZTFhITG0rd01VeDBXT3J4eGh2MlVtMmtZaGxYZ3FzNmVCWnNIVDBQR1V3TEIwMERleGtsQXNGcnI0dVJxRldEZDkwdDQwMGIwZGdqM001TXhRREtJcWwvaCs0UWI2Wk9IY1JQZURvUFE0dHVCeDNJOTJLVU52VEJLREVDdWJ5TVFnaEFlTzhXenBHZzR0eUtVTlNJc1NpSm9YR0VnZ0pZeGxYcmJjNjczNHZEZndNNzhNdDRZRElDdFNwZjE0cEVPMWg1UVNlQk5Xdm1FL25ZSHJxSDE0YTRXM3k0dmY0M2Y1RlBnZVNrQkZxS1RTTG8xMDBiQjl3WjRHWHg3Sk9uNCszQjkreC83Q3JzVDRtUE9MNTROa3BGd1gxT1dzYm1YbFIrazdhZE5NaitIRDI4blIwVWwyaFprdW5FNmJZMk5tbXFMd1RZWFRvNk0wNmZqM0pEdkFhdEdLcmNRa1BSaDFlTXFPRWZFd1VVVU5WSVBLNUxaME0yYlFsRnFjTkZOeTF1UUMzUGRTWmtLRnR2UjhTSXBvSG0wUlpISW1Pd0F4dlpEQXRBSXhEUzdxR1hsUGhkcGI2dGtyaGIwNFkvOEpaM3A3K2R4ck92YnNteUhzSzFrbitYelN1aEtmclBObE9qMkRRbXJGSGptajJ4cWM4MWFLZTBYZmUrN2NlNFh1OTkzTjN6OStuRDdORno1WDR2T1ZGUFBJT0J0bmVjZVBveGc1a202aEswZ0d0b0NOaFVNSkxDTUZPdERCNmY3dTVQb2pnOG51Z1dtN1pxWUgxMDczSDRWQXQvMHh5MDhQZENjSGo2eFBkdmRQMitkbWU3K2VIbkRtbmJoQnBlT01PRG1pblBoUnE1TWxXQUowMDRDVW5QQ2txdEVvYmVta21HY2pmWFlKMUp3NlpkK1lwK09GcVJiTUNGSDhNbExBOVlVK2lKL2Fkc3ErZ2VaL0VlTHNxUE43a0p5bWgxRlRLZm83VVppU1pVb2lwYkNzQWxrbGRlTFFvUTJIRHNGWkpCdGZLUHo4dGdPMzBkL1l4K3hqa0lXczI5ckg2QUFSWFp4MHlzRlo2a1FPSW9XRW1wQ0xMOHVxS2JYNEFrRjQrWmwzdk05NTRQaytHTzJ6U1I4ZDczc0RQM3pMbVgwL0t1NHJZN3pVZjNOZkUvZGs2dXoyWmtyaEhJbjN2cTVvTko2UHQrVHI2L045OFhoZk50dVgvMHJsOHBGNFlUd2VpTXZ4RWFpSXg3TUw0dnkrUmQwUG9QK0d1RVpUbDh5RW02VlFqVk9Pd0Rab3hLUnk0c2FObEc2OGNXaG8rQ0JqQitrelEwODhNWVJqNUs1aUI0ZUhEN3AzTis1MVlIWXZUTGNKOTdaR3BHNDVNMlNmd0VUVmVPbTlxTFBYSGZSdHh3Y0o0SEpEbERBODBCeHorbERsK2M0MW5ac1hMNEFnWklTcjNLNE1LKy9kbkZqVGZzZDFMNTJEK2psZE11TUwyK2swOFNKS3pFbVFzWEp0QnNhZXFtRFBkTHJvZUJsZFUwT1NLR2x1bTByUTI3dVNWbnNpLzhMYk54bmhLK3E2L3RnSEMwZHljVU5OWDFiVjJyaGsxRDRLTDhwVlA2ME0vTXYrVlM3WnNpSldZZitQUG5wTlUwZHZVMWpScWxxdXY3TDlobUpzMlhoSFUvU2VETG1GNjhjb2RDOUJYdVJrcmJTUnhub2lpd0IwUjNrQW1nRjVxYVNvaGh5V0xtVmRiTTRubFhTbWNhMlI3Z0xUcWdGTnI2YlpERjV4eUdHSEpLOVh1cmlQMC9mOFplR3REMVMySnkyUEtERnhubFFaYmV4WTJMM2s5bFJiVE5uNE9ndVZoWlhhK3JyNnpvVU52VEZKQUh5eWdUTEc1QVdMNitKWE56ZklNT0tWNG53bkpQR2dsbGx3MDRoUERDcjFuZFZlUDZidXBWVUwyaHZyTG8vN2RIL1pTQ2hxWmF2Q1FUM3NMUzBMbFlpQ0pPWENXRDVvVUZ2bEU2cnExRWhIY2w2ZHYrZ3o5Q1M4eFU4Y0VqbzlhYS9BMFp0azFnZlcwdmZSQXhiaGJMRU9kUTJHWllJSlNOc3NMR2s0YTA3V0xaYU5hREU1eEMrWm5Fa3YzRk91S09Xdklva0d3VDd2aXloZVdBekJxQUpXUStHTEJndXdmZFVmRFBvZFFrVi9rRDdPcDkwMTVmZllIM3VWaU85NlB2bUtLMDFGYlBsdVFYL2hDODUzN3BkUDJaMnNERThaNnh6TGpWMjh2QkFFWXBDYndjdzZRenkwdE5FRW5QTUkvVWVoRGhiMUJGYXUvdTR5dWVmenl3UGI5aXdmU2tXMFFFOXJCd3UzQ243N3FUVXJWdzNBVmJLbnRkVWoyODg4K0tONTZacGxWOEcxZnFGWUwvK2R2c1BTQkt0bmZwZWk4M1RoallNS0xlNGxhQlVtdWs3c09wR0VBaFl2TTBvOGtRYUZzcnFsOGVqVlNSWnNTSGp1OTFUTmw1bGhwR3FqUzVPQ1hGL3JvYTlGd2g1QkZvUlNBWjl5VVFFaEVpbmNHZEZGSVZCU0xnQkRaa21BaWVFSW1ZMy9oK0VWdlBFSnpGU1dhSCtOUFJ4UkNrdVVTRVNoTHlrUjJLRlVWaHFWbFZ6Y2gvai9pL0VBcEFMak1VeXFuTHFwaVZoNDRsM2NJOXc3MmlqV2lKaXMxYXdITTE4ZDVyMDZUSDRlelVMVDVveVVoMmRJdkZaRkhhMnRXVGppWXZpWDZjZUphRFIrOGFQcWFMVDYzYWtwMEUrRE5qVlZPSDRHbGcydVl5VUE3OXIvbnBxNjdGMmdQdUhXeDgrY2djL09NS2lLRi9vVFdOalUwRi9Hb29XWGQ4TnUvQjdadVhNM2dDUmMwYk5qeDg2Lzd1NWRJcFFDMjdGejUwNzNieDc1OGhQMkUxYU9kNEtCMkpjaGRpdUhkMzVhNUFWQUYraGFGK1FNVG5VdGg5MTBBRDIyQmlSUng3SWdnUDloQWlEeUlkWUxXZzRySXM0U2tZY0xPakVEV01nVE00SWdIaFpFVU1IcmFkMGxpaTBlendWUjNOWHE4U0pMRkE2TGdwRFpoYVdqOHRYOHJwazFoYlBmSWtuSHZzbHBFY1hGYzFiTmFMTDNmelUvdXd2VWZJc2tJZjhITXJZNUMzaWNZMkJrWUdBQVl2M24zQUx4L0RaZkdiaFpHRURnMW92RFVRajZmeE1MQTNNZGtNdkJ3QVFTQlFBbERRcXdBSGljWTJCa1lHQnUrTi9BRU1OU3lBQUVMQXdNakF5b1FBNEFVaTBDK0FBQWVKeGpZV0JnWUtFMkxpU3NCZ0FzK3dEcUFBQUFBQUFBQUZnQW1nRGNBVGdCZ2dIQUFmZ0NUZ0orQXNnQzhnTmNBNVFEeEFQb0JCUUVVZ1I0Qko0RXlnVUtCWklGb0FYNEJqSUdlQWFTQnZZSGZBQUFlSnhqWUdSZ1lKQmppR2ZnWWdBQkppRG1BclAvZy9rTUFCV2hBWjRBQUFCNG5IV1J6VXJEUUJTRlQvcWptSUFMeGE3SGpZS1M5R2NqRkZ3Vld0Y1Z1bStUU1pxU1pNSmtXdWpHTjNEaDgvZ1V2b0EraFh1UDZRaWwyQXk1Zk9mTW1adkxCTUFGUHVGZzkxengzYkVEajJySERaeENXRzdTdjdYY0lnOHN0OG1QbGsvSVQ1WmQzT1Bac29kTHZMQ0QwenFqdXNPYlpRY2R2RnR1NEJ3ZmxwdjB2eXkzeU4rVzIrZzRudVVUOHJWbEZ6UG53YktIRytmVkhXazVOeklTaTYxSVExWEVxakR1eHM4algwYXBVWG9xazNVMjEzdk9IczZrcmxKVmlIN1EyM01uc3BENnIyZTFTUWJHeENMV0toZGpOcGRacGtTcDFVcUdKbGdhVXc2NzNkajZRYWh5amppQ2hzUWNoalhpdFM2d1pVMFJRcUZBWEZmRDNBWStjaWI4T3BmU1V6dzVwVXF3UnNZTytram1mM2RHcFZGUi8zNUJvSThBdlNQWkNWVlI1dy9uckhnaTRVODNYREYxekl4aUI0R3huVnh5dG93c1VOWjdLem9oL1FETCtsU0pJYnBjOFVFK3FHOGcvd0VCQ25VN0FIaWNiWTFKZG9Nd0VFUXBFSVpnazNrZTdCTndLQkFOS0FnMWFZUkpmUHJ3a3BkZC9xYmVYMVJWRUFhL1pNSC83QkVpZ2tLTURSS2tPRU9HTFhiSWNZNExYT0lLMTdqQkxlNXdqd2M4NGduUGVNRXIzckRISVVoR29hT2hKUmRxaEthdUVOTjJmdmRubGhxZm5KaUh3cmowSjNuMmtXZXRwaStuWXhyNDNhUzZJOTFYL0JsclM2VkUzb3hxS28ra3JIRjlaSVpXYWE0cG5HM0lWZ25WckdaWGMvd3hzeWRWc2EzenlZdnB5WGZDYzl0bHBRZ3ZSYzJMMi9KSWJuMHVIQzNaV2lJcDFrM2FHRjlhbzdPT3haellyUkw3c3JLVU5iTzFreFlpRndUZkZ1cFBtQT09KSBmb3JtYXQoXFxcIndvZmZcXFwiKSx1cmwoZGF0YTpmb250L3R0ZjtiYXNlNjQsQUFFQUFBQUxBSUFBQXdBd1IxTlZRckQrcyswQUFBRTRBQUFBUWs5VEx6SThmRTBlQUFBQmZBQUFBRlpqYldGd0V6dGU1Z0FBQWt3QUFBT1FaMng1WmhLSkI1d0FBQVljQUFBTytHaGxZV1FZOE1xeEFBQUE0QUFBQURab2FHVmhCOTRFRUFBQUFMd0FBQUFrYUcxMGVIaHhBQUFBQUFIVUFBQUFlR3h2WTJFNWREWVdBQUFGM0FBQUFENXRZWGh3QVRJQWF3QUFBUmdBQUFBZ2JtRnRaWUEyWUc4QUFCVVVBQUFDa1hCdmMzU3Ywbi9RQUFBWHFBQUFBVGdBQVFBQUE0RC9nQUJjQkhFQUFBQUFCQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQjRBQVFBQUFBRUFBQy9uQ3hCZkR6ejFBQXNFQUFBQUFBRGE2TU5hQUFBQUFOcm93MW9BQVArQ0JBQURmZ0FBQUFnQUFnQUFBQUFBQUFBQkFBQUFIZ0JmQUFvQUFBQUFBQUlBQUFBS0FBb0FBQUQvQUFBQUFBQUFBQUVBQUFBS0FCNEFMQUFCUkVaTVZBQUlBQVFBQUFBQUFBQUFBUUFBQUFGc2FXZGhBQWdBQUFBQkFBQUFBUUFFQUFRQUFBQUJBQWdBQVFBR0FBQUFBUUFBQUFBQUFRUUVBWkFBQlFBSUFva0N6QUFBQUk4Q2lRTE1BQUFCNndBeUFRZ0FBQUlBQlFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFVR1pGWkFCQTVnYnJLQU9BLzRBQVhBT0FBSUFBQUFBQkFBQUFBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJIRUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUFBQUFCUUFBQUFNQUFBQXNBQUFBQkFBQUFpUUFBUUFBQUFBQkhnQURBQUVBQUFBc0FBTUFDZ0FBQWlRQUJBRHlBQUFBS2dBZ0FBUUFDdVlHNWd6bUR1WVI1aGptSk9aQjVuRG1lK2F6NXV6bThlYis1d0xuQitjUjUwRG53ZWp4NnlqLy93QUE1Z2JtRE9ZTzVoRG1GT1lqNWtIbWNPWjc1clBtN09idzV2N25BdWNINXcvblFPZkI2UEhyS1AvL0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUNvQUtnQXFBQ29BTEFBMEFEWUFOZ0EyQURZQU5nQTJBRGdBT0FBNEFEZ0FQQUE4QUR3QVBBQUFBQjBBSEFBYkFCb0FHUUFDQUFNQUJBQUZBQUVBRndBTUFCZ0FCd0FJQUJRQUNnQVRBQklBRFFBT0FBOEFGZ0FRQUJFQUNRQVZBQXNBQmdBQUFRWUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURBQUFBQUFCYkFBQUFBQUFBQUFkQUFEbUJnQUE1Z1lBQUFBZEFBRG1EQUFBNWd3QUFBQWNBQURtRGdBQTVnNEFBQUFiQUFEbUVBQUE1aEFBQUFBYUFBRG1FUUFBNWhFQUFBQVpBQURtRkFBQTVoUUFBQUFDQUFEbUZRQUE1aFVBQUFBREFBRG1GZ0FBNWhZQUFBQUVBQURtRndBQTVoY0FBQUFGQUFEbUdBQUE1aGdBQUFBQkFBRG1Jd0FBNWlNQUFBQVhBQURtSkFBQTVpUUFBQUFNQUFEbVFRQUE1a0VBQUFBWUFBRG1jQUFBNW5BQUFBQUhBQURtZXdBQTVuc0FBQUFJQUFEbXN3QUE1ck1BQUFBVUFBRG03QUFBNXV3QUFBQUtBQURtOEFBQTV2QUFBQUFUQUFEbThRQUE1dkVBQUFBU0FBRG0vZ0FBNXY0QUFBQU5BQURuQWdBQTV3SUFBQUFPQUFEbkJ3QUE1d2NBQUFBUEFBRG5Ed0FBNXc4QUFBQVdBQURuRUFBQTV4QUFBQUFRQUFEbkVRQUE1eEVBQUFBUkFBRG5RQUFBNTBBQUFBQUpBQURud1FBQTU4RUFBQUFWQUFEbzhRQUE2UEVBQUFBTEFBRHJLQUFBNnlnQUFBQUdBQUFBQUFCWUFKb0EzQUU0QVlJQndBSDRBazRDZmdMSUF2SURYQU9VQThRRDZBUVVCRklFZUFTZUJNb0ZDZ1dTQmFBRitBWXlCbmdHa2diMkIzd0FBQUFFQUFBQUFBUUFBdFlBQ3dBWEFDTUFMd0FBQVJZQUZ3WUFCeVlBSnpZQUZ3NEJCeDRCRno0Qk55NEJCeDRCRnc0QkJ5NEJKejRCRnc0QkJ4NEJGejRCTnk0QkFnRHlBUXdDQXY3MDh2TCs5QUlDQVF6eXF1SXBLZUtxcXVJcEtlS3FYMzhDQW45ZlgzOENBbjlmUkZvQ0FscEVSRm9DQWxvQzFSYit6QllXL3N3V0ZnRTBGaFlCTkNvTHowWkd6d3NMejBaR3p6VUNmMTlmZndJQ2YxOWZmejRDV2tSRVdnSUNXa1JFV2dBQUFBRUFBUCsrQThJRFVnQW9BQUFCTlRRMk1oWVhGUTRCQnlNdUFUUTJPd0V1QVFjT0FSY2VBUmMrQVRjekRnRUhMZ0VuUGdJRUF6RVZIeFlCQVJZUHJoRVZGUkZ0WFBkMGMyVWZJc2FEbjlNRlN3WCt2Ny8rQlFHUCtnRURBc3c2RVJVVkVhNFBGUUlDRlI4VllDazhRT1dCZjVrREJOU2Z2LzRGQmY2L2lOeHRLd0FBQUFFQUFQKytBOE1EVWdBcEFBQVRNeklXRkFZSEl5NEJQUUUwTmpJV0hRRTJKQmNlQVJjT0FRY3VBU2N6SGdFWFBnRTNMZ0VuSmdicmJSRVZGUkd1RVJVVklSVmxBUU45ZlpBQkJmNi92LzRGU3dUVW41L1RCUUdCYlc3ZUFuMFZIeFlCQVJZUHJoRVZGUkU2V2lzME9keUl2LzRGQmY2L245UUVCTlNmZHJzc0tUSUFBQU1BQVArK0E4SURSZ0FTQUI0QU9nQUFKUmNXRkFZaUx3RUdKQ2NtRWpjMkpCY1dFZ1UrQVRjdUFTY09BUWNlQVJNMU5EWXlGaDBCTXpJV0ZBWXJBUlVVQmlJbVBRRWpJaVkwTmpNRE40SUpGQm9LZ29yK3IzeDJCbnlCQVZDR2dCVCtScHpPQkFUT25Kek5CQVROZXhNZEUyTVBFeE1QWXhNZEUyUU9FeE1PZUlJS0doUUpnbkVVZ0lZQlVJRjhCblo4L3EvZUJNNmNuTTBFQk0yY25NNEJpMlFPRXhNT1pCTWRFMk1QRXhNUFl4TWRFd0FBQUFBREFBRC92Z1BDQTBZQUVnQWVBQ29BQUNVWEZoUUdJaThCQmlRbkpoSTNOaVFYRmhJRlBnRTNMZ0VuRGdFSEhnRVRJVElXRkFZaklTSW1ORFlETjRJSkZCb0tnb3IrcjN4MkJueUJBVkNHZ0JUK1Jwek9CQVRPbkp6TkJBVE5Gd0VLRHhNVEQvNzJEaE1UZUlJS0doUUpnbkVVZ0lZQlVJRjhCblo4L3EvZUJNNmNuTTBFQk0yY25NNEJpeE1kRXhNZEV3QUFCQUFBLzljRHFRTXBBQU1BQndBWEFDUUFBQk1SSVJFbElUVWhKeUV5RmhVUkZBWWpJU0ltTlJFME5oTXlGaGNSRGdFaUppY1JQZ0cyQXBUOWJBS1UvV3d2QXZJVUd4c1UvUTRVR3h2UUZCc0JBUnNvR2dFQkd3SU4vaWtCMTE5ZVhoc1UvUTRVR3hzVUF2SVVHLzYyR3hUKzVSUWFHaFFCR3hRYkFBSUFBUCtDQTIwRGZnQVBBQjhBQUFFMUJ4YzFIZ0VYRkFjWFBnRTFMZ0VETGdFbk5qY25EZ0VWSGdFWEZUY25BZ0MydG5TYUF5QkNIQjBFenBwMG1nTUJIMEljSFFUT21yYTJBdk9MdXJtTEE1MTJSanhETEdNMm5kTDlld09kZGtZOFF5cGxOcDNTQkl1NnVRQUFBQUFGQUFEL21nUG1BMllBQ3dBWEFDQUFLUUF3QUFBRkpnQW5OZ0EzRmdBWEJnQUREZ0VISGdFWFBnRTNMZ0VUSWlZME5qSVdGQVloSWlZME5qSVdGQVlISGdFWFBnRTNBZ0RPL3U0RkJRRVN6czRCRWdVRi91N09wTndFQk55a3BOd0VCTndlRmhvYUxCb2EvbVlXR2hvc0dob1dBbTVTVW00Q1pRVUJFczdPQVJJRkJmN3V6czcrN2dOa0JOeWtwTndFQk55a3BOeitzUm9zR2hvc0dob3NHaG9zR21KU2JnSUNibElBQXdBQS84c0R0UU0xQUE4QUV3QVpBQUFUSVRJV0ZSRVVCaU1oTGdFbkVUUTJGeEVoRVFFbk54Y0JGM3dEQ0JRZEhSVDgrQlViQVIxRUFxaitmTTVFaWdFU1JRTTFIUlQ4K0JRZEFSc1ZBd2dVSFdIOVdBS28vZXJPUklrQkUwVUFCUUFBLzc0RHd3TmxBQUFBREFBZUFDSUFKd0FBTnpNaE1oMEJGQ01oSWowQk5EY1hGak1oTWpjQk5pWW5BU1lHQndFR0Zna0JBd0VIQVFjaEowOEpBMUFKQ2Z5d0NRK1REaEVCWnhnUEFSRVRCeG4rb3hvOUZmNTRFd2dCMFFGVTBQNnJNZ0ZWQXY2MGhoQUpQd2tKUHduU2N3b1RBVjBhUFJVQkVCUUlHZjRMR2o4Q0dQNzIvdlVCQ2tEKzlRRnBBQUFBQUFJQUFQKzRBOGdEU0FBU0FCa0FBQk1oTWhZVkVSUUdLd0VISnlNaUpqVVJORFlYRVRNWE56TVJsQUxZSmpVMUpyYTJ0clltTlRVbTNKQ1EzQU5ITlNiOTNpWTF0clkxSmdJaUpqVmIvZDZRa0FJaUFBUUFBUC9jQTZRREpBQVRBREVBTlFCRkFBQWxEZ0VISVM0Qkp4RStBVGNoTWhZZkFSNEJGUU1STkNZdkFTNEJJeFVPQVFjaExnRW5OU01STXpVK0FUY2hIZ0VYRlNNMUlSVUJOQ1lyQVNJR0hRRVVGanNCTWpZMUE2UUJIUmY5SVJZZEFRRWRGZ0g4RnpJUm1SQVZSZ3NGbWdjWUNRRWRGLzdGRmgwQlJrWUJIUllCeHhjZEFVYitYQUVZQ2docEJ3b0tCMmtJQ2hFWEhRRUJIUmNDM3hZZEFSVVFtUkV5Ri80V0Flb0pHUWFhQmdyakZ4MEJBUjBYNC8xRTVCWWRBUUVkRnVUUzBnS3JCd29LQjY4SUNnb0lBQUFBQXdBQS84QUR3QU5BQUFzQUZ3QWJBQUFCQnhjM0p6Y1hCeWNIRnpjQkZ3Y25OeGMzSndjQk55Y2pBUmNCQW0zMVpVUWlic3R0SWtSbTlmNGZJbTdMYlNKRVp2VUJVL1ZsekFFUFJQN3hBMEQxWmtRaWJjdHVJa1JsOWY3cUltM0xiaUpFWmZYK3JmVm1BUTlFL3ZFQUFBVUFBQUFBQThBREFBQURBQWNBRFFBT0FCY0FBQk1SSVJFRElRRVhOU2NCSXhFaEJTTWVBVEkyTkNZaUJrQURnR0QrQ0FFZjJkbitXVUFDd1AzZ01BRWJLQnNiS0JzREFQMEFBd0Q5WUFFZzJZalovbGdDUUtBVUd4c29HeHNBQUFNQUFBQUFBOTRDdEFBRkFBc0FEd0FBRXdNVE13TVRJU01UQXpNVEFUTVRJOVN5c25heXNnSGlkckt5ZDdIOW0ycWthZ0t6L3MzK3pRRXpBVFAremY3TkFUUCt6UUptQUFZQUFBQUFBOEFDNEFBREFBY0FDd0FQQUJNQUZ3QUFBU0VWSVJFaEZTRVJJUlVoQXpNVkl4VXpGU01WTXhVakFRQUN3UDFBQXNEOVFBTEEvVURBWUdCZ1lHQmdBYkJnQVpCZy9nQmdBc0JnMEdEUVlBQUFBQUFHQUFBQUFBUEFBdkFBQXdBSEFBc0FFUUFlQUNnQUFBRWhGU0VSSVJVaEVTRVZJUU16TlNNVk13TVZNeFVqRlRNVkl4VXpOU01UTlNNVk13Y1ZNelVqQVFBQ3dQMUFBc0Q5UUFMQS9VQ1FJRUFnTUVBb0tFQmdJQ0JnTXpOZ1FBR3dZQUdRWVA0QVlBSlFnQ0Q5d0NBUElCRWdnQUVRSUNBekxTQUFBUUFBQUFBRGd3TWtBQlFBQUFFaE5SY0hOU0VPQVFjZUFSY3pGU011QVNjK0FRR0lBU3pPenY3VVdYY0NBbmRaZUhoL3FnTURxZ0tzZUtXbGVBSjNXVmwzQWxvRHFuOS9xZ0FBQUFFQUFBQUFBNlFESkFBVUFBQUJJVFVIRnpVaEhnRVhEZ0VISXhVelBnRTNMZ0VDZVA3VXpzNEJMRmwzQWdKM1dYaDRmNm9EQTZvQ3JIaWxwWGdDZDFsWmR3SmFBNnAvZjZvQUFBQUNBQUFBQUFOeEF0VUFDd0FYQUFBQlBnRTNKd1lIQmgwQklSRWhQZ0UzSndZSEJoMEJJUkVCSEFWSlRqNkJQQzBCRWdFeUJFcE9Qb0U4TFFFUkFWUjdnU0ZqT25GVnZ1b0JLSHVCSVdNNmNWVys2Z0VvQUFBQUF3QUFBQUFEaWdMMUFBa0FGQUFuQUFBQk1qYzJOQ2NtS3dFVkV6STNOalUwSnlZckFSRURJVElYRmhVVUJ3WUhGaGNXRlJRSEJpTWhBbXMvSWpjNklVQ3gxVnNuR0VjbFA4UmdBVG1BTmlBbkZTWTRIREVzUXBEK3pBRzZFUnlTR1Evbi9xYzJJakJTSFJEKytRS1VUaTQ5Umk0WUV4WWNNRlpJT2xnQUFBQURBQUQvL2dQQ0F3SUFEd0F5QUY0QUFBRXlGaDBCRkFZaklTSW1QUUUwTmpNM0ppY21OVFEyTXpJWEZoY1dGeFlWRkE4Qkx3RW1KeVlqSWdZVkZCWVhGaGNXRndjekZoVVVCd1lIQmdjR0J3WWpJaThCSmljbVBRRTBKeVkvQVRVM0h3RVdGeDRDTXpJK0FUVTBKeVlEc2djSkNRZjhuQWNKQ1FmakRnd1lob01aT2lJM0JRWUhBd1lxQnhrYkxEMDVSRUpySXpRZEUzZlBBeFFNR0JNa0tDVW9QamtwUmgwSEJBRUJBUUV6RHd3REF4RXRQQ1VnVEM4cEVRR0FDUWNnQndrSkJ5QUhDU0FTRmpJdFc0QUtCaElUS0Q0ZUNRNEJBd0ZMSEMwNkxDVkRJQW9YRGd5QUZCczNNeHdZRWhjWUNRc01GQWdHQkFjSE5oZ1BFeE1XQVNRY0NnUWNKUlVhUFNJcUpRNEFBQUVBQUFBQUF0Y0Iwd0FDQUFBQklSY0MxLzVTMXdIVDBRQUFBQUFDQUFBQUFBTmtBdVFBRndBN0FBQUJJeTRCTkRZN0FUSVdIUUVVQmlJbUp6VUJCaUltTkRjRlBnRXlGaDBCRGdFSElTNEJKeEUrQVRjek1oWVVCZ2NqSWdZVkVSUVdNeUV5TmpVQzluVU5FeE1Od3cwVEV4c1NBZjd5Q2hvVENRRThBUkliRXdFM0tmMzZLVGNCQVRjcHd3NFNFZzdERGhJU0RnSUdEaElDb3dFU0d4TVREY01ORXhNTmRmN3hDUk1hQ2xZT0VoSU93aWszQVFFM0tRSUdLVGNCRXhzU0FSSU8vZm9PRWhJT0FBSUFBUC8wQTNJRERBQURBQ1FBQURjaEZTRVJJUlVQQVJFVUZqTXlOalVSTHdFMU14VVBBUkVVQmlNaUppY3VBVFVSTHdHUEF0djlKUUU3UlE5VVgxZFBFVVg0UXcrSW1WQjRJeG9XRDBVeFBRTVlNUVFPL3FsalZGcG1BVW9SQlRFeEJSSCtySWw2S2lZZlQwb0JVdzRFQUFBQUFRQUEvOW9DMkFNbUFDc0FBQUUySmljbU5UUS9BUjRCTXpJMk54WVZGQWNPQVFjREJoWVhGaFVVQnlZbkppTWlCZ2NtTlRRM1BnRTNBZ2dGR2lrVEFnTWxTeUFiVENJREVpa2hCWDRGSENzUkF5Y25JeVFiU3lJRUVTZ2tCUUxIR2hnRkJCRUVCQXNFQkFRRURRWVRBUVFhR3YxeUdoY0dCQThJRFFRQkF3UUVEUWdQQXdZWUdnQUFBQUFCQUFBQUFBT01BY0lBREFBQUFSUUdJeUVpSmpRMk15RXlGZ09NR2hQOVFoTWFHaE1DdmhNYUFaVVRHUmtuR1JrQUFBQUFDZ0FBLyt3RHdnTUJBQkFBRkFBWUFCd0FJQUFwQUM0QU53QTdBRDhBQUFFaE1oWVZFUlFHSnlFaUpqVVJORFl6RXlNVk13VTFJeFVsTXpVakpSVXpOUVVXTnpJMk5UWW5Jd1V6TlNNVkp6VWpCaGNVRmpNV056TTFJd1UxSXhVQ0FnR0VJUnNiSVB6d0hoc2JIdUhnNEFFWDNnRVc0T0Q5MHQ4QlQyMXBBd2dCQWVIKzZlRGdPT0VCQWdvRVo2UGYzd0gzM3dNQkhDRDlaU0VkQVJzZkFxSWRHLzIvbUFHWW1BR1l5NWFXbUFFQkJ3UkhSWldWbHNxWVJrSUVDd0VEbFphV2xnQUFBQUFFQUFELzh3T05BdzBBRXdBbkFEc0FUd0FBQVRjMkppOEJKZ1lmQVI0QlB3RVhGajhCTmljWEZqOEJGeFkyUHdFMkpnOEJEZ0VmQVFjR0Z3RXVBUThCSnlZUEFRWWZBUWNHRmg4QkZqWW5BU1lQQVNjbUJnOEJCaFkvQVQ0Qkx3RTNOaWNCQmpJRUJBYTBCQVlCRlFFSkJUR1hCZ1l3QlFYMkJnYVhNUVVKQVJVQkJnUzBCZ1FFTXBjRkJRRVRBUWtGTVpjR0JqQUZCWmN5QkFRR3RBUUdBZjNpQmdhWE1RVUpBUlVCQmdTMEJnUUVNcGNGQlFLMk1RVUpBUlVCQmdTMEJnUUVNcGNGQlRBR0Jqd0ZCWmN5QkFRR3RBUUdBUlVCQ1FVeGx3WUcvcDhHQkFReWx3VUZNQVlHbHpFRkNRRVZBUVlFQVI4RkJaY3lCQVFHdEFRR0FSVUJDUVV4bHdZR0FBQUFBQUFTQU40QUFRQUFBQUFBQUFBVkFBQUFBUUFBQUFBQUFRQUxBQlVBQVFBQUFBQUFBZ0FIQUNBQUFRQUFBQUFBQXdBTEFDY0FBUUFBQUFBQUJBQUxBRElBQVFBQUFBQUFCUUFMQUQwQUFRQUFBQUFBQmdBTEFFZ0FBUUFBQUFBQUNnQXJBRk1BQVFBQUFBQUFDd0FUQUg0QUF3QUJCQWtBQUFBcUFKRUFBd0FCQkFrQUFRQVdBTHNBQXdBQkJBa0FBZ0FPQU5FQUF3QUJCQWtBQXdBV0FOOEFBd0FCQkFrQUJBQVdBUFVBQXdBQkJBa0FCUUFXQVFzQUF3QUJCQWtBQmdBV0FTRUFBd0FCQkFrQUNnQldBVGNBQXdBQkJBa0FDd0FtQVkwS1EzSmxZWFJsWkNCaWVTQnBZMjl1Wm05dWRBcDJMVzFrTFdWa2FYUnZjbEpsWjNWc1lYSjJMVzFrTFdWa2FYUnZjbll0YldRdFpXUnBkRzl5Vm1WeWMybHZiaUF4TGpCMkxXMWtMV1ZrYVhSdmNrZGxibVZ5WVhSbFpDQmllU0J6ZG1jeWRIUm1JR1p5YjIwZ1JtOXVkR1ZzYkc4Z2NISnZhbVZqZEM1b2RIUndPaTh2Wm05dWRHVnNiRzh1WTI5dEFBb0FRd0J5QUdVQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUdrQVl3QnZBRzRBWmdCdkFHNEFkQUFLQUhZQUxRQnRBR1FBTFFCbEFHUUFhUUIwQUc4QWNnQlNBR1VBWndCMUFHd0FZUUJ5QUhZQUxRQnRBR1FBTFFCbEFHUUFhUUIwQUc4QWNnQjJBQzBBYlFCa0FDMEFaUUJrQUdrQWRBQnZBSElBVmdCbEFISUFjd0JwQUc4QWJnQWdBREVBTGdBd0FIWUFMUUJ0QUdRQUxRQmxBR1FBYVFCMEFHOEFjZ0JIQUdVQWJnQmxBSElBWVFCMEFHVUFaQUFnQUdJQWVRQWdBSE1BZGdCbkFESUFkQUIwQUdZQUlBQm1BSElBYndCdEFDQUFSZ0J2QUc0QWRBQmxBR3dBYkFCdkFDQUFjQUJ5QUc4QWFnQmxBR01BZEFBdUFHZ0FkQUIwQUhBQU9nQXZBQzhBWmdCdkFHNEFkQUJsQUd3QWJBQnZBQzRBWXdCdkFHMEFBQUFBQWdBQUFBQUFBQUFLQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWVBUUlCQXdFRUFRVUJCZ0VIQVFnQkNRRUtBUXNCREFFTkFRNEJEd0VRQVJFQkVnRVRBUlFCRlFFV0FSY0JHQUVaQVJvQkd3RWNBUjBCSGdFZkFBZHdjbVYyYVdWM0RYSmxabkpsYzJndGNtbG5hSFFNY21WbWNtVnphQzFzWldaMEIzcHZiMjB0YVc0SWVtOXZiUzF2ZFhRRGRHOWpCSE41Ym1NRlpXMXZhbWtJWTJobFkydGliM2dGWTJ4bFlYSURkR2x3QkhOaGRtVUViR2x1YXdOcGJXY0VZMjlrWlFKMWJBSnZiQVJ5WldSdkJIVnVaRzhGY1hWdmRHVUVZbTlzWkExemRISnBhMlYwYUhKdmRXZG9DbUZ5Y205M0xXUnZkMjRMYjNCbGJpMXBiaTF1WlhjS2RXNWtaWEl0YkdsdVpRWnBkR0ZzYVdNS2FHOXlhWHB2Ym5SaGJBVjBZV0pzWlFwbWRXeHNjMk55WldWdUFBQT0pIGZvcm1hdChcXFwidHJ1ZXR5cGVcXFwiKX1bY2xhc3MqPXYtbWQtaWNvbi1de2ZvbnQtc2l6ZToxNnB4O2ZvbnQtZmFtaWx5OnYtbWQtaWNvbmZvbnQhaW1wb3J0YW50O2ZvbnQtc3R5bGU6bm9ybWFsIWltcG9ydGFudDstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZX0udi1tZC1pY29uLXByZXZpZXc6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjE4XFxcIn0udi1tZC1pY29uLXJlZnJlc2gtcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjE0XFxcIn0udi1tZC1pY29uLXJlZnJlc2gtbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2MTVcXFwifS52LW1kLWljb24tem9vbS1pbjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2MTZcXFwifS52LW1kLWljb24tem9vbS1vdXQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjE3XFxcIn0udi1tZC1pY29uLXRvYzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGViMjhcXFwifS52LW1kLWljb24tc3luYzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2NzBcXFwifS52LW1kLWljb24tZW1vamk6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjdiXFxcIn0udi1tZC1pY29uLWNoZWNrYm94OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTc0MFxcXCJ9LnYtbWQtaWNvbi1jbGVhcjpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2ZWNcXFwifS52LW1kLWljb24tdGlwOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZThmMVxcXCJ9LnYtbWQtaWNvbi1zYXZlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYyNFxcXCJ9LnYtbWQtaWNvbi1saW5rOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTZmZVxcXCJ9LnYtbWQtaWNvbi1pbWc6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNzAyXFxcIn0udi1tZC1pY29uLWNvZGU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNzA3XFxcIn0udi1tZC1pY29uLXVsOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTcxMFxcXCJ9LnYtbWQtaWNvbi1vbDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU3MTFcXFwifS52LW1kLWljb24tcmVkbzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2ZjFcXFwifS52LW1kLWljb24tdW5kbzpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU2ZjBcXFwifS52LW1kLWljb24tcXVvdGU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNmIzXFxcIn0udi1tZC1pY29uLWJvbGQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlN2MxXFxcIn0udi1tZC1pY29uLXN0cmlrZXRocm91Z2g6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNzBmXFxcIn0udi1tZC1pY29uLWFycm93LWRvd246YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjIzXFxcIn0udi1tZC1pY29uLW9wZW4taW4tbmV3OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTY0MVxcXCJ9LnYtbWQtaWNvbi11bmRlci1saW5lOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYxMVxcXCJ9LnYtbWQtaWNvbi1pdGFsaWM6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjEwXFxcIn0udi1tZC1pY29uLWhvcml6b250YWw6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlNjBlXFxcIn0udi1tZC1pY29uLXRhYmxlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYwY1xcXCJ9LnYtbWQtaWNvbi1mdWxsc2NyZWVuOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTYwNlxcXCJ9LnYtbWQtZWRpdG9yX190b29sdGlwe3otaW5kZXg6MTAxO3BhZGRpbmc6NHB4IDZweDtjb2xvcjojZmZmO2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjE7d2hpdGUtc3BhY2U6bm93cmFwO2JhY2tncm91bmQtY29sb3I6Izg3ODc4Nztib3JkZXItcmFkaXVzOjJweH0udi1tZC1lZGl0b3JfX21lbnUsLnYtbWQtZWRpdG9yX190b29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO2JveC1zaGFkb3c6MCAycHggMTJweCAwIHJnYmEoMCwwLDAsLjEpfS52LW1kLWVkaXRvcl9fbWVudXt0b3A6MzhweDt6LWluZGV4Ojk5O2xpc3Qtc3R5bGU6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyLXJhZGl1czozcHg7LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciB0b3A7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXIgdG9wfS52LW1kLWVkaXRvcl9fbWVudTo6LXdlYmtpdC1zY3JvbGxiYXJ7d2lkdGg6NnB4fS52LW1kLWVkaXRvcl9fbWVudTo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDE0NCwxNDcsMTUzLC4zKTtib3JkZXItcmFkaXVzOjRweH0udi1tZC1lZGl0b3JfX21lbnU6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iOmhvdmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgxNDQsMTQ3LDE1MywuNSl9LnYtbWQtZWRpdG9yX19tZW51LWl0ZW17Y29sb3I6IzU5NTk1OTtmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOjE0cHg7d2hpdGUtc3BhY2U6bm93cmFwO2xpc3Qtc3R5bGU6bm9uZX0udi1tZC1lZGl0b3JfX21lbnUtaXRlbTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjV9LnYtbWQtZWRpdG9yX19tZW51LS1saXN0e3BhZGRpbmc6NXB4IDB9LnYtbWQtZWRpdG9yX19tZW51LS1saXN0IC52LW1kLWVkaXRvcl9fbWVudS1pdGVte3BhZGRpbmc6MCAyNHB4O2xpbmUtaGVpZ2h0OjM0cHg7dGV4dC1hbGlnbjpsZWZ0fS52LW1kLWVkaXRvcl9fbWVudS0tcGFuZWx7bWF4LWhlaWdodDoyMDBweDtwYWRkaW5nOjEycHggMTBweDtvdmVyZmxvdy15OmF1dG99LnYtbWQtZWRpdG9yX19tZW51LS1wYW5lbCAudi1tZC1lZGl0b3JfX21lbnUtcm93e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4Oy13ZWJraXQtZmxleC13cmFwOm5vd3JhcDtmbGV4LXdyYXA6bm93cmFwfS52LW1kLWVkaXRvcl9fbWVudS0tcGFuZWwgLnYtbWQtZWRpdG9yX19tZW51LXJvdzpub3QoOmxhc3QtY2hpbGQpe21hcmdpbi1ib3R0b206NnB4fS52LW1kLWVkaXRvcl9fbWVudS0tcGFuZWwgLnYtbWQtZWRpdG9yX19tZW51LWl0ZW17ZGlzcGxheTppbmxpbmUtYmxvY2s7cGFkZGluZzo4cHggMDtsaW5lLWhlaWdodDoxO3RleHQtYWxpZ246Y2VudGVyO2JvcmRlci1yYWRpdXM6MnB4fS52LW1kLWVkaXRvcl9fbWVudS0tcGFuZWwgLnYtbWQtZWRpdG9yX19tZW51LWl0ZW06bm90KDpsYXN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6NHB4fS52LW1kLWVkaXRvcl9fbWVudS1jdHJse3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7ZGlzcGxheTpub25lfS52LW1kLWVkaXRvcl9fdG9vbGJhci1pdGVte3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoyOHB4O3BhZGRpbmc6MCA2cHg7Y29sb3I6IzU5NTk1OTtmb250LXNpemU6MTZweDtsaW5lLWhlaWdodDoyOHB4O3RleHQtYWxpZ246Y2VudGVyO2JvcmRlci1yYWRpdXM6NHB4O2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjJzIGxpbmVhciAwczt0cmFuc2l0aW9uOmFsbCAuMnMgbGluZWFyIDBzfS52LW1kLWVkaXRvcl9fdG9vbGJhci1pdGVtOm5vdCg6Zmlyc3QtY2hpbGQpe21hcmdpbi1sZWZ0OjRweH0udi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbTpob3ZlcntiYWNrZ3JvdW5kOiNmNWY1ZjV9LnYtbWQtZWRpdG9yX190b29sYmFyLWl0ZW0tLW1lbnV7cGFkZGluZy1yaWdodDoxNnB4fS52LW1kLWVkaXRvcl9fdG9vbGJhci1pdGVtLS1tZW51IC52LW1kLWVkaXRvcl9fbWVudS1jdHJse2Rpc3BsYXk6aW5saW5lLWJsb2NrfS52LW1kLWVkaXRvcl9fdG9vbGJhci1pdGVtLS1hY3RpdmUsLnYtbWQtZWRpdG9yX190b29sYmFyLWl0ZW0tLWFjdGl2ZTpob3ZlcntiYWNrZ3JvdW5kOiNlOGU4ZTh9LnYtbWQtZWRpdG9yX190b29sYmFye2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LXBhY2s6anVzdGlmeTstd2Via2l0LWp1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuOy13ZWJraXQtYm94LWFsaWduOmNlbnRlcjstd2Via2l0LWFsaWduLWl0ZW1zOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjEwMCU7cGFkZGluZzo2cHg7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2RkZH0udi1tZC1lZGl0b3JfX3Rvb2xiYXItbGVmdCwudi1tZC1lZGl0b3JfX3Rvb2xiYXItcmlnaHR7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi13ZWJraXQtZmxleDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1mbGV4LXdyYXA6d3JhcDtmbGV4LXdyYXA6d3JhcDttYXJnaW46MDtwYWRkaW5nOjA7bGlzdC1zdHlsZTpub25lfS52LW1kLWVkaXRvcl9fdG9vbGJhci1sZWZ0Ky52LW1kLWVkaXRvcl9fdG9vbGJhci1yaWdodHttYXJnaW4tbGVmdDo2MHB4fS52LW1kLWVkaXRvcl9fdG9vbGJhci1kaXZpZGVye3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoyOHB4O21hcmdpbjowIDEwcHh9LnYtbWQtZWRpdG9yX190b29sYmFyLWRpdmlkZXIrbGkudi1tZC1lZGl0b3JfX3Rvb2xiYXItaXRlbXttYXJnaW4tbGVmdDowfS52LW1kLWVkaXRvcl9fdG9vbGJhci1kaXZpZGVyOmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NHB4O2JvdHRvbTo0cHg7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNkZGQ7Y29udGVudDpcXFwiXFxcIn0udi1tZC1lZGl0b3J7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi13ZWJraXQtZmxleDtkaXNwbGF5OmZsZXg7d2lkdGg6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyLXJhZGl1czo0cHg7Ym94LXNoYWRvdzowIDJweCAxMnB4IDAgcmdiYSgwLDAsMCwuMSl9LnYtbWQtZWRpdG9yX19sZWZ0LWFyZWEsLnYtbWQtZWRpdG9yX19yaWdodC1hcmVhe2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LW9yaWVudDp2ZXJ0aWNhbDstd2Via2l0LWJveC1kaXJlY3Rpb246bm9ybWFsOy13ZWJraXQtZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjt3aWR0aDoyMDBweH0udi1tZC1lZGl0b3JfX2xlZnQtYXJlYXtoZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW47Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCAjZGRkOy13ZWJraXQtdHJhbnNpdGlvbjouM3M7dHJhbnNpdGlvbjouM3N9LnYtbWQtZWRpdG9yX19sZWZ0LWFyZWEtdGl0bGV7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjQxcHg7cGFkZGluZzowIDE0cHg7Y29sb3I6IzJjM2U1MDtmb250LXdlaWdodDo2MDA7Zm9udC1zaXplOjE2cHg7bGluZS1oZWlnaHQ6NDFweDt3aGl0ZS1zcGFjZTpub3dyYXB9LnYtbWQtZWRpdG9yX19sZWZ0LWFyZWEtdGl0bGU6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2RkZDtjb250ZW50OlxcXCJcXFwifS52LW1kLWVkaXRvcl9fbGVmdC1hcmVhLWJvZHl7LXdlYmtpdC1ib3gtZmxleDoxOy13ZWJraXQtZmxleDoxO2ZsZXg6MTtwYWRkaW5nOjhweCAxNHB4O292ZXJmbG93OmhpZGRlbn0udi1tZC1lZGl0b3ItLWxlZnQtYXJlYS1yZXZlcnNley13ZWJraXQtYm94LW9yaWVudDpob3Jpem9udGFsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpyZXZlcnNlOy13ZWJraXQtZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2U7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9LnYtbWQtZWRpdG9yLS1sZWZ0LWFyZWEtcmV2ZXJzZSAudi1tZC1lZGl0b3JfX2xlZnQtYXJlYXtib3JkZXItcmlnaHQ6bm9uZTtib3JkZXItbGVmdDoxcHggc29saWQgI2RkZH0udi1tZC1lZGl0b3JfX3JpZ2h0LWFyZWF7LXdlYmtpdC1ib3gtZmxleDoxOy13ZWJraXQtZmxleDoxO2ZsZXg6MX0udi1tZC1lZGl0b3ItLXByZXZpZXd7Ym94LXNoYWRvdzpub25lfS52LW1kLWVkaXRvci0tZnVsbHNjcmVlbntwb3NpdGlvbjpmaXhlZDt0b3A6MDtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDt6LWluZGV4OjEwMDF9LnYtbWQtZWRpdG9yX19tYWlue2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4Oy13ZWJraXQtYm94LWZsZXg6MTstd2Via2l0LWZsZXg6MTtmbGV4OjE7d2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW59LnYtbWQtZWRpdG9yX19lZGl0b3Itd3JhcHBlciwudi1tZC1lZGl0b3JfX3ByZXZpZXctd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LWJveC1mbGV4OjE7LXdlYmtpdC1mbGV4OjE7ZmxleDoxO2hlaWdodDoxMDAlO292ZXJmbG93OmhpZGRlbn0udi1tZC1lZGl0b3JfX2VkaXRvci13cmFwcGVye2N1cnNvcjp0ZXh0Oy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS52LW1kLWVkaXRvci0tZWRpdGFibGUgLnYtbWQtZWRpdG9yX19lZGl0b3Itd3JhcHBlcntib3JkZXItcmlnaHQ6MXB4IHNvbGlkICNkZGR9LnNjcm9sbGJhcntoZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW59LnNjcm9sbGJhcjphY3RpdmUgLnNjcm9sbGJhcl9fYmFyLC5zY3JvbGxiYXI6Zm9jdXMgLnNjcm9sbGJhcl9fYmFyLC5zY3JvbGxiYXI6aG92ZXIgLnNjcm9sbGJhcl9fYmFye29wYWNpdHk6MX0uc2Nyb2xsYmFyX193cmFwe2hlaWdodDoxMDAlO292ZXJmbG93LXg6aGlkZGVufS5zY3JvbGxiYXJfX3dyYXAtLWhpZGRlbi1kZWZhdWx0e3Njcm9sbGJhci13aWR0aDpub25lfS5zY3JvbGxiYXJfX3dyYXAtLWhpZGRlbi1kZWZhdWx0Ojotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDowO2hlaWdodDowfS5zY3JvbGxiYXJfX3RodW1ie3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMTQ0LDE0NywxNTMsLjMpO2JvcmRlci1yYWRpdXM6aW5oZXJpdDtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXRyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuM3M7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4zc30uc2Nyb2xsYmFyX190aHVtYjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMTQ0LDE0NywxNTMsLjUpfS5zY3JvbGxiYXJfX2Jhcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoycHg7Ym90dG9tOjJweDt6LWluZGV4OjE7Ym9yZGVyLXJhZGl1czo0cHg7Y3Vyc29yOnBvaW50ZXI7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4zNHMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpvcGFjaXR5IC4zNHMgZWFzZS1vdXR9LnNjcm9sbGJhcl9fYmFyLmlzLXZlcnRpY2Fse3RvcDoycHg7d2lkdGg6NnB4fS5zY3JvbGxiYXJfX2Jhci5pcy12ZXJ0aWNhbD5kaXZ7d2lkdGg6MTAwJX0uc2Nyb2xsYmFyX19iYXIuaXMtaG9yaXpvbnRhbHtsZWZ0OjJweDtoZWlnaHQ6NnB4fS5zY3JvbGxiYXJfX2Jhci5pcy1ob3Jpem9udGFsPmRpdntoZWlnaHQ6MTAwJX0udi1tZC1lZGl0b3JfX3RvYy1uYXZ7bWFyZ2luOjA7cGFkZGluZzowO2xpc3Qtc3R5bGU6bm9uZX0udi1tZC1lZGl0b3JfX3RvYy1uYXYtaXRlbXtwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MzhweDtvdmVyZmxvdzpoaWRkZW47Y29sb3I6IzJjM2U1MDtsaW5lLWhlaWdodDozOHB4O3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO2N1cnNvcjpwb2ludGVyfS52LW1kLWVkaXRvcl9fdG9jLW5hdi1pdGVtOmhvdmVyIC52LW1kLWVkaXRvcl9fdG9jLW5hdi10aXRsZXtmb250LXNpemU6MTdweDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46Y2VudGVyIGNlbnRlcjt0cmFuc2Zvcm0tb3JpZ2luOmNlbnRlciBjZW50ZXJ9LnYtbWQtZWRpdG9yX190b2MtbmF2LXRpdGxle3Bvc2l0aW9uOnJlbGF0aXZlO2ZvbnQtc2l6ZToxNnB4Oy13ZWJraXQtdHJhbnNpdGlvbjouM3M7dHJhbnNpdGlvbjouM3N9XCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/@kangc/v-md-editor/lib/style/base-editor.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"[data-v-md-anchor]{cursor:pointer}.vuepress-markdown-body code[class*=v-md-prism-],.vuepress-markdown-body pre[class*=v-md-prism-]{color:#ccc;font-size:1em;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;line-height:1.5;white-space:pre;text-align:left;word-wrap:normal;word-break:normal;word-spacing:normal;-webkit-hyphens:none;hyphens:none;background:none}.vuepress-markdown-body>:first-child,.vuepress-markdown-body>div[data-v-md-line]:first-child>:first-child{margin-top:0!important}.vuepress-markdown-body>:last-child,.vuepress-markdown-body>div[data-v-md-line]:last-child>:last-child{margin-bottom:0!important}.vuepress-markdown-body pre[class*=v-md-prism-]{margin:.5em 0;padding:1em;overflow:auto}.vuepress-markdown-body :not(pre)>code[class*=v-md-prism-],.vuepress-markdown-body pre[class*=v-md-prism-]{background:#2d2d2d}.vuepress-markdown-body :not(pre)>code[class*=v-md-prism-]{padding:.1em;white-space:normal;border-radius:.3em}.vuepress-markdown-body .token.block-comment,.vuepress-markdown-body .token.cdata,.vuepress-markdown-body .token.comment,.vuepress-markdown-body .token.doctype,.vuepress-markdown-body .token.prolog{color:#999}.vuepress-markdown-body .token.punctuation{color:#ccc}.vuepress-markdown-body .token.attr-name,.vuepress-markdown-body .token.deleted,.vuepress-markdown-body .token.namespace,.vuepress-markdown-body .token.tag{color:#e2777a}.vuepress-markdown-body .token.function-name{color:#6196cc}.vuepress-markdown-body .token.boolean,.vuepress-markdown-body .token.function,.vuepress-markdown-body .token.number{color:#f08d49}.vuepress-markdown-body .token.class-name,.vuepress-markdown-body .token.constant,.vuepress-markdown-body .token.property,.vuepress-markdown-body .token.symbol{color:#f8c555}.vuepress-markdown-body .token.atrule,.vuepress-markdown-body .token.builtin,.vuepress-markdown-body .token.important,.vuepress-markdown-body .token.keyword,.vuepress-markdown-body .token.selector{color:#cc99cd}.vuepress-markdown-body .token.attr-value,.vuepress-markdown-body .token.char,.vuepress-markdown-body .token.regex,.vuepress-markdown-body .token.string,.vuepress-markdown-body .token.variable{color:#7ec699}.vuepress-markdown-body .token.entity,.vuepress-markdown-body .token.operator,.vuepress-markdown-body .token.url{color:#67cdcc}.vuepress-markdown-body .token.bold,.vuepress-markdown-body .token.important{font-weight:700}.vuepress-markdown-body .token.italic{font-style:italic}.vuepress-markdown-body .token.entity{cursor:help}.vuepress-markdown-body .token.inserted{color:green}.vuepress-markdown-body code{margin:0;padding:.25rem .5rem;color:#476582;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.vuepress-markdown-body code .token.deleted{color:#ec5975}.vuepress-markdown-body code .token.inserted{color:#3eaf7c}.vuepress-markdown-body pre,.vuepress-markdown-body pre[class*=v-md-prism-]{margin:.85rem 0;padding:1.25rem 1.5rem;overflow:auto;line-height:1.4;background-color:#282c34;border-radius:6px}.vuepress-markdown-body pre[class*=v-md-prism-] code,.vuepress-markdown-body pre code{padding:0;color:#fff;background-color:initial;border-radius:0}.vuepress-markdown-body div[class*=v-md-pre-wrapper-]{position:relative;background-color:#282c34;border-radius:6px}.vuepress-markdown-body div[class*=v-md-pre-wrapper-] pre,.vuepress-markdown-body div[class*=v-md-pre-wrapper-] pre[class*=v-md-prism-]{position:relative;z-index:1;background:transparent}.vuepress-markdown-body div[class*=v-md-pre-wrapper-]:before{position:absolute;top:.8em;right:1em;z-index:3;color:hsla(0,0%,100%,.4);font-size:.75rem}.vuepress-markdown-body div[class*=v-md-pre-wrapper-]:not(.line-numbers-mode) .line-numbers-wrapper{display:none}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode pre{padding-left:4.5rem;vertical-align:middle}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode .line-numbers-wrapper{position:absolute;top:0;width:3.5rem;padding:1.25rem 0;color:hsla(0,0%,100%,.3);line-height:1.4;text-align:center}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode .line-numbers-wrapper br{-webkit-user-select:none;user-select:none}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode .line-numbers-wrapper .line-number{position:relative;z-index:4;font-size:.85em;-webkit-user-select:none;user-select:none}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode:after{position:absolute;top:0;left:0;z-index:2;width:3.5rem;height:100%;background-color:#282c34;border-right:1px solid rgba(0,0,0,.66);border-radius:6px 0 0 6px;content:\\\"\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-js]:before{content:\\\"js\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-ts]:before{content:\\\"ts\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-html]:before{content:\\\"html\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-md]:before{content:\\\"md\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-vue]:before{content:\\\"vue\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-css]:before{content:\\\"css\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-sass]:before{content:\\\"sass\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-scss]:before{content:\\\"scss\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-less]:before{content:\\\"less\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-stylus]:before{content:\\\"stylus\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-go]:before{content:\\\"go\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-java]:before{content:\\\"java\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-c]:before{content:\\\"c\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-sh]:before{content:\\\"sh\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-yaml]:before{content:\\\"yaml\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-py]:before{content:\\\"py\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-docker]:before{content:\\\"docker\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-dockerfile]:before{content:\\\"dockerfile\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-makefile]:before{content:\\\"makefile\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-javascript]:before{content:\\\"js\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-typescript]:before{content:\\\"ts\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-markup]:before{content:\\\"html\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-markdown]:before{content:\\\"md\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-json]:before{content:\\\"json\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-ruby]:before{content:\\\"rb\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-python]:before{content:\\\"py\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-bash]:before{content:\\\"sh\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-php]:before{content:\\\"php\\\"}.vuepress-markdown-body .arrow{display:inline-block;width:0;height:0}.vuepress-markdown-body .arrow.up{border-bottom:6px solid #ccc}.vuepress-markdown-body .arrow.down,.vuepress-markdown-body .arrow.up{border-right:4px solid transparent;border-left:4px solid transparent}.vuepress-markdown-body .arrow.down{border-top:6px solid #ccc}.vuepress-markdown-body .arrow.right{border-left:6px solid #ccc}.vuepress-markdown-body .arrow.left,.vuepress-markdown-body .arrow.right{border-top:4px solid transparent;border-bottom:4px solid transparent}.vuepress-markdown-body .arrow.left{border-right:6px solid #ccc}.vuepress-markdown-body:not(.custom){padding:2rem 2.5rem}@media (max-width:959px){.vuepress-markdown-body:not(.custom){padding:2rem}}@media (max-width:419px){.vuepress-markdown-body:not(.custom){padding:1.5rem}}.vuepress-markdown-body .table-of-contents .badge{vertical-align:middle}.vuepress-markdown-body{color:#2c3e50;font-size:16px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#fff}.vuepress-markdown-body:not(.custom) a:hover{text-decoration:underline}.vuepress-markdown-body:not(.custom) p.demo{padding:1rem 1.5rem;border:1px solid #ddd;border-radius:4px}.vuepress-markdown-body:not(.custom) img{max-width:100%}.vuepress-markdown-body.custom{margin:0;padding:0}.vuepress-markdown-body.custom img{max-width:100%}.vuepress-markdown-body a{font-weight:500;text-decoration:none}.vuepress-markdown-body a,.vuepress-markdown-body p a code{color:#3eaf7c}.vuepress-markdown-body p a code{font-weight:400}.vuepress-markdown-body kbd{padding:0 .15em;background:#eee;border:.15rem solid #ddd;border-bottom:.25rem solid #ddd;border-radius:.15rem}.vuepress-markdown-body blockquote{margin:1rem 0;padding:.25rem 0 .25rem 1rem;color:#999;font-size:1rem;border-left:.2rem solid #dfe2e5}.vuepress-markdown-body blockquote>p{margin:0}.vuepress-markdown-body ol,.vuepress-markdown-body ul{margin:1em 0;padding-left:1.2em}.vuepress-markdown-body strong{font-weight:600}.vuepress-markdown-body h1,.vuepress-markdown-body h2,.vuepress-markdown-body h3,.vuepress-markdown-body h4,.vuepress-markdown-body h5,.vuepress-markdown-body h6{font-weight:600;line-height:1.25}.vuepress-markdown-body h1{margin:.67em 0;font-size:2.2rem}.vuepress-markdown-body h2{margin:.83em 0;padding-bottom:.3rem;font-size:1.65rem;border-bottom:1px solid #eaecef}.vuepress-markdown-body h3{margin:1em 0;font-size:1.35rem}.vuepress-markdown-body h4{margin:1.33em 0}.vuepress-markdown-body h5{margin:1.67em 0}.vuepress-markdown-body h6{margin:2.33em 0}.vuepress-markdown-body em,.vuepress-markdown-body i{font-style:italic}.vuepress-markdown-body ul{list-style-type:disc}.vuepress-markdown-body ol ul,.vuepress-markdown-body ul ul{list-style-type:circle}.vuepress-markdown-body ol ol ul,.vuepress-markdown-body ol ul ul,.vuepress-markdown-body ul ol ul,.vuepress-markdown-body ul ul ul{list-style-type:square}.vuepress-markdown-body ol{list-style-type:decimal}.vuepress-markdown-body .line-number,.vuepress-markdown-body code,.vuepress-markdown-body kbd{font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}.vuepress-markdown-body ol,.vuepress-markdown-body p,.vuepress-markdown-body ul{line-height:1.7}.vuepress-markdown-body hr{border:0;border-top:1px solid #eaecef}.vuepress-markdown-body table{display:block;margin:1rem 0;overflow-x:auto;border-collapse:collapse}.vuepress-markdown-body tr{border-top:1px solid #dfe2e5}.vuepress-markdown-body tr:nth-child(2n){background-color:#f6f8fa}.vuepress-markdown-body td,.vuepress-markdown-body th{padding:.6em 1em;border:1px solid #dfe2e5}.vuepress-markdown-body .v-md-svg-outbound{position:relative;top:-1px;display:inline-block;color:#aaa;vertical-align:middle}@media (max-width:419px){.vuepress-markdown-body h1{font-size:1.9rem}.vuepress-markdown-body div[class*=v-md-pre-wrapper-]{margin:.85rem -1.5rem;border-radius:0}}.v-md-plugin-tip p{margin-top:1em;margin-bottom:1em}.v-md-plugin-tip .v-md-plugin-tip-title{margin-bottom:-.4rem;font-weight:600}.v-md-plugin-tip.danger,.v-md-plugin-tip.tip,.v-md-plugin-tip.warning{margin:1rem 0;padding:.1rem 1.5rem;border-left-width:.5rem;border-left-style:solid}.v-md-plugin-tip.tip{background-color:#f3f5f7;border-color:#42b983}.v-md-plugin-tip.warning{color:#6b5900;background-color:rgba(255,229,100,.3);border-color:#e7c000}.v-md-plugin-tip.warning .v-md-plugin-tip-title{color:#b29400}.v-md-plugin-tip.warning a{color:#2c3e50}.v-md-plugin-tip.danger{color:#4d0000;background-color:#ffe6e6;border-color:#c00}.v-md-plugin-tip.danger .v-md-plugin-tip-title{color:#900}.v-md-plugin-tip.danger a{color:#2c3e50}.v-md-plugin-tip.details{position:relative;display:block;margin:1.6em 0;padding:1.6em;background-color:#eee;border-radius:2px}.v-md-plugin-tip.details h4{margin-top:0}.v-md-plugin-tip.details figure:last-child,.v-md-plugin-tip.details p:last-child{margin-bottom:0;padding-bottom:0}.v-md-plugin-tip.details summary{outline:none;cursor:pointer}\", \"\",{\"version\":3,\"sources\":[\"webpack://./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"[data-v-md-anchor]{cursor:pointer}.vuepress-markdown-body code[class*=v-md-prism-],.vuepress-markdown-body pre[class*=v-md-prism-]{color:#ccc;font-size:1em;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;line-height:1.5;white-space:pre;text-align:left;word-wrap:normal;word-break:normal;word-spacing:normal;-webkit-hyphens:none;hyphens:none;background:none}.vuepress-markdown-body>:first-child,.vuepress-markdown-body>div[data-v-md-line]:first-child>:first-child{margin-top:0!important}.vuepress-markdown-body>:last-child,.vuepress-markdown-body>div[data-v-md-line]:last-child>:last-child{margin-bottom:0!important}.vuepress-markdown-body pre[class*=v-md-prism-]{margin:.5em 0;padding:1em;overflow:auto}.vuepress-markdown-body :not(pre)>code[class*=v-md-prism-],.vuepress-markdown-body pre[class*=v-md-prism-]{background:#2d2d2d}.vuepress-markdown-body :not(pre)>code[class*=v-md-prism-]{padding:.1em;white-space:normal;border-radius:.3em}.vuepress-markdown-body .token.block-comment,.vuepress-markdown-body .token.cdata,.vuepress-markdown-body .token.comment,.vuepress-markdown-body .token.doctype,.vuepress-markdown-body .token.prolog{color:#999}.vuepress-markdown-body .token.punctuation{color:#ccc}.vuepress-markdown-body .token.attr-name,.vuepress-markdown-body .token.deleted,.vuepress-markdown-body .token.namespace,.vuepress-markdown-body .token.tag{color:#e2777a}.vuepress-markdown-body .token.function-name{color:#6196cc}.vuepress-markdown-body .token.boolean,.vuepress-markdown-body .token.function,.vuepress-markdown-body .token.number{color:#f08d49}.vuepress-markdown-body .token.class-name,.vuepress-markdown-body .token.constant,.vuepress-markdown-body .token.property,.vuepress-markdown-body .token.symbol{color:#f8c555}.vuepress-markdown-body .token.atrule,.vuepress-markdown-body .token.builtin,.vuepress-markdown-body .token.important,.vuepress-markdown-body .token.keyword,.vuepress-markdown-body .token.selector{color:#cc99cd}.vuepress-markdown-body .token.attr-value,.vuepress-markdown-body .token.char,.vuepress-markdown-body .token.regex,.vuepress-markdown-body .token.string,.vuepress-markdown-body .token.variable{color:#7ec699}.vuepress-markdown-body .token.entity,.vuepress-markdown-body .token.operator,.vuepress-markdown-body .token.url{color:#67cdcc}.vuepress-markdown-body .token.bold,.vuepress-markdown-body .token.important{font-weight:700}.vuepress-markdown-body .token.italic{font-style:italic}.vuepress-markdown-body .token.entity{cursor:help}.vuepress-markdown-body .token.inserted{color:green}.vuepress-markdown-body code{margin:0;padding:.25rem .5rem;color:#476582;font-size:.85em;background-color:rgba(27,31,35,.05);border-radius:3px}.vuepress-markdown-body code .token.deleted{color:#ec5975}.vuepress-markdown-body code .token.inserted{color:#3eaf7c}.vuepress-markdown-body pre,.vuepress-markdown-body pre[class*=v-md-prism-]{margin:.85rem 0;padding:1.25rem 1.5rem;overflow:auto;line-height:1.4;background-color:#282c34;border-radius:6px}.vuepress-markdown-body pre[class*=v-md-prism-] code,.vuepress-markdown-body pre code{padding:0;color:#fff;background-color:initial;border-radius:0}.vuepress-markdown-body div[class*=v-md-pre-wrapper-]{position:relative;background-color:#282c34;border-radius:6px}.vuepress-markdown-body div[class*=v-md-pre-wrapper-] pre,.vuepress-markdown-body div[class*=v-md-pre-wrapper-] pre[class*=v-md-prism-]{position:relative;z-index:1;background:transparent}.vuepress-markdown-body div[class*=v-md-pre-wrapper-]:before{position:absolute;top:.8em;right:1em;z-index:3;color:hsla(0,0%,100%,.4);font-size:.75rem}.vuepress-markdown-body div[class*=v-md-pre-wrapper-]:not(.line-numbers-mode) .line-numbers-wrapper{display:none}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode pre{padding-left:4.5rem;vertical-align:middle}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode .line-numbers-wrapper{position:absolute;top:0;width:3.5rem;padding:1.25rem 0;color:hsla(0,0%,100%,.3);line-height:1.4;text-align:center}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode .line-numbers-wrapper br{-webkit-user-select:none;user-select:none}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode .line-numbers-wrapper .line-number{position:relative;z-index:4;font-size:.85em;-webkit-user-select:none;user-select:none}.vuepress-markdown-body div[class*=v-md-pre-wrapper-].line-numbers-mode:after{position:absolute;top:0;left:0;z-index:2;width:3.5rem;height:100%;background-color:#282c34;border-right:1px solid rgba(0,0,0,.66);border-radius:6px 0 0 6px;content:\\\"\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-js]:before{content:\\\"js\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-ts]:before{content:\\\"ts\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-html]:before{content:\\\"html\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-md]:before{content:\\\"md\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-vue]:before{content:\\\"vue\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-css]:before{content:\\\"css\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-sass]:before{content:\\\"sass\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-scss]:before{content:\\\"scss\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-less]:before{content:\\\"less\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-stylus]:before{content:\\\"stylus\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-go]:before{content:\\\"go\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-java]:before{content:\\\"java\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-c]:before{content:\\\"c\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-sh]:before{content:\\\"sh\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-yaml]:before{content:\\\"yaml\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-py]:before{content:\\\"py\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-docker]:before{content:\\\"docker\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-dockerfile]:before{content:\\\"dockerfile\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-makefile]:before{content:\\\"makefile\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-javascript]:before{content:\\\"js\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-typescript]:before{content:\\\"ts\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-markup]:before{content:\\\"html\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-markdown]:before{content:\\\"md\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-json]:before{content:\\\"json\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-ruby]:before{content:\\\"rb\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-python]:before{content:\\\"py\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-bash]:before{content:\\\"sh\\\"}.vuepress-markdown-body div[class~=v-md-pre-wrapper-php]:before{content:\\\"php\\\"}.vuepress-markdown-body .arrow{display:inline-block;width:0;height:0}.vuepress-markdown-body .arrow.up{border-bottom:6px solid #ccc}.vuepress-markdown-body .arrow.down,.vuepress-markdown-body .arrow.up{border-right:4px solid transparent;border-left:4px solid transparent}.vuepress-markdown-body .arrow.down{border-top:6px solid #ccc}.vuepress-markdown-body .arrow.right{border-left:6px solid #ccc}.vuepress-markdown-body .arrow.left,.vuepress-markdown-body .arrow.right{border-top:4px solid transparent;border-bottom:4px solid transparent}.vuepress-markdown-body .arrow.left{border-right:6px solid #ccc}.vuepress-markdown-body:not(.custom){padding:2rem 2.5rem}@media (max-width:959px){.vuepress-markdown-body:not(.custom){padding:2rem}}@media (max-width:419px){.vuepress-markdown-body:not(.custom){padding:1.5rem}}.vuepress-markdown-body .table-of-contents .badge{vertical-align:middle}.vuepress-markdown-body{color:#2c3e50;font-size:16px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#fff}.vuepress-markdown-body:not(.custom) a:hover{text-decoration:underline}.vuepress-markdown-body:not(.custom) p.demo{padding:1rem 1.5rem;border:1px solid #ddd;border-radius:4px}.vuepress-markdown-body:not(.custom) img{max-width:100%}.vuepress-markdown-body.custom{margin:0;padding:0}.vuepress-markdown-body.custom img{max-width:100%}.vuepress-markdown-body a{font-weight:500;text-decoration:none}.vuepress-markdown-body a,.vuepress-markdown-body p a code{color:#3eaf7c}.vuepress-markdown-body p a code{font-weight:400}.vuepress-markdown-body kbd{padding:0 .15em;background:#eee;border:.15rem solid #ddd;border-bottom:.25rem solid #ddd;border-radius:.15rem}.vuepress-markdown-body blockquote{margin:1rem 0;padding:.25rem 0 .25rem 1rem;color:#999;font-size:1rem;border-left:.2rem solid #dfe2e5}.vuepress-markdown-body blockquote>p{margin:0}.vuepress-markdown-body ol,.vuepress-markdown-body ul{margin:1em 0;padding-left:1.2em}.vuepress-markdown-body strong{font-weight:600}.vuepress-markdown-body h1,.vuepress-markdown-body h2,.vuepress-markdown-body h3,.vuepress-markdown-body h4,.vuepress-markdown-body h5,.vuepress-markdown-body h6{font-weight:600;line-height:1.25}.vuepress-markdown-body h1{margin:.67em 0;font-size:2.2rem}.vuepress-markdown-body h2{margin:.83em 0;padding-bottom:.3rem;font-size:1.65rem;border-bottom:1px solid #eaecef}.vuepress-markdown-body h3{margin:1em 0;font-size:1.35rem}.vuepress-markdown-body h4{margin:1.33em 0}.vuepress-markdown-body h5{margin:1.67em 0}.vuepress-markdown-body h6{margin:2.33em 0}.vuepress-markdown-body em,.vuepress-markdown-body i{font-style:italic}.vuepress-markdown-body ul{list-style-type:disc}.vuepress-markdown-body ol ul,.vuepress-markdown-body ul ul{list-style-type:circle}.vuepress-markdown-body ol ol ul,.vuepress-markdown-body ol ul ul,.vuepress-markdown-body ul ol ul,.vuepress-markdown-body ul ul ul{list-style-type:square}.vuepress-markdown-body ol{list-style-type:decimal}.vuepress-markdown-body .line-number,.vuepress-markdown-body code,.vuepress-markdown-body kbd{font-family:source-code-pro,Menlo,Monaco,Consolas,Courier New,monospace}.vuepress-markdown-body ol,.vuepress-markdown-body p,.vuepress-markdown-body ul{line-height:1.7}.vuepress-markdown-body hr{border:0;border-top:1px solid #eaecef}.vuepress-markdown-body table{display:block;margin:1rem 0;overflow-x:auto;border-collapse:collapse}.vuepress-markdown-body tr{border-top:1px solid #dfe2e5}.vuepress-markdown-body tr:nth-child(2n){background-color:#f6f8fa}.vuepress-markdown-body td,.vuepress-markdown-body th{padding:.6em 1em;border:1px solid #dfe2e5}.vuepress-markdown-body .v-md-svg-outbound{position:relative;top:-1px;display:inline-block;color:#aaa;vertical-align:middle}@media (max-width:419px){.vuepress-markdown-body h1{font-size:1.9rem}.vuepress-markdown-body div[class*=v-md-pre-wrapper-]{margin:.85rem -1.5rem;border-radius:0}}.v-md-plugin-tip p{margin-top:1em;margin-bottom:1em}.v-md-plugin-tip .v-md-plugin-tip-title{margin-bottom:-.4rem;font-weight:600}.v-md-plugin-tip.danger,.v-md-plugin-tip.tip,.v-md-plugin-tip.warning{margin:1rem 0;padding:.1rem 1.5rem;border-left-width:.5rem;border-left-style:solid}.v-md-plugin-tip.tip{background-color:#f3f5f7;border-color:#42b983}.v-md-plugin-tip.warning{color:#6b5900;background-color:rgba(255,229,100,.3);border-color:#e7c000}.v-md-plugin-tip.warning .v-md-plugin-tip-title{color:#b29400}.v-md-plugin-tip.warning a{color:#2c3e50}.v-md-plugin-tip.danger{color:#4d0000;background-color:#ffe6e6;border-color:#c00}.v-md-plugin-tip.danger .v-md-plugin-tip-title{color:#900}.v-md-plugin-tip.danger a{color:#2c3e50}.v-md-plugin-tip.details{position:relative;display:block;margin:1.6em 0;padding:1.6em;background-color:#eee;border-radius:2px}.v-md-plugin-tip.details h4{margin-top:0}.v-md-plugin-tip.details figure:last-child,.v-md-plugin-tip.details p:last-child{margin-bottom:0;padding-bottom:0}.v-md-plugin-tip.details summary{outline:none;cursor:pointer}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsyXSEuL25vZGVfbW9kdWxlcy9Aa2FuZ2Mvdi1tZC1lZGl0b3IvbGliL3RoZW1lL3N0eWxlL3Z1ZXByZXNzLmNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ3FIO0FBQzdCO0FBQ3hGLDhCQUE4QixzRUFBMkIsQ0FBQywyRkFBcUM7QUFDL0Y7QUFDQSw2REFBNkQsZUFBZSxpR0FBaUcsV0FBVyxjQUFjLDhEQUE4RCxnQkFBZ0IsZ0JBQWdCLGdCQUFnQixpQkFBaUIsa0JBQWtCLG9CQUFvQixxQkFBcUIsYUFBYSxnQkFBZ0IsMEdBQTBHLHVCQUF1Qix1R0FBdUcsMEJBQTBCLGdEQUFnRCxjQUFjLFlBQVksY0FBYywyR0FBMkcsbUJBQW1CLDJEQUEyRCxhQUFhLG1CQUFtQixtQkFBbUIsc01BQXNNLFdBQVcsMkNBQTJDLFdBQVcsNEpBQTRKLGNBQWMsNkNBQTZDLGNBQWMscUhBQXFILGNBQWMsZ0tBQWdLLGNBQWMscU1BQXFNLGNBQWMsaU1BQWlNLGNBQWMsaUhBQWlILGNBQWMsNkVBQTZFLGdCQUFnQixzQ0FBc0Msa0JBQWtCLHNDQUFzQyxZQUFZLHdDQUF3QyxZQUFZLDZCQUE2QixTQUFTLHFCQUFxQixjQUFjLGdCQUFnQixvQ0FBb0Msa0JBQWtCLDRDQUE0QyxjQUFjLDZDQUE2QyxjQUFjLDRFQUE0RSxnQkFBZ0IsdUJBQXVCLGNBQWMsZ0JBQWdCLHlCQUF5QixrQkFBa0Isc0ZBQXNGLFVBQVUsV0FBVyx5QkFBeUIsZ0JBQWdCLHNEQUFzRCxrQkFBa0IseUJBQXlCLGtCQUFrQix3SUFBd0ksa0JBQWtCLFVBQVUsdUJBQXVCLDZEQUE2RCxrQkFBa0IsU0FBUyxVQUFVLFVBQVUseUJBQXlCLGlCQUFpQixvR0FBb0csYUFBYSw0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dUIsMkJBQTJCLHdCQUF3Qiw4RkFBOEYsd0VBQXdFLGdGQUFnRixnQkFBZ0IsMkJBQTJCLFNBQVMsNkJBQTZCLDhCQUE4QixjQUFjLGNBQWMsZ0JBQWdCLHlCQUF5QiwyQkFBMkIsNkJBQTZCLHlDQUF5Qyx5QkFBeUIsc0RBQXNELGlCQUFpQix5QkFBeUIsMkNBQTJDLGtCQUFrQixTQUFTLHFCQUFxQixXQUFXLHNCQUFzQix5QkFBeUIsMkJBQTJCLGlCQUFpQixzREFBc0Qsc0JBQXNCLGlCQUFpQixtQkFBbUIsZUFBZSxrQkFBa0Isd0NBQXdDLHFCQUFxQixnQkFBZ0Isc0VBQXNFLGNBQWMscUJBQXFCLHdCQUF3Qix3QkFBd0IscUJBQXFCLHlCQUF5QixxQkFBcUIseUJBQXlCLGNBQWMsc0NBQXNDLHFCQUFxQixnREFBZ0QsY0FBYywyQkFBMkIsY0FBYyx3QkFBd0IsY0FBYyx5QkFBeUIsa0JBQWtCLCtDQUErQyxXQUFXLDBCQUEwQixjQUFjLHlCQUF5QixrQkFBa0IsY0FBYyxlQUFlLGNBQWMsc0JBQXNCLGtCQUFrQiw0QkFBNEIsYUFBYSxpRkFBaUYsZ0JBQWdCLGlCQUFpQixpQ0FBaUMsYUFBYSxlQUFlLG1CQUFtQjtBQUN6aTJCO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGthbmdjL3YtbWQtZWRpdG9yL2xpYi90aGVtZS9zdHlsZS92dWVwcmVzcy5jc3M/ODY1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJbZGF0YS12LW1kLWFuY2hvcl17Y3Vyc29yOnBvaW50ZXJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgY29kZVtjbGFzcyo9di1tZC1wcmlzbS1dLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHByZVtjbGFzcyo9di1tZC1wcmlzbS1de2NvbG9yOiNjY2M7Zm9udC1zaXplOjFlbTtmb250LWZhbWlseTpDb25zb2xhcyxNb25hY28sQW5kYWxlIE1vbm8sVWJ1bnR1IE1vbm8sbW9ub3NwYWNlO2xpbmUtaGVpZ2h0OjEuNTt3aGl0ZS1zcGFjZTpwcmU7dGV4dC1hbGlnbjpsZWZ0O3dvcmQtd3JhcDpub3JtYWw7d29yZC1icmVhazpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDstd2Via2l0LWh5cGhlbnM6bm9uZTtoeXBoZW5zOm5vbmU7YmFja2dyb3VuZDpub25lfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5PjpmaXJzdC1jaGlsZCwudnVlcHJlc3MtbWFya2Rvd24tYm9keT5kaXZbZGF0YS12LW1kLWxpbmVdOmZpcnN0LWNoaWxkPjpmaXJzdC1jaGlsZHttYXJnaW4tdG9wOjAhaW1wb3J0YW50fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5PjpsYXN0LWNoaWxkLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5PmRpdltkYXRhLXYtbWQtbGluZV06bGFzdC1jaGlsZD46bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjAhaW1wb3J0YW50fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHByZVtjbGFzcyo9di1tZC1wcmlzbS1de21hcmdpbjouNWVtIDA7cGFkZGluZzoxZW07b3ZlcmZsb3c6YXV0b30udnVlcHJlc3MtbWFya2Rvd24tYm9keSA6bm90KHByZSk+Y29kZVtjbGFzcyo9di1tZC1wcmlzbS1dLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHByZVtjbGFzcyo9di1tZC1wcmlzbS1de2JhY2tncm91bmQ6IzJkMmQyZH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSA6bm90KHByZSk+Y29kZVtjbGFzcyo9di1tZC1wcmlzbS1de3BhZGRpbmc6LjFlbTt3aGl0ZS1zcGFjZTpub3JtYWw7Ym9yZGVyLXJhZGl1czouM2VtfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5ibG9jay1jb21tZW50LC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5jZGF0YSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uY29tbWVudCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uZG9jdHlwZSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4ucHJvbG9ne2NvbG9yOiM5OTl9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLnB1bmN0dWF0aW9ue2NvbG9yOiNjY2N9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmF0dHItbmFtZSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uZGVsZXRlZCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4ubmFtZXNwYWNlLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi50YWd7Y29sb3I6I2UyNzc3YX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uZnVuY3Rpb24tbmFtZXtjb2xvcjojNjE5NmNjfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5ib29sZWFuLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5mdW5jdGlvbiwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4ubnVtYmVye2NvbG9yOiNmMDhkNDl9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmNsYXNzLW5hbWUsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmNvbnN0YW50LC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5wcm9wZXJ0eSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uc3ltYm9se2NvbG9yOiNmOGM1NTV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmF0cnVsZSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uYnVpbHRpbiwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uaW1wb3J0YW50LC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5rZXl3b3JkLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5zZWxlY3Rvcntjb2xvcjojY2M5OWNkfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5hdHRyLXZhbHVlLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5jaGFyLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5yZWdleCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uc3RyaW5nLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi52YXJpYWJsZXtjb2xvcjojN2VjNjk5fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5lbnRpdHksLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLm9wZXJhdG9yLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi51cmx7Y29sb3I6IzY3Y2RjY30udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uYm9sZCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uaW1wb3J0YW50e2ZvbnQtd2VpZ2h0OjcwMH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uaXRhbGlje2ZvbnQtc3R5bGU6aXRhbGljfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5lbnRpdHl7Y3Vyc29yOmhlbHB9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmluc2VydGVke2NvbG9yOmdyZWVufS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGNvZGV7bWFyZ2luOjA7cGFkZGluZzouMjVyZW0gLjVyZW07Y29sb3I6IzQ3NjU4Mjtmb250LXNpemU6Ljg1ZW07YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDI3LDMxLDM1LC4wNSk7Ym9yZGVyLXJhZGl1czozcHh9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgY29kZSAudG9rZW4uZGVsZXRlZHtjb2xvcjojZWM1OTc1fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGNvZGUgLnRva2VuLmluc2VydGVke2NvbG9yOiMzZWFmN2N9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgcHJlLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHByZVtjbGFzcyo9di1tZC1wcmlzbS1de21hcmdpbjouODVyZW0gMDtwYWRkaW5nOjEuMjVyZW0gMS41cmVtO292ZXJmbG93OmF1dG87bGluZS1oZWlnaHQ6MS40O2JhY2tncm91bmQtY29sb3I6IzI4MmMzNDtib3JkZXItcmFkaXVzOjZweH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBwcmVbY2xhc3MqPXYtbWQtcHJpc20tXSBjb2RlLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHByZSBjb2Rle3BhZGRpbmc6MDtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6aW5pdGlhbDtib3JkZXItcmFkaXVzOjB9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzKj12LW1kLXByZS13cmFwcGVyLV17cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZC1jb2xvcjojMjgyYzM0O2JvcmRlci1yYWRpdXM6NnB4fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzcyo9di1tZC1wcmUtd3JhcHBlci1dIHByZSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3MqPXYtbWQtcHJlLXdyYXBwZXItXSBwcmVbY2xhc3MqPXYtbWQtcHJpc20tXXtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjE7YmFja2dyb3VuZDp0cmFuc3BhcmVudH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3MqPXYtbWQtcHJlLXdyYXBwZXItXTpiZWZvcmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOi44ZW07cmlnaHQ6MWVtO3otaW5kZXg6Mztjb2xvcjpoc2xhKDAsMCUsMTAwJSwuNCk7Zm9udC1zaXplOi43NXJlbX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3MqPXYtbWQtcHJlLXdyYXBwZXItXTpub3QoLmxpbmUtbnVtYmVycy1tb2RlKSAubGluZS1udW1iZXJzLXdyYXBwZXJ7ZGlzcGxheTpub25lfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzcyo9di1tZC1wcmUtd3JhcHBlci1dLmxpbmUtbnVtYmVycy1tb2RlIHByZXtwYWRkaW5nLWxlZnQ6NC41cmVtO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3MqPXYtbWQtcHJlLXdyYXBwZXItXS5saW5lLW51bWJlcnMtbW9kZSAubGluZS1udW1iZXJzLXdyYXBwZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7d2lkdGg6My41cmVtO3BhZGRpbmc6MS4yNXJlbSAwO2NvbG9yOmhzbGEoMCwwJSwxMDAlLC4zKTtsaW5lLWhlaWdodDoxLjQ7dGV4dC1hbGlnbjpjZW50ZXJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzKj12LW1kLXByZS13cmFwcGVyLV0ubGluZS1udW1iZXJzLW1vZGUgLmxpbmUtbnVtYmVycy13cmFwcGVyIGJyey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzcyo9di1tZC1wcmUtd3JhcHBlci1dLmxpbmUtbnVtYmVycy1tb2RlIC5saW5lLW51bWJlcnMtd3JhcHBlciAubGluZS1udW1iZXJ7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDo0O2ZvbnQtc2l6ZTouODVlbTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3MqPXYtbWQtcHJlLXdyYXBwZXItXS5saW5lLW51bWJlcnMtbW9kZTphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7ei1pbmRleDoyO3dpZHRoOjMuNXJlbTtoZWlnaHQ6MTAwJTtiYWNrZ3JvdW5kLWNvbG9yOiMyODJjMzQ7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCByZ2JhKDAsMCwwLC42Nik7Ym9yZGVyLXJhZGl1czo2cHggMCAwIDZweDtjb250ZW50OlxcXCJcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1qc106YmVmb3Jle2NvbnRlbnQ6XFxcImpzXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItdHNdOmJlZm9yZXtjb250ZW50OlxcXCJ0c1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWh0bWxdOmJlZm9yZXtjb250ZW50OlxcXCJodG1sXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItbWRdOmJlZm9yZXtjb250ZW50OlxcXCJtZFxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXZ1ZV06YmVmb3Jle2NvbnRlbnQ6XFxcInZ1ZVxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWNzc106YmVmb3Jle2NvbnRlbnQ6XFxcImNzc1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXNhc3NdOmJlZm9yZXtjb250ZW50OlxcXCJzYXNzXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItc2Nzc106YmVmb3Jle2NvbnRlbnQ6XFxcInNjc3NcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1sZXNzXTpiZWZvcmV7Y29udGVudDpcXFwibGVzc1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXN0eWx1c106YmVmb3Jle2NvbnRlbnQ6XFxcInN0eWx1c1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWdvXTpiZWZvcmV7Y29udGVudDpcXFwiZ29cXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1qYXZhXTpiZWZvcmV7Y29udGVudDpcXFwiamF2YVxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWNdOmJlZm9yZXtjb250ZW50OlxcXCJjXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItc2hdOmJlZm9yZXtjb250ZW50OlxcXCJzaFxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXlhbWxdOmJlZm9yZXtjb250ZW50OlxcXCJ5YW1sXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItcHldOmJlZm9yZXtjb250ZW50OlxcXCJweVxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWRvY2tlcl06YmVmb3Jle2NvbnRlbnQ6XFxcImRvY2tlclxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWRvY2tlcmZpbGVdOmJlZm9yZXtjb250ZW50OlxcXCJkb2NrZXJmaWxlXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItbWFrZWZpbGVdOmJlZm9yZXtjb250ZW50OlxcXCJtYWtlZmlsZVxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWphdmFzY3JpcHRdOmJlZm9yZXtjb250ZW50OlxcXCJqc1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXR5cGVzY3JpcHRdOmJlZm9yZXtjb250ZW50OlxcXCJ0c1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLW1hcmt1cF06YmVmb3Jle2NvbnRlbnQ6XFxcImh0bWxcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1tYXJrZG93bl06YmVmb3Jle2NvbnRlbnQ6XFxcIm1kXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItanNvbl06YmVmb3Jle2NvbnRlbnQ6XFxcImpzb25cXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1ydWJ5XTpiZWZvcmV7Y29udGVudDpcXFwicmJcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1weXRob25dOmJlZm9yZXtjb250ZW50OlxcXCJweVxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWJhc2hdOmJlZm9yZXtjb250ZW50OlxcXCJzaFxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXBocF06YmVmb3Jle2NvbnRlbnQ6XFxcInBocFxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLmFycm93e2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjA7aGVpZ2h0OjB9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLmFycm93LnVwe2JvcmRlci1ib3R0b206NnB4IHNvbGlkICNjY2N9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLmFycm93LmRvd24sLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLmFycm93LnVwe2JvcmRlci1yaWdodDo0cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHRyYW5zcGFyZW50fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5hcnJvdy5kb3due2JvcmRlci10b3A6NnB4IHNvbGlkICNjY2N9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLmFycm93LnJpZ2h0e2JvcmRlci1sZWZ0OjZweCBzb2xpZCAjY2NjfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5hcnJvdy5sZWZ0LC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5hcnJvdy5yaWdodHtib3JkZXItdG9wOjRweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjRweCBzb2xpZCB0cmFuc3BhcmVudH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAuYXJyb3cubGVmdHtib3JkZXItcmlnaHQ6NnB4IHNvbGlkICNjY2N9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHk6bm90KC5jdXN0b20pe3BhZGRpbmc6MnJlbSAyLjVyZW19QG1lZGlhIChtYXgtd2lkdGg6OTU5cHgpey52dWVwcmVzcy1tYXJrZG93bi1ib2R5Om5vdCguY3VzdG9tKXtwYWRkaW5nOjJyZW19fUBtZWRpYSAobWF4LXdpZHRoOjQxOXB4KXsudnVlcHJlc3MtbWFya2Rvd24tYm9keTpub3QoLmN1c3RvbSl7cGFkZGluZzoxLjVyZW19fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50YWJsZS1vZi1jb250ZW50cyAuYmFkZ2V7dmVydGljYWwtYWxpZ246bWlkZGxlfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5e2NvbG9yOiMyYzNlNTA7Zm9udC1zaXplOjE2cHg7Zm9udC1mYW1pbHk6LWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsU2Vnb2UgVUksUm9ib3RvLE94eWdlbixVYnVudHUsQ2FudGFyZWxsLEZpcmEgU2FucyxEcm9pZCBTYW5zLEhlbHZldGljYSBOZXVlLHNhbnMtc2VyaWY7LXdlYmtpdC1mb250LXNtb290aGluZzphbnRpYWxpYXNlZDstbW96LW9zeC1mb250LXNtb290aGluZzpncmF5c2NhbGU7YmFja2dyb3VuZC1jb2xvcjojZmZmfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5Om5vdCguY3VzdG9tKSBhOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHk6bm90KC5jdXN0b20pIHAuZGVtb3twYWRkaW5nOjFyZW0gMS41cmVtO2JvcmRlcjoxcHggc29saWQgI2RkZDtib3JkZXItcmFkaXVzOjRweH0udnVlcHJlc3MtbWFya2Rvd24tYm9keTpub3QoLmN1c3RvbSkgaW1ne21heC13aWR0aDoxMDAlfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5LmN1c3RvbXttYXJnaW46MDtwYWRkaW5nOjB9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkuY3VzdG9tIGltZ3ttYXgtd2lkdGg6MTAwJX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBhe2ZvbnQtd2VpZ2h0OjUwMDt0ZXh0LWRlY29yYXRpb246bm9uZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBhLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHAgYSBjb2Rle2NvbG9yOiMzZWFmN2N9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgcCBhIGNvZGV7Zm9udC13ZWlnaHQ6NDAwfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGtiZHtwYWRkaW5nOjAgLjE1ZW07YmFja2dyb3VuZDojZWVlO2JvcmRlcjouMTVyZW0gc29saWQgI2RkZDtib3JkZXItYm90dG9tOi4yNXJlbSBzb2xpZCAjZGRkO2JvcmRlci1yYWRpdXM6LjE1cmVtfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGJsb2NrcXVvdGV7bWFyZ2luOjFyZW0gMDtwYWRkaW5nOi4yNXJlbSAwIC4yNXJlbSAxcmVtO2NvbG9yOiM5OTk7Zm9udC1zaXplOjFyZW07Ym9yZGVyLWxlZnQ6LjJyZW0gc29saWQgI2RmZTJlNX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBibG9ja3F1b3RlPnB7bWFyZ2luOjB9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgb2wsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdWx7bWFyZ2luOjFlbSAwO3BhZGRpbmctbGVmdDoxLjJlbX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBzdHJvbmd7Zm9udC13ZWlnaHQ6NjAwfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGgxLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGgyLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGgzLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGg0LC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGg1LC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGg2e2ZvbnQtd2VpZ2h0OjYwMDtsaW5lLWhlaWdodDoxLjI1fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGgxe21hcmdpbjouNjdlbSAwO2ZvbnQtc2l6ZToyLjJyZW19LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgaDJ7bWFyZ2luOi44M2VtIDA7cGFkZGluZy1ib3R0b206LjNyZW07Zm9udC1zaXplOjEuNjVyZW07Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2VhZWNlZn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBoM3ttYXJnaW46MWVtIDA7Zm9udC1zaXplOjEuMzVyZW19LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgaDR7bWFyZ2luOjEuMzNlbSAwfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGg1e21hcmdpbjoxLjY3ZW0gMH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBoNnttYXJnaW46Mi4zM2VtIDB9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZW0sLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgaXtmb250LXN0eWxlOml0YWxpY30udnVlcHJlc3MtbWFya2Rvd24tYm9keSB1bHtsaXN0LXN0eWxlLXR5cGU6ZGlzY30udnVlcHJlc3MtbWFya2Rvd24tYm9keSBvbCB1bCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSB1bCB1bHtsaXN0LXN0eWxlLXR5cGU6Y2lyY2xlfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IG9sIG9sIHVsLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IG9sIHVsIHVsLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHVsIG9sIHVsLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHVsIHVsIHVse2xpc3Qtc3R5bGUtdHlwZTpzcXVhcmV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgb2x7bGlzdC1zdHlsZS10eXBlOmRlY2ltYWx9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLmxpbmUtbnVtYmVyLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGNvZGUsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkga2Jke2ZvbnQtZmFtaWx5OnNvdXJjZS1jb2RlLXBybyxNZW5sbyxNb25hY28sQ29uc29sYXMsQ291cmllciBOZXcsbW9ub3NwYWNlfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IG9sLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHAsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdWx7bGluZS1oZWlnaHQ6MS43fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGhye2JvcmRlcjowO2JvcmRlci10b3A6MXB4IHNvbGlkICNlYWVjZWZ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdGFibGV7ZGlzcGxheTpibG9jazttYXJnaW46MXJlbSAwO292ZXJmbG93LXg6YXV0bztib3JkZXItY29sbGFwc2U6Y29sbGFwc2V9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdHJ7Ym9yZGVyLXRvcDoxcHggc29saWQgI2RmZTJlNX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSB0cjpudGgtY2hpbGQoMm4pe2JhY2tncm91bmQtY29sb3I6I2Y2ZjhmYX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSB0ZCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSB0aHtwYWRkaW5nOi42ZW0gMWVtO2JvcmRlcjoxcHggc29saWQgI2RmZTJlNX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudi1tZC1zdmctb3V0Ym91bmR7cG9zaXRpb246cmVsYXRpdmU7dG9wOi0xcHg7ZGlzcGxheTppbmxpbmUtYmxvY2s7Y29sb3I6I2FhYTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9QG1lZGlhIChtYXgtd2lkdGg6NDE5cHgpey52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGgxe2ZvbnQtc2l6ZToxLjlyZW19LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzKj12LW1kLXByZS13cmFwcGVyLV17bWFyZ2luOi44NXJlbSAtMS41cmVtO2JvcmRlci1yYWRpdXM6MH19LnYtbWQtcGx1Z2luLXRpcCBwe21hcmdpbi10b3A6MWVtO21hcmdpbi1ib3R0b206MWVtfS52LW1kLXBsdWdpbi10aXAgLnYtbWQtcGx1Z2luLXRpcC10aXRsZXttYXJnaW4tYm90dG9tOi0uNHJlbTtmb250LXdlaWdodDo2MDB9LnYtbWQtcGx1Z2luLXRpcC5kYW5nZXIsLnYtbWQtcGx1Z2luLXRpcC50aXAsLnYtbWQtcGx1Z2luLXRpcC53YXJuaW5ne21hcmdpbjoxcmVtIDA7cGFkZGluZzouMXJlbSAxLjVyZW07Ym9yZGVyLWxlZnQtd2lkdGg6LjVyZW07Ym9yZGVyLWxlZnQtc3R5bGU6c29saWR9LnYtbWQtcGx1Z2luLXRpcC50aXB7YmFja2dyb3VuZC1jb2xvcjojZjNmNWY3O2JvcmRlci1jb2xvcjojNDJiOTgzfS52LW1kLXBsdWdpbi10aXAud2FybmluZ3tjb2xvcjojNmI1OTAwO2JhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsMjI5LDEwMCwuMyk7Ym9yZGVyLWNvbG9yOiNlN2MwMDB9LnYtbWQtcGx1Z2luLXRpcC53YXJuaW5nIC52LW1kLXBsdWdpbi10aXAtdGl0bGV7Y29sb3I6I2IyOTQwMH0udi1tZC1wbHVnaW4tdGlwLndhcm5pbmcgYXtjb2xvcjojMmMzZTUwfS52LW1kLXBsdWdpbi10aXAuZGFuZ2Vye2NvbG9yOiM0ZDAwMDA7YmFja2dyb3VuZC1jb2xvcjojZmZlNmU2O2JvcmRlci1jb2xvcjojYzAwfS52LW1kLXBsdWdpbi10aXAuZGFuZ2VyIC52LW1kLXBsdWdpbi10aXAtdGl0bGV7Y29sb3I6IzkwMH0udi1tZC1wbHVnaW4tdGlwLmRhbmdlciBhe2NvbG9yOiMyYzNlNTB9LnYtbWQtcGx1Z2luLXRpcC5kZXRhaWxze3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjEuNmVtIDA7cGFkZGluZzoxLjZlbTtiYWNrZ3JvdW5kLWNvbG9yOiNlZWU7Ym9yZGVyLXJhZGl1czoycHh9LnYtbWQtcGx1Z2luLXRpcC5kZXRhaWxzIGg0e21hcmdpbi10b3A6MH0udi1tZC1wbHVnaW4tdGlwLmRldGFpbHMgZmlndXJlOmxhc3QtY2hpbGQsLnYtbWQtcGx1Z2luLXRpcC5kZXRhaWxzIHA6bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjA7cGFkZGluZy1ib3R0b206MH0udi1tZC1wbHVnaW4tdGlwLmRldGFpbHMgc3VtbWFyeXtvdXRsaW5lOm5vbmU7Y3Vyc29yOnBvaW50ZXJ9XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL0BrYW5nYy92LW1kLWVkaXRvci9saWIvdGhlbWUvc3R5bGUvdnVlcHJlc3MuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLG1CQUFtQixjQUFjLENBQUMsaUdBQWlHLFVBQVUsQ0FBQyxhQUFhLENBQUMsNkRBQTZELENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsbUJBQW1CLENBQUMsb0JBQW9CLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQywwR0FBMEcsc0JBQXNCLENBQUMsdUdBQXVHLHlCQUF5QixDQUFDLGdE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Z0IsQ0FBQyx3QkFBd0IsQ0FBQywyQ0FBMkMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLG9CQUFvQixDQUFDLFVBQVUsQ0FBQyxxQkFBcUIsQ0FBQyx5QkFBeUIsMkJBQTJCLGdCQUFnQixDQUFDLHNEQUFzRCxxQkFBcUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxtQkFBbUIsY0FBYyxDQUFDLGlCQUFpQixDQUFDLHdDQUF3QyxvQkFBb0IsQ0FBQyxlQUFlLENBQUMsc0VBQXNFLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQyx1QkFBdUIsQ0FBQyx1QkFBdUIsQ0FBQyxxQkFBcUIsd0JBQXdCLENBQUMsb0JBQW9CLENBQUMseUJBQXlCLGFBQWEsQ0FBQyxxQ0FBcUMsQ0FBQyxvQkFBb0IsQ0FBQyxnREFBZ0QsYUFBYSxDQUFDLDJCQUEyQixhQUFhLENBQUMsd0JBQXdCLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxpQkFBaUIsQ0FBQywrQ0FBK0MsVUFBVSxDQUFDLDBCQUEwQixhQUFhLENBQUMseUJBQXlCLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLHFCQUFxQixDQUFDLGlCQUFpQixDQUFDLDRCQUE0QixZQUFZLENBQUMsaUZBQWlGLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxpQ0FBaUMsWUFBWSxDQUFDLGNBQWNcIixcInNvdXJjZXNDb250ZW50XCI6W1wiW2RhdGEtdi1tZC1hbmNob3Jde2N1cnNvcjpwb2ludGVyfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGNvZGVbY2xhc3MqPXYtbWQtcHJpc20tXSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBwcmVbY2xhc3MqPXYtbWQtcHJpc20tXXtjb2xvcjojY2NjO2ZvbnQtc2l6ZToxZW07Zm9udC1mYW1pbHk6Q29uc29sYXMsTW9uYWNvLEFuZGFsZSBNb25vLFVidW50dSBNb25vLG1vbm9zcGFjZTtsaW5lLWhlaWdodDoxLjU7d2hpdGUtc3BhY2U6cHJlO3RleHQtYWxpZ246bGVmdDt3b3JkLXdyYXA6bm9ybWFsO3dvcmQtYnJlYWs6bm9ybWFsO3dvcmQtc3BhY2luZzpub3JtYWw7LXdlYmtpdC1oeXBoZW5zOm5vbmU7aHlwaGVuczpub25lO2JhY2tncm91bmQ6bm9uZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keT46Zmlyc3QtY2hpbGQsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHk+ZGl2W2RhdGEtdi1tZC1saW5lXTpmaXJzdC1jaGlsZD46Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDowIWltcG9ydGFudH0udnVlcHJlc3MtbWFya2Rvd24tYm9keT46bGFzdC1jaGlsZCwudnVlcHJlc3MtbWFya2Rvd24tYm9keT5kaXZbZGF0YS12LW1kLWxpbmVdOmxhc3QtY2hpbGQ+Omxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTowIWltcG9ydGFudH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBwcmVbY2xhc3MqPXYtbWQtcHJpc20tXXttYXJnaW46LjVlbSAwO3BhZGRpbmc6MWVtO292ZXJmbG93OmF1dG99LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgOm5vdChwcmUpPmNvZGVbY2xhc3MqPXYtbWQtcHJpc20tXSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBwcmVbY2xhc3MqPXYtbWQtcHJpc20tXXtiYWNrZ3JvdW5kOiMyZDJkMmR9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgOm5vdChwcmUpPmNvZGVbY2xhc3MqPXYtbWQtcHJpc20tXXtwYWRkaW5nOi4xZW07d2hpdGUtc3BhY2U6bm9ybWFsO2JvcmRlci1yYWRpdXM6LjNlbX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uYmxvY2stY29tbWVudCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uY2RhdGEsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmNvbW1lbnQsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmRvY3R5cGUsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLnByb2xvZ3tjb2xvcjojOTk5fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5wdW5jdHVhdGlvbntjb2xvcjojY2NjfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5hdHRyLW5hbWUsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmRlbGV0ZWQsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLm5hbWVzcGFjZSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4udGFne2NvbG9yOiNlMjc3N2F9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmZ1bmN0aW9uLW5hbWV7Y29sb3I6IzYxOTZjY30udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uYm9vbGVhbiwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uZnVuY3Rpb24sLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLm51bWJlcntjb2xvcjojZjA4ZDQ5fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5jbGFzcy1uYW1lLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5jb25zdGFudCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4ucHJvcGVydHksLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLnN5bWJvbHtjb2xvcjojZjhjNTU1fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5hdHJ1bGUsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmJ1aWx0aW4sLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmltcG9ydGFudCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4ua2V5d29yZCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uc2VsZWN0b3J7Y29sb3I6I2NjOTljZH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uYXR0ci12YWx1ZSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uY2hhciwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4ucmVnZXgsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLnN0cmluZywudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4udmFyaWFibGV7Y29sb3I6IzdlYzY5OX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uZW50aXR5LC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5vcGVyYXRvciwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4udXJse2NvbG9yOiM2N2NkY2N9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmJvbGQsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLmltcG9ydGFudHtmb250LXdlaWdodDo3MDB9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnRva2VuLml0YWxpY3tmb250LXN0eWxlOml0YWxpY30udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudG9rZW4uZW50aXR5e2N1cnNvcjpoZWxwfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC50b2tlbi5pbnNlcnRlZHtjb2xvcjpncmVlbn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBjb2Rle21hcmdpbjowO3BhZGRpbmc6LjI1cmVtIC41cmVtO2NvbG9yOiM0NzY1ODI7Zm9udC1zaXplOi44NWVtO2JhY2tncm91bmQtY29sb3I6cmdiYSgyNywzMSwzNSwuMDUpO2JvcmRlci1yYWRpdXM6M3B4fS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGNvZGUgLnRva2VuLmRlbGV0ZWR7Y29sb3I6I2VjNTk3NX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBjb2RlIC50b2tlbi5pbnNlcnRlZHtjb2xvcjojM2VhZjdjfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHByZSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBwcmVbY2xhc3MqPXYtbWQtcHJpc20tXXttYXJnaW46Ljg1cmVtIDA7cGFkZGluZzoxLjI1cmVtIDEuNXJlbTtvdmVyZmxvdzphdXRvO2xpbmUtaGVpZ2h0OjEuNDtiYWNrZ3JvdW5kLWNvbG9yOiMyODJjMzQ7Ym9yZGVyLXJhZGl1czo2cHh9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgcHJlW2NsYXNzKj12LW1kLXByaXNtLV0gY29kZSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBwcmUgY29kZXtwYWRkaW5nOjA7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOmluaXRpYWw7Ym9yZGVyLXJhZGl1czowfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzcyo9di1tZC1wcmUtd3JhcHBlci1de3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQtY29sb3I6IzI4MmMzNDtib3JkZXItcmFkaXVzOjZweH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3MqPXYtbWQtcHJlLXdyYXBwZXItXSBwcmUsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzKj12LW1kLXByZS13cmFwcGVyLV0gcHJlW2NsYXNzKj12LW1kLXByaXNtLV17cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxO2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzKj12LW1kLXByZS13cmFwcGVyLV06YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO3RvcDouOGVtO3JpZ2h0OjFlbTt6LWluZGV4OjM7Y29sb3I6aHNsYSgwLDAlLDEwMCUsLjQpO2ZvbnQtc2l6ZTouNzVyZW19LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzKj12LW1kLXByZS13cmFwcGVyLV06bm90KC5saW5lLW51bWJlcnMtbW9kZSkgLmxpbmUtbnVtYmVycy13cmFwcGVye2Rpc3BsYXk6bm9uZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3MqPXYtbWQtcHJlLXdyYXBwZXItXS5saW5lLW51bWJlcnMtbW9kZSBwcmV7cGFkZGluZy1sZWZ0OjQuNXJlbTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzKj12LW1kLXByZS13cmFwcGVyLV0ubGluZS1udW1iZXJzLW1vZGUgLmxpbmUtbnVtYmVycy13cmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3dpZHRoOjMuNXJlbTtwYWRkaW5nOjEuMjVyZW0gMDtjb2xvcjpoc2xhKDAsMCUsMTAwJSwuMyk7bGluZS1oZWlnaHQ6MS40O3RleHQtYWxpZ246Y2VudGVyfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzcyo9di1tZC1wcmUtd3JhcHBlci1dLmxpbmUtbnVtYmVycy1tb2RlIC5saW5lLW51bWJlcnMtd3JhcHBlciBicnstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3MqPXYtbWQtcHJlLXdyYXBwZXItXS5saW5lLW51bWJlcnMtbW9kZSAubGluZS1udW1iZXJzLXdyYXBwZXIgLmxpbmUtbnVtYmVye3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6NDtmb250LXNpemU6Ljg1ZW07LXdlYmtpdC11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzKj12LW1kLXByZS13cmFwcGVyLV0ubGluZS1udW1iZXJzLW1vZGU6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3otaW5kZXg6Mjt3aWR0aDozLjVyZW07aGVpZ2h0OjEwMCU7YmFja2dyb3VuZC1jb2xvcjojMjgyYzM0O2JvcmRlci1yaWdodDoxcHggc29saWQgcmdiYSgwLDAsMCwuNjYpO2JvcmRlci1yYWRpdXM6NnB4IDAgMCA2cHg7Y29udGVudDpcXFwiXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItanNdOmJlZm9yZXtjb250ZW50OlxcXCJqc1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXRzXTpiZWZvcmV7Y29udGVudDpcXFwidHNcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1odG1sXTpiZWZvcmV7Y29udGVudDpcXFwiaHRtbFxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLW1kXTpiZWZvcmV7Y29udGVudDpcXFwibWRcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci12dWVdOmJlZm9yZXtjb250ZW50OlxcXCJ2dWVcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1jc3NdOmJlZm9yZXtjb250ZW50OlxcXCJjc3NcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1zYXNzXTpiZWZvcmV7Y29udGVudDpcXFwic2Fzc1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXNjc3NdOmJlZm9yZXtjb250ZW50OlxcXCJzY3NzXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItbGVzc106YmVmb3Jle2NvbnRlbnQ6XFxcImxlc3NcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1zdHlsdXNdOmJlZm9yZXtjb250ZW50OlxcXCJzdHlsdXNcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1nb106YmVmb3Jle2NvbnRlbnQ6XFxcImdvXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItamF2YV06YmVmb3Jle2NvbnRlbnQ6XFxcImphdmFcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1jXTpiZWZvcmV7Y29udGVudDpcXFwiY1xcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXNoXTpiZWZvcmV7Y29udGVudDpcXFwic2hcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci15YW1sXTpiZWZvcmV7Y29udGVudDpcXFwieWFtbFxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLXB5XTpiZWZvcmV7Y29udGVudDpcXFwicHlcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1kb2NrZXJdOmJlZm9yZXtjb250ZW50OlxcXCJkb2NrZXJcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1kb2NrZXJmaWxlXTpiZWZvcmV7Y29udGVudDpcXFwiZG9ja2VyZmlsZVxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLW1ha2VmaWxlXTpiZWZvcmV7Y29udGVudDpcXFwibWFrZWZpbGVcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1qYXZhc2NyaXB0XTpiZWZvcmV7Y29udGVudDpcXFwianNcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci10eXBlc2NyaXB0XTpiZWZvcmV7Y29udGVudDpcXFwidHNcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1tYXJrdXBdOmJlZm9yZXtjb250ZW50OlxcXCJodG1sXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItbWFya2Rvd25dOmJlZm9yZXtjb250ZW50OlxcXCJtZFxcXCJ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgZGl2W2NsYXNzfj12LW1kLXByZS13cmFwcGVyLWpzb25dOmJlZm9yZXtjb250ZW50OlxcXCJqc29uXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItcnVieV06YmVmb3Jle2NvbnRlbnQ6XFxcInJiXFxcIn0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBkaXZbY2xhc3N+PXYtbWQtcHJlLXdyYXBwZXItcHl0aG9uXTpiZWZvcmV7Y29udGVudDpcXFwicHlcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1iYXNoXTpiZWZvcmV7Y29udGVudDpcXFwic2hcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzc349di1tZC1wcmUtd3JhcHBlci1waHBdOmJlZm9yZXtjb250ZW50OlxcXCJwaHBcXFwifS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5hcnJvd3tkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDowO2hlaWdodDowfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5hcnJvdy51cHtib3JkZXItYm90dG9tOjZweCBzb2xpZCAjY2NjfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5hcnJvdy5kb3duLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5hcnJvdy51cHtib3JkZXItcmlnaHQ6NHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjRweCBzb2xpZCB0cmFuc3BhcmVudH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAuYXJyb3cuZG93bntib3JkZXItdG9wOjZweCBzb2xpZCAjY2NjfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5hcnJvdy5yaWdodHtib3JkZXItbGVmdDo2cHggc29saWQgI2NjY30udnVlcHJlc3MtbWFya2Rvd24tYm9keSAuYXJyb3cubGVmdCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSAuYXJyb3cucmlnaHR7Ym9yZGVyLXRvcDo0cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo0cHggc29saWQgdHJhbnNwYXJlbnR9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLmFycm93LmxlZnR7Ym9yZGVyLXJpZ2h0OjZweCBzb2xpZCAjY2NjfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5Om5vdCguY3VzdG9tKXtwYWRkaW5nOjJyZW0gMi41cmVtfUBtZWRpYSAobWF4LXdpZHRoOjk1OXB4KXsudnVlcHJlc3MtbWFya2Rvd24tYm9keTpub3QoLmN1c3RvbSl7cGFkZGluZzoycmVtfX1AbWVkaWEgKG1heC13aWR0aDo0MTlweCl7LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHk6bm90KC5jdXN0b20pe3BhZGRpbmc6MS41cmVtfX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSAudGFibGUtb2YtY29udGVudHMgLmJhZGdle3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keXtjb2xvcjojMmMzZTUwO2ZvbnQtc2l6ZToxNnB4O2ZvbnQtZmFtaWx5Oi1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxPeHlnZW4sVWJ1bnR1LENhbnRhcmVsbCxGaXJhIFNhbnMsRHJvaWQgU2FucyxIZWx2ZXRpY2EgTmV1ZSxzYW5zLXNlcmlmOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2JhY2tncm91bmQtY29sb3I6I2ZmZn0udnVlcHJlc3MtbWFya2Rvd24tYm9keTpub3QoLmN1c3RvbSkgYTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5Om5vdCguY3VzdG9tKSBwLmRlbW97cGFkZGluZzoxcmVtIDEuNXJlbTtib3JkZXI6MXB4IHNvbGlkICNkZGQ7Ym9yZGVyLXJhZGl1czo0cHh9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHk6bm90KC5jdXN0b20pIGltZ3ttYXgtd2lkdGg6MTAwJX0udnVlcHJlc3MtbWFya2Rvd24tYm9keS5jdXN0b217bWFyZ2luOjA7cGFkZGluZzowfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5LmN1c3RvbSBpbWd7bWF4LXdpZHRoOjEwMCV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgYXtmb250LXdlaWdodDo1MDA7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgYSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBwIGEgY29kZXtjb2xvcjojM2VhZjdjfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHAgYSBjb2Rle2ZvbnQtd2VpZ2h0OjQwMH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBrYmR7cGFkZGluZzowIC4xNWVtO2JhY2tncm91bmQ6I2VlZTtib3JkZXI6LjE1cmVtIHNvbGlkICNkZGQ7Ym9yZGVyLWJvdHRvbTouMjVyZW0gc29saWQgI2RkZDtib3JkZXItcmFkaXVzOi4xNXJlbX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBibG9ja3F1b3Rle21hcmdpbjoxcmVtIDA7cGFkZGluZzouMjVyZW0gMCAuMjVyZW0gMXJlbTtjb2xvcjojOTk5O2ZvbnQtc2l6ZToxcmVtO2JvcmRlci1sZWZ0Oi4ycmVtIHNvbGlkICNkZmUyZTV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgYmxvY2txdW90ZT5we21hcmdpbjowfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IG9sLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHVse21hcmdpbjoxZW0gMDtwYWRkaW5nLWxlZnQ6MS4yZW19LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgc3Ryb25ne2ZvbnQtd2VpZ2h0OjYwMH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBoMSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBoMiwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBoMywudnVlcHJlc3MtbWFya2Rvd24tYm9keSBoNCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBoNSwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBoNntmb250LXdlaWdodDo2MDA7bGluZS1oZWlnaHQ6MS4yNX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBoMXttYXJnaW46LjY3ZW0gMDtmb250LXNpemU6Mi4ycmVtfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGgye21hcmdpbjouODNlbSAwO3BhZGRpbmctYm90dG9tOi4zcmVtO2ZvbnQtc2l6ZToxLjY1cmVtO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlYWVjZWZ9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgaDN7bWFyZ2luOjFlbSAwO2ZvbnQtc2l6ZToxLjM1cmVtfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGg0e21hcmdpbjoxLjMzZW0gMH0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBoNXttYXJnaW46MS42N2VtIDB9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgaDZ7bWFyZ2luOjIuMzNlbSAwfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGVtLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGl7Zm9udC1zdHlsZTppdGFsaWN9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdWx7bGlzdC1zdHlsZS10eXBlOmRpc2N9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgb2wgdWwsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdWwgdWx7bGlzdC1zdHlsZS10eXBlOmNpcmNsZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBvbCBvbCB1bCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBvbCB1bCB1bCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSB1bCBvbCB1bCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSB1bCB1bCB1bHtsaXN0LXN0eWxlLXR5cGU6c3F1YXJlfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IG9se2xpc3Qtc3R5bGUtdHlwZTpkZWNpbWFsfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IC5saW5lLW51bWJlciwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBjb2RlLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGtiZHtmb250LWZhbWlseTpzb3VyY2UtY29kZS1wcm8sTWVubG8sTW9uYWNvLENvbnNvbGFzLENvdXJpZXIgTmV3LG1vbm9zcGFjZX0udnVlcHJlc3MtbWFya2Rvd24tYm9keSBvbCwudnVlcHJlc3MtbWFya2Rvd24tYm9keSBwLC52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHVse2xpbmUtaGVpZ2h0OjEuN30udnVlcHJlc3MtbWFya2Rvd24tYm9keSBocntib3JkZXI6MDtib3JkZXItdG9wOjFweCBzb2xpZCAjZWFlY2VmfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHRhYmxle2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjFyZW0gMDtvdmVyZmxvdy14OmF1dG87Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IHRye2JvcmRlci10b3A6MXB4IHNvbGlkICNkZmUyZTV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdHI6bnRoLWNoaWxkKDJuKXtiYWNrZ3JvdW5kLWNvbG9yOiNmNmY4ZmF9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdGQsLnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgdGh7cGFkZGluZzouNmVtIDFlbTtib3JkZXI6MXB4IHNvbGlkICNkZmUyZTV9LnZ1ZXByZXNzLW1hcmtkb3duLWJvZHkgLnYtbWQtc3ZnLW91dGJvdW5ke3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDotMXB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2NvbG9yOiNhYWE7dmVydGljYWwtYWxpZ246bWlkZGxlfUBtZWRpYSAobWF4LXdpZHRoOjQxOXB4KXsudnVlcHJlc3MtbWFya2Rvd24tYm9keSBoMXtmb250LXNpemU6MS45cmVtfS52dWVwcmVzcy1tYXJrZG93bi1ib2R5IGRpdltjbGFzcyo9di1tZC1wcmUtd3JhcHBlci1de21hcmdpbjouODVyZW0gLTEuNXJlbTtib3JkZXItcmFkaXVzOjB9fS52LW1kLXBsdWdpbi10aXAgcHttYXJnaW4tdG9wOjFlbTttYXJnaW4tYm90dG9tOjFlbX0udi1tZC1wbHVnaW4tdGlwIC52LW1kLXBsdWdpbi10aXAtdGl0bGV7bWFyZ2luLWJvdHRvbTotLjRyZW07Zm9udC13ZWlnaHQ6NjAwfS52LW1kLXBsdWdpbi10aXAuZGFuZ2VyLC52LW1kLXBsdWdpbi10aXAudGlwLC52LW1kLXBsdWdpbi10aXAud2FybmluZ3ttYXJnaW46MXJlbSAwO3BhZGRpbmc6LjFyZW0gMS41cmVtO2JvcmRlci1sZWZ0LXdpZHRoOi41cmVtO2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkfS52LW1kLXBsdWdpbi10aXAudGlwe2JhY2tncm91bmQtY29sb3I6I2YzZjVmNztib3JkZXItY29sb3I6IzQyYjk4M30udi1tZC1wbHVnaW4tdGlwLndhcm5pbmd7Y29sb3I6IzZiNTkwMDtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjU1LDIyOSwxMDAsLjMpO2JvcmRlci1jb2xvcjojZTdjMDAwfS52LW1kLXBsdWdpbi10aXAud2FybmluZyAudi1tZC1wbHVnaW4tdGlwLXRpdGxle2NvbG9yOiNiMjk0MDB9LnYtbWQtcGx1Z2luLXRpcC53YXJuaW5nIGF7Y29sb3I6IzJjM2U1MH0udi1tZC1wbHVnaW4tdGlwLmRhbmdlcntjb2xvcjojNGQwMDAwO2JhY2tncm91bmQtY29sb3I6I2ZmZTZlNjtib3JkZXItY29sb3I6I2MwMH0udi1tZC1wbHVnaW4tdGlwLmRhbmdlciAudi1tZC1wbHVnaW4tdGlwLXRpdGxle2NvbG9yOiM5MDB9LnYtbWQtcGx1Z2luLXRpcC5kYW5nZXIgYXtjb2xvcjojMmMzZTUwfS52LW1kLXBsdWdpbi10aXAuZGV0YWlsc3twb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO21hcmdpbjoxLjZlbSAwO3BhZGRpbmc6MS42ZW07YmFja2dyb3VuZC1jb2xvcjojZWVlO2JvcmRlci1yYWRpdXM6MnB4fS52LW1kLXBsdWdpbi10aXAuZGV0YWlscyBoNHttYXJnaW4tdG9wOjB9LnYtbWQtcGx1Z2luLXRpcC5kZXRhaWxzIGZpZ3VyZTpsYXN0LWNoaWxkLC52LW1kLXBsdWdpbi10aXAuZGV0YWlscyBwOmxhc3QtY2hpbGR7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmctYm90dG9tOjB9LnYtbWQtcGx1Z2luLXRpcC5kZXRhaWxzIHN1bW1hcnl7b3V0bGluZTpub25lO2N1cnNvcjpwb2ludGVyfVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMscUJBQXFCO0FBQ2pFOztBQUVBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxQkFBcUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/YWU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0M7O0FBRWxDLDhCQUE4Qjs7QUFFOUIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLHlDQUF5Qyw4RkFBOEYsd0JBQXdCLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxNQUFNLHdCQUF3QiwrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRXZlLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcz9mNjVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKSB7XG4gIHZhciBfaXRlbSA9IF9zbGljZWRUb0FycmF5KGl0ZW0sIDQpLFxuICAgICAgY29udGVudCA9IF9pdGVtWzFdLFxuICAgICAgY3NzTWFwcGluZyA9IF9pdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_clonedRuleSet_12_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_12_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_12_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_HackerNews_vue_vue_type_style_index_0_id_3595117c_lang_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_clonedRuleSet_12_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_12_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_12_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_HackerNews_vue_vue_type_style_index_0_id_3595117c_lang_scss__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_clonedRuleSet_12_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_12_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_12_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_HackerNews_vue_vue_type_style_index_0_id_3595117c_lang_scss__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzFdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzJdIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTEyLnVzZVszXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy92dWUvSGFja2VyTmV3cy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zNTk1MTE3YyZsYW5nPXNjc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrRztBQUNsRyxZQUFtYzs7QUFFbmM7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLDBHQUFHLENBQUMsZ1lBQU87Ozs7QUFJeEIsaUVBQWUsdVlBQWMsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdnVlL0hhY2tlck5ld3MudnVlP2MwOGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtMTIudXNlWzFdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC0xMi51c2VbMl0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTEyLnVzZVszXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL0hhY2tlck5ld3MudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MzU5NTExN2MmbGFuZz1zY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss\n");

/***/ }),

/***/ "./node_modules/@kangc/v-md-editor/lib/style/base-editor.css":
/*!*******************************************************************!*\
  !*** ./node_modules/@kangc/v-md-editor/lib/style/base-editor.css ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_base_editor_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./base-editor.css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/@kangc/v-md-editor/lib/style/base-editor.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_base_editor_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_base_editor_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGthbmdjL3YtbWQtZWRpdG9yL2xpYi9zdHlsZS9iYXNlLWVkaXRvci5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxRjtBQUNyRixZQUFnTDs7QUFFaEw7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLDZGQUFHLENBQUMsc0pBQU87Ozs7QUFJeEIsaUVBQWUsNkpBQWMsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2FuZ2Mvdi1tZC1lZGl0b3IvbGliL3N0eWxlL2Jhc2UtZWRpdG9yLmNzcz80Mzk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuLi8uLi8uLi8uLi9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsyXSEuL2Jhc2UtZWRpdG9yLmNzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kangc/v-md-editor/lib/style/base-editor.css\n");

/***/ }),

/***/ "./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css":
/*!**********************************************************************!*\
  !*** ./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_vuepress_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./vuepress.css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_vuepress_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_vuepress_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGthbmdjL3YtbWQtZWRpdG9yL2xpYi90aGVtZS9zdHlsZS92dWVwcmVzcy5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RjtBQUN4RixZQUFtTDs7QUFFbkw7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLDZGQUFHLENBQUMsbUpBQU87Ozs7QUFJeEIsaUVBQWUsMEpBQWMsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2FuZ2Mvdi1tZC1lZGl0b3IvbGliL3RoZW1lL3N0eWxlL3Z1ZXByZXNzLmNzcz8yM2RlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuLi8uLi8uLi8uLi8uLi9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsyXSEuL3Z1ZXByZXNzLmNzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kangc/v-md-editor/lib/theme/style/vuepress.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLHFFQUFxRSxxQkFBcUIsY0FBYzs7QUFFeEc7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RCxJQUFJOztBQUVKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsNkJBQTZCO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz9kYmQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports[\"default\"] = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcz8zN2RmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gcnVudGltZSBoZWxwZXIgZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBjb21wb25lbnRzXG4vLyBpbiBhIHRyZWUtc2hha2FibGUgd2F5XG5leHBvcnRzLmRlZmF1bHQgPSAoc2ZjLCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IHNmYy5fX3ZjY09wdHMgfHwgc2ZjO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBwcm9wcykge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/dist/exportHelper.js\n");

/***/ }),

/***/ "./resources/assets/js/vue/HackerNews.vue":
/*!************************************************!*\
  !*** ./resources/assets/js/vue/HackerNews.vue ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _HackerNews_vue_vue_type_template_id_3595117c__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HackerNews.vue?vue&type=template&id=3595117c */ \"./resources/assets/js/vue/HackerNews.vue?vue&type=template&id=3595117c\");\n/* harmony import */ var _HackerNews_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HackerNews.vue?vue&type=script&lang=js */ \"./resources/assets/js/vue/HackerNews.vue?vue&type=script&lang=js\");\n/* harmony import */ var _HackerNews_vue_vue_type_style_index_0_id_3595117c_lang_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss */ \"./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss\");\n/* harmony import */ var _home_sputnick_Projects_data_www_todayintel_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ \"./node_modules/vue-loader/dist/exportHelper.js\");\n\n\n\n\n;\n\n\nconst __exports__ = /*#__PURE__*/(0,_home_sputnick_Projects_data_www_todayintel_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_HackerNews_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], [['render',_HackerNews_vue_vue_type_template_id_3595117c__WEBPACK_IMPORTED_MODULE_0__.render],['__file',\"resources/assets/js/vue/HackerNews.vue\"]])\n/* hot reload */\nif (false) {}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3Z1ZS9IYWNrZXJOZXdzLnZ1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1RTtBQUNWO0FBQ0w7O0FBRXhELENBQXNFOztBQUVnRDtBQUN0SCxpQ0FBaUMsb0lBQWUsQ0FBQywrRUFBTSxhQUFhLGlGQUFNO0FBQzFFO0FBQ0EsSUFBSSxLQUFVLEVBQUUsRUFjZjs7O0FBR0QsaUVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3Z1ZS9IYWNrZXJOZXdzLnZ1ZT9kMzUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL0hhY2tlck5ld3MudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM1OTUxMTdjXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vSGFja2VyTmV3cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vSGFja2VyTmV3cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgXCIuL0hhY2tlck5ld3MudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MzU5NTExN2MmbGFuZz1zY3NzXCJcblxuaW1wb3J0IGV4cG9ydENvbXBvbmVudCBmcm9tIFwiL2hvbWUvc3B1dG5pY2svUHJvamVjdHMvZGF0YS93d3cvdG9kYXlpbnRlbC9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qc1wiXG5jb25zdCBfX2V4cG9ydHNfXyA9IC8qI19fUFVSRV9fKi9leHBvcnRDb21wb25lbnQoc2NyaXB0LCBbWydyZW5kZXInLHJlbmRlcl0sWydfX2ZpbGUnLFwicmVzb3VyY2VzL2Fzc2V0cy9qcy92dWUvSGFja2VyTmV3cy52dWVcIl1dKVxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgX19leHBvcnRzX18uX19obXJJZCA9IFwiMzU5NTExN2NcIlxuICBjb25zdCBhcGkgPSBfX1ZVRV9ITVJfUlVOVElNRV9fXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFhcGkuY3JlYXRlUmVjb3JkKCczNTk1MTE3YycsIF9fZXhwb3J0c19fKSkge1xuICAgIGNvbnNvbGUubG9nKCdyZWxvYWQnKVxuICAgIGFwaS5yZWxvYWQoJzM1OTUxMTdjJywgX19leHBvcnRzX18pXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9IYWNrZXJOZXdzLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zNTk1MTE3Y1wiLCAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ3JlLXJlbmRlcicpXG4gICAgYXBpLnJlcmVuZGVyKCczNTk1MTE3YycsIHJlbmRlcilcbiAgfSlcblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IF9fZXhwb3J0c19fIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/js/vue/HackerNews.vue\n");

/***/ }),

/***/ "./resources/assets/js/vue/HackerNews.vue?vue&type=script&lang=js":
/*!************************************************************************!*\
  !*** ./resources/assets/js/vue/HackerNews.vue?vue&type=script&lang=js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_HackerNews_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_HackerNews_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./HackerNews.vue?vue&type=script&lang=js */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=script&lang=js\");\n //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYXNzZXRzL2pzL3Z1ZS9IYWNrZXJOZXdzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxTiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvdnVlL0hhY2tlck5ld3MudnVlPzhhYjIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vSGFja2VyTmV3cy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIjsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9IYWNrZXJOZXdzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/assets/js/vue/HackerNews.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./resources/assets/js/vue/HackerNews.vue?vue&type=template&id=3595117c":
/*!******************************************************************************!*\
  !*** ./resources/assets/js/vue/HackerNews.vue?vue&type=template&id=3595117c ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_HackerNews_vue_vue_type_template_id_3595117c__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_HackerNews_vue_vue_type_template_id_3595117c__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./HackerNews.vue?vue&type=template&id=3595117c */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=template&id=3595117c");


/***/ }),

/***/ "./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss":
/*!*********************************************************************************************!*\
  !*** ./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_12_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_12_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_12_use_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_HackerNews_vue_vue_type_style_index_0_id_3595117c_lang_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/style-loader/dist/cjs.js!../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!../../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-12.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-12.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-12.use[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/assets/js/vue/HackerNews.vue?vue&type=style&index=0&id=3595117c&lang=scss");


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-bundler.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-bundler.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseTransition\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BaseTransition),\n/* harmony export */   \"Comment\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Comment),\n/* harmony export */   \"EffectScope\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EffectScope),\n/* harmony export */   \"Fragment\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   \"KeepAlive\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KeepAlive),\n/* harmony export */   \"ReactiveEffect\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ReactiveEffect),\n/* harmony export */   \"Static\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Static),\n/* harmony export */   \"Suspense\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Suspense),\n/* harmony export */   \"Teleport\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Teleport),\n/* harmony export */   \"Text\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Text),\n/* harmony export */   \"Transition\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Transition),\n/* harmony export */   \"TransitionGroup\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.TransitionGroup),\n/* harmony export */   \"VueElement\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.VueElement),\n/* harmony export */   \"assertNumber\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.assertNumber),\n/* harmony export */   \"callWithAsyncErrorHandling\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithAsyncErrorHandling),\n/* harmony export */   \"callWithErrorHandling\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling),\n/* harmony export */   \"camelize\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.camelize),\n/* harmony export */   \"capitalize\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.capitalize),\n/* harmony export */   \"cloneVNode\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.cloneVNode),\n/* harmony export */   \"compatUtils\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.compatUtils),\n/* harmony export */   \"compile\": () => (/* binding */ compileToFunction),\n/* harmony export */   \"computed\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.computed),\n/* harmony export */   \"createApp\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createApp),\n/* harmony export */   \"createBlock\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createBlock),\n/* harmony export */   \"createCommentVNode\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode),\n/* harmony export */   \"createElementBlock\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementBlock),\n/* harmony export */   \"createElementVNode\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createElementVNode),\n/* harmony export */   \"createHydrationRenderer\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createHydrationRenderer),\n/* harmony export */   \"createPropsRestProxy\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createPropsRestProxy),\n/* harmony export */   \"createRenderer\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createRenderer),\n/* harmony export */   \"createSSRApp\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSSRApp),\n/* harmony export */   \"createSlots\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createSlots),\n/* harmony export */   \"createStaticVNode\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createStaticVNode),\n/* harmony export */   \"createTextVNode\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),\n/* harmony export */   \"createVNode\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.createVNode),\n/* harmony export */   \"customRef\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.customRef),\n/* harmony export */   \"defineAsyncComponent\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent),\n/* harmony export */   \"defineComponent\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineComponent),\n/* harmony export */   \"defineCustomElement\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineCustomElement),\n/* harmony export */   \"defineEmits\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineEmits),\n/* harmony export */   \"defineExpose\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineExpose),\n/* harmony export */   \"defineProps\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineProps),\n/* harmony export */   \"defineSSRCustomElement\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.defineSSRCustomElement),\n/* harmony export */   \"devtools\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.devtools),\n/* harmony export */   \"effect\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effect),\n/* harmony export */   \"effectScope\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.effectScope),\n/* harmony export */   \"getCurrentInstance\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance),\n/* harmony export */   \"getCurrentScope\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope),\n/* harmony export */   \"getTransitionRawChildren\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.getTransitionRawChildren),\n/* harmony export */   \"guardReactiveProps\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.guardReactiveProps),\n/* harmony export */   \"h\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   \"handleError\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.handleError),\n/* harmony export */   \"hydrate\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hydrate),\n/* harmony export */   \"initCustomFormatter\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initCustomFormatter),\n/* harmony export */   \"initDirectivesForSSR\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.initDirectivesForSSR),\n/* harmony export */   \"inject\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.inject),\n/* harmony export */   \"isMemoSame\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isMemoSame),\n/* harmony export */   \"isProxy\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isProxy),\n/* harmony export */   \"isReactive\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReactive),\n/* harmony export */   \"isReadonly\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isReadonly),\n/* harmony export */   \"isRef\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRef),\n/* harmony export */   \"isRuntimeOnly\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isRuntimeOnly),\n/* harmony export */   \"isShallow\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isShallow),\n/* harmony export */   \"isVNode\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.isVNode),\n/* harmony export */   \"markRaw\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.markRaw),\n/* harmony export */   \"mergeDefaults\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults),\n/* harmony export */   \"mergeProps\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mergeProps),\n/* harmony export */   \"nextTick\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nextTick),\n/* harmony export */   \"normalizeClass\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeClass),\n/* harmony export */   \"normalizeProps\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),\n/* harmony export */   \"normalizeStyle\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle),\n/* harmony export */   \"onActivated\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onActivated),\n/* harmony export */   \"onBeforeMount\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount),\n/* harmony export */   \"onBeforeUnmount\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount),\n/* harmony export */   \"onBeforeUpdate\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate),\n/* harmony export */   \"onDeactivated\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onDeactivated),\n/* harmony export */   \"onErrorCaptured\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured),\n/* harmony export */   \"onMounted\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onMounted),\n/* harmony export */   \"onRenderTracked\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked),\n/* harmony export */   \"onRenderTriggered\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered),\n/* harmony export */   \"onScopeDispose\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose),\n/* harmony export */   \"onServerPrefetch\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch),\n/* harmony export */   \"onUnmounted\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUnmounted),\n/* harmony export */   \"onUpdated\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.onUpdated),\n/* harmony export */   \"openBlock\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.openBlock),\n/* harmony export */   \"popScopeId\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.popScopeId),\n/* harmony export */   \"provide\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.provide),\n/* harmony export */   \"proxyRefs\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.proxyRefs),\n/* harmony export */   \"pushScopeId\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pushScopeId),\n/* harmony export */   \"queuePostFlushCb\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.queuePostFlushCb),\n/* harmony export */   \"reactive\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.reactive),\n/* harmony export */   \"readonly\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.readonly),\n/* harmony export */   \"ref\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ref),\n/* harmony export */   \"registerRuntimeCompiler\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.registerRuntimeCompiler),\n/* harmony export */   \"render\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.render),\n/* harmony export */   \"renderList\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderList),\n/* harmony export */   \"renderSlot\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.renderSlot),\n/* harmony export */   \"resolveComponent\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveComponent),\n/* harmony export */   \"resolveDirective\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDirective),\n/* harmony export */   \"resolveDynamicComponent\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveDynamicComponent),\n/* harmony export */   \"resolveFilter\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveFilter),\n/* harmony export */   \"resolveTransitionHooks\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.resolveTransitionHooks),\n/* harmony export */   \"setBlockTracking\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setBlockTracking),\n/* harmony export */   \"setDevtoolsHook\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setDevtoolsHook),\n/* harmony export */   \"setTransitionHooks\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.setTransitionHooks),\n/* harmony export */   \"shallowReactive\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReactive),\n/* harmony export */   \"shallowReadonly\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly),\n/* harmony export */   \"shallowRef\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.shallowRef),\n/* harmony export */   \"ssrContextKey\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrContextKey),\n/* harmony export */   \"ssrUtils\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ssrUtils),\n/* harmony export */   \"stop\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.stop),\n/* harmony export */   \"toDisplayString\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toDisplayString),\n/* harmony export */   \"toHandlerKey\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlerKey),\n/* harmony export */   \"toHandlers\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toHandlers),\n/* harmony export */   \"toRaw\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRaw),\n/* harmony export */   \"toRef\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRef),\n/* harmony export */   \"toRefs\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.toRefs),\n/* harmony export */   \"transformVNodeArgs\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.transformVNodeArgs),\n/* harmony export */   \"triggerRef\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.triggerRef),\n/* harmony export */   \"unref\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.unref),\n/* harmony export */   \"useAttrs\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useAttrs),\n/* harmony export */   \"useCssModule\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssModule),\n/* harmony export */   \"useCssVars\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useCssVars),\n/* harmony export */   \"useSSRContext\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSSRContext),\n/* harmony export */   \"useSlots\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useSlots),\n/* harmony export */   \"useTransitionState\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.useTransitionState),\n/* harmony export */   \"vModelCheckbox\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelCheckbox),\n/* harmony export */   \"vModelDynamic\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelDynamic),\n/* harmony export */   \"vModelRadio\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelRadio),\n/* harmony export */   \"vModelSelect\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelSelect),\n/* harmony export */   \"vModelText\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vModelText),\n/* harmony export */   \"vShow\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vShow),\n/* harmony export */   \"version\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.version),\n/* harmony export */   \"warn\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.warn),\n/* harmony export */   \"watch\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watch),\n/* harmony export */   \"watchEffect\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchEffect),\n/* harmony export */   \"watchPostEffect\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect),\n/* harmony export */   \"watchSyncEffect\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect),\n/* harmony export */   \"withAsyncContext\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withAsyncContext),\n/* harmony export */   \"withCtx\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withCtx),\n/* harmony export */   \"withDefaults\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDefaults),\n/* harmony export */   \"withDirectives\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withDirectives),\n/* harmony export */   \"withKeys\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withKeys),\n/* harmony export */   \"withMemo\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withMemo),\n/* harmony export */   \"withModifiers\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withModifiers),\n/* harmony export */   \"withScopeId\": () => (/* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.withScopeId)\n/* harmony export */ });\n/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vue/runtime-dom */ \"./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js\");\n/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/runtime-dom */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n/* harmony import */ var _vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/compiler-dom */ \"./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js\");\n/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @vue/shared */ \"./node_modules/vue/node_modules/@vue/shared/dist/shared.esm-bundler.js\");\n\n\n\n\n\n\nfunction initDev() {\n    {\n        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.initCustomFormatter)();\n    }\n}\n\n// This entry is the \"full-build\" that includes both the runtime\nif ((true)) {\n    initDev();\n}\nconst compileCache = Object.create(null);\nfunction compileToFunction(template, options) {\n    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.isString)(template)) {\n        if (template.nodeType) {\n            template = template.innerHTML;\n        }\n        else {\n            ( true) && (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`invalid template option: `, template);\n            return _vue_shared__WEBPACK_IMPORTED_MODULE_2__.NOOP;\n        }\n    }\n    const key = template;\n    const cached = compileCache[key];\n    if (cached) {\n        return cached;\n    }\n    if (template[0] === '#') {\n        const el = document.querySelector(template);\n        if (( true) && !el) {\n            (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(`Template element not found or is empty: ${template}`);\n        }\n        // __UNSAFE__\n        // Reason: potential execution of JS expressions in in-DOM template.\n        // The user must make sure the in-DOM template is trusted. If it's rendered\n        // by the server, the template should not contain any user data.\n        template = el ? el.innerHTML : ``;\n    }\n    const opts = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.extend)({\n        hoistStatic: true,\n        onError: ( true) ? onError : 0,\n        onWarn: ( true) ? e => onError(e, true) : 0\n    }, options);\n    if (!opts.isCustomElement && typeof customElements !== 'undefined') {\n        opts.isCustomElement = tag => !!customElements.get(tag);\n    }\n    const { code } = (0,_vue_compiler_dom__WEBPACK_IMPORTED_MODULE_3__.compile)(template, opts);\n    function onError(err, asWarning = false) {\n        const message = asWarning\n            ? err.message\n            : `Template compilation error: ${err.message}`;\n        const codeFrame = err.loc &&\n            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_2__.generateCodeFrame)(template, err.loc.start.offset, err.loc.end.offset);\n        (0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.warn)(codeFrame ? `${message}\\n${codeFrame}` : message);\n    }\n    // The wildcard import results in a huge object with every export\n    // with keys that cannot be mangled, and can be quite heavy size-wise.\n    // In the global build we know `Vue` is available globally so we can avoid\n    // the wildcard object.\n    const render = (new Function('Vue', code)(_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__));\n    render._rc = true;\n    return (compileCache[key] = render);\n}\n(0,_vue_runtime_dom__WEBPACK_IMPORTED_MODULE_1__.registerRuntimeCompiler)(compileToFunction);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQztBQUN1QztBQUNyRDtBQUNXO0FBQzRCOztBQUV4RTtBQUNBO0FBQ0EsUUFBUSxxRUFBbUI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBcUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQyxLQUFLLHNEQUFJO0FBQzNELG1CQUFtQiw2Q0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xELFlBQVksc0RBQUksNENBQTRDLFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbURBQU07QUFDdkI7QUFDQSxrQkFBa0IsS0FBcUMsY0FBYyxDQUFTO0FBQzlFLGlCQUFpQixLQUFxQyw0QkFBNEIsQ0FBSTtBQUN0RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPLEVBQUUsMERBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQSxZQUFZLDhEQUFpQjtBQUM3QixRQUFRLHNEQUFJLGdCQUFnQixRQUFRLElBQUksVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDZDQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHlFQUF1Qjs7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzPzViMTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcnVudGltZURvbSBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGluaXRDdXN0b21Gb3JtYXR0ZXIsIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyLCB3YXJuIH0gZnJvbSAnQHZ1ZS9ydW50aW1lLWRvbSc7XG5leHBvcnQgKiBmcm9tICdAdnVlL3J1bnRpbWUtZG9tJztcbmltcG9ydCB7IGNvbXBpbGUgfSBmcm9tICdAdnVlL2NvbXBpbGVyLWRvbSc7XG5pbXBvcnQgeyBpc1N0cmluZywgTk9PUCwgZXh0ZW5kLCBnZW5lcmF0ZUNvZGVGcmFtZSB9IGZyb20gJ0B2dWUvc2hhcmVkJztcblxuZnVuY3Rpb24gaW5pdERldigpIHtcbiAgICB7XG4gICAgICAgIGluaXRDdXN0b21Gb3JtYXR0ZXIoKTtcbiAgICB9XG59XG5cbi8vIFRoaXMgZW50cnkgaXMgdGhlIFwiZnVsbC1idWlsZFwiIHRoYXQgaW5jbHVkZXMgYm90aCB0aGUgcnVudGltZVxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xuICAgIGluaXREZXYoKTtcbn1cbmNvbnN0IGNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbih0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgIGlmICghaXNTdHJpbmcodGVtcGxhdGUpKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybihgaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246IGAsIHRlbXBsYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBOT09QO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHRlbXBsYXRlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNvbXBpbGVDYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlWzBdID09PSAnIycpIHtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRlbXBsYXRlKTtcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZWwpIHtcbiAgICAgICAgICAgIHdhcm4oYFRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiAke3RlbXBsYXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIF9fVU5TQUZFX19cbiAgICAgICAgLy8gUmVhc29uOiBwb3RlbnRpYWwgZXhlY3V0aW9uIG9mIEpTIGV4cHJlc3Npb25zIGluIGluLURPTSB0ZW1wbGF0ZS5cbiAgICAgICAgLy8gVGhlIHVzZXIgbXVzdCBtYWtlIHN1cmUgdGhlIGluLURPTSB0ZW1wbGF0ZSBpcyB0cnVzdGVkLiBJZiBpdCdzIHJlbmRlcmVkXG4gICAgICAgIC8vIGJ5IHRoZSBzZXJ2ZXIsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgbm90IGNvbnRhaW4gYW55IHVzZXIgZGF0YS5cbiAgICAgICAgdGVtcGxhdGUgPSBlbCA/IGVsLmlubmVySFRNTCA6IGBgO1xuICAgIH1cbiAgICBjb25zdCBvcHRzID0gZXh0ZW5kKHtcbiAgICAgICAgaG9pc3RTdGF0aWM6IHRydWUsXG4gICAgICAgIG9uRXJyb3I6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IG9uRXJyb3IgOiB1bmRlZmluZWQsXG4gICAgICAgIG9uV2FybjogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gZSA9PiBvbkVycm9yKGUsIHRydWUpIDogTk9PUFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGlmICghb3B0cy5pc0N1c3RvbUVsZW1lbnQgJiYgdHlwZW9mIGN1c3RvbUVsZW1lbnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRzLmlzQ3VzdG9tRWxlbWVudCA9IHRhZyA9PiAhIWN1c3RvbUVsZW1lbnRzLmdldCh0YWcpO1xuICAgIH1cbiAgICBjb25zdCB7IGNvZGUgfSA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdHMpO1xuICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyLCBhc1dhcm5pbmcgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYXNXYXJuaW5nXG4gICAgICAgICAgICA/IGVyci5tZXNzYWdlXG4gICAgICAgICAgICA6IGBUZW1wbGF0ZSBjb21waWxhdGlvbiBlcnJvcjogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICBjb25zdCBjb2RlRnJhbWUgPSBlcnIubG9jICYmXG4gICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZXJyLmxvYy5zdGFydC5vZmZzZXQsIGVyci5sb2MuZW5kLm9mZnNldCk7XG4gICAgICAgIHdhcm4oY29kZUZyYW1lID8gYCR7bWVzc2FnZX1cXG4ke2NvZGVGcmFtZX1gIDogbWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIFRoZSB3aWxkY2FyZCBpbXBvcnQgcmVzdWx0cyBpbiBhIGh1Z2Ugb2JqZWN0IHdpdGggZXZlcnkgZXhwb3J0XG4gICAgLy8gd2l0aCBrZXlzIHRoYXQgY2Fubm90IGJlIG1hbmdsZWQsIGFuZCBjYW4gYmUgcXVpdGUgaGVhdnkgc2l6ZS13aXNlLlxuICAgIC8vIEluIHRoZSBnbG9iYWwgYnVpbGQgd2Uga25vdyBgVnVlYCBpcyBhdmFpbGFibGUgZ2xvYmFsbHkgc28gd2UgY2FuIGF2b2lkXG4gICAgLy8gdGhlIHdpbGRjYXJkIG9iamVjdC5cbiAgICBjb25zdCByZW5kZXIgPSAobmV3IEZ1bmN0aW9uKCdWdWUnLCBjb2RlKShydW50aW1lRG9tKSk7XG4gICAgcmVuZGVyLl9yYyA9IHRydWU7XG4gICAgcmV0dXJuIChjb21waWxlQ2FjaGVba2V5XSA9IHJlbmRlcik7XG59XG5yZWdpc3RlclJ1bnRpbWVDb21waWxlcihjb21waWxlVG9GdW5jdGlvbik7XG5cbmV4cG9ydCB7IGNvbXBpbGVUb0Z1bmN0aW9uIGFzIGNvbXBpbGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.esm-bundler.js\n");

/***/ }),

/***/ "./node_modules/vue/node_modules/@vue/shared/dist/shared.esm-bundler.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vue/node_modules/@vue/shared/dist/shared.esm-bundler.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EMPTY_ARR\": () => (/* binding */ EMPTY_ARR),\n/* harmony export */   \"EMPTY_OBJ\": () => (/* binding */ EMPTY_OBJ),\n/* harmony export */   \"NO\": () => (/* binding */ NO),\n/* harmony export */   \"NOOP\": () => (/* binding */ NOOP),\n/* harmony export */   \"PatchFlagNames\": () => (/* binding */ PatchFlagNames),\n/* harmony export */   \"camelize\": () => (/* binding */ camelize),\n/* harmony export */   \"capitalize\": () => (/* binding */ capitalize),\n/* harmony export */   \"def\": () => (/* binding */ def),\n/* harmony export */   \"escapeHtml\": () => (/* binding */ escapeHtml),\n/* harmony export */   \"escapeHtmlComment\": () => (/* binding */ escapeHtmlComment),\n/* harmony export */   \"extend\": () => (/* binding */ extend),\n/* harmony export */   \"genPropsAccessExp\": () => (/* binding */ genPropsAccessExp),\n/* harmony export */   \"generateCodeFrame\": () => (/* binding */ generateCodeFrame),\n/* harmony export */   \"getGlobalThis\": () => (/* binding */ getGlobalThis),\n/* harmony export */   \"hasChanged\": () => (/* binding */ hasChanged),\n/* harmony export */   \"hasOwn\": () => (/* binding */ hasOwn),\n/* harmony export */   \"hyphenate\": () => (/* binding */ hyphenate),\n/* harmony export */   \"includeBooleanAttr\": () => (/* binding */ includeBooleanAttr),\n/* harmony export */   \"invokeArrayFns\": () => (/* binding */ invokeArrayFns),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"isBooleanAttr\": () => (/* binding */ isBooleanAttr),\n/* harmony export */   \"isBuiltInDirective\": () => (/* binding */ isBuiltInDirective),\n/* harmony export */   \"isDate\": () => (/* binding */ isDate),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isGloballyWhitelisted\": () => (/* binding */ isGloballyWhitelisted),\n/* harmony export */   \"isHTMLTag\": () => (/* binding */ isHTMLTag),\n/* harmony export */   \"isIntegerKey\": () => (/* binding */ isIntegerKey),\n/* harmony export */   \"isKnownHtmlAttr\": () => (/* binding */ isKnownHtmlAttr),\n/* harmony export */   \"isKnownSvgAttr\": () => (/* binding */ isKnownSvgAttr),\n/* harmony export */   \"isMap\": () => (/* binding */ isMap),\n/* harmony export */   \"isModelListener\": () => (/* binding */ isModelListener),\n/* harmony export */   \"isObject\": () => (/* binding */ isObject),\n/* harmony export */   \"isOn\": () => (/* binding */ isOn),\n/* harmony export */   \"isPlainObject\": () => (/* binding */ isPlainObject),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"isRegExp\": () => (/* binding */ isRegExp),\n/* harmony export */   \"isReservedProp\": () => (/* binding */ isReservedProp),\n/* harmony export */   \"isSSRSafeAttrName\": () => (/* binding */ isSSRSafeAttrName),\n/* harmony export */   \"isSVGTag\": () => (/* binding */ isSVGTag),\n/* harmony export */   \"isSet\": () => (/* binding */ isSet),\n/* harmony export */   \"isSpecialBooleanAttr\": () => (/* binding */ isSpecialBooleanAttr),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"isSymbol\": () => (/* binding */ isSymbol),\n/* harmony export */   \"isVoidTag\": () => (/* binding */ isVoidTag),\n/* harmony export */   \"looseEqual\": () => (/* binding */ looseEqual),\n/* harmony export */   \"looseIndexOf\": () => (/* binding */ looseIndexOf),\n/* harmony export */   \"looseToNumber\": () => (/* binding */ looseToNumber),\n/* harmony export */   \"makeMap\": () => (/* binding */ makeMap),\n/* harmony export */   \"normalizeClass\": () => (/* binding */ normalizeClass),\n/* harmony export */   \"normalizeProps\": () => (/* binding */ normalizeProps),\n/* harmony export */   \"normalizeStyle\": () => (/* binding */ normalizeStyle),\n/* harmony export */   \"objectToString\": () => (/* binding */ objectToString),\n/* harmony export */   \"parseStringStyle\": () => (/* binding */ parseStringStyle),\n/* harmony export */   \"propsToAttrMap\": () => (/* binding */ propsToAttrMap),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"slotFlagsText\": () => (/* binding */ slotFlagsText),\n/* harmony export */   \"stringifyStyle\": () => (/* binding */ stringifyStyle),\n/* harmony export */   \"toDisplayString\": () => (/* binding */ toDisplayString),\n/* harmony export */   \"toHandlerKey\": () => (/* binding */ toHandlerKey),\n/* harmony export */   \"toNumber\": () => (/* binding */ toNumber),\n/* harmony export */   \"toRawType\": () => (/* binding */ toRawType),\n/* harmony export */   \"toTypeString\": () => (/* binding */ toTypeString)\n/* harmony export */ });\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    // Split the content into individual lines but capture the newline sequence\n    // that separated each line. This is important because the actual sequence is\n    // needed to properly take into account the full line length for offset\n    // comparison\n    let lines = source.split(/(\\r?\\n)/);\n    // Separate the lines and newline sequences into separate arrays for easier referencing\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n    lines = lines.filter((_, idx) => idx % 2 === 0);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count +=\n            lines[i].length +\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - (lineLength + newLineSeqLength));\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + newLineSeqLength;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\nfunction normalizeStyle(value) {\n    if (isArray(value)) {\n        const res = {};\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            const normalized = isString(item)\n                ? parseStringStyle(item)\n                : normalizeStyle(item);\n            if (normalized) {\n                for (const key in normalized) {\n                    res[key] = normalized[key];\n                }\n            }\n        }\n        return res;\n    }\n    else if (isString(value)) {\n        return value;\n    }\n    else if (isObject(value)) {\n        return value;\n    }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n    const ret = {};\n    cssText\n        .replace(styleCommentRE, '')\n        .split(listDelimiterRE)\n        .forEach(item => {\n        if (item) {\n            const tmp = item.split(propertyDelimiterRE);\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return ret;\n}\nfunction stringifyStyle(styles) {\n    let ret = '';\n    if (!styles || isString(styles)) {\n        return ret;\n    }\n    for (const key in styles) {\n        const value = styles[key];\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n        if (isString(value) || typeof value === 'number') {\n            // only render valid values\n            ret += `${normalizedKey}:${value};`;\n        }\n    }\n    return ret;\n}\nfunction normalizeClass(value) {\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value)) {\n        for (const name in value) {\n            if (value[name]) {\n                res += name + ' ';\n            }\n        }\n    }\n    return res.trim();\n}\nfunction normalizeProps(props) {\n    if (!props)\n        return null;\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n        props.class = normalizeClass(klass);\n    }\n    if (style) {\n        props.style = normalizeStyle(style);\n    }\n    return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n    'option,output,progress,select,textarea,details,dialog,menu,' +\n    'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n    'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n    return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n        return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n        console.error(`unsafe attribute name: ${name}`);\n    }\n    return (attrValidationCache[name] = !isUnsafe);\n}\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`);\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n    const str = '' + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n        return str;\n    }\n    let html = '';\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34: // \"\n                escaped = '&quot;';\n                break;\n            case 38: // &\n                escaped = '&amp;';\n                break;\n            case 39: // '\n                escaped = '&#39;';\n                break;\n            case 60: // <\n                escaped = '&lt;';\n                break;\n            case 62: // >\n                escaped = '&gt;';\n                break;\n            default:\n                continue;\n        }\n        if (lastIndex !== index) {\n            html += str.slice(lastIndex, index);\n        }\n        lastIndex = index + 1;\n        html += escaped;\n    }\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n    return src.replace(commentStripRE, '');\n}\n\nfunction looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n        equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n}\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isSymbol(a);\n    bValidType = isSymbol(b);\n    if (aValidType || bValidType) {\n        return a === b;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n        /* istanbul ignore if: this if will probably never be called */\n        if (!aValidType || !bValidType) {\n            return false;\n        }\n        const aKeysCount = Object.keys(a).length;\n        const bKeysCount = Object.keys(b).length;\n        if (aKeysCount !== bKeysCount) {\n            return false;\n        }\n        for (const key in a) {\n            const aHasKey = a.hasOwnProperty(key);\n            const bHasKey = b.hasOwnProperty(key);\n            if ((aHasKey && !bHasKey) ||\n                (!aHasKey && bHasKey) ||\n                !looseEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n    }\n    return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n    return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = (val) => {\n    return isString(val)\n        ? val\n        : val == null\n            ? ''\n            : isArray(val) ||\n                (isObject(val) &&\n                    (val.toString === objectToString || !isFunction(val.toString)))\n                ? JSON.stringify(val, replacer, 2)\n                : String(val);\n};\nconst replacer = (_key, val) => {\n    // can't use isRef here since @vue/shared has no deps\n    if (val && val.__v_isRef) {\n        return replacer(_key, val.value);\n    }\n    else if (isMap(val)) {\n        return {\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                entries[`${key} =>`] = val;\n                return entries;\n            }, {})\n        };\n    }\n    else if (isSet(val)) {\n        return {\n            [`Set(${val.size})`]: [...val.values()]\n        };\n    }\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n        return String(val);\n    }\n    return val;\n};\n\nconst EMPTY_OBJ = ( true)\n    ? Object.freeze({})\n    : 0;\nconst EMPTY_ARR = ( true) ? Object.freeze([]) : 0;\nconst NOOP = () => { };\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === '[object Map]';\nconst isSet = (val) => toTypeString(val) === '[object Set]';\nconst isDate = (val) => toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\nconst isFunction = (val) => typeof val === 'function';\nconst isString = (val) => typeof val === 'string';\nconst isSymbol = (val) => typeof val === 'symbol';\nconst isObject = (val) => val !== null && typeof val === 'object';\nconst isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\nconst isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\nconst def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = (val) => {\n    const n = isString(val) ? Number(val) : NaN;\n    return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof __webpack_require__.g !== 'undefined'\n                            ? __webpack_require__.g\n                            : {}));\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n    return identRE.test(name)\n        ? `__props.${name}`\n        : `__props[${JSON.stringify(name)}]`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlL25vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0JBQStCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLEVBQUUsaURBQWlELEtBQUssU0FBUztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDMUM7O0FBRXV6QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvbm9kZV9tb2R1bGVzL0B2dWUvc2hhcmVkL2Rpc3Qvc2hhcmVkLmVzbS1idW5kbGVyLmpzPzkyYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICogSU1QT1JUQU5UOiBhbGwgY2FsbHMgb2YgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHByZWZpeGVkIHdpdGhcbiAqIFxcL1xcKiNcXF9cXF9QVVJFXFxfXFxfXFwqXFwvXG4gKiBTbyB0aGF0IHJvbGx1cCBjYW4gdHJlZS1zaGFrZSB0aGVtIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2UgPyB2YWwgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogdmFsID0+ICEhbWFwW3ZhbF07XG59XG5cbi8qKlxuICogZGV2IG9ubHkgZmxhZyAtPiBuYW1lIG1hcHBpbmdcbiAqL1xuY29uc3QgUGF0Y2hGbGFnTmFtZXMgPSB7XG4gICAgWzEgLyogUGF0Y2hGbGFncy5URVhUICovXTogYFRFWFRgLFxuICAgIFsyIC8qIFBhdGNoRmxhZ3MuQ0xBU1MgKi9dOiBgQ0xBU1NgLFxuICAgIFs0IC8qIFBhdGNoRmxhZ3MuU1RZTEUgKi9dOiBgU1RZTEVgLFxuICAgIFs4IC8qIFBhdGNoRmxhZ3MuUFJPUFMgKi9dOiBgUFJPUFNgLFxuICAgIFsxNiAvKiBQYXRjaEZsYWdzLkZVTExfUFJPUFMgKi9dOiBgRlVMTF9QUk9QU2AsXG4gICAgWzMyIC8qIFBhdGNoRmxhZ3MuSFlEUkFURV9FVkVOVFMgKi9dOiBgSFlEUkFURV9FVkVOVFNgLFxuICAgIFs2NCAvKiBQYXRjaEZsYWdzLlNUQUJMRV9GUkFHTUVOVCAqL106IGBTVEFCTEVfRlJBR01FTlRgLFxuICAgIFsxMjggLyogUGF0Y2hGbGFncy5LRVlFRF9GUkFHTUVOVCAqL106IGBLRVlFRF9GUkFHTUVOVGAsXG4gICAgWzI1NiAvKiBQYXRjaEZsYWdzLlVOS0VZRURfRlJBR01FTlQgKi9dOiBgVU5LRVlFRF9GUkFHTUVOVGAsXG4gICAgWzUxMiAvKiBQYXRjaEZsYWdzLk5FRURfUEFUQ0ggKi9dOiBgTkVFRF9QQVRDSGAsXG4gICAgWzEwMjQgLyogUGF0Y2hGbGFncy5EWU5BTUlDX1NMT1RTICovXTogYERZTkFNSUNfU0xPVFNgLFxuICAgIFsyMDQ4IC8qIFBhdGNoRmxhZ3MuREVWX1JPT1RfRlJBR01FTlQgKi9dOiBgREVWX1JPT1RfRlJBR01FTlRgLFxuICAgIFstMSAvKiBQYXRjaEZsYWdzLkhPSVNURUQgKi9dOiBgSE9JU1RFRGAsXG4gICAgWy0yIC8qIFBhdGNoRmxhZ3MuQkFJTCAqL106IGBCQUlMYFxufTtcblxuLyoqXG4gKiBEZXYgb25seVxuICovXG5jb25zdCBzbG90RmxhZ3NUZXh0ID0ge1xuICAgIFsxIC8qIFNsb3RGbGFncy5TVEFCTEUgKi9dOiAnU1RBQkxFJyxcbiAgICBbMiAvKiBTbG90RmxhZ3MuRFlOQU1JQyAqL106ICdEWU5BTUlDJyxcbiAgICBbMyAvKiBTbG90RmxhZ3MuRk9SV0FSREVEICovXTogJ0ZPUldBUkRFRCdcbn07XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksJyArXG4gICAgJ2RlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LE1hdGgsTnVtYmVyLERhdGUsQXJyYXksJyArXG4gICAgJ09iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50JztcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgLy8gU3BsaXQgdGhlIGNvbnRlbnQgaW50byBpbmRpdmlkdWFsIGxpbmVzIGJ1dCBjYXB0dXJlIHRoZSBuZXdsaW5lIHNlcXVlbmNlXG4gICAgLy8gdGhhdCBzZXBhcmF0ZWQgZWFjaCBsaW5lLiBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBhY3R1YWwgc2VxdWVuY2UgaXNcbiAgICAvLyBuZWVkZWQgdG8gcHJvcGVybHkgdGFrZSBpbnRvIGFjY291bnQgdGhlIGZ1bGwgbGluZSBsZW5ndGggZm9yIG9mZnNldFxuICAgIC8vIGNvbXBhcmlzb25cbiAgICBsZXQgbGluZXMgPSBzb3VyY2Uuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICAgIC8vIFNlcGFyYXRlIHRoZSBsaW5lcyBhbmQgbmV3bGluZSBzZXF1ZW5jZXMgaW50byBzZXBhcmF0ZSBhcnJheXMgZm9yIGVhc2llciByZWZlcmVuY2luZ1xuICAgIGNvbnN0IG5ld2xpbmVTZXF1ZW5jZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMSk7XG4gICAgbGluZXMgPSBsaW5lcy5maWx0ZXIoKF8sIGlkeCkgPT4gaWR4ICUgMiA9PT0gMCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvdW50ICs9XG4gICAgICAgICAgICBsaW5lc1tpXS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICgobmV3bGluZVNlcXVlbmNlc1tpXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2ldLmxlbmd0aCkgfHwgMCk7XG4gICAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGogKyAxO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAke2xpbmV9JHsnICcucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcobGluZSkubGVuZ3RoLCAwKSl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpbmVTZXFMZW5ndGggPSAobmV3bGluZVNlcXVlbmNlc1tqXSAmJiBuZXdsaW5lU2VxdWVuY2VzW2pdLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBzdGFydCAtIChjb3VudCAtIChsaW5lTGVuZ3RoICsgbmV3TGluZVNlcUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heCgxLCBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgJyAnLnJlcGVhdChwYWQpICsgJ14nLnJlcGVhdChsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyAnXicucmVwZWF0KGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyBuZXdMaW5lU2VxTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlKHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSlcbiAgICAgICAgICAgICAgICA/IHBhcnNlU3RyaW5nU3R5bGUoaXRlbSlcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVN0eWxlKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplZFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XG5jb25zdCBwcm9wZXJ0eURlbGltaXRlclJFID0gLzooW15dKykvO1xuY29uc3Qgc3R5bGVDb21tZW50UkUgPSAvXFwvXFwqLio/XFwqXFwvL2dzO1xuZnVuY3Rpb24gcGFyc2VTdHJpbmdTdHlsZShjc3NUZXh0KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgY3NzVGV4dFxuICAgICAgICAucmVwbGFjZShzdHlsZUNvbW1lbnRSRSwgJycpXG4gICAgICAgIC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpXG4gICAgICAgIC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcbiAgICAgICAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXRbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHlsZShzdHlsZXMpIHtcbiAgICBsZXQgcmV0ID0gJyc7XG4gICAgaWYgKCFzdHlsZXMgfHwgaXNTdHJpbmcoc3R5bGVzKSkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZXNba2V5XTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGtleS5zdGFydHNXaXRoKGAtLWApID8ga2V5IDogaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gb25seSByZW5kZXIgdmFsaWQgdmFsdWVzXG4gICAgICAgICAgICByZXQgKz0gYCR7bm9ybWFsaXplZEtleX06JHt2YWx1ZX07YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3ModmFsdWUpIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZUNsYXNzKHZhbHVlW2ldKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IG5vcm1hbGl6ZWQgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IG5hbWUgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy50cmltKCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhwcm9wcykge1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xuICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XG4gICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xuICAgIH1cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgcHJvcHMuc3R5bGUgPSBub3JtYWxpemVTdHlsZShzdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cblxuLy8gVGhlc2UgdGFnIGNvbmZpZ3MgYXJlIHNoYXJlZCBiZXR3ZWVuIGNvbXBpbGVyLWRvbSBhbmQgcnVudGltZS1kb20sIHNvIHRoZXlcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudFxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXG4gICAgJ2hlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sJyArXG4gICAgJ2ZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLCcgK1xuICAgICdkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCwnICtcbiAgICAndGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSwnICtcbiAgICAnY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLCcgK1xuICAgICd0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsJyArXG4gICAgJ29wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsJyArXG4gICAgJ3N1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnRcbmNvbnN0IFNWR19UQUdTID0gJ3N2ZyxhbmltYXRlLGFuaW1hdGVNb3Rpb24sYW5pbWF0ZVRyYW5zZm9ybSxjaXJjbGUsY2xpcFBhdGgsY29sb3ItcHJvZmlsZSwnICtcbiAgICAnZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlciwnICtcbiAgICAnZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCwnICtcbiAgICAnZmVEaXN0YW50TGlnaHQsZmVEcm9wU2hhZG93LGZlRmxvb2QsZmVGdW5jQSxmZUZ1bmNCLGZlRnVuY0csZmVGdW5jUiwnICtcbiAgICAnZmVHYXVzc2lhbkJsdXIsZmVJbWFnZSxmZU1lcmdlLGZlTWVyZ2VOb2RlLGZlTW9ycGhvbG9neSxmZU9mZnNldCwnICtcbiAgICAnZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlciwnICtcbiAgICAnZm9yZWlnbk9iamVjdCxnLGhhdGNoLGhhdGNocGF0aCxpbWFnZSxsaW5lLGxpbmVhckdyYWRpZW50LG1hcmtlcixtYXNrLCcgK1xuICAgICdtZXNoLG1lc2hncmFkaWVudCxtZXNocGF0Y2gsbWVzaHJvdyxtZXRhZGF0YSxtcGF0aCxwYXRoLHBhdHRlcm4sJyArXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsJyArXG4gICAgJ3RleHQsdGV4dFBhdGgsdGl0bGUsdHNwYW4sdW5rbm93bix1c2Usdmlldyc7XG5jb25zdCBWT0lEX1RBR1MgPSAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInO1xuLyoqXG4gKiBDb21waWxlciBvbmx5LlxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxuICovXG5jb25zdCBpc0hUTUxUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoSFRNTF9UQUdTKTtcbi8qKlxuICogQ29tcGlsZXIgb25seS5cbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cbiAqL1xuY29uc3QgaXNTVkdUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuLyoqXG4gKiBDb21waWxlciBvbmx5LlxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxuICovXG5jb25zdCBpc1ZvaWRUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoVk9JRF9UQUdTKTtcblxuLyoqXG4gKiBPbiB0aGUgY2xpZW50IHdlIG9ubHkgbmVlZCB0byBvZmZlciBzcGVjaWFsIGNhc2VzIGZvciBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdFxuICogaGF2ZSBkaWZmZXJlbnQgbmFtZXMgZnJvbSB0aGVpciBjb3JyZXNwb25kaW5nIGRvbSBwcm9wZXJ0aWVzOlxuICogLSBpdGVtc2NvcGUgLT4gTi9BXG4gKiAtIGFsbG93ZnVsbHNjcmVlbiAtPiBhbGxvd0Z1bGxzY3JlZW5cbiAqIC0gZm9ybW5vdmFsaWRhdGUgLT4gZm9ybU5vVmFsaWRhdGVcbiAqIC0gaXNtYXAgLT4gaXNNYXBcbiAqIC0gbm9tb2R1bGUgLT4gbm9Nb2R1bGVcbiAqIC0gbm92YWxpZGF0ZSAtPiBub1ZhbGlkYXRlXG4gKiAtIHJlYWRvbmx5IC0+IHJlYWRPbmx5XG4gKi9cbmNvbnN0IHNwZWNpYWxCb29sZWFuQXR0cnMgPSBgaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5YDtcbmNvbnN0IGlzU3BlY2lhbEJvb2xlYW5BdHRyID0gLyojX19QVVJFX18qLyBtYWtlTWFwKHNwZWNpYWxCb29sZWFuQXR0cnMpO1xuLyoqXG4gKiBUaGUgZnVsbCBsaXN0IGlzIG5lZWRlZCBkdXJpbmcgU1NSIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgaW5pdGlhbCBtYXJrdXAuXG4gKi9cbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoc3BlY2lhbEJvb2xlYW5BdHRycyArXG4gICAgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4sYCArXG4gICAgYGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsYCArXG4gICAgYGNoZWNrZWQsbXV0ZWQsbXVsdGlwbGUsc2VsZWN0ZWRgKTtcbi8qKlxuICogQm9vbGVhbiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IG9yICcnLlxuICogZS5nLiBgPHNlbGVjdCBtdWx0aXBsZT5gIGNvbXBpbGVzIHRvIGB7IG11bHRpcGxlOiAnJyB9YFxuICovXG5mdW5jdGlvbiBpbmNsdWRlQm9vbGVhbkF0dHIodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gJyc7XG59XG5jb25zdCB1bnNhZmVBdHRyQ2hhclJFID0gL1s+Lz1cIidcXHUwMDA5XFx1MDAwYVxcdTAwMGNcXHUwMDIwXS87XG5jb25zdCBhdHRyVmFsaWRhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBpc1NTUlNhZmVBdHRyTmFtZShuYW1lKSB7XG4gICAgaWYgKGF0dHJWYWxpZGF0aW9uQ2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJWYWxpZGF0aW9uQ2FjaGVbbmFtZV07XG4gICAgfVxuICAgIGNvbnN0IGlzVW5zYWZlID0gdW5zYWZlQXR0ckNoYXJSRS50ZXN0KG5hbWUpO1xuICAgIGlmIChpc1Vuc2FmZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGB1bnNhZmUgYXR0cmlidXRlIG5hbWU6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIChhdHRyVmFsaWRhdGlvbkNhY2hlW25hbWVdID0gIWlzVW5zYWZlKTtcbn1cbmNvbnN0IHByb3BzVG9BdHRyTWFwID0ge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG59O1xuLyoqXG4gKiBLbm93biBhdHRyaWJ1dGVzLCB0aGlzIGlzIHVzZWQgZm9yIHN0cmluZ2lmaWNhdGlvbiBvZiBydW50aW1lIHN0YXRpYyBub2Rlc1xuICogc28gdGhhdCB3ZSBkb24ndCBzdHJpbmdpZnkgYmluZGluZ3MgdGhhdCBjYW5ub3QgYmUgc2V0IGZyb20gSFRNTC5cbiAqIERvbid0IGFsc28gZm9yZ2V0IHRvIGFsbG93IGBkYXRhLSpgIGFuZCBgYXJpYS0qYCFcbiAqIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlc1xuICovXG5jb25zdCBpc0tub3duSHRtbEF0dHIgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoYGFjY2VwdCxhY2NlcHQtY2hhcnNldCxhY2Nlc3NrZXksYWN0aW9uLGFsaWduLGFsbG93LGFsdCxhc3luYyxgICtcbiAgICBgYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYCArXG4gICAgYGJvcmRlcixidWZmZXJlZCxjYXB0dXJlLGNoYWxsZW5nZSxjaGFyc2V0LGNoZWNrZWQsY2l0ZSxjbGFzcyxjb2RlLGAgK1xuICAgIGBjb2RlYmFzZSxjb2xvcixjb2xzLGNvbHNwYW4sY29udGVudCxjb250ZW50ZWRpdGFibGUsY29udGV4dG1lbnUsY29udHJvbHMsYCArXG4gICAgYGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGAgK1xuICAgIGBkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxlbnRlcmtleWhpbnQsZm9yLGZvcm0sYCArXG4gICAgYGZvcm1hY3Rpb24sZm9ybWVuY3R5cGUsZm9ybW1ldGhvZCxmb3Jtbm92YWxpZGF0ZSxmb3JtdGFyZ2V0LGhlYWRlcnMsYCArXG4gICAgYGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGludGVncml0eSxgICtcbiAgICBgaXNtYXAsaXRlbXByb3Asa2V5dHlwZSxraW5kLGxhYmVsLGxhbmcsbGFuZ3VhZ2UsbG9hZGluZyxsaXN0LGxvb3AsbG93LGAgK1xuICAgIGBtYW5pZmVzdCxtYXgsbWF4bGVuZ3RoLG1pbmxlbmd0aCxtZWRpYSxtaW4sbXVsdGlwbGUsbXV0ZWQsbmFtZSxub3ZhbGlkYXRlLGAgK1xuICAgIGBvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHksYCArXG4gICAgYHJlZmVycmVycG9saWN5LHJlbCxyZXF1aXJlZCxyZXZlcnNlZCxyb3dzLHJvd3NwYW4sc2FuZGJveCxzY29wZSxzY29wZWQsYCArXG4gICAgYHNlbGVjdGVkLHNoYXBlLHNpemUsc2l6ZXMsc2xvdCxzcGFuLHNwZWxsY2hlY2ssc3JjLHNyY2RvYyxzcmNsYW5nLHNyY3NldCxgICtcbiAgICBgc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsYCArXG4gICAgYHZhbHVlLHdpZHRoLHdyYXBgKTtcbi8qKlxuICogR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZVxuICovXG5jb25zdCBpc0tub3duU3ZnQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChgeG1sbnMsYWNjZW50LWhlaWdodCxhY2N1bXVsYXRlLGFkZGl0aXZlLGFsaWdubWVudC1iYXNlbGluZSxhbHBoYWJldGljLGFtcGxpdHVkZSxgICtcbiAgICBgYXJhYmljLWZvcm0sYXNjZW50LGF0dHJpYnV0ZU5hbWUsYXR0cmlidXRlVHlwZSxhemltdXRoLGJhc2VGcmVxdWVuY3ksYCArXG4gICAgYGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGAgK1xuICAgIGBjbGlwLGNsaXBQYXRoVW5pdHMsY2xpcC1wYXRoLGNsaXAtcnVsZSxjb2xvcixjb2xvci1pbnRlcnBvbGF0aW9uLGAgK1xuICAgIGBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsY29sb3ItcHJvZmlsZSxjb2xvci1yZW5kZXJpbmcsYCArXG4gICAgYGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxgICtcbiAgICBgZGVzY2VudCxkaWZmdXNlQ29uc3RhbnQsZGlyZWN0aW9uLGRpc3BsYXksZGl2aXNvcixkb21pbmFudC1iYXNlbGluZSxkdXIsZHgsYCArXG4gICAgYGR5LGVkZ2VNb2RlLGVsZXZhdGlvbixlbmFibGUtYmFja2dyb3VuZCxlbmQsZXhwb25lbnQsZmlsbCxmaWxsLW9wYWNpdHksYCArXG4gICAgYGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksYCArXG4gICAgYGZvbnQtZmFtaWx5LGZvbnQtc2l6ZSxmb250LXNpemUtYWRqdXN0LGZvbnQtc3RyZXRjaCxmb250LXN0eWxlLGAgK1xuICAgIGBmb250LXZhcmlhbnQsZm9udC13ZWlnaHQsZm9ybWF0LGZyb20sZnIsZngsZnksZzEsZzIsZ2x5cGgtbmFtZSxgICtcbiAgICBgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixgICtcbiAgICBgZ3JhZGllbnRUcmFuc2Zvcm0sZ3JhZGllbnRVbml0cyxoYW5naW5nLGhlaWdodCxocmVmLGhyZWZsYW5nLGhvcml6LWFkdi14LGAgK1xuICAgIGBob3Jpei1vcmlnaW4teCxpZCxpZGVvZ3JhcGhpYyxpbWFnZS1yZW5kZXJpbmcsaW4saW4yLGludGVyY2VwdCxrLGsxLGsyLGszLGAgK1xuICAgIGBrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGAgK1xuICAgIGBsYW5nLGxlbmd0aEFkanVzdCxsZXR0ZXItc3BhY2luZyxsaWdodGluZy1jb2xvcixsaW1pdGluZ0NvbmVBbmdsZSxsb2NhbCxgICtcbiAgICBgbWFya2VyLWVuZCxtYXJrZXItbWlkLG1hcmtlci1zdGFydCxtYXJrZXJIZWlnaHQsbWFya2VyVW5pdHMsbWFya2VyV2lkdGgsYCArXG4gICAgYG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsYCArXG4gICAgYG5hbWUsbnVtT2N0YXZlcyxvZmZzZXQsb3BhY2l0eSxvcGVyYXRvcixvcmRlcixvcmllbnQsb3JpZW50YXRpb24sb3JpZ2luLGAgK1xuICAgIGBvdmVyZmxvdyxvdmVybGluZS1wb3NpdGlvbixvdmVybGluZS10aGlja25lc3MscGFub3NlLTEscGFpbnQtb3JkZXIscGF0aCxgICtcbiAgICBgcGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcsYCArXG4gICAgYHBvaW50ZXItZXZlbnRzLHBvaW50cyxwb2ludHNBdFgscG9pbnRzQXRZLHBvaW50c0F0WixwcmVzZXJ2ZUFscGhhLGAgK1xuICAgIGBwcmVzZXJ2ZUFzcGVjdFJhdGlvLHByaW1pdGl2ZVVuaXRzLHIscmFkaXVzLHJlZmVycmVyUG9saWN5LHJlZlgscmVmWSxyZWwsYCArXG4gICAgYHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLGAgK1xuICAgIGByZXN0YXJ0LHJlc3VsdCxyb3RhdGUscngscnksc2NhbGUsc2VlZCxzaGFwZS1yZW5kZXJpbmcsc2xvcGUsc3BhY2luZyxgICtcbiAgICBgc3BlY3VsYXJDb25zdGFudCxzcGVjdWxhckV4cG9uZW50LHNwZWVkLHNwcmVhZE1ldGhvZCxzdGFydE9mZnNldCxgICtcbiAgICBgc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LGAgK1xuICAgIGBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uLHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzLHN0cmluZyxzdHJva2UsYCArXG4gICAgYHN0cm9rZS1kYXNoYXJyYXksc3Ryb2tlLWRhc2hvZmZzZXQsc3Ryb2tlLWxpbmVjYXAsc3Ryb2tlLWxpbmVqb2luLGAgK1xuICAgIGBzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLGAgK1xuICAgIGBzeXN0ZW1MYW5ndWFnZSx0YWJpbmRleCx0YWJsZVZhbHVlcyx0YXJnZXQsdGFyZ2V0WCx0YXJnZXRZLHRleHQtYW5jaG9yLGAgK1xuICAgIGB0ZXh0LWRlY29yYXRpb24sdGV4dC1yZW5kZXJpbmcsdGV4dExlbmd0aCx0byx0cmFuc2Zvcm0sdHJhbnNmb3JtLW9yaWdpbixgICtcbiAgICBgdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSxgICtcbiAgICBgdW5pY29kZS1yYW5nZSx1bml0cy1wZXItZW0sdi1hbHBoYWJldGljLHYtaGFuZ2luZyx2LWlkZW9ncmFwaGljLGAgK1xuICAgIGB2LW1hdGhlbWF0aWNhbCx2YWx1ZXMsdmVjdG9yLWVmZmVjdCx2ZXJzaW9uLHZlcnQtYWR2LXksdmVydC1vcmlnaW4teCxgICtcbiAgICBgdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLGAgK1xuICAgIGB3cml0aW5nLW1vZGUseCx4LWhlaWdodCx4MSx4Mix4Q2hhbm5lbFNlbGVjdG9yLHhsaW5rOmFjdHVhdGUseGxpbms6YXJjcm9sZSxgICtcbiAgICBgeGxpbms6aHJlZix4bGluazpyb2xlLHhsaW5rOnNob3cseGxpbms6dGl0bGUseGxpbms6dHlwZSx4bWw6YmFzZSx4bWw6bGFuZyxgICtcbiAgICBgeG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5gKTtcblxuY29uc3QgZXNjYXBlUkUgPSAvW1wiJyY8Pl0vO1xuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgICBjb25zdCBzdHIgPSAnJyArIHN0cmluZztcbiAgICBjb25zdCBtYXRjaCA9IGVzY2FwZVJFLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGxldCBodG1sID0gJyc7XG4gICAgbGV0IGVzY2FwZWQ7XG4gICAgbGV0IGluZGV4O1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICAgICAgICBjYXNlIDM0OiAvLyBcIlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJnF1b3Q7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzg6IC8vICZcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZhbXA7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzk6IC8vICdcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyYjMzk7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjA6IC8vIDxcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gJyZsdDsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MjogLy8gPlxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAnJmd0Oyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICBodG1sICs9IHN0ci5zbGljZShsYXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGh0bWwgKz0gZXNjYXBlZDtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTIvc3ludGF4Lmh0bWwjY29tbWVudHNcbmNvbnN0IGNvbW1lbnRTdHJpcFJFID0gL14tPz58PCEtLXwtLT58LS0hPnw8IS0kL2c7XG5mdW5jdGlvbiBlc2NhcGVIdG1sQ29tbWVudChzcmMpIHtcbiAgICByZXR1cm4gc3JjLnJlcGxhY2UoY29tbWVudFN0cmlwUkUsICcnKTtcbn1cblxuZnVuY3Rpb24gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgZXF1YWwgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZXF1YWw7XG59XG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFWYWxpZFR5cGUgPSBpc0RhdGUoYSk7XG4gICAgbGV0IGJWYWxpZFR5cGUgPSBpc0RhdGUoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpIDogZmFsc2U7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNTeW1ib2woYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG4gICAgYVZhbGlkVHlwZSA9IGlzQXJyYXkoYSk7XG4gICAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgICByZXR1cm4gYVZhbGlkVHlwZSAmJiBiVmFsaWRUeXBlID8gbG9vc2VDb21wYXJlQXJyYXlzKGEsIGIpIDogZmFsc2U7XG4gICAgfVxuICAgIGFWYWxpZFR5cGUgPSBpc09iamVjdChhKTtcbiAgICBiVmFsaWRUeXBlID0gaXNPYmplY3QoYik7XG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRoaXMgaWYgd2lsbCBwcm9iYWJseSBuZXZlciBiZSBjYWxsZWQgKi9cbiAgICAgICAgaWYgKCFhVmFsaWRUeXBlIHx8ICFiVmFsaWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYUtleXNDb3VudCA9IE9iamVjdC5rZXlzKGEpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcbiAgICAgICAgaWYgKGFLZXlzQ291bnQgIT09IGJLZXlzQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgICAgICBjb25zdCBhSGFzS2V5ID0gYS5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgICAgICAgIGlmICgoYUhhc0tleSAmJiAhYkhhc0tleSkgfHxcbiAgICAgICAgICAgICAgICAoIWFIYXNLZXkgJiYgYkhhc0tleSkgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoaXRlbSA9PiBsb29zZUVxdWFsKGl0ZW0sIHZhbCkpO1xufVxuXG4vKipcbiAqIEZvciBjb252ZXJ0aW5nIHt7IGludGVycG9sYXRpb24gfX0gdmFsdWVzIHRvIGRpc3BsYXllZCBzdHJpbmdzLlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgdG9EaXNwbGF5U3RyaW5nID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogdmFsID09IG51bGxcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogaXNBcnJheSh2YWwpIHx8XG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KHZhbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHZhbC50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgIWlzRnVuY3Rpb24odmFsLnRvU3RyaW5nKSkpXG4gICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxuICAgICAgICAgICAgICAgIDogU3RyaW5nKHZhbCk7XG59O1xuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XG4gICAgLy8gY2FuJ3QgdXNlIGlzUmVmIGhlcmUgc2luY2UgQHZ1ZS9zaGFyZWQgaGFzIG5vIGRlcHNcbiAgICBpZiAodmFsICYmIHZhbC5fX3ZfaXNSZWYpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTWFwKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtgTWFwKCR7dmFsLnNpemV9KWBdOiBbLi4udmFsLmVudHJpZXMoKV0ucmVkdWNlKChlbnRyaWVzLCBba2V5LCB2YWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgZW50cmllc1tgJHtrZXl9ID0+YF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTZXQodmFsKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbmNvbnN0IEVNUFRZX09CSiA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxuICAgID8gT2JqZWN0LmZyZWV6ZSh7fSlcbiAgICA6IHt9O1xuY29uc3QgRU1QVFlfQVJSID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXTtcbmNvbnN0IE5PT1AgPSAoKSA9PiB7IH07XG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XG5jb25zdCBvblJFID0gL15vblteYS16XS87XG5jb25zdCBpc09uID0gKGtleSkgPT4gb25SRS50ZXN0KGtleSk7XG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnb25VcGRhdGU6Jyk7XG5jb25zdCBleHRlbmQgPSBPYmplY3QuYXNzaWduO1xuY29uc3QgcmVtb3ZlID0gKGFyciwgZWwpID0+IHtcbiAgICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcbiAgICB9XG59O1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBTZXRdJztcbmNvbnN0IGlzRGF0ZSA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG5jb25zdCBpc1JlZ0V4cCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBSZWdFeHBdJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuY29uc3QgaXNTdHJpbmcgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcbmNvbnN0IGlzUHJvbWlzZSA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XG59O1xuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbmNvbnN0IHRvUmF3VHlwZSA9ICh2YWx1ZSkgPT4ge1xuICAgIC8vIGV4dHJhY3QgXCJSYXdUeXBlXCIgZnJvbSBzdHJpbmdzIGxpa2UgXCJbb2JqZWN0IFJhd1R5cGVdXCJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59O1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcbiAgICBrZXkgIT09ICdOYU4nICYmXG4gICAga2V5WzBdICE9PSAnLScgJiZcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XG5jb25zdCBpc1Jlc2VydmVkUHJvcCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChcbi8vIHRoZSBsZWFkaW5nIGNvbW1hIGlzIGludGVudGlvbmFsIHNvIGVtcHR5IHN0cmluZyBcIlwiIGlzIGFsc28gaW5jbHVkZWRcbicsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksJyArXG4gICAgJ29uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCwnICtcbiAgICAnb25Wbm9kZUJlZm9yZVVwZGF0ZSxvblZub2RlVXBkYXRlZCwnICtcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xuY29uc3QgaXNCdWlsdEluRGlyZWN0aXZlID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdiaW5kLGNsb2FrLGVsc2UtaWYsZWxzZSxmb3IsaHRtbCxpZixtb2RlbCxvbixvbmNlLHByZSxzaG93LHNsb3QsdGV4dCxtZW1vJyk7XG5jb25zdCBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiAoKHN0cikgPT4ge1xuICAgICAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XG4gICAgfSk7XG59O1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgKF8sIGMpID0+IChjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpKTtcbn0pO1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRvSGFuZGxlcktleSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyID8gYG9uJHtjYXBpdGFsaXplKHN0cil9YCA6IGBgKTtcbi8vIGNvbXBhcmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLCBhY2NvdW50aW5nIGZvciBOYU4uXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xuY29uc3QgaW52b2tlQXJyYXlGbnMgPSAoZm5zLCBhcmcpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0oYXJnKTtcbiAgICB9XG59O1xuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZVxuICAgIH0pO1xufTtcbi8qKlxuICogXCIxMjMtZm9vXCIgd2lsbCBiZSBwYXJzZWQgdG8gMTIzXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHRoZSAubnVtYmVyIG1vZGlmaWVyIGluIHYtbW9kZWxcbiAqL1xuY29uc3QgbG9vc2VUb051bWJlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59O1xuLyoqXG4gKiBPbmx5IGNvbmVyY2VzIG51bWJlci1saWtlIHN0cmluZ3NcbiAqIFwiMTIzLWZvb1wiIHdpbGwgYmUgcmV0dXJuZWQgYXMtaXNcbiAqL1xuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbiA9IGlzU3RyaW5nKHZhbCkgPyBOdW1iZXIodmFsKSA6IE5hTjtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuO1xufTtcbmxldCBfZ2xvYmFsVGhpcztcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxuICAgICAgICAoX2dsb2JhbFRoaXMgPVxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXG4gICAgICAgICAgICAgICAgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gd2luZG93XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSk7XG59O1xuY29uc3QgaWRlbnRSRSA9IC9eW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSokLztcbmZ1bmN0aW9uIGdlblByb3BzQWNjZXNzRXhwKG5hbWUpIHtcbiAgICByZXR1cm4gaWRlbnRSRS50ZXN0KG5hbWUpXG4gICAgICAgID8gYF9fcHJvcHMuJHtuYW1lfWBcbiAgICAgICAgOiBgX19wcm9wc1ske0pTT04uc3RyaW5naWZ5KG5hbWUpfV1gO1xufVxuXG5leHBvcnQgeyBFTVBUWV9BUlIsIEVNUFRZX09CSiwgTk8sIE5PT1AsIFBhdGNoRmxhZ05hbWVzLCBjYW1lbGl6ZSwgY2FwaXRhbGl6ZSwgZGVmLCBlc2NhcGVIdG1sLCBlc2NhcGVIdG1sQ29tbWVudCwgZXh0ZW5kLCBnZW5Qcm9wc0FjY2Vzc0V4cCwgZ2VuZXJhdGVDb2RlRnJhbWUsIGdldEdsb2JhbFRoaXMsIGhhc0NoYW5nZWQsIGhhc093biwgaHlwaGVuYXRlLCBpbmNsdWRlQm9vbGVhbkF0dHIsIGludm9rZUFycmF5Rm5zLCBpc0FycmF5LCBpc0Jvb2xlYW5BdHRyLCBpc0J1aWx0SW5EaXJlY3RpdmUsIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNHbG9iYWxseVdoaXRlbGlzdGVkLCBpc0hUTUxUYWcsIGlzSW50ZWdlcktleSwgaXNLbm93bkh0bWxBdHRyLCBpc0tub3duU3ZnQXR0ciwgaXNNYXAsIGlzTW9kZWxMaXN0ZW5lciwgaXNPYmplY3QsIGlzT24sIGlzUGxhaW5PYmplY3QsIGlzUHJvbWlzZSwgaXNSZWdFeHAsIGlzUmVzZXJ2ZWRQcm9wLCBpc1NTUlNhZmVBdHRyTmFtZSwgaXNTVkdUYWcsIGlzU2V0LCBpc1NwZWNpYWxCb29sZWFuQXR0ciwgaXNTdHJpbmcsIGlzU3ltYm9sLCBpc1ZvaWRUYWcsIGxvb3NlRXF1YWwsIGxvb3NlSW5kZXhPZiwgbG9vc2VUb051bWJlciwgbWFrZU1hcCwgbm9ybWFsaXplQ2xhc3MsIG5vcm1hbGl6ZVByb3BzLCBub3JtYWxpemVTdHlsZSwgb2JqZWN0VG9TdHJpbmcsIHBhcnNlU3RyaW5nU3R5bGUsIHByb3BzVG9BdHRyTWFwLCByZW1vdmUsIHNsb3RGbGFnc1RleHQsIHN0cmluZ2lmeVN0eWxlLCB0b0Rpc3BsYXlTdHJpbmcsIHRvSGFuZGxlcktleSwgdG9OdW1iZXIsIHRvUmF3VHlwZSwgdG9UeXBlU3RyaW5nIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue/node_modules/@vue/shared/dist/shared.esm-bundler.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/assets/js/hacker-news.js");
/******/ 	
/******/ })()
;